-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the types generated from the schema ScriptValue
module Wallet.Types.ScriptValue where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Wallet.Common
import Wallet.TypeAlias

-- | Defines the object schema located at @components.schemas.ScriptValue.oneOf@ in the specification.
-- 
-- 
data ScriptValueOneOf2 = ScriptValueOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  scriptValueOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ScriptValueOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= scriptValueOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= scriptValueOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ScriptValueOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ScriptValueOneOf2" (\obj -> GHC.Base.pure ScriptValueOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'ScriptValueOneOf2' with all required fields.
mkScriptValueOneOf2 :: [ScriptValue] -- ^ 'scriptValueOneOf2All'
  -> ScriptValueOneOf2
mkScriptValueOneOf2 scriptValueOneOf2All = ScriptValueOneOf2{scriptValueOneOf2All = scriptValueOneOf2All}
-- | Defines the object schema located at @components.schemas.ScriptValue.oneOf@ in the specification.
-- 
-- 
data ScriptValueOneOf3 = ScriptValueOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  scriptValueOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ScriptValueOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= scriptValueOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= scriptValueOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ScriptValueOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ScriptValueOneOf3" (\obj -> GHC.Base.pure ScriptValueOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'ScriptValueOneOf3' with all required fields.
mkScriptValueOneOf3 :: [ScriptValue] -- ^ 'scriptValueOneOf3Any'
  -> ScriptValueOneOf3
mkScriptValueOneOf3 scriptValueOneOf3Any = ScriptValueOneOf3{scriptValueOneOf3Any = scriptValueOneOf3Any}
-- | Defines the object schema located at @components.schemas.ScriptValue.oneOf@ in the specification.
-- 
-- 
data ScriptValueOneOf4 = ScriptValueOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  scriptValueOneOf4Some :: ScriptValueOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ScriptValueOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= scriptValueOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= scriptValueOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ScriptValueOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ScriptValueOneOf4" (\obj -> GHC.Base.pure ScriptValueOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'ScriptValueOneOf4' with all required fields.
mkScriptValueOneOf4 :: ScriptValueOneOf4Some -- ^ 'scriptValueOneOf4Some'
  -> ScriptValueOneOf4
mkScriptValueOneOf4 scriptValueOneOf4Some = ScriptValueOneOf4{scriptValueOneOf4Some = scriptValueOneOf4Some}
-- | Defines the object schema located at @components.schemas.ScriptValue.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data ScriptValueOneOf4Some = ScriptValueOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  scriptValueOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , scriptValueOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ScriptValueOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= scriptValueOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= scriptValueOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= scriptValueOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= scriptValueOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ScriptValueOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ScriptValueOneOf4Some" (\obj -> (GHC.Base.pure ScriptValueOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'ScriptValueOneOf4Some' with all required fields.
mkScriptValueOneOf4Some :: GHC.Types.Int -- ^ 'scriptValueOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'scriptValueOneOf4SomeFrom'
  -> ScriptValueOneOf4Some
mkScriptValueOneOf4Some scriptValueOneOf4SomeAt_least scriptValueOneOf4SomeFrom = ScriptValueOneOf4Some{scriptValueOneOf4SomeAt_least = scriptValueOneOf4SomeAt_least,
                                                                                                        scriptValueOneOf4SomeFrom = scriptValueOneOf4SomeFrom}
-- | Defines the object schema located at @components.schemas.ScriptValue.oneOf@ in the specification.
-- 
-- 
data ScriptValueOneOf5 = ScriptValueOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`â‰¥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  scriptValueOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ScriptValueOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= scriptValueOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= scriptValueOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ScriptValueOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ScriptValueOneOf5" (\obj -> GHC.Base.pure ScriptValueOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'ScriptValueOneOf5' with all required fields.
mkScriptValueOneOf5 :: GHC.Types.Int -- ^ 'scriptValueOneOf5Active_from'
  -> ScriptValueOneOf5
mkScriptValueOneOf5 scriptValueOneOf5Active_from = ScriptValueOneOf5{scriptValueOneOf5Active_from = scriptValueOneOf5Active_from}
-- | Defines the object schema located at @components.schemas.ScriptValue.oneOf@ in the specification.
-- 
-- 
data ScriptValueOneOf6 = ScriptValueOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  scriptValueOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ScriptValueOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= scriptValueOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= scriptValueOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ScriptValueOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ScriptValueOneOf6" (\obj -> GHC.Base.pure ScriptValueOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'ScriptValueOneOf6' with all required fields.
mkScriptValueOneOf6 :: GHC.Types.Int -- ^ 'scriptValueOneOf6Active_until'
  -> ScriptValueOneOf6
mkScriptValueOneOf6 scriptValueOneOf6Active_until = ScriptValueOneOf6{scriptValueOneOf6Active_until = scriptValueOneOf6Active_until}
-- | Defines the oneOf schema located at @components.schemas.ScriptValue.oneOf@ in the specification.
-- 
-- 
data ScriptValueVariants =
   ScriptValueVariant1 Data.Text.Internal.Text
  | ScriptValueVariant2 ScriptValueOneOf2
  | ScriptValueVariant3 ScriptValueOneOf3
  | ScriptValueVariant4 ScriptValueOneOf4
  | ScriptValueVariant5 ScriptValueOneOf5
  | ScriptValueVariant6 ScriptValueOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ScriptValueVariants
    where toJSON (ScriptValueVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ScriptValueVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ScriptValueVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ScriptValueVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ScriptValueVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ScriptValueVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ScriptValueVariants
    where parseJSON val = case (ScriptValueVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ScriptValueVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ScriptValueVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ScriptValueVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ScriptValueVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ScriptValueVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines an alias for the schema located at @components.schemas.ScriptValue.oneOf@ in the specification.
-- 
-- 
type ScriptValue = ScriptValueVariants
