-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation balanceTransaction
module Wallet.Operations.BalanceTransaction where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /wallets/{walletId}/transactions-balance
-- 
-- \<p align=\"right\">status: \<strong>under development\<\/strong>\<\/p>
-- Balance a transaction body of a given transaction, add needed inputs\/outputs,
-- so as the transaction can be signed from the wallet.
balanceTransaction :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> BalanceTransactionRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response BalanceTransactionResponse) -- ^ Monadic computation which returns the result of the operation
balanceTransaction walletId
                   body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either BalanceTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> BalanceTransactionResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         BalanceTransactionResponseBody202)
                                                                                                                                                                       | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> BalanceTransactionResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         BalanceTransactionResponseBody400Variants)
                                                                                                                                                                       | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> BalanceTransactionResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         BalanceTransactionResponseBody403Variants)
                                                                                                                                                                       | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> BalanceTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         BalanceTransactionResponseBody404)
                                                                                                                                                                       | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> BalanceTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         BalanceTransactionResponseBody406)
                                                                                                                                                                       | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> BalanceTransactionResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         BalanceTransactionResponseBody415)
                                                                                                                                                                       | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-balance")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.requestBody.content.application\/json.schema@ in the specification.
-- 
-- 
data BalanceTransactionRequestBody = BalanceTransactionRequestBody {
  -- | encoding: Encoding of transaction CBOR returned in response (base64 by default).
  balanceTransactionRequestBodyEncoding :: (GHC.Maybe.Maybe BalanceTransactionRequestBodyEncoding)
  -- | inputs: A list of additional transaction inputs foreign to the wallet.
  , balanceTransactionRequestBodyInputs :: (GHC.Maybe.Maybe ([BalanceTransactionRequestBodyInputs]))
  -- | redeemers: A list of redeemers data with their purpose.
  , balanceTransactionRequestBodyRedeemers :: (GHC.Maybe.Maybe ([BalanceTransactionRequestBodyRedeemersVariants]))
  -- | transaction: The CBOR-encoded transaction, represented in either hex or base64 encoding.
  -- This always includes the transaction body and the witness set, even if the
  -- latter is empty.
  , balanceTransactionRequestBodyTransaction :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("encoding" Data.Aeson.Types.ToJSON..=)) (balanceTransactionRequestBodyEncoding obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inputs" Data.Aeson.Types.ToJSON..=)) (balanceTransactionRequestBodyInputs obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("redeemers" Data.Aeson.Types.ToJSON..=)) (balanceTransactionRequestBodyRedeemers obj) : ["transaction" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyTransaction obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("encoding" Data.Aeson.Types.ToJSON..=)) (balanceTransactionRequestBodyEncoding obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inputs" Data.Aeson.Types.ToJSON..=)) (balanceTransactionRequestBodyInputs obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("redeemers" Data.Aeson.Types.ToJSON..=)) (balanceTransactionRequestBodyRedeemers obj) : ["transaction" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyTransaction obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionRequestBody" (\obj -> (((GHC.Base.pure BalanceTransactionRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "encoding")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "redeemers")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "transaction"))
-- | Create a new 'BalanceTransactionRequestBody' with all required fields.
mkBalanceTransactionRequestBody :: Data.Text.Internal.Text -- ^ 'balanceTransactionRequestBodyTransaction'
  -> BalanceTransactionRequestBody
mkBalanceTransactionRequestBody balanceTransactionRequestBodyTransaction = BalanceTransactionRequestBody{balanceTransactionRequestBodyEncoding = GHC.Maybe.Nothing,
                                                                                                         balanceTransactionRequestBodyInputs = GHC.Maybe.Nothing,
                                                                                                         balanceTransactionRequestBodyRedeemers = GHC.Maybe.Nothing,
                                                                                                         balanceTransactionRequestBodyTransaction = balanceTransactionRequestBodyTransaction}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.requestBody.content.application\/json.schema.properties.encoding@ in the specification.
-- 
-- Encoding of transaction CBOR returned in response (base64 by default).
data BalanceTransactionRequestBodyEncoding =
   BalanceTransactionRequestBodyEncodingOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | BalanceTransactionRequestBodyEncodingTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | BalanceTransactionRequestBodyEncodingEnumBase16 -- ^ Represents the JSON value @"base16"@
  | BalanceTransactionRequestBodyEncodingEnumBase64 -- ^ Represents the JSON value @"base64"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionRequestBodyEncoding
    where toJSON (BalanceTransactionRequestBodyEncodingOther val) = val
          toJSON (BalanceTransactionRequestBodyEncodingTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (BalanceTransactionRequestBodyEncodingEnumBase16) = "base16"
          toJSON (BalanceTransactionRequestBodyEncodingEnumBase64) = "base64"
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionRequestBodyEncoding
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "base16" -> BalanceTransactionRequestBodyEncodingEnumBase16
                                            | val GHC.Classes.== "base64" -> BalanceTransactionRequestBodyEncodingEnumBase64
                                            | GHC.Base.otherwise -> BalanceTransactionRequestBodyEncodingOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.requestBody.content.application\/json.schema.properties.inputs.items@ in the specification.
-- 
-- 
data BalanceTransactionRequestBodyInputs = BalanceTransactionRequestBodyInputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  balanceTransactionRequestBodyInputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , balanceTransactionRequestBodyInputsAmount :: BalanceTransactionRequestBodyInputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , balanceTransactionRequestBodyInputsAssets :: ([BalanceTransactionRequestBodyInputsAssets])
  -- | datum: A datum hash.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , balanceTransactionRequestBodyInputsDatum :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , balanceTransactionRequestBodyInputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , balanceTransactionRequestBodyInputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionRequestBodyInputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsAmount obj] : ["assets" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsAssets obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("datum" Data.Aeson.Types.ToJSON..=)) (balanceTransactionRequestBodyInputsDatum obj) : ["id" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsId obj] : ["index" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsAmount obj] : ["assets" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsAssets obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("datum" Data.Aeson.Types.ToJSON..=)) (balanceTransactionRequestBodyInputsDatum obj) : ["id" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsId obj] : ["index" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionRequestBodyInputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionRequestBodyInputs" (\obj -> (((((GHC.Base.pure BalanceTransactionRequestBodyInputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "datum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'BalanceTransactionRequestBodyInputs' with all required fields.
mkBalanceTransactionRequestBodyInputs :: Data.Text.Internal.Text -- ^ 'balanceTransactionRequestBodyInputsAddress'
  -> BalanceTransactionRequestBodyInputsAmount -- ^ 'balanceTransactionRequestBodyInputsAmount'
  -> [BalanceTransactionRequestBodyInputsAssets] -- ^ 'balanceTransactionRequestBodyInputsAssets'
  -> Data.Text.Internal.Text -- ^ 'balanceTransactionRequestBodyInputsId'
  -> GHC.Types.Int -- ^ 'balanceTransactionRequestBodyInputsIndex'
  -> BalanceTransactionRequestBodyInputs
mkBalanceTransactionRequestBodyInputs balanceTransactionRequestBodyInputsAddress balanceTransactionRequestBodyInputsAmount balanceTransactionRequestBodyInputsAssets balanceTransactionRequestBodyInputsId balanceTransactionRequestBodyInputsIndex = BalanceTransactionRequestBodyInputs{balanceTransactionRequestBodyInputsAddress = balanceTransactionRequestBodyInputsAddress,
                                                                                                                                                                                                                                                                                          balanceTransactionRequestBodyInputsAmount = balanceTransactionRequestBodyInputsAmount,
                                                                                                                                                                                                                                                                                          balanceTransactionRequestBodyInputsAssets = balanceTransactionRequestBodyInputsAssets,
                                                                                                                                                                                                                                                                                          balanceTransactionRequestBodyInputsDatum = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                          balanceTransactionRequestBodyInputsId = balanceTransactionRequestBodyInputsId,
                                                                                                                                                                                                                                                                                          balanceTransactionRequestBodyInputsIndex = balanceTransactionRequestBodyInputsIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.requestBody.content.application\/json.schema.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data BalanceTransactionRequestBodyInputsAmount = BalanceTransactionRequestBodyInputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  balanceTransactionRequestBodyInputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionRequestBodyInputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionRequestBodyInputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionRequestBodyInputsAmount" (\obj -> GHC.Base.pure BalanceTransactionRequestBodyInputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'BalanceTransactionRequestBodyInputsAmount' with all required fields.
mkBalanceTransactionRequestBodyInputsAmount :: GHC.Types.Int -- ^ 'balanceTransactionRequestBodyInputsAmountQuantity'
  -> BalanceTransactionRequestBodyInputsAmount
mkBalanceTransactionRequestBodyInputsAmount balanceTransactionRequestBodyInputsAmountQuantity = BalanceTransactionRequestBodyInputsAmount{balanceTransactionRequestBodyInputsAmountQuantity = balanceTransactionRequestBodyInputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.requestBody.content.application\/json.schema.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data BalanceTransactionRequestBodyInputsAssets = BalanceTransactionRequestBodyInputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  balanceTransactionRequestBodyInputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , balanceTransactionRequestBodyInputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , balanceTransactionRequestBodyInputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionRequestBodyInputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyInputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionRequestBodyInputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionRequestBodyInputsAssets" (\obj -> ((GHC.Base.pure BalanceTransactionRequestBodyInputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'BalanceTransactionRequestBodyInputsAssets' with all required fields.
mkBalanceTransactionRequestBodyInputsAssets :: Data.Text.Internal.Text -- ^ 'balanceTransactionRequestBodyInputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'balanceTransactionRequestBodyInputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'balanceTransactionRequestBodyInputsAssetsQuantity'
  -> BalanceTransactionRequestBodyInputsAssets
mkBalanceTransactionRequestBodyInputsAssets balanceTransactionRequestBodyInputsAssetsAsset_name balanceTransactionRequestBodyInputsAssetsPolicy_id balanceTransactionRequestBodyInputsAssetsQuantity = BalanceTransactionRequestBodyInputsAssets{balanceTransactionRequestBodyInputsAssetsAsset_name = balanceTransactionRequestBodyInputsAssetsAsset_name,
                                                                                                                                                                                                                                                 balanceTransactionRequestBodyInputsAssetsPolicy_id = balanceTransactionRequestBodyInputsAssetsPolicy_id,
                                                                                                                                                                                                                                                 balanceTransactionRequestBodyInputsAssetsQuantity = balanceTransactionRequestBodyInputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.requestBody.content.application\/json.schema.properties.redeemers.items.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionRequestBodyRedeemersOneOf1 = BalanceTransactionRequestBodyRedeemersOneOf1 {
  -- | data
  balanceTransactionRequestBodyRedeemersOneOf1Data :: Data.Text.Internal.Text
  -- | input
  , balanceTransactionRequestBodyRedeemersOneOf1Input :: BalanceTransactionRequestBodyRedeemersOneOf1Input
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionRequestBodyRedeemersOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["data" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf1Data obj] : ["input" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf1Input obj] : ["purpose" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "spending"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["data" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf1Data obj] : ["input" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf1Input obj] : ["purpose" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "spending"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionRequestBodyRedeemersOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionRequestBodyRedeemersOneOf1" (\obj -> (GHC.Base.pure BalanceTransactionRequestBodyRedeemersOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "input"))
-- | Create a new 'BalanceTransactionRequestBodyRedeemersOneOf1' with all required fields.
mkBalanceTransactionRequestBodyRedeemersOneOf1 :: Data.Text.Internal.Text -- ^ 'balanceTransactionRequestBodyRedeemersOneOf1Data'
  -> BalanceTransactionRequestBodyRedeemersOneOf1Input -- ^ 'balanceTransactionRequestBodyRedeemersOneOf1Input'
  -> BalanceTransactionRequestBodyRedeemersOneOf1
mkBalanceTransactionRequestBodyRedeemersOneOf1 balanceTransactionRequestBodyRedeemersOneOf1Data balanceTransactionRequestBodyRedeemersOneOf1Input = BalanceTransactionRequestBodyRedeemersOneOf1{balanceTransactionRequestBodyRedeemersOneOf1Data = balanceTransactionRequestBodyRedeemersOneOf1Data,
                                                                                                                                                                                                 balanceTransactionRequestBodyRedeemersOneOf1Input = balanceTransactionRequestBodyRedeemersOneOf1Input}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.requestBody.content.application\/json.schema.properties.redeemers.items.oneOf.properties.input@ in the specification.
-- 
-- 
data BalanceTransactionRequestBodyRedeemersOneOf1Input = BalanceTransactionRequestBodyRedeemersOneOf1Input {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  balanceTransactionRequestBodyRedeemersOneOf1InputId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , balanceTransactionRequestBodyRedeemersOneOf1InputIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionRequestBodyRedeemersOneOf1Input
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf1InputId obj] : ["index" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf1InputIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf1InputId obj] : ["index" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf1InputIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionRequestBodyRedeemersOneOf1Input
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionRequestBodyRedeemersOneOf1Input" (\obj -> (GHC.Base.pure BalanceTransactionRequestBodyRedeemersOneOf1Input GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'BalanceTransactionRequestBodyRedeemersOneOf1Input' with all required fields.
mkBalanceTransactionRequestBodyRedeemersOneOf1Input :: Data.Text.Internal.Text -- ^ 'balanceTransactionRequestBodyRedeemersOneOf1InputId'
  -> GHC.Types.Int -- ^ 'balanceTransactionRequestBodyRedeemersOneOf1InputIndex'
  -> BalanceTransactionRequestBodyRedeemersOneOf1Input
mkBalanceTransactionRequestBodyRedeemersOneOf1Input balanceTransactionRequestBodyRedeemersOneOf1InputId balanceTransactionRequestBodyRedeemersOneOf1InputIndex = BalanceTransactionRequestBodyRedeemersOneOf1Input{balanceTransactionRequestBodyRedeemersOneOf1InputId = balanceTransactionRequestBodyRedeemersOneOf1InputId,
                                                                                                                                                                                                                   balanceTransactionRequestBodyRedeemersOneOf1InputIndex = balanceTransactionRequestBodyRedeemersOneOf1InputIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.requestBody.content.application\/json.schema.properties.redeemers.items.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionRequestBodyRedeemersOneOf2 = BalanceTransactionRequestBodyRedeemersOneOf2 {
  -- | data
  balanceTransactionRequestBodyRedeemersOneOf2Data :: Data.Text.Internal.Text
  -- | policy_id
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  , balanceTransactionRequestBodyRedeemersOneOf2Policy_id :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionRequestBodyRedeemersOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["data" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf2Data obj] : ["policy_id" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf2Policy_id obj] : ["purpose" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "minting"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["data" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf2Data obj] : ["policy_id" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf2Policy_id obj] : ["purpose" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "minting"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionRequestBodyRedeemersOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionRequestBodyRedeemersOneOf2" (\obj -> (GHC.Base.pure BalanceTransactionRequestBodyRedeemersOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id"))
-- | Create a new 'BalanceTransactionRequestBodyRedeemersOneOf2' with all required fields.
mkBalanceTransactionRequestBodyRedeemersOneOf2 :: Data.Text.Internal.Text -- ^ 'balanceTransactionRequestBodyRedeemersOneOf2Data'
  -> Data.Text.Internal.Text -- ^ 'balanceTransactionRequestBodyRedeemersOneOf2Policy_id'
  -> BalanceTransactionRequestBodyRedeemersOneOf2
mkBalanceTransactionRequestBodyRedeemersOneOf2 balanceTransactionRequestBodyRedeemersOneOf2Data balanceTransactionRequestBodyRedeemersOneOf2Policy_id = BalanceTransactionRequestBodyRedeemersOneOf2{balanceTransactionRequestBodyRedeemersOneOf2Data = balanceTransactionRequestBodyRedeemersOneOf2Data,
                                                                                                                                                                                                     balanceTransactionRequestBodyRedeemersOneOf2Policy_id = balanceTransactionRequestBodyRedeemersOneOf2Policy_id}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.requestBody.content.application\/json.schema.properties.redeemers.items.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionRequestBodyRedeemersOneOf3 = BalanceTransactionRequestBodyRedeemersOneOf3 {
  -- | data
  balanceTransactionRequestBodyRedeemersOneOf3Data :: Data.Text.Internal.Text
  -- | stake_address
  , balanceTransactionRequestBodyRedeemersOneOf3Stake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionRequestBodyRedeemersOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["data" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf3Data obj] : ["stake_address" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf3Stake_address obj] : ["purpose" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "rewarding"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["data" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf3Data obj] : ["stake_address" Data.Aeson.Types.ToJSON..= balanceTransactionRequestBodyRedeemersOneOf3Stake_address obj] : ["purpose" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "rewarding"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionRequestBodyRedeemersOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionRequestBodyRedeemersOneOf3" (\obj -> (GHC.Base.pure BalanceTransactionRequestBodyRedeemersOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "data")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'BalanceTransactionRequestBodyRedeemersOneOf3' with all required fields.
mkBalanceTransactionRequestBodyRedeemersOneOf3 :: Data.Text.Internal.Text -- ^ 'balanceTransactionRequestBodyRedeemersOneOf3Data'
  -> Data.Text.Internal.Text -- ^ 'balanceTransactionRequestBodyRedeemersOneOf3Stake_address'
  -> BalanceTransactionRequestBodyRedeemersOneOf3
mkBalanceTransactionRequestBodyRedeemersOneOf3 balanceTransactionRequestBodyRedeemersOneOf3Data balanceTransactionRequestBodyRedeemersOneOf3Stake_address = BalanceTransactionRequestBodyRedeemersOneOf3{balanceTransactionRequestBodyRedeemersOneOf3Data = balanceTransactionRequestBodyRedeemersOneOf3Data,
                                                                                                                                                                                                         balanceTransactionRequestBodyRedeemersOneOf3Stake_address = balanceTransactionRequestBodyRedeemersOneOf3Stake_address}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.requestBody.content.application\/json.schema.properties.redeemers.items.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionRequestBodyRedeemersVariants =
   BalanceTransactionRequestBodyRedeemersVariant1 BalanceTransactionRequestBodyRedeemersOneOf1
  | BalanceTransactionRequestBodyRedeemersVariant2 BalanceTransactionRequestBodyRedeemersOneOf2
  | BalanceTransactionRequestBodyRedeemersVariant3 BalanceTransactionRequestBodyRedeemersOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionRequestBodyRedeemersVariants
    where toJSON (BalanceTransactionRequestBodyRedeemersVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionRequestBodyRedeemersVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionRequestBodyRedeemersVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionRequestBodyRedeemersVariants
    where parseJSON val = case (BalanceTransactionRequestBodyRedeemersVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionRequestBodyRedeemersVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionRequestBodyRedeemersVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Represents a response of the operation 'balanceTransaction'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'BalanceTransactionResponseError' is used.
data BalanceTransactionResponse =
   BalanceTransactionResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | BalanceTransactionResponse202 BalanceTransactionResponseBody202 -- ^ Accepted
  | BalanceTransactionResponse400 BalanceTransactionResponseBody400Variants -- ^ Bad Request
  | BalanceTransactionResponse403 BalanceTransactionResponseBody403Variants -- ^ Forbidden
  | BalanceTransactionResponse404 BalanceTransactionResponseBody404 -- ^ Not Found
  | BalanceTransactionResponse406 BalanceTransactionResponseBody406 -- ^ Not Acceptable
  | BalanceTransactionResponse415 BalanceTransactionResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.202.content.application\/json.schema@ in the specification.
-- 
-- An encoded transaction.
data BalanceTransactionResponseBody202 = BalanceTransactionResponseBody202 {
  -- | transaction: The CBOR-encoded transaction, represented in either hex or base64 encoding.
  -- This always includes the transaction body and the witness set, even if the
  -- latter is empty.
  balanceTransactionResponseBody202Transaction :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody202
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["transaction" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody202Transaction obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["transaction" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody202Transaction obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody202
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody202" (\obj -> GHC.Base.pure BalanceTransactionResponseBody202 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "transaction"))
-- | Create a new 'BalanceTransactionResponseBody202' with all required fields.
mkBalanceTransactionResponseBody202 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody202Transaction'
  -> BalanceTransactionResponseBody202
mkBalanceTransactionResponseBody202 balanceTransactionResponseBody202Transaction = BalanceTransactionResponseBody202{balanceTransactionResponseBody202Transaction = balanceTransactionResponseBody202Transaction}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody400OneOf1 = BalanceTransactionResponseBody400OneOf1 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  balanceTransactionResponseBody400OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody400OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody400OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody400OneOf1" (\obj -> GHC.Base.pure BalanceTransactionResponseBody400OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody400OneOf1' with all required fields.
mkBalanceTransactionResponseBody400OneOf1 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody400OneOf1Message'
  -> BalanceTransactionResponseBody400OneOf1
mkBalanceTransactionResponseBody400OneOf1 balanceTransactionResponseBody400OneOf1Message = BalanceTransactionResponseBody400OneOf1{balanceTransactionResponseBody400OneOf1Message = balanceTransactionResponseBody400OneOf1Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody400OneOf2 = BalanceTransactionResponseBody400OneOf2 {
  -- | message: Occurs when balancing transaction with failing scripts.
  balanceTransactionResponseBody400OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody400OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody400OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "redeemer_script_failure"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody400OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "redeemer_script_failure"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody400OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody400OneOf2" (\obj -> GHC.Base.pure BalanceTransactionResponseBody400OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody400OneOf2' with all required fields.
mkBalanceTransactionResponseBody400OneOf2 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody400OneOf2Message'
  -> BalanceTransactionResponseBody400OneOf2
mkBalanceTransactionResponseBody400OneOf2 balanceTransactionResponseBody400OneOf2Message = BalanceTransactionResponseBody400OneOf2{balanceTransactionResponseBody400OneOf2Message = balanceTransactionResponseBody400OneOf2Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody400OneOf3 = BalanceTransactionResponseBody400OneOf3 {
  -- | message: Occurs when balancing transaction with reedemers that point to unknown entities.
  balanceTransactionResponseBody400OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody400OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody400OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "redeemer_target_not_found"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody400OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "redeemer_target_not_found"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody400OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody400OneOf3" (\obj -> GHC.Base.pure BalanceTransactionResponseBody400OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody400OneOf3' with all required fields.
mkBalanceTransactionResponseBody400OneOf3 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody400OneOf3Message'
  -> BalanceTransactionResponseBody400OneOf3
mkBalanceTransactionResponseBody400OneOf3 balanceTransactionResponseBody400OneOf3Message = BalanceTransactionResponseBody400OneOf3{balanceTransactionResponseBody400OneOf3Message = balanceTransactionResponseBody400OneOf3Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody400OneOf4 = BalanceTransactionResponseBody400OneOf4 {
  -- | message: Occurs when data in provided redeemers do not decode to valid Plutus data.
  balanceTransactionResponseBody400OneOf4Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody400OneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody400OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "redeemer_invalid_data"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody400OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "redeemer_invalid_data"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody400OneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody400OneOf4" (\obj -> GHC.Base.pure BalanceTransactionResponseBody400OneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody400OneOf4' with all required fields.
mkBalanceTransactionResponseBody400OneOf4 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody400OneOf4Message'
  -> BalanceTransactionResponseBody400OneOf4
mkBalanceTransactionResponseBody400OneOf4 balanceTransactionResponseBody400OneOf4Message = BalanceTransactionResponseBody400OneOf4{balanceTransactionResponseBody400OneOf4Message = balanceTransactionResponseBody400OneOf4Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody400OneOf5 = BalanceTransactionResponseBody400OneOf5 {
  -- | message: Occurs when any data in a provided transaction cannot be translated in a given era
  balanceTransactionResponseBody400OneOf5Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody400OneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody400OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "translation_error"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody400OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "translation_error"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody400OneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody400OneOf5" (\obj -> GHC.Base.pure BalanceTransactionResponseBody400OneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody400OneOf5' with all required fields.
mkBalanceTransactionResponseBody400OneOf5 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody400OneOf5Message'
  -> BalanceTransactionResponseBody400OneOf5
mkBalanceTransactionResponseBody400OneOf5 balanceTransactionResponseBody400OneOf5Message = BalanceTransactionResponseBody400OneOf5{balanceTransactionResponseBody400OneOf5Message = balanceTransactionResponseBody400OneOf5Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody400OneOf6 = BalanceTransactionResponseBody400OneOf6 {
  -- | message: There are inputs in the transaction for which the corresponding outputs
  -- could not be found.
  balanceTransactionResponseBody400OneOf6Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody400OneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody400OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unknown_inputs"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody400OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unknown_inputs"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody400OneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody400OneOf6" (\obj -> GHC.Base.pure BalanceTransactionResponseBody400OneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody400OneOf6' with all required fields.
mkBalanceTransactionResponseBody400OneOf6 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody400OneOf6Message'
  -> BalanceTransactionResponseBody400OneOf6
mkBalanceTransactionResponseBody400OneOf6 balanceTransactionResponseBody400OneOf6Message = BalanceTransactionResponseBody400OneOf6{balanceTransactionResponseBody400OneOf6Message = balanceTransactionResponseBody400OneOf6Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody400OneOf7 = BalanceTransactionResponseBody400OneOf7 {
  -- | message: At least one of the provided inputs has an
  -- asset quantity or address that is different from that
  -- recorded in the wallet\'s UTxO set.
  balanceTransactionResponseBody400OneOf7Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody400OneOf7
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody400OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "input_resolution_conflicts"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody400OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "input_resolution_conflicts"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody400OneOf7
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody400OneOf7" (\obj -> GHC.Base.pure BalanceTransactionResponseBody400OneOf7 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody400OneOf7' with all required fields.
mkBalanceTransactionResponseBody400OneOf7 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody400OneOf7Message'
  -> BalanceTransactionResponseBody400OneOf7
mkBalanceTransactionResponseBody400OneOf7 balanceTransactionResponseBody400OneOf7Message = BalanceTransactionResponseBody400OneOf7{balanceTransactionResponseBody400OneOf7Message = balanceTransactionResponseBody400OneOf7Message}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody400Variants =
   BalanceTransactionResponseBody400Variant1 BalanceTransactionResponseBody400OneOf1
  | BalanceTransactionResponseBody400Variant2 BalanceTransactionResponseBody400OneOf2
  | BalanceTransactionResponseBody400Variant3 BalanceTransactionResponseBody400OneOf3
  | BalanceTransactionResponseBody400Variant4 BalanceTransactionResponseBody400OneOf4
  | BalanceTransactionResponseBody400Variant5 BalanceTransactionResponseBody400OneOf5
  | BalanceTransactionResponseBody400Variant6 BalanceTransactionResponseBody400OneOf6
  | BalanceTransactionResponseBody400Variant7 BalanceTransactionResponseBody400OneOf7
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody400Variants
    where toJSON (BalanceTransactionResponseBody400Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody400Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody400Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody400Variant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody400Variant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody400Variant6 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody400Variant7 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody400Variants
    where parseJSON val = case (BalanceTransactionResponseBody400Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody400Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody400Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody400Variant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody400Variant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody400Variant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody400Variant7 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf1 = BalanceTransactionResponseBody403OneOf1 {
  -- | message: May occur when submitting a withdrawal while another withdrawal is pending.
  balanceTransactionResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf1" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf1' with all required fields.
mkBalanceTransactionResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf1Message'
  -> BalanceTransactionResponseBody403OneOf1
mkBalanceTransactionResponseBody403OneOf1 balanceTransactionResponseBody403OneOf1Message = BalanceTransactionResponseBody403OneOf1{balanceTransactionResponseBody403OneOf1Message = balanceTransactionResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- Occurs when the operation requires the node to be in a recent era, but is not.
data BalanceTransactionResponseBody403OneOf2 = BalanceTransactionResponseBody403OneOf2 {
  -- | info
  balanceTransactionResponseBody403OneOf2Info :: (GHC.Maybe.Maybe BalanceTransactionResponseBody403OneOf2Info)
  -- | message
  , balanceTransactionResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (balanceTransactionResponseBody403OneOf2Info obj) : ["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "node_not_yet_in_recent_era"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (balanceTransactionResponseBody403OneOf2Info obj) : ["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "node_not_yet_in_recent_era"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf2" (\obj -> (GHC.Base.pure BalanceTransactionResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "info")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf2' with all required fields.
mkBalanceTransactionResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf2Message'
  -> BalanceTransactionResponseBody403OneOf2
mkBalanceTransactionResponseBody403OneOf2 balanceTransactionResponseBody403OneOf2Message = BalanceTransactionResponseBody403OneOf2{balanceTransactionResponseBody403OneOf2Info = GHC.Maybe.Nothing,
                                                                                                                                   balanceTransactionResponseBody403OneOf2Message = balanceTransactionResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf.properties.info@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf2Info = BalanceTransactionResponseBody403OneOf2Info {
  -- | node_era
  balanceTransactionResponseBody403OneOf2InfoNode_era :: BalanceTransactionResponseBody403OneOf2InfoNode_era
  -- | recent_eras
  , balanceTransactionResponseBody403OneOf2InfoRecent_eras :: ([BalanceTransactionResponseBody403OneOf2InfoRecent_eras])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf2Info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["node_era" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf2InfoNode_era obj] : ["recent_eras" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf2InfoRecent_eras obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["node_era" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf2InfoNode_era obj] : ["recent_eras" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf2InfoRecent_eras obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf2Info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf2Info" (\obj -> (GHC.Base.pure BalanceTransactionResponseBody403OneOf2Info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "node_era")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "recent_eras"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf2Info' with all required fields.
mkBalanceTransactionResponseBody403OneOf2Info :: BalanceTransactionResponseBody403OneOf2InfoNode_era -- ^ 'balanceTransactionResponseBody403OneOf2InfoNode_era'
  -> [BalanceTransactionResponseBody403OneOf2InfoRecent_eras] -- ^ 'balanceTransactionResponseBody403OneOf2InfoRecent_eras'
  -> BalanceTransactionResponseBody403OneOf2Info
mkBalanceTransactionResponseBody403OneOf2Info balanceTransactionResponseBody403OneOf2InfoNode_era balanceTransactionResponseBody403OneOf2InfoRecent_eras = BalanceTransactionResponseBody403OneOf2Info{balanceTransactionResponseBody403OneOf2InfoNode_era = balanceTransactionResponseBody403OneOf2InfoNode_era,
                                                                                                                                                                                                       balanceTransactionResponseBody403OneOf2InfoRecent_eras = balanceTransactionResponseBody403OneOf2InfoRecent_eras}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.node_era@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf2InfoNode_era =
   BalanceTransactionResponseBody403OneOf2InfoNode_eraOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | BalanceTransactionResponseBody403OneOf2InfoNode_eraTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumByron -- ^ Represents the JSON value @"byron"@
  | BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumShelley -- ^ Represents the JSON value @"shelley"@
  | BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumAllegra -- ^ Represents the JSON value @"allegra"@
  | BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumMary -- ^ Represents the JSON value @"mary"@
  | BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumAlonzo -- ^ Represents the JSON value @"alonzo"@
  | BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumBabbage -- ^ Represents the JSON value @"babbage"@
  | BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumConway -- ^ Represents the JSON value @"conway"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf2InfoNode_era
    where toJSON (BalanceTransactionResponseBody403OneOf2InfoNode_eraOther val) = val
          toJSON (BalanceTransactionResponseBody403OneOf2InfoNode_eraTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumByron) = "byron"
          toJSON (BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumShelley) = "shelley"
          toJSON (BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumAllegra) = "allegra"
          toJSON (BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumMary) = "mary"
          toJSON (BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumAlonzo) = "alonzo"
          toJSON (BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumBabbage) = "babbage"
          toJSON (BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumConway) = "conway"
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf2InfoNode_era
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "byron" -> BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumByron
                                            | val GHC.Classes.== "shelley" -> BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumShelley
                                            | val GHC.Classes.== "allegra" -> BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumAllegra
                                            | val GHC.Classes.== "mary" -> BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumMary
                                            | val GHC.Classes.== "alonzo" -> BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumAlonzo
                                            | val GHC.Classes.== "babbage" -> BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumBabbage
                                            | val GHC.Classes.== "conway" -> BalanceTransactionResponseBody403OneOf2InfoNode_eraEnumConway
                                            | GHC.Base.otherwise -> BalanceTransactionResponseBody403OneOf2InfoNode_eraOther val)
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.recent_eras.items@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf2InfoRecent_eras =
   BalanceTransactionResponseBody403OneOf2InfoRecent_erasOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | BalanceTransactionResponseBody403OneOf2InfoRecent_erasTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumByron -- ^ Represents the JSON value @"byron"@
  | BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumShelley -- ^ Represents the JSON value @"shelley"@
  | BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumAllegra -- ^ Represents the JSON value @"allegra"@
  | BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumMary -- ^ Represents the JSON value @"mary"@
  | BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumAlonzo -- ^ Represents the JSON value @"alonzo"@
  | BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumBabbage -- ^ Represents the JSON value @"babbage"@
  | BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumConway -- ^ Represents the JSON value @"conway"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf2InfoRecent_eras
    where toJSON (BalanceTransactionResponseBody403OneOf2InfoRecent_erasOther val) = val
          toJSON (BalanceTransactionResponseBody403OneOf2InfoRecent_erasTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumByron) = "byron"
          toJSON (BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumShelley) = "shelley"
          toJSON (BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumAllegra) = "allegra"
          toJSON (BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumMary) = "mary"
          toJSON (BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumAlonzo) = "alonzo"
          toJSON (BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumBabbage) = "babbage"
          toJSON (BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumConway) = "conway"
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf2InfoRecent_eras
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "byron" -> BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumByron
                                            | val GHC.Classes.== "shelley" -> BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumShelley
                                            | val GHC.Classes.== "allegra" -> BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumAllegra
                                            | val GHC.Classes.== "mary" -> BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumMary
                                            | val GHC.Classes.== "alonzo" -> BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumAlonzo
                                            | val GHC.Classes.== "babbage" -> BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumBabbage
                                            | val GHC.Classes.== "conway" -> BalanceTransactionResponseBody403OneOf2InfoRecent_erasEnumConway
                                            | GHC.Base.otherwise -> BalanceTransactionResponseBody403OneOf2InfoRecent_erasOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf3 = BalanceTransactionResponseBody403OneOf3 {
  -- | message: There are withdrawals for multiple networks
  -- (e.g. both mainnet and testnet) in the provided transaction.
  -- This makes no sense, and I\'m confused.
  balanceTransactionResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "balance_tx_conflicting_networks"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "balance_tx_conflicting_networks"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf3" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf3' with all required fields.
mkBalanceTransactionResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf3Message'
  -> BalanceTransactionResponseBody403OneOf3
mkBalanceTransactionResponseBody403OneOf3 balanceTransactionResponseBody403OneOf3Message = BalanceTransactionResponseBody403OneOf3{balanceTransactionResponseBody403OneOf3Message = balanceTransactionResponseBody403OneOf3Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf4 = BalanceTransactionResponseBody403OneOf4 {
  -- | message: I cannot balance transactions with pre-defined collateral.
  balanceTransactionResponseBody403OneOf4Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "balance_tx_existing_collateral"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "balance_tx_existing_collateral"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf4" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf4' with all required fields.
mkBalanceTransactionResponseBody403OneOf4 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf4Message'
  -> BalanceTransactionResponseBody403OneOf4
mkBalanceTransactionResponseBody403OneOf4 balanceTransactionResponseBody403OneOf4Message = BalanceTransactionResponseBody403OneOf4{balanceTransactionResponseBody403OneOf4Message = balanceTransactionResponseBody403OneOf4Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf5 = BalanceTransactionResponseBody403OneOf5 {
  -- | message: The transaction could not be balanced, because it contains
  -- existing key-witnesses which would be invalid after
  -- the transaction body is modified.
  -- Please sign the transaction after it is balanced instead.
  balanceTransactionResponseBody403OneOf5Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "balance_tx_existing_key_witnesses"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "balance_tx_existing_key_witnesses"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf5" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf5' with all required fields.
mkBalanceTransactionResponseBody403OneOf5 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf5Message'
  -> BalanceTransactionResponseBody403OneOf5
mkBalanceTransactionResponseBody403OneOf5 balanceTransactionResponseBody403OneOf5Message = BalanceTransactionResponseBody403OneOf5{balanceTransactionResponseBody403OneOf5Message = balanceTransactionResponseBody403OneOf5Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf6 = BalanceTransactionResponseBody403OneOf6 {
  -- | message: Balancing transactions with pre-defined collateral return outputs
  -- is not yet supported.
  balanceTransactionResponseBody403OneOf6Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "balance_tx_existing_collateral_return_outputs"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "balance_tx_existing_collateral_return_outputs"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf6" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf6' with all required fields.
mkBalanceTransactionResponseBody403OneOf6 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf6Message'
  -> BalanceTransactionResponseBody403OneOf6
mkBalanceTransactionResponseBody403OneOf6 balanceTransactionResponseBody403OneOf6Message = BalanceTransactionResponseBody403OneOf6{balanceTransactionResponseBody403OneOf6Message = balanceTransactionResponseBody403OneOf6Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf7 = BalanceTransactionResponseBody403OneOf7 {
  -- | message: I cannot balance transactions with pre-defined total collateral.
  balanceTransactionResponseBody403OneOf7Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf7
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "balance_tx_existing_total_collateral"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "balance_tx_existing_total_collateral"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf7
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf7" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf7 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf7' with all required fields.
mkBalanceTransactionResponseBody403OneOf7 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf7Message'
  -> BalanceTransactionResponseBody403OneOf7
mkBalanceTransactionResponseBody403OneOf7 balanceTransactionResponseBody403OneOf7Message = BalanceTransactionResponseBody403OneOf7{balanceTransactionResponseBody403OneOf7Message = balanceTransactionResponseBody403OneOf7Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf8 = BalanceTransactionResponseBody403OneOf8 {
  -- | message: Balancing transaction failed for an internal reason.
  balanceTransactionResponseBody403OneOf8Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf8
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "balance_tx_internal_error"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "balance_tx_internal_error"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf8
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf8" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf8 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf8' with all required fields.
mkBalanceTransactionResponseBody403OneOf8 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf8Message'
  -> BalanceTransactionResponseBody403OneOf8
mkBalanceTransactionResponseBody403OneOf8 balanceTransactionResponseBody403OneOf8Message = BalanceTransactionResponseBody403OneOf8{balanceTransactionResponseBody403OneOf8Message = balanceTransactionResponseBody403OneOf8Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf9 = BalanceTransactionResponseBody403OneOf9 {
  -- | message: May occur when a transaction can\'t be balanced for fees.
  balanceTransactionResponseBody403OneOf9Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf9
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf9
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf9" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf9 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf9' with all required fields.
mkBalanceTransactionResponseBody403OneOf9 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf9Message'
  -> BalanceTransactionResponseBody403OneOf9
mkBalanceTransactionResponseBody403OneOf9 balanceTransactionResponseBody403OneOf9Message = BalanceTransactionResponseBody403OneOf9{balanceTransactionResponseBody403OneOf9Message = balanceTransactionResponseBody403OneOf9Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf10 = BalanceTransactionResponseBody403OneOf10 {
  -- | message: May occur when the total balance of pure ada UTxOs in the wallet is
  -- insufficient to cover the minimum collateral amount required for a
  -- transaction requiring collateral.
  balanceTransactionResponseBody403OneOf10Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf10
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf10Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf10Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf10
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf10" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf10 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf10' with all required fields.
mkBalanceTransactionResponseBody403OneOf10 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf10Message'
  -> BalanceTransactionResponseBody403OneOf10
mkBalanceTransactionResponseBody403OneOf10 balanceTransactionResponseBody403OneOf10Message = BalanceTransactionResponseBody403OneOf10{balanceTransactionResponseBody403OneOf10Message = balanceTransactionResponseBody403OneOf10Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf11 = BalanceTransactionResponseBody403OneOf11 {
  -- | message: May occur when trying to perform an operation not supported by this type of wallet.
  balanceTransactionResponseBody403OneOf11Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf11
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf11Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf11Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf11
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf11" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf11 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf11' with all required fields.
mkBalanceTransactionResponseBody403OneOf11 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf11Message'
  -> BalanceTransactionResponseBody403OneOf11
mkBalanceTransactionResponseBody403OneOf11 balanceTransactionResponseBody403OneOf11Message = BalanceTransactionResponseBody403OneOf11{balanceTransactionResponseBody403OneOf11Message = balanceTransactionResponseBody403OneOf11Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf12 = BalanceTransactionResponseBody403OneOf12 {
  -- | message: May occur when there\'s not enough money in the wallet to cover a requested payment.
  balanceTransactionResponseBody403OneOf12Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf12
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf12Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf12Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf12
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf12" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf12 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf12' with all required fields.
mkBalanceTransactionResponseBody403OneOf12 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf12Message'
  -> BalanceTransactionResponseBody403OneOf12
mkBalanceTransactionResponseBody403OneOf12 balanceTransactionResponseBody403OneOf12Message = BalanceTransactionResponseBody403OneOf12{balanceTransactionResponseBody403OneOf12Message = balanceTransactionResponseBody403OneOf12Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf13 = BalanceTransactionResponseBody403OneOf13 {
  -- | message: Occurs when a transaction is already balanced.
  balanceTransactionResponseBody403OneOf13Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf13
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf13Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_already_balanced"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf13Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_already_balanced"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf13
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf13" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf13 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf13' with all required fields.
mkBalanceTransactionResponseBody403OneOf13 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf13Message'
  -> BalanceTransactionResponseBody403OneOf13
mkBalanceTransactionResponseBody403OneOf13 balanceTransactionResponseBody403OneOf13Message = BalanceTransactionResponseBody403OneOf13{balanceTransactionResponseBody403OneOf13Message = balanceTransactionResponseBody403OneOf13Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf14 = BalanceTransactionResponseBody403OneOf14 {
  -- | message: May occur when the wallet can\'t cover for all requested outputs without making the transaction too large.
  balanceTransactionResponseBody403OneOf14Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf14
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf14Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_is_too_big"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf14Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_is_too_big"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf14
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf14" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf14 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf14' with all required fields.
mkBalanceTransactionResponseBody403OneOf14 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf14Message'
  -> BalanceTransactionResponseBody403OneOf14
mkBalanceTransactionResponseBody403OneOf14 balanceTransactionResponseBody403OneOf14Message = BalanceTransactionResponseBody403OneOf14{balanceTransactionResponseBody403OneOf14Message = balanceTransactionResponseBody403OneOf14Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf15 = BalanceTransactionResponseBody403OneOf15 {
  -- | info
  balanceTransactionResponseBody403OneOf15Info :: (GHC.Maybe.Maybe BalanceTransactionResponseBody403OneOf15Info)
  -- | message: Occurs when a requested output has a quantity of lovelace that is below the minimum required by the ledger.
  , balanceTransactionResponseBody403OneOf15Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf15
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (balanceTransactionResponseBody403OneOf15Info obj) : ["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf15Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (balanceTransactionResponseBody403OneOf15Info obj) : ["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf15Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf15
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf15" (\obj -> (GHC.Base.pure BalanceTransactionResponseBody403OneOf15 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "info")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf15' with all required fields.
mkBalanceTransactionResponseBody403OneOf15 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf15Message'
  -> BalanceTransactionResponseBody403OneOf15
mkBalanceTransactionResponseBody403OneOf15 balanceTransactionResponseBody403OneOf15Message = BalanceTransactionResponseBody403OneOf15{balanceTransactionResponseBody403OneOf15Info = GHC.Maybe.Nothing,
                                                                                                                                      balanceTransactionResponseBody403OneOf15Message = balanceTransactionResponseBody403OneOf15Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf.properties.info@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf15Info = BalanceTransactionResponseBody403OneOf15Info {
  -- | tx_output_index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  balanceTransactionResponseBody403OneOf15InfoTx_output_index :: GHC.Types.Int
  -- | tx_output_lovelace_required_minimum: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum :: BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum
  -- | tx_output_lovelace_specified: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified :: BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf15Info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf15InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf15InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf15Info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf15Info" (\obj -> ((GHC.Base.pure BalanceTransactionResponseBody403OneOf15Info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_index")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_required_minimum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_specified"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf15Info' with all required fields.
mkBalanceTransactionResponseBody403OneOf15Info :: GHC.Types.Int -- ^ 'balanceTransactionResponseBody403OneOf15InfoTx_output_index'
  -> BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum -- ^ 'balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum'
  -> BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified -- ^ 'balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified'
  -> BalanceTransactionResponseBody403OneOf15Info
mkBalanceTransactionResponseBody403OneOf15Info balanceTransactionResponseBody403OneOf15InfoTx_output_index balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified = BalanceTransactionResponseBody403OneOf15Info{balanceTransactionResponseBody403OneOf15InfoTx_output_index = balanceTransactionResponseBody403OneOf15InfoTx_output_index,
                                                                                                                                                                                                                                                                                                                   balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum = balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum,
                                                                                                                                                                                                                                                                                                                   balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified = balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_required_minimum@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum = BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimumQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum' with all required fields.
mkBalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum :: GHC.Types.Int -- ^ 'balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimumQuantity'
  -> BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum
mkBalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimumQuantity = BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimum{balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimumQuantity = balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_required_minimumQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_specified@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified = BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specifiedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified' with all required fields.
mkBalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified :: GHC.Types.Int -- ^ 'balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specifiedQuantity'
  -> BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified
mkBalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specifiedQuantity = BalanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specified{balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specifiedQuantity = balanceTransactionResponseBody403OneOf15InfoTx_output_lovelace_specifiedQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403OneOf16 = BalanceTransactionResponseBody403OneOf16 {
  -- | message: The transaction could be deserialised, just not in the era of the local node.
  balanceTransactionResponseBody403OneOf16Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403OneOf16
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf16Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "tx_not_in_node_era"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody403OneOf16Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "tx_not_in_node_era"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403OneOf16
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody403OneOf16" (\obj -> GHC.Base.pure BalanceTransactionResponseBody403OneOf16 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody403OneOf16' with all required fields.
mkBalanceTransactionResponseBody403OneOf16 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody403OneOf16Message'
  -> BalanceTransactionResponseBody403OneOf16
mkBalanceTransactionResponseBody403OneOf16 balanceTransactionResponseBody403OneOf16Message = BalanceTransactionResponseBody403OneOf16{balanceTransactionResponseBody403OneOf16Message = balanceTransactionResponseBody403OneOf16Message}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody403Variants =
   BalanceTransactionResponseBody403Variant1 BalanceTransactionResponseBody403OneOf1
  | BalanceTransactionResponseBody403Variant2 BalanceTransactionResponseBody403OneOf2
  | BalanceTransactionResponseBody403Variant3 BalanceTransactionResponseBody403OneOf3
  | BalanceTransactionResponseBody403Variant4 BalanceTransactionResponseBody403OneOf4
  | BalanceTransactionResponseBody403Variant5 BalanceTransactionResponseBody403OneOf5
  | BalanceTransactionResponseBody403Variant6 BalanceTransactionResponseBody403OneOf6
  | BalanceTransactionResponseBody403Variant7 BalanceTransactionResponseBody403OneOf7
  | BalanceTransactionResponseBody403Variant8 BalanceTransactionResponseBody403OneOf8
  | BalanceTransactionResponseBody403Variant9 BalanceTransactionResponseBody403OneOf9
  | BalanceTransactionResponseBody403Variant10 BalanceTransactionResponseBody403OneOf10
  | BalanceTransactionResponseBody403Variant11 BalanceTransactionResponseBody403OneOf11
  | BalanceTransactionResponseBody403Variant12 BalanceTransactionResponseBody403OneOf12
  | BalanceTransactionResponseBody403Variant13 BalanceTransactionResponseBody403OneOf13
  | BalanceTransactionResponseBody403Variant14 BalanceTransactionResponseBody403OneOf14
  | BalanceTransactionResponseBody403Variant15 BalanceTransactionResponseBody403OneOf15
  | BalanceTransactionResponseBody403Variant16 BalanceTransactionResponseBody403OneOf16
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody403Variants
    where toJSON (BalanceTransactionResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody403Variant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody403Variant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody403Variant6 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody403Variant7 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody403Variant8 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody403Variant9 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody403Variant10 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody403Variant11 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody403Variant12 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody403Variant13 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody403Variant14 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody403Variant15 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (BalanceTransactionResponseBody403Variant16 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody403Variants
    where parseJSON val = case (BalanceTransactionResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody403Variant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody403Variant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody403Variant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody403Variant7 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody403Variant8 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody403Variant9 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody403Variant10 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody403Variant11 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody403Variant12 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody403Variant13 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody403Variant14 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody403Variant15 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((BalanceTransactionResponseBody403Variant16 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))))))))))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody404 = BalanceTransactionResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  balanceTransactionResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody404" (\obj -> GHC.Base.pure BalanceTransactionResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody404' with all required fields.
mkBalanceTransactionResponseBody404 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody404Message'
  -> BalanceTransactionResponseBody404
mkBalanceTransactionResponseBody404 balanceTransactionResponseBody404Message = BalanceTransactionResponseBody404{balanceTransactionResponseBody404Message = balanceTransactionResponseBody404Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody406 = BalanceTransactionResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  balanceTransactionResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody406" (\obj -> GHC.Base.pure BalanceTransactionResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody406' with all required fields.
mkBalanceTransactionResponseBody406 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody406Message'
  -> BalanceTransactionResponseBody406
mkBalanceTransactionResponseBody406 balanceTransactionResponseBody406Message = BalanceTransactionResponseBody406{balanceTransactionResponseBody406Message = balanceTransactionResponseBody406Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-balance.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data BalanceTransactionResponseBody415 = BalanceTransactionResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  balanceTransactionResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON BalanceTransactionResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= balanceTransactionResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON BalanceTransactionResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "BalanceTransactionResponseBody415" (\obj -> GHC.Base.pure BalanceTransactionResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'BalanceTransactionResponseBody415' with all required fields.
mkBalanceTransactionResponseBody415 :: Data.Text.Internal.Text -- ^ 'balanceTransactionResponseBody415Message'
  -> BalanceTransactionResponseBody415
mkBalanceTransactionResponseBody415 balanceTransactionResponseBody415Message = BalanceTransactionResponseBody415{balanceTransactionResponseBody415Message = balanceTransactionResponseBody415Message}
-- | > POST /wallets/{walletId}/transactions-balance
-- 
-- The same as 'balanceTransaction' but accepts an explicit configuration.
balanceTransactionWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> BalanceTransactionRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response BalanceTransactionResponse) -- ^ Monadic computation which returns the result of the operation
balanceTransactionWithConfiguration config
                                    walletId
                                    body = GHC.Base.fmap (\response_7 -> GHC.Base.fmap (Data.Either.either BalanceTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> BalanceTransactionResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                          BalanceTransactionResponseBody202)
                                                                                                                                                                                        | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> BalanceTransactionResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                          BalanceTransactionResponseBody400Variants)
                                                                                                                                                                                        | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> BalanceTransactionResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                            BalanceTransactionResponseBody403Variants)
                                                                                                                                                                                        | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> BalanceTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                            BalanceTransactionResponseBody404)
                                                                                                                                                                                        | (\status_12 -> Network.HTTP.Types.Status.statusCode status_12 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> BalanceTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                            BalanceTransactionResponseBody406)
                                                                                                                                                                                        | (\status_13 -> Network.HTTP.Types.Status.statusCode status_13 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> BalanceTransactionResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                            BalanceTransactionResponseBody415)
                                                                                                                                                                                        | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_7) response_7) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-balance")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/transactions-balance
-- 
-- The same as 'balanceTransaction' but returns the raw 'Data.ByteString.ByteString'.
balanceTransactionRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> BalanceTransactionRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
balanceTransactionRaw walletId
                      body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-balance")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/transactions-balance
-- 
-- The same as 'balanceTransaction' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
balanceTransactionWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> BalanceTransactionRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
balanceTransactionWithConfigurationRaw config
                                       walletId
                                       body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-balance")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
