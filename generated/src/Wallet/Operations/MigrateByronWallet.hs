-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation migrateByronWallet
module Wallet.Operations.MigrateByronWallet where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /byron-wallets/{walletId}/migrations
-- 
-- Migrate the UTxO balance of this wallet to the given set of addresses.
-- 
-- This operation will attempt to transfer as much of the wallet\'s balance
-- as possible to the given set of addresses, by creating and submitting
-- as many transactions as may be necessary to migrate the entire balance.
-- 
-- In order to minimize the total transaction fee required, UTxO entries
-- are coalesced together to the greatest extent possible in the resulting
-- transactions. No attempt is made to preserve the wallet\'s UTxO
-- distribution.
-- 
-- This operation is performed on a best-effort basis. If there is
-- insufficient ada available to pay for the entire UTxO set to be
-- migrated, then only a subset of the wallet\'s UTxO set will be migrated.
-- 
-- A typical use of this operation would be to move all funds from an old
-- wallet to a new wallet, by providing addresses that belong to the new
-- wallet.
migrateByronWallet :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> MigrateByronWalletRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response MigrateByronWalletResponse) -- ^ Monadic computation which returns the result of the operation
migrateByronWallet walletId
                   body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either MigrateByronWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> MigrateByronWalletResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         ([MigrateByronWalletResponseBody202]))
                                                                                                                                                                       | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> MigrateByronWalletResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         MigrateByronWalletResponseBody403Variants)
                                                                                                                                                                       | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> MigrateByronWalletResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         MigrateByronWalletResponseBody404)
                                                                                                                                                                       | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> MigrateByronWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         MigrateByronWalletResponseBody406)
                                                                                                                                                                       | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> MigrateByronWalletResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         MigrateByronWalletResponseBody415)
                                                                                                                                                                       | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/migrations")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.requestBody.content.application\/json.schema@ in the specification.
-- 
-- 
data MigrateByronWalletRequestBody = MigrateByronWalletRequestBody {
  -- | addresses: The recipient addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateByronWalletRequestBodyAddresses :: ([Data.Text.Internal.Text])
  -- | passphrase: The wallet\'s master passphrase.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 0
  , migrateByronWalletRequestBodyPassphrase :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["addresses" Data.Aeson.Types.ToJSON..= migrateByronWalletRequestBodyAddresses obj] : ["passphrase" Data.Aeson.Types.ToJSON..= migrateByronWalletRequestBodyPassphrase obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["addresses" Data.Aeson.Types.ToJSON..= migrateByronWalletRequestBodyAddresses obj] : ["passphrase" Data.Aeson.Types.ToJSON..= migrateByronWalletRequestBodyPassphrase obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletRequestBody" (\obj -> (GHC.Base.pure MigrateByronWalletRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "addresses")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "passphrase"))
-- | Create a new 'MigrateByronWalletRequestBody' with all required fields.
mkMigrateByronWalletRequestBody :: [Data.Text.Internal.Text] -- ^ 'migrateByronWalletRequestBodyAddresses'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletRequestBodyPassphrase'
  -> MigrateByronWalletRequestBody
mkMigrateByronWalletRequestBody migrateByronWalletRequestBodyAddresses migrateByronWalletRequestBodyPassphrase = MigrateByronWalletRequestBody{migrateByronWalletRequestBodyAddresses = migrateByronWalletRequestBodyAddresses,
                                                                                                                                               migrateByronWalletRequestBodyPassphrase = migrateByronWalletRequestBodyPassphrase}
-- | Represents a response of the operation 'migrateByronWallet'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'MigrateByronWalletResponseError' is used.
data MigrateByronWalletResponse =
   MigrateByronWalletResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | MigrateByronWalletResponse202 ([MigrateByronWalletResponseBody202]) -- ^ Accepted
  | MigrateByronWalletResponse403 MigrateByronWalletResponseBody403Variants -- ^ Forbidden
  | MigrateByronWalletResponse404 MigrateByronWalletResponseBody404 -- ^ Not Found
  | MigrateByronWalletResponse406 MigrateByronWalletResponseBody406 -- ^ Not Acceptable
  | MigrateByronWalletResponse415 MigrateByronWalletResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202 = MigrateByronWalletResponseBody202 {
  -- | amount: An amount of Ada spent or received, from the perspective of the wallet.
  -- 
  -- That is, for outgoing transaction, it represents the amount of Ada consumed
  -- as inputs including the amount of Ada spent as fees or deposits.
  -- 
  -- For incoming transaction, it represents the total amount of Ada received to
  -- addresses that belong to the wallet.
  migrateByronWalletResponseBody202Amount :: MigrateByronWalletResponseBody202Amount
  -- | burn
  , migrateByronWalletResponseBody202Burn :: (GHC.Maybe.Maybe MigrateByronWalletResponseBody202Burn)
  -- | certificates
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , migrateByronWalletResponseBody202Certificates :: (GHC.Maybe.Maybe ([MigrateByronWalletResponseBody202CertificatesVariants]))
  -- | collateral: A list of transaction inputs used for collateral.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , migrateByronWalletResponseBody202Collateral :: (GHC.Maybe.Maybe ([MigrateByronWalletResponseBody202Collateral]))
  -- | collateral_outputs: A list of collateral return outputs with amounts specified.
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 1 items
  -- * Must have a minimum of 0 items
  , migrateByronWalletResponseBody202Collateral_outputs :: (GHC.Maybe.Maybe ([MigrateByronWalletResponseBody202Collateral_outputs]))
  -- | deposit_returned: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , migrateByronWalletResponseBody202Deposit_returned :: MigrateByronWalletResponseBody202Deposit_returned
  -- | deposit_taken: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , migrateByronWalletResponseBody202Deposit_taken :: MigrateByronWalletResponseBody202Deposit_taken
  -- | depth: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Current depth of the transaction in the local chain
  , migrateByronWalletResponseBody202Depth :: (GHC.Maybe.Maybe MigrateByronWalletResponseBody202Depth)
  -- | direction
  , migrateByronWalletResponseBody202Direction :: MigrateByronWalletResponseBody202Direction
  -- | expires_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending OR status == expired
  -- \<\/span>\<br\/>
  -- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
  , migrateByronWalletResponseBody202Expires_at :: (GHC.Maybe.Maybe MigrateByronWalletResponseBody202Expires_at)
  -- | extra_signatures
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , migrateByronWalletResponseBody202Extra_signatures :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | fee: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , migrateByronWalletResponseBody202Fee :: MigrateByronWalletResponseBody202Fee
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , migrateByronWalletResponseBody202Id :: Data.Text.Internal.Text
  -- | inputs: A list of transaction inputs.
  -- 
  -- \`assets\` and \`address\` are always present for \`outgoing\`
  -- transactions but generally absent for \`incoming\`
  -- transactions. This information is present on the Cardano explorer,
  -- but is not tracked by the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , migrateByronWalletResponseBody202Inputs :: ([MigrateByronWalletResponseBody202Inputs])
  -- | inserted_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Absolute time at which the transaction was inserted in a block.
  , migrateByronWalletResponseBody202Inserted_at :: (GHC.Maybe.Maybe MigrateByronWalletResponseBody202Inserted_at)
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  , migrateByronWalletResponseBody202Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | mint
  , migrateByronWalletResponseBody202Mint :: (GHC.Maybe.Maybe MigrateByronWalletResponseBody202Mint)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , migrateByronWalletResponseBody202Outputs :: ([MigrateByronWalletResponseBody202Outputs])
  -- | pending_since: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending
  -- \<\/span>\<br\/>
  -- The point in time at which a transaction became pending.
  , migrateByronWalletResponseBody202Pending_since :: (GHC.Maybe.Maybe MigrateByronWalletResponseBody202Pending_since)
  -- | script_integrity: A script data integrity hash - 32 bytes
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^(script_data)1[0-9a-z]*\$\'
  , migrateByronWalletResponseBody202Script_integrity :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | script_validity: Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
  -- used in the transaction validated or not. Validity may be null if this
  -- transaction was from an era that doesn\'t support phase-2 monetary policy
  -- scripts, or is a pending transaction (we don\'t know if validation passed or
  -- failed until the transaction hits the ledger).
  , migrateByronWalletResponseBody202Script_validity :: (GHC.Maybe.Maybe (Wallet.Common.Nullable MigrateByronWalletResponseBody202Script_validityNonNullable))
  -- | status: Current transaction status.
  -- 
  --   \`\`\`
  --        *-----------*
  --   ---> |  PENDING  |----------------*
  --        *-----------*                |
  --              |                      |
  --              V                      V
  --        *-----------*          *-----------*
  --        |           |---------->  EXPIRED  |
  --        |           |  (ttl)   *-----------*
  --        | SUBMITTED |
  --        |           \<----------------*
  --        |           |                |
  --        *-----------*           (rollback)
  --               |                     |
  --          (in ledger)          *-----------*
  --               |               |           |
  --               *---------------> IN_LEDGER |
  --                               |           |
  --                               *-----------*
  --   \`\`\`
  , migrateByronWalletResponseBody202Status :: MigrateByronWalletResponseBody202Status
  -- | validity_interval
  , migrateByronWalletResponseBody202Validity_interval :: (GHC.Maybe.Maybe MigrateByronWalletResponseBody202Validity_interval)
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , migrateByronWalletResponseBody202Withdrawals :: ([MigrateByronWalletResponseBody202Withdrawals])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Fee obj] : ["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Withdrawals obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Fee obj] : ["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Withdrawals obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202" (\obj -> (((((((((((((((((((((((GHC.Base.pure MigrateByronWalletResponseBody202 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "burn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral_outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "depth")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "direction")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "expires_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "extra_signatures")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fee")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "inserted_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pending_since")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_integrity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_validity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "validity_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "withdrawals"))
-- | Create a new 'MigrateByronWalletResponseBody202' with all required fields.
mkMigrateByronWalletResponseBody202 :: MigrateByronWalletResponseBody202Amount -- ^ 'migrateByronWalletResponseBody202Amount'
  -> MigrateByronWalletResponseBody202Deposit_returned -- ^ 'migrateByronWalletResponseBody202Deposit_returned'
  -> MigrateByronWalletResponseBody202Deposit_taken -- ^ 'migrateByronWalletResponseBody202Deposit_taken'
  -> MigrateByronWalletResponseBody202Direction -- ^ 'migrateByronWalletResponseBody202Direction'
  -> MigrateByronWalletResponseBody202Fee -- ^ 'migrateByronWalletResponseBody202Fee'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202Id'
  -> [MigrateByronWalletResponseBody202Inputs] -- ^ 'migrateByronWalletResponseBody202Inputs'
  -> [MigrateByronWalletResponseBody202Outputs] -- ^ 'migrateByronWalletResponseBody202Outputs'
  -> MigrateByronWalletResponseBody202Status -- ^ 'migrateByronWalletResponseBody202Status'
  -> [MigrateByronWalletResponseBody202Withdrawals] -- ^ 'migrateByronWalletResponseBody202Withdrawals'
  -> MigrateByronWalletResponseBody202
mkMigrateByronWalletResponseBody202 migrateByronWalletResponseBody202Amount migrateByronWalletResponseBody202Deposit_returned migrateByronWalletResponseBody202Deposit_taken migrateByronWalletResponseBody202Direction migrateByronWalletResponseBody202Fee migrateByronWalletResponseBody202Id migrateByronWalletResponseBody202Inputs migrateByronWalletResponseBody202Outputs migrateByronWalletResponseBody202Status migrateByronWalletResponseBody202Withdrawals = MigrateByronWalletResponseBody202{migrateByronWalletResponseBody202Amount = migrateByronWalletResponseBody202Amount,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Burn = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Certificates = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Collateral = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Collateral_outputs = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Deposit_returned = migrateByronWalletResponseBody202Deposit_returned,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Deposit_taken = migrateByronWalletResponseBody202Deposit_taken,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Depth = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Direction = migrateByronWalletResponseBody202Direction,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Expires_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Extra_signatures = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Fee = migrateByronWalletResponseBody202Fee,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Id = migrateByronWalletResponseBody202Id,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Inputs = migrateByronWalletResponseBody202Inputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Inserted_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Mint = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Outputs = migrateByronWalletResponseBody202Outputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Pending_since = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Script_integrity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Script_validity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Status = migrateByronWalletResponseBody202Status,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Validity_interval = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Withdrawals = migrateByronWalletResponseBody202Withdrawals}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.amount@ in the specification.
-- 
-- An amount of Ada spent or received, from the perspective of the wallet.
-- 
-- That is, for outgoing transaction, it represents the amount of Ada consumed
-- as inputs including the amount of Ada spent as fees or deposits.
-- 
-- For incoming transaction, it represents the total amount of Ada received to
-- addresses that belong to the wallet.
data MigrateByronWalletResponseBody202Amount = MigrateByronWalletResponseBody202Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Amount" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202Amount' with all required fields.
mkMigrateByronWalletResponseBody202Amount :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202AmountQuantity'
  -> MigrateByronWalletResponseBody202Amount
mkMigrateByronWalletResponseBody202Amount migrateByronWalletResponseBody202AmountQuantity = MigrateByronWalletResponseBody202Amount{migrateByronWalletResponseBody202AmountQuantity = migrateByronWalletResponseBody202AmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202Burn = MigrateByronWalletResponseBody202Burn {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  migrateByronWalletResponseBody202BurnTokens :: ([MigrateByronWalletResponseBody202BurnTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , migrateByronWalletResponseBody202BurnWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , migrateByronWalletResponseBody202BurnWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202BurnWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202BurnWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Burn" (\obj -> ((GHC.Base.pure MigrateByronWalletResponseBody202Burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'MigrateByronWalletResponseBody202Burn' with all required fields.
mkMigrateByronWalletResponseBody202Burn :: [MigrateByronWalletResponseBody202BurnTokens] -- ^ 'migrateByronWalletResponseBody202BurnTokens'
  -> MigrateByronWalletResponseBody202Burn
mkMigrateByronWalletResponseBody202Burn migrateByronWalletResponseBody202BurnTokens = MigrateByronWalletResponseBody202Burn{migrateByronWalletResponseBody202BurnTokens = migrateByronWalletResponseBody202BurnTokens,
                                                                                                                            migrateByronWalletResponseBody202BurnWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                            migrateByronWalletResponseBody202BurnWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202BurnTokens = MigrateByronWalletResponseBody202BurnTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateByronWalletResponseBody202BurnTokensAssets :: ([MigrateByronWalletResponseBody202BurnTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateByronWalletResponseBody202BurnTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , migrateByronWalletResponseBody202BurnTokensPolicy_script :: MigrateByronWalletResponseBody202BurnTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202BurnTokens" (\obj -> ((GHC.Base.pure MigrateByronWalletResponseBody202BurnTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'MigrateByronWalletResponseBody202BurnTokens' with all required fields.
mkMigrateByronWalletResponseBody202BurnTokens :: [MigrateByronWalletResponseBody202BurnTokensAssets] -- ^ 'migrateByronWalletResponseBody202BurnTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_id'
  -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptVariants -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_script'
  -> MigrateByronWalletResponseBody202BurnTokens
mkMigrateByronWalletResponseBody202BurnTokens migrateByronWalletResponseBody202BurnTokensAssets migrateByronWalletResponseBody202BurnTokensPolicy_id migrateByronWalletResponseBody202BurnTokensPolicy_script = MigrateByronWalletResponseBody202BurnTokens{migrateByronWalletResponseBody202BurnTokensAssets = migrateByronWalletResponseBody202BurnTokensAssets,
                                                                                                                                                                                                                                                            migrateByronWalletResponseBody202BurnTokensPolicy_id = migrateByronWalletResponseBody202BurnTokensPolicy_id,
                                                                                                                                                                                                                                                            migrateByronWalletResponseBody202BurnTokensPolicy_script = migrateByronWalletResponseBody202BurnTokensPolicy_script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202BurnTokensAssets = MigrateByronWalletResponseBody202BurnTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  migrateByronWalletResponseBody202BurnTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , migrateByronWalletResponseBody202BurnTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202BurnTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202BurnTokensAssets" (\obj -> ((GHC.Base.pure MigrateByronWalletResponseBody202BurnTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202BurnTokensAssets' with all required fields.
mkMigrateByronWalletResponseBody202BurnTokensAssets :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202BurnTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202BurnTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202BurnTokensAssetsQuantity'
  -> MigrateByronWalletResponseBody202BurnTokensAssets
mkMigrateByronWalletResponseBody202BurnTokensAssets migrateByronWalletResponseBody202BurnTokensAssetsAsset_name migrateByronWalletResponseBody202BurnTokensAssetsFingerprint migrateByronWalletResponseBody202BurnTokensAssetsQuantity = MigrateByronWalletResponseBody202BurnTokensAssets{migrateByronWalletResponseBody202BurnTokensAssetsAsset_name = migrateByronWalletResponseBody202BurnTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202BurnTokensAssetsFingerprint = migrateByronWalletResponseBody202BurnTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202BurnTokensAssetsQuantity = migrateByronWalletResponseBody202BurnTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1 = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference)
  -- | script
  , migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Script :: MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1' with all required fields.
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1 :: MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Script'
  -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1 migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Script = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1{migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                       migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Script = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference' with all required fields.
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex'
  -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference{migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2{migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3{migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 :: MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4{migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some{migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                            migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5{migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6{migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants =
   MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
  | MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
  | MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
  | MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
  | MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2 = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info :: MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2' with all required fields.
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2 :: MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info'
  -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2 migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2{migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                            migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference' with all required fields.
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex'
  -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference{migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version :: MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info :: MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info{migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                                       migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3 = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References :: ([MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3' with all required fields.
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3 :: [MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References] -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash'
  -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3 migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3{migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                                     migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References' with all required fields.
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex'
  -> MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References
mkMigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex = MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3References{migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                               migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex = migrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202BurnTokensPolicy_scriptVariants =
   MigrateByronWalletResponseBody202BurnTokensPolicy_scriptVariant1 MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf1
  | MigrateByronWalletResponseBody202BurnTokensPolicy_scriptVariant2 MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf2
  | MigrateByronWalletResponseBody202BurnTokensPolicy_scriptVariant3 MigrateByronWalletResponseBody202BurnTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptVariants
    where toJSON (MigrateByronWalletResponseBody202BurnTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202BurnTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202BurnTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202BurnTokensPolicy_scriptVariants
    where parseJSON val = case (MigrateByronWalletResponseBody202BurnTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202BurnTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202BurnTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data MigrateByronWalletResponseBody202CertificatesOneOf1 = MigrateByronWalletResponseBody202CertificatesOneOf1 {
  -- | certificate_type
  migrateByronWalletResponseBody202CertificatesOneOf1Certificate_type :: MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_type
  -- | pool: A unique identifier for the pool.
  , migrateByronWalletResponseBody202CertificatesOneOf1Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , migrateByronWalletResponseBody202CertificatesOneOf1Reward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202CertificatesOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202CertificatesOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202CertificatesOneOf1" (\obj -> ((GHC.Base.pure MigrateByronWalletResponseBody202CertificatesOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'MigrateByronWalletResponseBody202CertificatesOneOf1' with all required fields.
mkMigrateByronWalletResponseBody202CertificatesOneOf1 :: MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_type -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf1Certificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf1Reward_account_path'
  -> MigrateByronWalletResponseBody202CertificatesOneOf1
mkMigrateByronWalletResponseBody202CertificatesOneOf1 migrateByronWalletResponseBody202CertificatesOneOf1Certificate_type migrateByronWalletResponseBody202CertificatesOneOf1Reward_account_path = MigrateByronWalletResponseBody202CertificatesOneOf1{migrateByronWalletResponseBody202CertificatesOneOf1Certificate_type = migrateByronWalletResponseBody202CertificatesOneOf1Certificate_type,
                                                                                                                                                                                                                                                       migrateByronWalletResponseBody202CertificatesOneOf1Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                       migrateByronWalletResponseBody202CertificatesOneOf1Reward_account_path = migrateByronWalletResponseBody202CertificatesOneOf1Reward_account_path}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_type =
   MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_type
    where toJSON (MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_typeOther val) = val
          toJSON (MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool) = "join_pool"
          toJSON (MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> MigrateByronWalletResponseBody202CertificatesOneOf1Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate not belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data MigrateByronWalletResponseBody202CertificatesOneOf2 = MigrateByronWalletResponseBody202CertificatesOneOf2 {
  -- | certificate_type
  migrateByronWalletResponseBody202CertificatesOneOf2Certificate_type :: MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_type
  -- | pool: A unique identifier for the pool.
  , migrateByronWalletResponseBody202CertificatesOneOf2Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account
  , migrateByronWalletResponseBody202CertificatesOneOf2Reward_account :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202CertificatesOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf2Reward_account obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf2Reward_account obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202CertificatesOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202CertificatesOneOf2" (\obj -> ((GHC.Base.pure MigrateByronWalletResponseBody202CertificatesOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account"))
-- | Create a new 'MigrateByronWalletResponseBody202CertificatesOneOf2' with all required fields.
mkMigrateByronWalletResponseBody202CertificatesOneOf2 :: MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_type -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf2Certificate_type'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf2Reward_account'
  -> MigrateByronWalletResponseBody202CertificatesOneOf2
mkMigrateByronWalletResponseBody202CertificatesOneOf2 migrateByronWalletResponseBody202CertificatesOneOf2Certificate_type migrateByronWalletResponseBody202CertificatesOneOf2Reward_account = MigrateByronWalletResponseBody202CertificatesOneOf2{migrateByronWalletResponseBody202CertificatesOneOf2Certificate_type = migrateByronWalletResponseBody202CertificatesOneOf2Certificate_type,
                                                                                                                                                                                                                                                  migrateByronWalletResponseBody202CertificatesOneOf2Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                  migrateByronWalletResponseBody202CertificatesOneOf2Reward_account = migrateByronWalletResponseBody202CertificatesOneOf2Reward_account}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_type =
   MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external -- ^ Represents the JSON value @"join_pool_external"@
  | MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external -- ^ Represents the JSON value @"quit_pool_external"@
  | MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external -- ^ Represents the JSON value @"register_reward_account_external"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_type
    where toJSON (MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_typeOther val) = val
          toJSON (MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external) = "join_pool_external"
          toJSON (MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external) = "quit_pool_external"
          toJSON (MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external) = "register_reward_account_external"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool_external" -> MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external
                                            | val GHC.Classes.== "quit_pool_external" -> MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external
                                            | val GHC.Classes.== "register_reward_account_external" -> MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external
                                            | GHC.Base.otherwise -> MigrateByronWalletResponseBody202CertificatesOneOf2Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202CertificatesOneOf3 = MigrateByronWalletResponseBody202CertificatesOneOf3 {
  -- | pool_cost: Estimated cost set by the pool operator when registering his pool.
  -- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  migrateByronWalletResponseBody202CertificatesOneOf3Pool_cost :: MigrateByronWalletResponseBody202CertificatesOneOf3Pool_cost
  -- | pool_id: A unique identifier for the pool.
  , migrateByronWalletResponseBody202CertificatesOneOf3Pool_id :: Data.Text.Internal.Text
  -- | pool_margin: Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , migrateByronWalletResponseBody202CertificatesOneOf3Pool_margin :: MigrateByronWalletResponseBody202CertificatesOneOf3Pool_margin
  -- | pool_metadata
  , migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata :: (GHC.Maybe.Maybe MigrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata)
  -- | pool_owners
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , migrateByronWalletResponseBody202CertificatesOneOf3Pool_owners :: ([Data.Text.Internal.Text])
  -- | pool_pledge: Minimal stake amount that a stake pool is willing to honor.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , migrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge :: MigrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202CertificatesOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202CertificatesOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202CertificatesOneOf3" (\obj -> (((((GHC.Base.pure MigrateByronWalletResponseBody202CertificatesOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_cost")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_margin")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool_metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_owners")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_pledge"))
-- | Create a new 'MigrateByronWalletResponseBody202CertificatesOneOf3' with all required fields.
mkMigrateByronWalletResponseBody202CertificatesOneOf3 :: MigrateByronWalletResponseBody202CertificatesOneOf3Pool_cost -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf3Pool_cost'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf3Pool_id'
  -> MigrateByronWalletResponseBody202CertificatesOneOf3Pool_margin -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf3Pool_margin'
  -> [Data.Text.Internal.Text] -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf3Pool_owners'
  -> MigrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge'
  -> MigrateByronWalletResponseBody202CertificatesOneOf3
mkMigrateByronWalletResponseBody202CertificatesOneOf3 migrateByronWalletResponseBody202CertificatesOneOf3Pool_cost migrateByronWalletResponseBody202CertificatesOneOf3Pool_id migrateByronWalletResponseBody202CertificatesOneOf3Pool_margin migrateByronWalletResponseBody202CertificatesOneOf3Pool_owners migrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge = MigrateByronWalletResponseBody202CertificatesOneOf3{migrateByronWalletResponseBody202CertificatesOneOf3Pool_cost = migrateByronWalletResponseBody202CertificatesOneOf3Pool_cost,
                                                                                                                                                                                                                                                                                                                                                                                                                                 migrateByronWalletResponseBody202CertificatesOneOf3Pool_id = migrateByronWalletResponseBody202CertificatesOneOf3Pool_id,
                                                                                                                                                                                                                                                                                                                                                                                                                                 migrateByronWalletResponseBody202CertificatesOneOf3Pool_margin = migrateByronWalletResponseBody202CertificatesOneOf3Pool_margin,
                                                                                                                                                                                                                                                                                                                                                                                                                                 migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                 migrateByronWalletResponseBody202CertificatesOneOf3Pool_owners = migrateByronWalletResponseBody202CertificatesOneOf3Pool_owners,
                                                                                                                                                                                                                                                                                                                                                                                                                                 migrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge = migrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_cost@ in the specification.
-- 
-- Estimated cost set by the pool operator when registering his pool.
-- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data MigrateByronWalletResponseBody202CertificatesOneOf3Pool_cost = MigrateByronWalletResponseBody202CertificatesOneOf3Pool_cost {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202CertificatesOneOf3Pool_costQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202CertificatesOneOf3Pool_cost
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202CertificatesOneOf3Pool_cost
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202CertificatesOneOf3Pool_cost" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202CertificatesOneOf3Pool_cost GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202CertificatesOneOf3Pool_cost' with all required fields.
mkMigrateByronWalletResponseBody202CertificatesOneOf3Pool_cost :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf3Pool_costQuantity'
  -> MigrateByronWalletResponseBody202CertificatesOneOf3Pool_cost
mkMigrateByronWalletResponseBody202CertificatesOneOf3Pool_cost migrateByronWalletResponseBody202CertificatesOneOf3Pool_costQuantity = MigrateByronWalletResponseBody202CertificatesOneOf3Pool_cost{migrateByronWalletResponseBody202CertificatesOneOf3Pool_costQuantity = migrateByronWalletResponseBody202CertificatesOneOf3Pool_costQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_margin@ in the specification.
-- 
-- Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data MigrateByronWalletResponseBody202CertificatesOneOf3Pool_margin = MigrateByronWalletResponseBody202CertificatesOneOf3Pool_margin {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202CertificatesOneOf3Pool_marginQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202CertificatesOneOf3Pool_margin
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202CertificatesOneOf3Pool_margin
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202CertificatesOneOf3Pool_margin" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202CertificatesOneOf3Pool_margin GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202CertificatesOneOf3Pool_margin' with all required fields.
mkMigrateByronWalletResponseBody202CertificatesOneOf3Pool_margin :: GHC.Types.Double -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf3Pool_marginQuantity'
  -> MigrateByronWalletResponseBody202CertificatesOneOf3Pool_margin
mkMigrateByronWalletResponseBody202CertificatesOneOf3Pool_margin migrateByronWalletResponseBody202CertificatesOneOf3Pool_marginQuantity = MigrateByronWalletResponseBody202CertificatesOneOf3Pool_margin{migrateByronWalletResponseBody202CertificatesOneOf3Pool_marginQuantity = migrateByronWalletResponseBody202CertificatesOneOf3Pool_marginQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_metadata@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata = MigrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata {
  -- | hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadataHash :: Data.Text.Internal.Text
  -- | url: A URL to the stake pool\'s website.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 250
  -- * Must match pattern \'^https:\/\/.+\'
  , migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadataUrl :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))
-- | Create a new 'MigrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata' with all required fields.
mkMigrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadataHash'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadataUrl'
  -> MigrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata
mkMigrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadataHash migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadataUrl = MigrateByronWalletResponseBody202CertificatesOneOf3Pool_metadata{migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadataHash = migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadataHash,
                                                                                                                                                                                                                                                                               migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadataUrl = migrateByronWalletResponseBody202CertificatesOneOf3Pool_metadataUrl}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_pledge@ in the specification.
-- 
-- Minimal stake amount that a stake pool is willing to honor.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data MigrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge = MigrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202CertificatesOneOf3Pool_pledgeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge' with all required fields.
mkMigrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf3Pool_pledgeQuantity'
  -> MigrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge
mkMigrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge migrateByronWalletResponseBody202CertificatesOneOf3Pool_pledgeQuantity = MigrateByronWalletResponseBody202CertificatesOneOf3Pool_pledge{migrateByronWalletResponseBody202CertificatesOneOf3Pool_pledgeQuantity = migrateByronWalletResponseBody202CertificatesOneOf3Pool_pledgeQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202CertificatesOneOf4 = MigrateByronWalletResponseBody202CertificatesOneOf4 {
  -- | pool_id: A unique identifier for the pool.
  migrateByronWalletResponseBody202CertificatesOneOf4Pool_id :: Data.Text.Internal.Text
  -- | retirement_epoch: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202CertificatesOneOf4Retirement_epoch :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202CertificatesOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202CertificatesOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202CertificatesOneOf4" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202CertificatesOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "retirement_epoch"))
-- | Create a new 'MigrateByronWalletResponseBody202CertificatesOneOf4' with all required fields.
mkMigrateByronWalletResponseBody202CertificatesOneOf4 :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf4Pool_id'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf4Retirement_epoch'
  -> MigrateByronWalletResponseBody202CertificatesOneOf4
mkMigrateByronWalletResponseBody202CertificatesOneOf4 migrateByronWalletResponseBody202CertificatesOneOf4Pool_id migrateByronWalletResponseBody202CertificatesOneOf4Retirement_epoch = MigrateByronWalletResponseBody202CertificatesOneOf4{migrateByronWalletResponseBody202CertificatesOneOf4Pool_id = migrateByronWalletResponseBody202CertificatesOneOf4Pool_id,
                                                                                                                                                                                                                                           migrateByronWalletResponseBody202CertificatesOneOf4Retirement_epoch = migrateByronWalletResponseBody202CertificatesOneOf4Retirement_epoch}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202CertificatesOneOf5 = MigrateByronWalletResponseBody202CertificatesOneOf5 {
  -- | certificate_type
  migrateByronWalletResponseBody202CertificatesOneOf5Certificate_type :: MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_type
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202CertificatesOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202CertificatesOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202CertificatesOneOf5" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202CertificatesOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type"))
-- | Create a new 'MigrateByronWalletResponseBody202CertificatesOneOf5' with all required fields.
mkMigrateByronWalletResponseBody202CertificatesOneOf5 :: MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_type -- ^ 'migrateByronWalletResponseBody202CertificatesOneOf5Certificate_type'
  -> MigrateByronWalletResponseBody202CertificatesOneOf5
mkMigrateByronWalletResponseBody202CertificatesOneOf5 migrateByronWalletResponseBody202CertificatesOneOf5Certificate_type = MigrateByronWalletResponseBody202CertificatesOneOf5{migrateByronWalletResponseBody202CertificatesOneOf5Certificate_type = migrateByronWalletResponseBody202CertificatesOneOf5Certificate_type}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_type =
   MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_typeEnumMir -- ^ Represents the JSON value @"mir"@
  | MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis -- ^ Represents the JSON value @"genesis"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_type
    where toJSON (MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_typeOther val) = val
          toJSON (MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_typeEnumMir) = "mir"
          toJSON (MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis) = "genesis"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "mir" -> MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_typeEnumMir
                                            | val GHC.Classes.== "genesis" -> MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis
                                            | GHC.Base.otherwise -> MigrateByronWalletResponseBody202CertificatesOneOf5Certificate_typeOther val)
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- Any certificate that could occur in an arbitrary transaction:
-- might be related to delegation, pool activities, genesis or MIR.
data MigrateByronWalletResponseBody202CertificatesVariants =
   MigrateByronWalletResponseBody202CertificatesVariant1 MigrateByronWalletResponseBody202CertificatesOneOf1
  | MigrateByronWalletResponseBody202CertificatesVariant2 MigrateByronWalletResponseBody202CertificatesOneOf2
  | MigrateByronWalletResponseBody202CertificatesVariant3 MigrateByronWalletResponseBody202CertificatesOneOf3
  | MigrateByronWalletResponseBody202CertificatesVariant4 MigrateByronWalletResponseBody202CertificatesOneOf4
  | MigrateByronWalletResponseBody202CertificatesVariant5 MigrateByronWalletResponseBody202CertificatesOneOf5
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202CertificatesVariants
    where toJSON (MigrateByronWalletResponseBody202CertificatesVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202CertificatesVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202CertificatesVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202CertificatesVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202CertificatesVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202CertificatesVariants
    where parseJSON val = case (MigrateByronWalletResponseBody202CertificatesVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202CertificatesVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202CertificatesVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202CertificatesVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202CertificatesVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.collateral.items@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202Collateral = MigrateByronWalletResponseBody202Collateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  migrateByronWalletResponseBody202CollateralAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , migrateByronWalletResponseBody202CollateralAmount :: (GHC.Maybe.Maybe MigrateByronWalletResponseBody202CollateralAmount)
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , migrateByronWalletResponseBody202CollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202CollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Collateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Collateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Collateral" (\obj -> (((GHC.Base.pure MigrateByronWalletResponseBody202Collateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateByronWalletResponseBody202Collateral' with all required fields.
mkMigrateByronWalletResponseBody202Collateral :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202CollateralId'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202CollateralIndex'
  -> MigrateByronWalletResponseBody202Collateral
mkMigrateByronWalletResponseBody202Collateral migrateByronWalletResponseBody202CollateralId migrateByronWalletResponseBody202CollateralIndex = MigrateByronWalletResponseBody202Collateral{migrateByronWalletResponseBody202CollateralAddress = GHC.Maybe.Nothing,
                                                                                                                                                                                           migrateByronWalletResponseBody202CollateralAmount = GHC.Maybe.Nothing,
                                                                                                                                                                                           migrateByronWalletResponseBody202CollateralId = migrateByronWalletResponseBody202CollateralId,
                                                                                                                                                                                           migrateByronWalletResponseBody202CollateralIndex = migrateByronWalletResponseBody202CollateralIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateByronWalletResponseBody202CollateralAmount = MigrateByronWalletResponseBody202CollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202CollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202CollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202CollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202CollateralAmount" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202CollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202CollateralAmount' with all required fields.
mkMigrateByronWalletResponseBody202CollateralAmount :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202CollateralAmountQuantity'
  -> MigrateByronWalletResponseBody202CollateralAmount
mkMigrateByronWalletResponseBody202CollateralAmount migrateByronWalletResponseBody202CollateralAmountQuantity = MigrateByronWalletResponseBody202CollateralAmount{migrateByronWalletResponseBody202CollateralAmountQuantity = migrateByronWalletResponseBody202CollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.collateral_outputs.items@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202Collateral_outputs = MigrateByronWalletResponseBody202Collateral_outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  migrateByronWalletResponseBody202Collateral_outputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , migrateByronWalletResponseBody202Collateral_outputsAmount :: MigrateByronWalletResponseBody202Collateral_outputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , migrateByronWalletResponseBody202Collateral_outputsAssets :: (GHC.Maybe.Maybe ([MigrateByronWalletResponseBody202Collateral_outputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Collateral_outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Collateral_outputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202Collateral_outputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Collateral_outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Collateral_outputs" (\obj -> ((GHC.Base.pure MigrateByronWalletResponseBody202Collateral_outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'MigrateByronWalletResponseBody202Collateral_outputs' with all required fields.
mkMigrateByronWalletResponseBody202Collateral_outputs :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202Collateral_outputsAddress'
  -> MigrateByronWalletResponseBody202Collateral_outputsAmount -- ^ 'migrateByronWalletResponseBody202Collateral_outputsAmount'
  -> MigrateByronWalletResponseBody202Collateral_outputs
mkMigrateByronWalletResponseBody202Collateral_outputs migrateByronWalletResponseBody202Collateral_outputsAddress migrateByronWalletResponseBody202Collateral_outputsAmount = MigrateByronWalletResponseBody202Collateral_outputs{migrateByronWalletResponseBody202Collateral_outputsAddress = migrateByronWalletResponseBody202Collateral_outputsAddress,
                                                                                                                                                                                                                                 migrateByronWalletResponseBody202Collateral_outputsAmount = migrateByronWalletResponseBody202Collateral_outputsAmount,
                                                                                                                                                                                                                                 migrateByronWalletResponseBody202Collateral_outputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.collateral_outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateByronWalletResponseBody202Collateral_outputsAmount = MigrateByronWalletResponseBody202Collateral_outputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202Collateral_outputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Collateral_outputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Collateral_outputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Collateral_outputsAmount" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202Collateral_outputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202Collateral_outputsAmount' with all required fields.
mkMigrateByronWalletResponseBody202Collateral_outputsAmount :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Collateral_outputsAmountQuantity'
  -> MigrateByronWalletResponseBody202Collateral_outputsAmount
mkMigrateByronWalletResponseBody202Collateral_outputsAmount migrateByronWalletResponseBody202Collateral_outputsAmountQuantity = MigrateByronWalletResponseBody202Collateral_outputsAmount{migrateByronWalletResponseBody202Collateral_outputsAmountQuantity = migrateByronWalletResponseBody202Collateral_outputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.collateral_outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data MigrateByronWalletResponseBody202Collateral_outputsAssets = MigrateByronWalletResponseBody202Collateral_outputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  migrateByronWalletResponseBody202Collateral_outputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateByronWalletResponseBody202Collateral_outputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202Collateral_outputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Collateral_outputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Collateral_outputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Collateral_outputsAssets" (\obj -> ((GHC.Base.pure MigrateByronWalletResponseBody202Collateral_outputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202Collateral_outputsAssets' with all required fields.
mkMigrateByronWalletResponseBody202Collateral_outputsAssets :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202Collateral_outputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202Collateral_outputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Collateral_outputsAssetsQuantity'
  -> MigrateByronWalletResponseBody202Collateral_outputsAssets
mkMigrateByronWalletResponseBody202Collateral_outputsAssets migrateByronWalletResponseBody202Collateral_outputsAssetsAsset_name migrateByronWalletResponseBody202Collateral_outputsAssetsPolicy_id migrateByronWalletResponseBody202Collateral_outputsAssetsQuantity = MigrateByronWalletResponseBody202Collateral_outputsAssets{migrateByronWalletResponseBody202Collateral_outputsAssetsAsset_name = migrateByronWalletResponseBody202Collateral_outputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                 migrateByronWalletResponseBody202Collateral_outputsAssetsPolicy_id = migrateByronWalletResponseBody202Collateral_outputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                 migrateByronWalletResponseBody202Collateral_outputsAssetsQuantity = migrateByronWalletResponseBody202Collateral_outputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.deposit_returned@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateByronWalletResponseBody202Deposit_returned = MigrateByronWalletResponseBody202Deposit_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202Deposit_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Deposit_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Deposit_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Deposit_returned" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202Deposit_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202Deposit_returned' with all required fields.
mkMigrateByronWalletResponseBody202Deposit_returned :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Deposit_returnedQuantity'
  -> MigrateByronWalletResponseBody202Deposit_returned
mkMigrateByronWalletResponseBody202Deposit_returned migrateByronWalletResponseBody202Deposit_returnedQuantity = MigrateByronWalletResponseBody202Deposit_returned{migrateByronWalletResponseBody202Deposit_returnedQuantity = migrateByronWalletResponseBody202Deposit_returnedQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.deposit_taken@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateByronWalletResponseBody202Deposit_taken = MigrateByronWalletResponseBody202Deposit_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202Deposit_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Deposit_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Deposit_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Deposit_taken" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202Deposit_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202Deposit_taken' with all required fields.
mkMigrateByronWalletResponseBody202Deposit_taken :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Deposit_takenQuantity'
  -> MigrateByronWalletResponseBody202Deposit_taken
mkMigrateByronWalletResponseBody202Deposit_taken migrateByronWalletResponseBody202Deposit_takenQuantity = MigrateByronWalletResponseBody202Deposit_taken{migrateByronWalletResponseBody202Deposit_takenQuantity = migrateByronWalletResponseBody202Deposit_takenQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.depth@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Current depth of the transaction in the local chain
data MigrateByronWalletResponseBody202Depth = MigrateByronWalletResponseBody202Depth {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202DepthQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Depth
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Depth
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Depth" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202Depth GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202Depth' with all required fields.
mkMigrateByronWalletResponseBody202Depth :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202DepthQuantity'
  -> MigrateByronWalletResponseBody202Depth
mkMigrateByronWalletResponseBody202Depth migrateByronWalletResponseBody202DepthQuantity = MigrateByronWalletResponseBody202Depth{migrateByronWalletResponseBody202DepthQuantity = migrateByronWalletResponseBody202DepthQuantity}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.direction@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202Direction =
   MigrateByronWalletResponseBody202DirectionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateByronWalletResponseBody202DirectionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateByronWalletResponseBody202DirectionEnumOutgoing -- ^ Represents the JSON value @"outgoing"@
  | MigrateByronWalletResponseBody202DirectionEnumIncoming -- ^ Represents the JSON value @"incoming"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Direction
    where toJSON (MigrateByronWalletResponseBody202DirectionOther val) = val
          toJSON (MigrateByronWalletResponseBody202DirectionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateByronWalletResponseBody202DirectionEnumOutgoing) = "outgoing"
          toJSON (MigrateByronWalletResponseBody202DirectionEnumIncoming) = "incoming"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Direction
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "outgoing" -> MigrateByronWalletResponseBody202DirectionEnumOutgoing
                                            | val GHC.Classes.== "incoming" -> MigrateByronWalletResponseBody202DirectionEnumIncoming
                                            | GHC.Base.otherwise -> MigrateByronWalletResponseBody202DirectionOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.expires_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending OR status == expired
-- \<\/span>\<br\/>
-- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
data MigrateByronWalletResponseBody202Expires_at = MigrateByronWalletResponseBody202Expires_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202Expires_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202Expires_atEpoch_number :: GHC.Types.Int
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202Expires_atSlot_number :: GHC.Types.Int
  -- | time
  , migrateByronWalletResponseBody202Expires_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Expires_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Expires_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Expires_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Expires_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Expires_at" (\obj -> (((GHC.Base.pure MigrateByronWalletResponseBody202Expires_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'MigrateByronWalletResponseBody202Expires_at' with all required fields.
mkMigrateByronWalletResponseBody202Expires_at :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Expires_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Expires_atEpoch_number'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Expires_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202Expires_atTime'
  -> MigrateByronWalletResponseBody202Expires_at
mkMigrateByronWalletResponseBody202Expires_at migrateByronWalletResponseBody202Expires_atAbsolute_slot_number migrateByronWalletResponseBody202Expires_atEpoch_number migrateByronWalletResponseBody202Expires_atSlot_number migrateByronWalletResponseBody202Expires_atTime = MigrateByronWalletResponseBody202Expires_at{migrateByronWalletResponseBody202Expires_atAbsolute_slot_number = migrateByronWalletResponseBody202Expires_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Expires_atEpoch_number = migrateByronWalletResponseBody202Expires_atEpoch_number,
                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Expires_atSlot_number = migrateByronWalletResponseBody202Expires_atSlot_number,
                                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202Expires_atTime = migrateByronWalletResponseBody202Expires_atTime}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.fee@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateByronWalletResponseBody202Fee = MigrateByronWalletResponseBody202Fee {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202FeeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Fee
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Fee
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Fee" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202Fee GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202Fee' with all required fields.
mkMigrateByronWalletResponseBody202Fee :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202FeeQuantity'
  -> MigrateByronWalletResponseBody202Fee
mkMigrateByronWalletResponseBody202Fee migrateByronWalletResponseBody202FeeQuantity = MigrateByronWalletResponseBody202Fee{migrateByronWalletResponseBody202FeeQuantity = migrateByronWalletResponseBody202FeeQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.inputs.items@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202Inputs = MigrateByronWalletResponseBody202Inputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  migrateByronWalletResponseBody202InputsAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , migrateByronWalletResponseBody202InputsAmount :: (GHC.Maybe.Maybe MigrateByronWalletResponseBody202InputsAmount)
  -- | assets: A flat list of assets (possibly empty).
  , migrateByronWalletResponseBody202InputsAssets :: (GHC.Maybe.Maybe ([MigrateByronWalletResponseBody202InputsAssets]))
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , migrateByronWalletResponseBody202InputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202InputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Inputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202InputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202InputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Inputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Inputs" (\obj -> ((((GHC.Base.pure MigrateByronWalletResponseBody202Inputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateByronWalletResponseBody202Inputs' with all required fields.
mkMigrateByronWalletResponseBody202Inputs :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202InputsId'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202InputsIndex'
  -> MigrateByronWalletResponseBody202Inputs
mkMigrateByronWalletResponseBody202Inputs migrateByronWalletResponseBody202InputsId migrateByronWalletResponseBody202InputsIndex = MigrateByronWalletResponseBody202Inputs{migrateByronWalletResponseBody202InputsAddress = GHC.Maybe.Nothing,
                                                                                                                                                                           migrateByronWalletResponseBody202InputsAmount = GHC.Maybe.Nothing,
                                                                                                                                                                           migrateByronWalletResponseBody202InputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                                           migrateByronWalletResponseBody202InputsId = migrateByronWalletResponseBody202InputsId,
                                                                                                                                                                           migrateByronWalletResponseBody202InputsIndex = migrateByronWalletResponseBody202InputsIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateByronWalletResponseBody202InputsAmount = MigrateByronWalletResponseBody202InputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202InputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202InputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202InputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202InputsAmount" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202InputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202InputsAmount' with all required fields.
mkMigrateByronWalletResponseBody202InputsAmount :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202InputsAmountQuantity'
  -> MigrateByronWalletResponseBody202InputsAmount
mkMigrateByronWalletResponseBody202InputsAmount migrateByronWalletResponseBody202InputsAmountQuantity = MigrateByronWalletResponseBody202InputsAmount{migrateByronWalletResponseBody202InputsAmountQuantity = migrateByronWalletResponseBody202InputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data MigrateByronWalletResponseBody202InputsAssets = MigrateByronWalletResponseBody202InputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  migrateByronWalletResponseBody202InputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateByronWalletResponseBody202InputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202InputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202InputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202InputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202InputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202InputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202InputsAssets" (\obj -> ((GHC.Base.pure MigrateByronWalletResponseBody202InputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202InputsAssets' with all required fields.
mkMigrateByronWalletResponseBody202InputsAssets :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202InputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202InputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202InputsAssetsQuantity'
  -> MigrateByronWalletResponseBody202InputsAssets
mkMigrateByronWalletResponseBody202InputsAssets migrateByronWalletResponseBody202InputsAssetsAsset_name migrateByronWalletResponseBody202InputsAssetsPolicy_id migrateByronWalletResponseBody202InputsAssetsQuantity = MigrateByronWalletResponseBody202InputsAssets{migrateByronWalletResponseBody202InputsAssetsAsset_name = migrateByronWalletResponseBody202InputsAssetsAsset_name,
                                                                                                                                                                                                                                                                     migrateByronWalletResponseBody202InputsAssetsPolicy_id = migrateByronWalletResponseBody202InputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                     migrateByronWalletResponseBody202InputsAssetsQuantity = migrateByronWalletResponseBody202InputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.inserted_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Absolute time at which the transaction was inserted in a block.
data MigrateByronWalletResponseBody202Inserted_at = MigrateByronWalletResponseBody202Inserted_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202Inserted_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202Inserted_atEpoch_number :: GHC.Types.Int
  -- | height
  , migrateByronWalletResponseBody202Inserted_atHeight :: MigrateByronWalletResponseBody202Inserted_atHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202Inserted_atSlot_number :: GHC.Types.Int
  -- | time
  , migrateByronWalletResponseBody202Inserted_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Inserted_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Inserted_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Inserted_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Inserted_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Inserted_at" (\obj -> ((((GHC.Base.pure MigrateByronWalletResponseBody202Inserted_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'MigrateByronWalletResponseBody202Inserted_at' with all required fields.
mkMigrateByronWalletResponseBody202Inserted_at :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Inserted_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Inserted_atEpoch_number'
  -> MigrateByronWalletResponseBody202Inserted_atHeight -- ^ 'migrateByronWalletResponseBody202Inserted_atHeight'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Inserted_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202Inserted_atTime'
  -> MigrateByronWalletResponseBody202Inserted_at
mkMigrateByronWalletResponseBody202Inserted_at migrateByronWalletResponseBody202Inserted_atAbsolute_slot_number migrateByronWalletResponseBody202Inserted_atEpoch_number migrateByronWalletResponseBody202Inserted_atHeight migrateByronWalletResponseBody202Inserted_atSlot_number migrateByronWalletResponseBody202Inserted_atTime = MigrateByronWalletResponseBody202Inserted_at{migrateByronWalletResponseBody202Inserted_atAbsolute_slot_number = migrateByronWalletResponseBody202Inserted_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                                    migrateByronWalletResponseBody202Inserted_atEpoch_number = migrateByronWalletResponseBody202Inserted_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                                    migrateByronWalletResponseBody202Inserted_atHeight = migrateByronWalletResponseBody202Inserted_atHeight,
                                                                                                                                                                                                                                                                                                                                                                                    migrateByronWalletResponseBody202Inserted_atSlot_number = migrateByronWalletResponseBody202Inserted_atSlot_number,
                                                                                                                                                                                                                                                                                                                                                                                    migrateByronWalletResponseBody202Inserted_atTime = migrateByronWalletResponseBody202Inserted_atTime}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.inserted_at.properties.height@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202Inserted_atHeight = MigrateByronWalletResponseBody202Inserted_atHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202Inserted_atHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Inserted_atHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Inserted_atHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Inserted_atHeight" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202Inserted_atHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202Inserted_atHeight' with all required fields.
mkMigrateByronWalletResponseBody202Inserted_atHeight :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Inserted_atHeightQuantity'
  -> MigrateByronWalletResponseBody202Inserted_atHeight
mkMigrateByronWalletResponseBody202Inserted_atHeight migrateByronWalletResponseBody202Inserted_atHeightQuantity = MigrateByronWalletResponseBody202Inserted_atHeight{migrateByronWalletResponseBody202Inserted_atHeightQuantity = migrateByronWalletResponseBody202Inserted_atHeightQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202Mint = MigrateByronWalletResponseBody202Mint {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  migrateByronWalletResponseBody202MintTokens :: ([MigrateByronWalletResponseBody202MintTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , migrateByronWalletResponseBody202MintWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , migrateByronWalletResponseBody202MintWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Mint
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202MintWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202MintWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Mint
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Mint" (\obj -> ((GHC.Base.pure MigrateByronWalletResponseBody202Mint GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'MigrateByronWalletResponseBody202Mint' with all required fields.
mkMigrateByronWalletResponseBody202Mint :: [MigrateByronWalletResponseBody202MintTokens] -- ^ 'migrateByronWalletResponseBody202MintTokens'
  -> MigrateByronWalletResponseBody202Mint
mkMigrateByronWalletResponseBody202Mint migrateByronWalletResponseBody202MintTokens = MigrateByronWalletResponseBody202Mint{migrateByronWalletResponseBody202MintTokens = migrateByronWalletResponseBody202MintTokens,
                                                                                                                            migrateByronWalletResponseBody202MintWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                            migrateByronWalletResponseBody202MintWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202MintTokens = MigrateByronWalletResponseBody202MintTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateByronWalletResponseBody202MintTokensAssets :: ([MigrateByronWalletResponseBody202MintTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateByronWalletResponseBody202MintTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , migrateByronWalletResponseBody202MintTokensPolicy_script :: MigrateByronWalletResponseBody202MintTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202MintTokens" (\obj -> ((GHC.Base.pure MigrateByronWalletResponseBody202MintTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'MigrateByronWalletResponseBody202MintTokens' with all required fields.
mkMigrateByronWalletResponseBody202MintTokens :: [MigrateByronWalletResponseBody202MintTokensAssets] -- ^ 'migrateByronWalletResponseBody202MintTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_id'
  -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptVariants -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_script'
  -> MigrateByronWalletResponseBody202MintTokens
mkMigrateByronWalletResponseBody202MintTokens migrateByronWalletResponseBody202MintTokensAssets migrateByronWalletResponseBody202MintTokensPolicy_id migrateByronWalletResponseBody202MintTokensPolicy_script = MigrateByronWalletResponseBody202MintTokens{migrateByronWalletResponseBody202MintTokensAssets = migrateByronWalletResponseBody202MintTokensAssets,
                                                                                                                                                                                                                                                            migrateByronWalletResponseBody202MintTokensPolicy_id = migrateByronWalletResponseBody202MintTokensPolicy_id,
                                                                                                                                                                                                                                                            migrateByronWalletResponseBody202MintTokensPolicy_script = migrateByronWalletResponseBody202MintTokensPolicy_script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202MintTokensAssets = MigrateByronWalletResponseBody202MintTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  migrateByronWalletResponseBody202MintTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , migrateByronWalletResponseBody202MintTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202MintTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202MintTokensAssets" (\obj -> ((GHC.Base.pure MigrateByronWalletResponseBody202MintTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202MintTokensAssets' with all required fields.
mkMigrateByronWalletResponseBody202MintTokensAssets :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202MintTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202MintTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202MintTokensAssetsQuantity'
  -> MigrateByronWalletResponseBody202MintTokensAssets
mkMigrateByronWalletResponseBody202MintTokensAssets migrateByronWalletResponseBody202MintTokensAssetsAsset_name migrateByronWalletResponseBody202MintTokensAssetsFingerprint migrateByronWalletResponseBody202MintTokensAssetsQuantity = MigrateByronWalletResponseBody202MintTokensAssets{migrateByronWalletResponseBody202MintTokensAssetsAsset_name = migrateByronWalletResponseBody202MintTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202MintTokensAssetsFingerprint = migrateByronWalletResponseBody202MintTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202MintTokensAssetsQuantity = migrateByronWalletResponseBody202MintTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1 = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference)
  -- | script
  , migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Script :: MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1' with all required fields.
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1 :: MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Script'
  -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1 migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Script = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1{migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                       migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Script = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference' with all required fields.
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex'
  -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference{migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2{migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3{migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 :: MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4{migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some{migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                            migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5{migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6{migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants =
   MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
  | MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
  | MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
  | MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
  | MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2 = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info :: MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2' with all required fields.
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2 :: MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info'
  -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2 migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2{migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                            migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference' with all required fields.
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex'
  -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference{migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                           migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version :: MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info :: MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info{migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                                       migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3 = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References :: ([MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3' with all required fields.
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3 :: [MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References] -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3Script_hash'
  -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3 migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3Script_hash = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3{migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                                     migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3Script_hash = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References' with all required fields.
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex'
  -> MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References
mkMigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex = MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3References{migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                               migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex = migrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202MintTokensPolicy_scriptVariants =
   MigrateByronWalletResponseBody202MintTokensPolicy_scriptVariant1 MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf1
  | MigrateByronWalletResponseBody202MintTokensPolicy_scriptVariant2 MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf2
  | MigrateByronWalletResponseBody202MintTokensPolicy_scriptVariant3 MigrateByronWalletResponseBody202MintTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptVariants
    where toJSON (MigrateByronWalletResponseBody202MintTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202MintTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody202MintTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202MintTokensPolicy_scriptVariants
    where parseJSON val = case (MigrateByronWalletResponseBody202MintTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202MintTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody202MintTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.outputs.items@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202Outputs = MigrateByronWalletResponseBody202Outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  migrateByronWalletResponseBody202OutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , migrateByronWalletResponseBody202OutputsAmount :: MigrateByronWalletResponseBody202OutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , migrateByronWalletResponseBody202OutputsAssets :: (GHC.Maybe.Maybe ([MigrateByronWalletResponseBody202OutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202OutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (migrateByronWalletResponseBody202OutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Outputs" (\obj -> ((GHC.Base.pure MigrateByronWalletResponseBody202Outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'MigrateByronWalletResponseBody202Outputs' with all required fields.
mkMigrateByronWalletResponseBody202Outputs :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202OutputsAddress'
  -> MigrateByronWalletResponseBody202OutputsAmount -- ^ 'migrateByronWalletResponseBody202OutputsAmount'
  -> MigrateByronWalletResponseBody202Outputs
mkMigrateByronWalletResponseBody202Outputs migrateByronWalletResponseBody202OutputsAddress migrateByronWalletResponseBody202OutputsAmount = MigrateByronWalletResponseBody202Outputs{migrateByronWalletResponseBody202OutputsAddress = migrateByronWalletResponseBody202OutputsAddress,
                                                                                                                                                                                     migrateByronWalletResponseBody202OutputsAmount = migrateByronWalletResponseBody202OutputsAmount,
                                                                                                                                                                                     migrateByronWalletResponseBody202OutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateByronWalletResponseBody202OutputsAmount = MigrateByronWalletResponseBody202OutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202OutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202OutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202OutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202OutputsAmount" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202OutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202OutputsAmount' with all required fields.
mkMigrateByronWalletResponseBody202OutputsAmount :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202OutputsAmountQuantity'
  -> MigrateByronWalletResponseBody202OutputsAmount
mkMigrateByronWalletResponseBody202OutputsAmount migrateByronWalletResponseBody202OutputsAmountQuantity = MigrateByronWalletResponseBody202OutputsAmount{migrateByronWalletResponseBody202OutputsAmountQuantity = migrateByronWalletResponseBody202OutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data MigrateByronWalletResponseBody202OutputsAssets = MigrateByronWalletResponseBody202OutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  migrateByronWalletResponseBody202OutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateByronWalletResponseBody202OutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202OutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202OutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202OutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202OutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202OutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202OutputsAssets" (\obj -> ((GHC.Base.pure MigrateByronWalletResponseBody202OutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202OutputsAssets' with all required fields.
mkMigrateByronWalletResponseBody202OutputsAssets :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202OutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202OutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202OutputsAssetsQuantity'
  -> MigrateByronWalletResponseBody202OutputsAssets
mkMigrateByronWalletResponseBody202OutputsAssets migrateByronWalletResponseBody202OutputsAssetsAsset_name migrateByronWalletResponseBody202OutputsAssetsPolicy_id migrateByronWalletResponseBody202OutputsAssetsQuantity = MigrateByronWalletResponseBody202OutputsAssets{migrateByronWalletResponseBody202OutputsAssetsAsset_name = migrateByronWalletResponseBody202OutputsAssetsAsset_name,
                                                                                                                                                                                                                                                                          migrateByronWalletResponseBody202OutputsAssetsPolicy_id = migrateByronWalletResponseBody202OutputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                          migrateByronWalletResponseBody202OutputsAssetsQuantity = migrateByronWalletResponseBody202OutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.pending_since@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending
-- \<\/span>\<br\/>
-- The point in time at which a transaction became pending.
data MigrateByronWalletResponseBody202Pending_since = MigrateByronWalletResponseBody202Pending_since {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202Pending_sinceAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202Pending_sinceEpoch_number :: GHC.Types.Int
  -- | height
  , migrateByronWalletResponseBody202Pending_sinceHeight :: MigrateByronWalletResponseBody202Pending_sinceHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateByronWalletResponseBody202Pending_sinceSlot_number :: GHC.Types.Int
  -- | time
  , migrateByronWalletResponseBody202Pending_sinceTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Pending_since
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Pending_sinceTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Pending_sinceTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Pending_since
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Pending_since" (\obj -> ((((GHC.Base.pure MigrateByronWalletResponseBody202Pending_since GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'MigrateByronWalletResponseBody202Pending_since' with all required fields.
mkMigrateByronWalletResponseBody202Pending_since :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Pending_sinceAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Pending_sinceEpoch_number'
  -> MigrateByronWalletResponseBody202Pending_sinceHeight -- ^ 'migrateByronWalletResponseBody202Pending_sinceHeight'
  -> GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Pending_sinceSlot_number'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202Pending_sinceTime'
  -> MigrateByronWalletResponseBody202Pending_since
mkMigrateByronWalletResponseBody202Pending_since migrateByronWalletResponseBody202Pending_sinceAbsolute_slot_number migrateByronWalletResponseBody202Pending_sinceEpoch_number migrateByronWalletResponseBody202Pending_sinceHeight migrateByronWalletResponseBody202Pending_sinceSlot_number migrateByronWalletResponseBody202Pending_sinceTime = MigrateByronWalletResponseBody202Pending_since{migrateByronWalletResponseBody202Pending_sinceAbsolute_slot_number = migrateByronWalletResponseBody202Pending_sinceAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                                                  migrateByronWalletResponseBody202Pending_sinceEpoch_number = migrateByronWalletResponseBody202Pending_sinceEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                                                  migrateByronWalletResponseBody202Pending_sinceHeight = migrateByronWalletResponseBody202Pending_sinceHeight,
                                                                                                                                                                                                                                                                                                                                                                                                  migrateByronWalletResponseBody202Pending_sinceSlot_number = migrateByronWalletResponseBody202Pending_sinceSlot_number,
                                                                                                                                                                                                                                                                                                                                                                                                  migrateByronWalletResponseBody202Pending_sinceTime = migrateByronWalletResponseBody202Pending_sinceTime}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.pending_since.properties.height@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202Pending_sinceHeight = MigrateByronWalletResponseBody202Pending_sinceHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202Pending_sinceHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Pending_sinceHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Pending_sinceHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Pending_sinceHeight" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202Pending_sinceHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202Pending_sinceHeight' with all required fields.
mkMigrateByronWalletResponseBody202Pending_sinceHeight :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Pending_sinceHeightQuantity'
  -> MigrateByronWalletResponseBody202Pending_sinceHeight
mkMigrateByronWalletResponseBody202Pending_sinceHeight migrateByronWalletResponseBody202Pending_sinceHeightQuantity = MigrateByronWalletResponseBody202Pending_sinceHeight{migrateByronWalletResponseBody202Pending_sinceHeightQuantity = migrateByronWalletResponseBody202Pending_sinceHeightQuantity}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.script_validity@ in the specification.
-- 
-- Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
-- used in the transaction validated or not. Validity may be null if this
-- transaction was from an era that doesn\'t support phase-2 monetary policy
-- scripts, or is a pending transaction (we don\'t know if validation passed or
-- failed until the transaction hits the ledger).
data MigrateByronWalletResponseBody202Script_validityNonNullable =
   MigrateByronWalletResponseBody202Script_validityNonNullableOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateByronWalletResponseBody202Script_validityNonNullableTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateByronWalletResponseBody202Script_validityNonNullableEnumValid -- ^ Represents the JSON value @"valid"@
  | MigrateByronWalletResponseBody202Script_validityNonNullableEnumInvalid -- ^ Represents the JSON value @"invalid"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Script_validityNonNullable
    where toJSON (MigrateByronWalletResponseBody202Script_validityNonNullableOther val) = val
          toJSON (MigrateByronWalletResponseBody202Script_validityNonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateByronWalletResponseBody202Script_validityNonNullableEnumValid) = "valid"
          toJSON (MigrateByronWalletResponseBody202Script_validityNonNullableEnumInvalid) = "invalid"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Script_validityNonNullable
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "valid" -> MigrateByronWalletResponseBody202Script_validityNonNullableEnumValid
                                            | val GHC.Classes.== "invalid" -> MigrateByronWalletResponseBody202Script_validityNonNullableEnumInvalid
                                            | GHC.Base.otherwise -> MigrateByronWalletResponseBody202Script_validityNonNullableOther val)
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.status@ in the specification.
-- 
-- Current transaction status.
-- 
--   \`\`\`
--        *-----------*
--   ---> |  PENDING  |----------------*
--        *-----------*                |
--              |                      |
--              V                      V
--        *-----------*          *-----------*
--        |           |---------->  EXPIRED  |
--        |           |  (ttl)   *-----------*
--        | SUBMITTED |
--        |           \<----------------*
--        |           |                |
--        *-----------*           (rollback)
--               |                     |
--          (in ledger)          *-----------*
--               |               |           |
--               *---------------> IN_LEDGER |
--                               |           |
--                               *-----------*
--   \`\`\`
data MigrateByronWalletResponseBody202Status =
   MigrateByronWalletResponseBody202StatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateByronWalletResponseBody202StatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateByronWalletResponseBody202StatusEnumPending -- ^ Represents the JSON value @"pending"@
  | MigrateByronWalletResponseBody202StatusEnumSubmitted -- ^ Represents the JSON value @"submitted"@
  | MigrateByronWalletResponseBody202StatusEnumIn_ledger -- ^ Represents the JSON value @"in_ledger"@
  | MigrateByronWalletResponseBody202StatusEnumExpired -- ^ Represents the JSON value @"expired"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Status
    where toJSON (MigrateByronWalletResponseBody202StatusOther val) = val
          toJSON (MigrateByronWalletResponseBody202StatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateByronWalletResponseBody202StatusEnumPending) = "pending"
          toJSON (MigrateByronWalletResponseBody202StatusEnumSubmitted) = "submitted"
          toJSON (MigrateByronWalletResponseBody202StatusEnumIn_ledger) = "in_ledger"
          toJSON (MigrateByronWalletResponseBody202StatusEnumExpired) = "expired"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Status
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "pending" -> MigrateByronWalletResponseBody202StatusEnumPending
                                            | val GHC.Classes.== "submitted" -> MigrateByronWalletResponseBody202StatusEnumSubmitted
                                            | val GHC.Classes.== "in_ledger" -> MigrateByronWalletResponseBody202StatusEnumIn_ledger
                                            | val GHC.Classes.== "expired" -> MigrateByronWalletResponseBody202StatusEnumExpired
                                            | GHC.Base.otherwise -> MigrateByronWalletResponseBody202StatusOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.validity_interval@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202Validity_interval = MigrateByronWalletResponseBody202Validity_interval {
  -- | invalid_before
  migrateByronWalletResponseBody202Validity_intervalInvalid_before :: MigrateByronWalletResponseBody202Validity_intervalInvalid_before
  -- | invalid_hereafter
  , migrateByronWalletResponseBody202Validity_intervalInvalid_hereafter :: MigrateByronWalletResponseBody202Validity_intervalInvalid_hereafter
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Validity_interval
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Validity_interval
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Validity_interval" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202Validity_interval GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_before")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_hereafter"))
-- | Create a new 'MigrateByronWalletResponseBody202Validity_interval' with all required fields.
mkMigrateByronWalletResponseBody202Validity_interval :: MigrateByronWalletResponseBody202Validity_intervalInvalid_before -- ^ 'migrateByronWalletResponseBody202Validity_intervalInvalid_before'
  -> MigrateByronWalletResponseBody202Validity_intervalInvalid_hereafter -- ^ 'migrateByronWalletResponseBody202Validity_intervalInvalid_hereafter'
  -> MigrateByronWalletResponseBody202Validity_interval
mkMigrateByronWalletResponseBody202Validity_interval migrateByronWalletResponseBody202Validity_intervalInvalid_before migrateByronWalletResponseBody202Validity_intervalInvalid_hereafter = MigrateByronWalletResponseBody202Validity_interval{migrateByronWalletResponseBody202Validity_intervalInvalid_before = migrateByronWalletResponseBody202Validity_intervalInvalid_before,
                                                                                                                                                                                                                                               migrateByronWalletResponseBody202Validity_intervalInvalid_hereafter = migrateByronWalletResponseBody202Validity_intervalInvalid_hereafter}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.validity_interval.properties.invalid_before@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202Validity_intervalInvalid_before = MigrateByronWalletResponseBody202Validity_intervalInvalid_before {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202Validity_intervalInvalid_beforeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Validity_intervalInvalid_before
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Validity_intervalInvalid_before
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Validity_intervalInvalid_before" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202Validity_intervalInvalid_before GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202Validity_intervalInvalid_before' with all required fields.
mkMigrateByronWalletResponseBody202Validity_intervalInvalid_before :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Validity_intervalInvalid_beforeQuantity'
  -> MigrateByronWalletResponseBody202Validity_intervalInvalid_before
mkMigrateByronWalletResponseBody202Validity_intervalInvalid_before migrateByronWalletResponseBody202Validity_intervalInvalid_beforeQuantity = MigrateByronWalletResponseBody202Validity_intervalInvalid_before{migrateByronWalletResponseBody202Validity_intervalInvalid_beforeQuantity = migrateByronWalletResponseBody202Validity_intervalInvalid_beforeQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.validity_interval.properties.invalid_hereafter@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202Validity_intervalInvalid_hereafter = MigrateByronWalletResponseBody202Validity_intervalInvalid_hereafter {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202Validity_intervalInvalid_hereafterQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Validity_intervalInvalid_hereafter
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Validity_intervalInvalid_hereafter
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Validity_intervalInvalid_hereafter" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202Validity_intervalInvalid_hereafter GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202Validity_intervalInvalid_hereafter' with all required fields.
mkMigrateByronWalletResponseBody202Validity_intervalInvalid_hereafter :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202Validity_intervalInvalid_hereafterQuantity'
  -> MigrateByronWalletResponseBody202Validity_intervalInvalid_hereafter
mkMigrateByronWalletResponseBody202Validity_intervalInvalid_hereafter migrateByronWalletResponseBody202Validity_intervalInvalid_hereafterQuantity = MigrateByronWalletResponseBody202Validity_intervalInvalid_hereafter{migrateByronWalletResponseBody202Validity_intervalInvalid_hereafterQuantity = migrateByronWalletResponseBody202Validity_intervalInvalid_hereafterQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.withdrawals.items@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody202Withdrawals = MigrateByronWalletResponseBody202Withdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  migrateByronWalletResponseBody202WithdrawalsAmount :: MigrateByronWalletResponseBody202WithdrawalsAmount
  -- | stake_address
  , migrateByronWalletResponseBody202WithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202Withdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202WithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202WithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202Withdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202Withdrawals" (\obj -> (GHC.Base.pure MigrateByronWalletResponseBody202Withdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'MigrateByronWalletResponseBody202Withdrawals' with all required fields.
mkMigrateByronWalletResponseBody202Withdrawals :: MigrateByronWalletResponseBody202WithdrawalsAmount -- ^ 'migrateByronWalletResponseBody202WithdrawalsAmount'
  -> Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody202WithdrawalsStake_address'
  -> MigrateByronWalletResponseBody202Withdrawals
mkMigrateByronWalletResponseBody202Withdrawals migrateByronWalletResponseBody202WithdrawalsAmount migrateByronWalletResponseBody202WithdrawalsStake_address = MigrateByronWalletResponseBody202Withdrawals{migrateByronWalletResponseBody202WithdrawalsAmount = migrateByronWalletResponseBody202WithdrawalsAmount,
                                                                                                                                                                                                           migrateByronWalletResponseBody202WithdrawalsStake_address = migrateByronWalletResponseBody202WithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateByronWalletResponseBody202WithdrawalsAmount = MigrateByronWalletResponseBody202WithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateByronWalletResponseBody202WithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody202WithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody202WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody202WithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody202WithdrawalsAmount" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody202WithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateByronWalletResponseBody202WithdrawalsAmount' with all required fields.
mkMigrateByronWalletResponseBody202WithdrawalsAmount :: GHC.Types.Int -- ^ 'migrateByronWalletResponseBody202WithdrawalsAmountQuantity'
  -> MigrateByronWalletResponseBody202WithdrawalsAmount
mkMigrateByronWalletResponseBody202WithdrawalsAmount migrateByronWalletResponseBody202WithdrawalsAmountQuantity = MigrateByronWalletResponseBody202WithdrawalsAmount{migrateByronWalletResponseBody202WithdrawalsAmountQuantity = migrateByronWalletResponseBody202WithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody403OneOf1 = MigrateByronWalletResponseBody403OneOf1 {
  -- | message: May occur when trying to migrate a wallet that is empty or full of dust.
  migrateByronWalletResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "nothing_to_migrate"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "nothing_to_migrate"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody403OneOf1" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'MigrateByronWalletResponseBody403OneOf1' with all required fields.
mkMigrateByronWalletResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody403OneOf1Message'
  -> MigrateByronWalletResponseBody403OneOf1
mkMigrateByronWalletResponseBody403OneOf1 migrateByronWalletResponseBody403OneOf1Message = MigrateByronWalletResponseBody403OneOf1{migrateByronWalletResponseBody403OneOf1Message = migrateByronWalletResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody403OneOf2 = MigrateByronWalletResponseBody403OneOf2 {
  -- | message: May occur when an action require a signing key but the wallet has only access to verification keys.
  migrateByronWalletResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody403OneOf2" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'MigrateByronWalletResponseBody403OneOf2' with all required fields.
mkMigrateByronWalletResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody403OneOf2Message'
  -> MigrateByronWalletResponseBody403OneOf2
mkMigrateByronWalletResponseBody403OneOf2 migrateByronWalletResponseBody403OneOf2Message = MigrateByronWalletResponseBody403OneOf2{migrateByronWalletResponseBody403OneOf2Message = migrateByronWalletResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody403OneOf3 = MigrateByronWalletResponseBody403OneOf3 {
  -- | message: May occur when the given spending passphrase is wrong.
  migrateByronWalletResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody403OneOf3" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'MigrateByronWalletResponseBody403OneOf3' with all required fields.
mkMigrateByronWalletResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody403OneOf3Message'
  -> MigrateByronWalletResponseBody403OneOf3
mkMigrateByronWalletResponseBody403OneOf3 migrateByronWalletResponseBody403OneOf3Message = MigrateByronWalletResponseBody403OneOf3{migrateByronWalletResponseBody403OneOf3Message = migrateByronWalletResponseBody403OneOf3Message}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody403Variants =
   MigrateByronWalletResponseBody403Variant1 MigrateByronWalletResponseBody403OneOf1
  | MigrateByronWalletResponseBody403Variant2 MigrateByronWalletResponseBody403OneOf2
  | MigrateByronWalletResponseBody403Variant3 MigrateByronWalletResponseBody403OneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody403Variants
    where toJSON (MigrateByronWalletResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateByronWalletResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody403Variants
    where parseJSON val = case (MigrateByronWalletResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateByronWalletResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody404 = MigrateByronWalletResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  migrateByronWalletResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody404" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'MigrateByronWalletResponseBody404' with all required fields.
mkMigrateByronWalletResponseBody404 :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody404Message'
  -> MigrateByronWalletResponseBody404
mkMigrateByronWalletResponseBody404 migrateByronWalletResponseBody404Message = MigrateByronWalletResponseBody404{migrateByronWalletResponseBody404Message = migrateByronWalletResponseBody404Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody406 = MigrateByronWalletResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  migrateByronWalletResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody406" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'MigrateByronWalletResponseBody406' with all required fields.
mkMigrateByronWalletResponseBody406 :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody406Message'
  -> MigrateByronWalletResponseBody406
mkMigrateByronWalletResponseBody406 migrateByronWalletResponseBody406Message = MigrateByronWalletResponseBody406{migrateByronWalletResponseBody406Message = migrateByronWalletResponseBody406Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data MigrateByronWalletResponseBody415 = MigrateByronWalletResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  migrateByronWalletResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateByronWalletResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateByronWalletResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateByronWalletResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateByronWalletResponseBody415" (\obj -> GHC.Base.pure MigrateByronWalletResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'MigrateByronWalletResponseBody415' with all required fields.
mkMigrateByronWalletResponseBody415 :: Data.Text.Internal.Text -- ^ 'migrateByronWalletResponseBody415Message'
  -> MigrateByronWalletResponseBody415
mkMigrateByronWalletResponseBody415 migrateByronWalletResponseBody415Message = MigrateByronWalletResponseBody415{migrateByronWalletResponseBody415Message = migrateByronWalletResponseBody415Message}
-- | > POST /byron-wallets/{walletId}/migrations
-- 
-- The same as 'migrateByronWallet' but accepts an explicit configuration.
migrateByronWalletWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> MigrateByronWalletRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response MigrateByronWalletResponse) -- ^ Monadic computation which returns the result of the operation
migrateByronWalletWithConfiguration config
                                    walletId
                                    body = GHC.Base.fmap (\response_6 -> GHC.Base.fmap (Data.Either.either MigrateByronWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> MigrateByronWalletResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                          ([MigrateByronWalletResponseBody202]))
                                                                                                                                                                                        | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> MigrateByronWalletResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                          MigrateByronWalletResponseBody403Variants)
                                                                                                                                                                                        | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> MigrateByronWalletResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                          MigrateByronWalletResponseBody404)
                                                                                                                                                                                        | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> MigrateByronWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                            MigrateByronWalletResponseBody406)
                                                                                                                                                                                        | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> MigrateByronWalletResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                            MigrateByronWalletResponseBody415)
                                                                                                                                                                                        | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_6) response_6) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/migrations")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /byron-wallets/{walletId}/migrations
-- 
-- The same as 'migrateByronWallet' but returns the raw 'Data.ByteString.ByteString'.
migrateByronWalletRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> MigrateByronWalletRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
migrateByronWalletRaw walletId
                      body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/migrations")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /byron-wallets/{walletId}/migrations
-- 
-- The same as 'migrateByronWallet' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
migrateByronWalletWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> MigrateByronWalletRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
migrateByronWalletWithConfigurationRaw config
                                       walletId
                                       body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/migrations")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
