-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation listByronTransactions
module Wallet.Operations.ListByronTransactions where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > GET /byron-wallets/{walletId}/transactions
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- List all incoming and outgoing transactions for the given wallet.
listByronTransactions :: forall m . Wallet.Common.MonadHTTP m => ListByronTransactionsParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response ListByronTransactionsResponse) -- ^ Monadic computation which returns the result of the operation
listByronTransactions parameters = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either ListByronTransactionsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ListByronTransactionsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                        ([ListByronTransactionsResponseBody200]))
                                                                                                                                                                                   | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> ListByronTransactionsResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                        ListByronTransactionsResponseBody400Variants)
                                                                                                                                                                                   | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> ListByronTransactionsResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                        ListByronTransactionsResponseBody404)
                                                                                                                                                                                   | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ListByronTransactionsResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                        ListByronTransactionsResponseBody406)
                                                                                                                                                                                   | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listByronTransactionsParametersPathWalletId parameters))) GHC.Base.<> "/transactions")) [Wallet.Common.QueryParameter (Data.Text.pack "start") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryStart parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Wallet.Common.QueryParameter (Data.Text.pack "end") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryEnd parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Wallet.Common.QueryParameter (Data.Text.pack "order") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryOrder parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      Wallet.Common.QueryParameter (Data.Text.pack "max_count") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryMax_count parameters) (Data.Text.pack "form") GHC.Types.False])
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.parameters@ in the specification.
-- 
-- 
data ListByronTransactionsParameters = ListByronTransactionsParameters {
  -- | pathWalletId: Represents the parameter named \'walletId\'
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  listByronTransactionsParametersPathWalletId :: Data.Text.Internal.Text
  -- | queryEnd: Represents the parameter named \'end\'
  -- 
  -- An optional end time in ISO 8601 date-and-time format. Basic and
  -- extended formats are both accepted. Times can be local (with a
  -- timezone offset) or UTC.
  -- 
  -- If both a start time and an end time are specified, then the start
  -- time must not be later than the end time.
  -- 
  -- Example: \`2008-08-08T08:08:08Z\`
  , listByronTransactionsParametersQueryEnd :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | queryMax_count: Represents the parameter named \'max_count\'
  -- 
  -- An optional maximum count.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 1.0
  , listByronTransactionsParametersQueryMax_count :: (GHC.Maybe.Maybe GHC.Types.Int)
  -- | queryOrder: Represents the parameter named \'order\'
  -- 
  -- An optional sort order.
  , listByronTransactionsParametersQueryOrder :: (GHC.Maybe.Maybe ListByronTransactionsParametersQueryOrder)
  -- | queryStart: Represents the parameter named \'start\'
  -- 
  -- An optional start time in ISO 8601 date-and-time format. Basic and
  -- extended formats are both accepted. Times can be local (with a
  -- timezone offset) or UTC.
  -- 
  -- If both a start time and an end time are specified, then the start
  -- time must not be later than the end time.
  -- 
  -- Example: \`2008-08-08T08:08:08Z\`
  , listByronTransactionsParametersQueryStart :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsParameters
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pathWalletId" Data.Aeson.Types.ToJSON..= listByronTransactionsParametersPathWalletId obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryEnd" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsParametersQueryEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryMax_count" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsParametersQueryMax_count obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryOrder" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsParametersQueryOrder obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryStart" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsParametersQueryStart obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pathWalletId" Data.Aeson.Types.ToJSON..= listByronTransactionsParametersPathWalletId obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryEnd" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsParametersQueryEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryMax_count" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsParametersQueryMax_count obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryOrder" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsParametersQueryOrder obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryStart" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsParametersQueryStart obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsParameters
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsParameters" (\obj -> ((((GHC.Base.pure ListByronTransactionsParameters GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pathWalletId")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "queryEnd")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "queryMax_count")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "queryOrder")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "queryStart"))
-- | Create a new 'ListByronTransactionsParameters' with all required fields.
mkListByronTransactionsParameters :: Data.Text.Internal.Text -- ^ 'listByronTransactionsParametersPathWalletId'
  -> ListByronTransactionsParameters
mkListByronTransactionsParameters listByronTransactionsParametersPathWalletId = ListByronTransactionsParameters{listByronTransactionsParametersPathWalletId = listByronTransactionsParametersPathWalletId,
                                                                                                                listByronTransactionsParametersQueryEnd = GHC.Maybe.Nothing,
                                                                                                                listByronTransactionsParametersQueryMax_count = GHC.Maybe.Nothing,
                                                                                                                listByronTransactionsParametersQueryOrder = GHC.Maybe.Nothing,
                                                                                                                listByronTransactionsParametersQueryStart = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.parameters.properties.queryOrder@ in the specification.
-- 
-- Represents the parameter named \'order\'
-- 
-- An optional sort order.
data ListByronTransactionsParametersQueryOrder =
   ListByronTransactionsParametersQueryOrderOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListByronTransactionsParametersQueryOrderTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListByronTransactionsParametersQueryOrderEnumAscending -- ^ Represents the JSON value @"ascending"@
  | ListByronTransactionsParametersQueryOrderEnumDescending -- ^ Represents the JSON value @"descending"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsParametersQueryOrder
    where toJSON (ListByronTransactionsParametersQueryOrderOther val) = val
          toJSON (ListByronTransactionsParametersQueryOrderTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListByronTransactionsParametersQueryOrderEnumAscending) = "ascending"
          toJSON (ListByronTransactionsParametersQueryOrderEnumDescending) = "descending"
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsParametersQueryOrder
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "ascending" -> ListByronTransactionsParametersQueryOrderEnumAscending
                                            | val GHC.Classes.== "descending" -> ListByronTransactionsParametersQueryOrderEnumDescending
                                            | GHC.Base.otherwise -> ListByronTransactionsParametersQueryOrderOther val)
-- | Represents a response of the operation 'listByronTransactions'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'ListByronTransactionsResponseError' is used.
data ListByronTransactionsResponse =
   ListByronTransactionsResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | ListByronTransactionsResponse200 ([ListByronTransactionsResponseBody200]) -- ^ Ok
  | ListByronTransactionsResponse400 ListByronTransactionsResponseBody400Variants -- ^ Bad Request
  | ListByronTransactionsResponse404 ListByronTransactionsResponseBody404 -- ^ Not Found
  | ListByronTransactionsResponse406 ListByronTransactionsResponseBody406 -- ^ Not Acceptable
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200 = ListByronTransactionsResponseBody200 {
  -- | amount: An amount of Ada spent or received, from the perspective of the wallet.
  -- 
  -- That is, for outgoing transaction, it represents the amount of Ada consumed
  -- as inputs including the amount of Ada spent as fees or deposits.
  -- 
  -- For incoming transaction, it represents the total amount of Ada received to
  -- addresses that belong to the wallet.
  listByronTransactionsResponseBody200Amount :: ListByronTransactionsResponseBody200Amount
  -- | burn
  , listByronTransactionsResponseBody200Burn :: (GHC.Maybe.Maybe ListByronTransactionsResponseBody200Burn)
  -- | certificates
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listByronTransactionsResponseBody200Certificates :: (GHC.Maybe.Maybe ([ListByronTransactionsResponseBody200CertificatesVariants]))
  -- | collateral: A list of transaction inputs used for collateral.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listByronTransactionsResponseBody200Collateral :: (GHC.Maybe.Maybe ([ListByronTransactionsResponseBody200Collateral]))
  -- | collateral_outputs: A list of collateral return outputs with amounts specified.
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 1 items
  -- * Must have a minimum of 0 items
  , listByronTransactionsResponseBody200Collateral_outputs :: (GHC.Maybe.Maybe ([ListByronTransactionsResponseBody200Collateral_outputs]))
  -- | deposit_returned: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listByronTransactionsResponseBody200Deposit_returned :: ListByronTransactionsResponseBody200Deposit_returned
  -- | deposit_taken: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listByronTransactionsResponseBody200Deposit_taken :: ListByronTransactionsResponseBody200Deposit_taken
  -- | depth: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Current depth of the transaction in the local chain
  , listByronTransactionsResponseBody200Depth :: (GHC.Maybe.Maybe ListByronTransactionsResponseBody200Depth)
  -- | direction
  , listByronTransactionsResponseBody200Direction :: ListByronTransactionsResponseBody200Direction
  -- | expires_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending OR status == expired
  -- \<\/span>\<br\/>
  -- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
  , listByronTransactionsResponseBody200Expires_at :: (GHC.Maybe.Maybe ListByronTransactionsResponseBody200Expires_at)
  -- | extra_signatures
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listByronTransactionsResponseBody200Extra_signatures :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | fee: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listByronTransactionsResponseBody200Fee :: ListByronTransactionsResponseBody200Fee
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , listByronTransactionsResponseBody200Id :: Data.Text.Internal.Text
  -- | inputs: A list of transaction inputs.
  -- 
  -- \`assets\` and \`address\` are always present for \`outgoing\`
  -- transactions but generally absent for \`incoming\`
  -- transactions. This information is present on the Cardano explorer,
  -- but is not tracked by the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listByronTransactionsResponseBody200Inputs :: ([ListByronTransactionsResponseBody200Inputs])
  -- | inserted_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Absolute time at which the transaction was inserted in a block.
  , listByronTransactionsResponseBody200Inserted_at :: (GHC.Maybe.Maybe ListByronTransactionsResponseBody200Inserted_at)
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  , listByronTransactionsResponseBody200Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | mint
  , listByronTransactionsResponseBody200Mint :: (GHC.Maybe.Maybe ListByronTransactionsResponseBody200Mint)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listByronTransactionsResponseBody200Outputs :: ([ListByronTransactionsResponseBody200Outputs])
  -- | pending_since: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending
  -- \<\/span>\<br\/>
  -- The point in time at which a transaction became pending.
  , listByronTransactionsResponseBody200Pending_since :: (GHC.Maybe.Maybe ListByronTransactionsResponseBody200Pending_since)
  -- | script_integrity: A script data integrity hash - 32 bytes
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^(script_data)1[0-9a-z]*\$\'
  , listByronTransactionsResponseBody200Script_integrity :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | script_validity: Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
  -- used in the transaction validated or not. Validity may be null if this
  -- transaction was from an era that doesn\'t support phase-2 monetary policy
  -- scripts, or is a pending transaction (we don\'t know if validation passed or
  -- failed until the transaction hits the ledger).
  , listByronTransactionsResponseBody200Script_validity :: (GHC.Maybe.Maybe (Wallet.Common.Nullable ListByronTransactionsResponseBody200Script_validityNonNullable))
  -- | status: Current transaction status.
  -- 
  --   \`\`\`
  --        *-----------*
  --   ---> |  PENDING  |----------------*
  --        *-----------*                |
  --              |                      |
  --              V                      V
  --        *-----------*          *-----------*
  --        |           |---------->  EXPIRED  |
  --        |           |  (ttl)   *-----------*
  --        | SUBMITTED |
  --        |           \<----------------*
  --        |           |                |
  --        *-----------*           (rollback)
  --               |                     |
  --          (in ledger)          *-----------*
  --               |               |           |
  --               *---------------> IN_LEDGER |
  --                               |           |
  --                               *-----------*
  --   \`\`\`
  , listByronTransactionsResponseBody200Status :: ListByronTransactionsResponseBody200Status
  -- | validity_interval
  , listByronTransactionsResponseBody200Validity_interval :: (GHC.Maybe.Maybe ListByronTransactionsResponseBody200Validity_interval)
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listByronTransactionsResponseBody200Withdrawals :: ([ListByronTransactionsResponseBody200Withdrawals])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Fee obj] : ["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Withdrawals obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Fee obj] : ["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Withdrawals obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200" (\obj -> (((((((((((((((((((((((GHC.Base.pure ListByronTransactionsResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "burn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral_outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "depth")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "direction")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "expires_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "extra_signatures")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fee")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "inserted_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pending_since")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_integrity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_validity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "validity_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "withdrawals"))
-- | Create a new 'ListByronTransactionsResponseBody200' with all required fields.
mkListByronTransactionsResponseBody200 :: ListByronTransactionsResponseBody200Amount -- ^ 'listByronTransactionsResponseBody200Amount'
  -> ListByronTransactionsResponseBody200Deposit_returned -- ^ 'listByronTransactionsResponseBody200Deposit_returned'
  -> ListByronTransactionsResponseBody200Deposit_taken -- ^ 'listByronTransactionsResponseBody200Deposit_taken'
  -> ListByronTransactionsResponseBody200Direction -- ^ 'listByronTransactionsResponseBody200Direction'
  -> ListByronTransactionsResponseBody200Fee -- ^ 'listByronTransactionsResponseBody200Fee'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200Id'
  -> [ListByronTransactionsResponseBody200Inputs] -- ^ 'listByronTransactionsResponseBody200Inputs'
  -> [ListByronTransactionsResponseBody200Outputs] -- ^ 'listByronTransactionsResponseBody200Outputs'
  -> ListByronTransactionsResponseBody200Status -- ^ 'listByronTransactionsResponseBody200Status'
  -> [ListByronTransactionsResponseBody200Withdrawals] -- ^ 'listByronTransactionsResponseBody200Withdrawals'
  -> ListByronTransactionsResponseBody200
mkListByronTransactionsResponseBody200 listByronTransactionsResponseBody200Amount listByronTransactionsResponseBody200Deposit_returned listByronTransactionsResponseBody200Deposit_taken listByronTransactionsResponseBody200Direction listByronTransactionsResponseBody200Fee listByronTransactionsResponseBody200Id listByronTransactionsResponseBody200Inputs listByronTransactionsResponseBody200Outputs listByronTransactionsResponseBody200Status listByronTransactionsResponseBody200Withdrawals = ListByronTransactionsResponseBody200{listByronTransactionsResponseBody200Amount = listByronTransactionsResponseBody200Amount,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Burn = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Certificates = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Collateral = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Collateral_outputs = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Deposit_returned = listByronTransactionsResponseBody200Deposit_returned,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Deposit_taken = listByronTransactionsResponseBody200Deposit_taken,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Depth = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Direction = listByronTransactionsResponseBody200Direction,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Expires_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Extra_signatures = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Fee = listByronTransactionsResponseBody200Fee,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Id = listByronTransactionsResponseBody200Id,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Inputs = listByronTransactionsResponseBody200Inputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Inserted_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Mint = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Outputs = listByronTransactionsResponseBody200Outputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Pending_since = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Script_integrity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Script_validity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Status = listByronTransactionsResponseBody200Status,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Validity_interval = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               listByronTransactionsResponseBody200Withdrawals = listByronTransactionsResponseBody200Withdrawals}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.amount@ in the specification.
-- 
-- An amount of Ada spent or received, from the perspective of the wallet.
-- 
-- That is, for outgoing transaction, it represents the amount of Ada consumed
-- as inputs including the amount of Ada spent as fees or deposits.
-- 
-- For incoming transaction, it represents the total amount of Ada received to
-- addresses that belong to the wallet.
data ListByronTransactionsResponseBody200Amount = ListByronTransactionsResponseBody200Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Amount" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200Amount' with all required fields.
mkListByronTransactionsResponseBody200Amount :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200AmountQuantity'
  -> ListByronTransactionsResponseBody200Amount
mkListByronTransactionsResponseBody200Amount listByronTransactionsResponseBody200AmountQuantity = ListByronTransactionsResponseBody200Amount{listByronTransactionsResponseBody200AmountQuantity = listByronTransactionsResponseBody200AmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200Burn = ListByronTransactionsResponseBody200Burn {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  listByronTransactionsResponseBody200BurnTokens :: ([ListByronTransactionsResponseBody200BurnTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , listByronTransactionsResponseBody200BurnWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , listByronTransactionsResponseBody200BurnWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200BurnWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200BurnWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Burn" (\obj -> ((GHC.Base.pure ListByronTransactionsResponseBody200Burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'ListByronTransactionsResponseBody200Burn' with all required fields.
mkListByronTransactionsResponseBody200Burn :: [ListByronTransactionsResponseBody200BurnTokens] -- ^ 'listByronTransactionsResponseBody200BurnTokens'
  -> ListByronTransactionsResponseBody200Burn
mkListByronTransactionsResponseBody200Burn listByronTransactionsResponseBody200BurnTokens = ListByronTransactionsResponseBody200Burn{listByronTransactionsResponseBody200BurnTokens = listByronTransactionsResponseBody200BurnTokens,
                                                                                                                                     listByronTransactionsResponseBody200BurnWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                                     listByronTransactionsResponseBody200BurnWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200BurnTokens = ListByronTransactionsResponseBody200BurnTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listByronTransactionsResponseBody200BurnTokensAssets :: ([ListByronTransactionsResponseBody200BurnTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listByronTransactionsResponseBody200BurnTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , listByronTransactionsResponseBody200BurnTokensPolicy_script :: ListByronTransactionsResponseBody200BurnTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200BurnTokens" (\obj -> ((GHC.Base.pure ListByronTransactionsResponseBody200BurnTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'ListByronTransactionsResponseBody200BurnTokens' with all required fields.
mkListByronTransactionsResponseBody200BurnTokens :: [ListByronTransactionsResponseBody200BurnTokensAssets] -- ^ 'listByronTransactionsResponseBody200BurnTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_id'
  -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptVariants -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_script'
  -> ListByronTransactionsResponseBody200BurnTokens
mkListByronTransactionsResponseBody200BurnTokens listByronTransactionsResponseBody200BurnTokensAssets listByronTransactionsResponseBody200BurnTokensPolicy_id listByronTransactionsResponseBody200BurnTokensPolicy_script = ListByronTransactionsResponseBody200BurnTokens{listByronTransactionsResponseBody200BurnTokensAssets = listByronTransactionsResponseBody200BurnTokensAssets,
                                                                                                                                                                                                                                                                           listByronTransactionsResponseBody200BurnTokensPolicy_id = listByronTransactionsResponseBody200BurnTokensPolicy_id,
                                                                                                                                                                                                                                                                           listByronTransactionsResponseBody200BurnTokensPolicy_script = listByronTransactionsResponseBody200BurnTokensPolicy_script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200BurnTokensAssets = ListByronTransactionsResponseBody200BurnTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listByronTransactionsResponseBody200BurnTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , listByronTransactionsResponseBody200BurnTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200BurnTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200BurnTokensAssets" (\obj -> ((GHC.Base.pure ListByronTransactionsResponseBody200BurnTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200BurnTokensAssets' with all required fields.
mkListByronTransactionsResponseBody200BurnTokensAssets :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200BurnTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200BurnTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200BurnTokensAssetsQuantity'
  -> ListByronTransactionsResponseBody200BurnTokensAssets
mkListByronTransactionsResponseBody200BurnTokensAssets listByronTransactionsResponseBody200BurnTokensAssetsAsset_name listByronTransactionsResponseBody200BurnTokensAssetsFingerprint listByronTransactionsResponseBody200BurnTokensAssetsQuantity = ListByronTransactionsResponseBody200BurnTokensAssets{listByronTransactionsResponseBody200BurnTokensAssetsAsset_name = listByronTransactionsResponseBody200BurnTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                                          listByronTransactionsResponseBody200BurnTokensAssetsFingerprint = listByronTransactionsResponseBody200BurnTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                                          listByronTransactionsResponseBody200BurnTokensAssetsQuantity = listByronTransactionsResponseBody200BurnTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1 = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference)
  -- | script
  , listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script :: ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1' with all required fields.
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1 :: ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script'
  -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1 listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1{listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                                listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference' with all required fields.
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex'
  -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference{listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                                       listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2{listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3{listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 :: ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4{listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some{listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                                        listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5{listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6{listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants =
   ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant2 ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
  | ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant3 ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
  | ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant4 ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
  | ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant5 ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
  | ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant6 ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2 = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info :: ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2' with all required fields.
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2 :: ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info'
  -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2 listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2{listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                                     listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference' with all required fields.
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex'
  -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference{listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                                       listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version :: ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info :: ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info{listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                                                   listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3 = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References :: ([ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3' with all required fields.
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3 :: [ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References] -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash'
  -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3 listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3{listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                                                 listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References' with all required fields.
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex'
  -> ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References
mkListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex = ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References{listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                                           listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex = listByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200BurnTokensPolicy_scriptVariants =
   ListByronTransactionsResponseBody200BurnTokensPolicy_scriptVariant1 ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1
  | ListByronTransactionsResponseBody200BurnTokensPolicy_scriptVariant2 ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2
  | ListByronTransactionsResponseBody200BurnTokensPolicy_scriptVariant3 ListByronTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptVariants
    where toJSON (ListByronTransactionsResponseBody200BurnTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200BurnTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200BurnTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200BurnTokensPolicy_scriptVariants
    where parseJSON val = case (ListByronTransactionsResponseBody200BurnTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200BurnTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200BurnTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data ListByronTransactionsResponseBody200CertificatesOneOf1 = ListByronTransactionsResponseBody200CertificatesOneOf1 {
  -- | certificate_type
  listByronTransactionsResponseBody200CertificatesOneOf1Certificate_type :: ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_type
  -- | pool: A unique identifier for the pool.
  , listByronTransactionsResponseBody200CertificatesOneOf1Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , listByronTransactionsResponseBody200CertificatesOneOf1Reward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200CertificatesOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200CertificatesOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200CertificatesOneOf1" (\obj -> ((GHC.Base.pure ListByronTransactionsResponseBody200CertificatesOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'ListByronTransactionsResponseBody200CertificatesOneOf1' with all required fields.
mkListByronTransactionsResponseBody200CertificatesOneOf1 :: ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_type -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf1Certificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf1Reward_account_path'
  -> ListByronTransactionsResponseBody200CertificatesOneOf1
mkListByronTransactionsResponseBody200CertificatesOneOf1 listByronTransactionsResponseBody200CertificatesOneOf1Certificate_type listByronTransactionsResponseBody200CertificatesOneOf1Reward_account_path = ListByronTransactionsResponseBody200CertificatesOneOf1{listByronTransactionsResponseBody200CertificatesOneOf1Certificate_type = listByronTransactionsResponseBody200CertificatesOneOf1Certificate_type,
                                                                                                                                                                                                                                                                   listByronTransactionsResponseBody200CertificatesOneOf1Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                   listByronTransactionsResponseBody200CertificatesOneOf1Reward_account_path = listByronTransactionsResponseBody200CertificatesOneOf1Reward_account_path}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_type =
   ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_type
    where toJSON (ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_typeOther val) = val
          toJSON (ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumJoin_pool) = "join_pool"
          toJSON (ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> ListByronTransactionsResponseBody200CertificatesOneOf1Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate not belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data ListByronTransactionsResponseBody200CertificatesOneOf2 = ListByronTransactionsResponseBody200CertificatesOneOf2 {
  -- | certificate_type
  listByronTransactionsResponseBody200CertificatesOneOf2Certificate_type :: ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_type
  -- | pool: A unique identifier for the pool.
  , listByronTransactionsResponseBody200CertificatesOneOf2Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account
  , listByronTransactionsResponseBody200CertificatesOneOf2Reward_account :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200CertificatesOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf2Reward_account obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf2Reward_account obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200CertificatesOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200CertificatesOneOf2" (\obj -> ((GHC.Base.pure ListByronTransactionsResponseBody200CertificatesOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account"))
-- | Create a new 'ListByronTransactionsResponseBody200CertificatesOneOf2' with all required fields.
mkListByronTransactionsResponseBody200CertificatesOneOf2 :: ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_type -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf2Certificate_type'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf2Reward_account'
  -> ListByronTransactionsResponseBody200CertificatesOneOf2
mkListByronTransactionsResponseBody200CertificatesOneOf2 listByronTransactionsResponseBody200CertificatesOneOf2Certificate_type listByronTransactionsResponseBody200CertificatesOneOf2Reward_account = ListByronTransactionsResponseBody200CertificatesOneOf2{listByronTransactionsResponseBody200CertificatesOneOf2Certificate_type = listByronTransactionsResponseBody200CertificatesOneOf2Certificate_type,
                                                                                                                                                                                                                                                              listByronTransactionsResponseBody200CertificatesOneOf2Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                              listByronTransactionsResponseBody200CertificatesOneOf2Reward_account = listByronTransactionsResponseBody200CertificatesOneOf2Reward_account}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_type =
   ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumJoin_pool_external -- ^ Represents the JSON value @"join_pool_external"@
  | ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumQuit_pool_external -- ^ Represents the JSON value @"quit_pool_external"@
  | ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external -- ^ Represents the JSON value @"register_reward_account_external"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_type
    where toJSON (ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_typeOther val) = val
          toJSON (ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumJoin_pool_external) = "join_pool_external"
          toJSON (ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumQuit_pool_external) = "quit_pool_external"
          toJSON (ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external) = "register_reward_account_external"
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool_external" -> ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumJoin_pool_external
                                            | val GHC.Classes.== "quit_pool_external" -> ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumQuit_pool_external
                                            | val GHC.Classes.== "register_reward_account_external" -> ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external
                                            | GHC.Base.otherwise -> ListByronTransactionsResponseBody200CertificatesOneOf2Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200CertificatesOneOf3 = ListByronTransactionsResponseBody200CertificatesOneOf3 {
  -- | pool_cost: Estimated cost set by the pool operator when registering his pool.
  -- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  listByronTransactionsResponseBody200CertificatesOneOf3Pool_cost :: ListByronTransactionsResponseBody200CertificatesOneOf3Pool_cost
  -- | pool_id: A unique identifier for the pool.
  , listByronTransactionsResponseBody200CertificatesOneOf3Pool_id :: Data.Text.Internal.Text
  -- | pool_margin: Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , listByronTransactionsResponseBody200CertificatesOneOf3Pool_margin :: ListByronTransactionsResponseBody200CertificatesOneOf3Pool_margin
  -- | pool_metadata
  , listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata :: (GHC.Maybe.Maybe ListByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata)
  -- | pool_owners
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listByronTransactionsResponseBody200CertificatesOneOf3Pool_owners :: ([Data.Text.Internal.Text])
  -- | pool_pledge: Minimal stake amount that a stake pool is willing to honor.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , listByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge :: ListByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200CertificatesOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200CertificatesOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200CertificatesOneOf3" (\obj -> (((((GHC.Base.pure ListByronTransactionsResponseBody200CertificatesOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_cost")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_margin")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool_metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_owners")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_pledge"))
-- | Create a new 'ListByronTransactionsResponseBody200CertificatesOneOf3' with all required fields.
mkListByronTransactionsResponseBody200CertificatesOneOf3 :: ListByronTransactionsResponseBody200CertificatesOneOf3Pool_cost -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf3Pool_cost'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf3Pool_id'
  -> ListByronTransactionsResponseBody200CertificatesOneOf3Pool_margin -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf3Pool_margin'
  -> [Data.Text.Internal.Text] -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf3Pool_owners'
  -> ListByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge'
  -> ListByronTransactionsResponseBody200CertificatesOneOf3
mkListByronTransactionsResponseBody200CertificatesOneOf3 listByronTransactionsResponseBody200CertificatesOneOf3Pool_cost listByronTransactionsResponseBody200CertificatesOneOf3Pool_id listByronTransactionsResponseBody200CertificatesOneOf3Pool_margin listByronTransactionsResponseBody200CertificatesOneOf3Pool_owners listByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge = ListByronTransactionsResponseBody200CertificatesOneOf3{listByronTransactionsResponseBody200CertificatesOneOf3Pool_cost = listByronTransactionsResponseBody200CertificatesOneOf3Pool_cost,
                                                                                                                                                                                                                                                                                                                                                                                                                                                      listByronTransactionsResponseBody200CertificatesOneOf3Pool_id = listByronTransactionsResponseBody200CertificatesOneOf3Pool_id,
                                                                                                                                                                                                                                                                                                                                                                                                                                                      listByronTransactionsResponseBody200CertificatesOneOf3Pool_margin = listByronTransactionsResponseBody200CertificatesOneOf3Pool_margin,
                                                                                                                                                                                                                                                                                                                                                                                                                                                      listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                      listByronTransactionsResponseBody200CertificatesOneOf3Pool_owners = listByronTransactionsResponseBody200CertificatesOneOf3Pool_owners,
                                                                                                                                                                                                                                                                                                                                                                                                                                                      listByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge = listByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_cost@ in the specification.
-- 
-- Estimated cost set by the pool operator when registering his pool.
-- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data ListByronTransactionsResponseBody200CertificatesOneOf3Pool_cost = ListByronTransactionsResponseBody200CertificatesOneOf3Pool_cost {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200CertificatesOneOf3Pool_cost
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200CertificatesOneOf3Pool_cost
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200CertificatesOneOf3Pool_cost" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200CertificatesOneOf3Pool_cost GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200CertificatesOneOf3Pool_cost' with all required fields.
mkListByronTransactionsResponseBody200CertificatesOneOf3Pool_cost :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity'
  -> ListByronTransactionsResponseBody200CertificatesOneOf3Pool_cost
mkListByronTransactionsResponseBody200CertificatesOneOf3Pool_cost listByronTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity = ListByronTransactionsResponseBody200CertificatesOneOf3Pool_cost{listByronTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity = listByronTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_margin@ in the specification.
-- 
-- Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data ListByronTransactionsResponseBody200CertificatesOneOf3Pool_margin = ListByronTransactionsResponseBody200CertificatesOneOf3Pool_margin {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200CertificatesOneOf3Pool_margin
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200CertificatesOneOf3Pool_margin
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200CertificatesOneOf3Pool_margin" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200CertificatesOneOf3Pool_margin GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200CertificatesOneOf3Pool_margin' with all required fields.
mkListByronTransactionsResponseBody200CertificatesOneOf3Pool_margin :: GHC.Types.Double -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity'
  -> ListByronTransactionsResponseBody200CertificatesOneOf3Pool_margin
mkListByronTransactionsResponseBody200CertificatesOneOf3Pool_margin listByronTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity = ListByronTransactionsResponseBody200CertificatesOneOf3Pool_margin{listByronTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity = listByronTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_metadata@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata = ListByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata {
  -- | hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash :: Data.Text.Internal.Text
  -- | url: A URL to the stake pool\'s website.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 250
  -- * Must match pattern \'^https:\/\/.+\'
  , listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))
-- | Create a new 'ListByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata' with all required fields.
mkListByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl'
  -> ListByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata
mkListByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl = ListByronTransactionsResponseBody200CertificatesOneOf3Pool_metadata{listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash = listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash,
                                                                                                                                                                                                                                                                                           listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl = listByronTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_pledge@ in the specification.
-- 
-- Minimal stake amount that a stake pool is willing to honor.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data ListByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge = ListByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge' with all required fields.
mkListByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity'
  -> ListByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge
mkListByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge listByronTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity = ListByronTransactionsResponseBody200CertificatesOneOf3Pool_pledge{listByronTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity = listByronTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200CertificatesOneOf4 = ListByronTransactionsResponseBody200CertificatesOneOf4 {
  -- | pool_id: A unique identifier for the pool.
  listByronTransactionsResponseBody200CertificatesOneOf4Pool_id :: Data.Text.Internal.Text
  -- | retirement_epoch: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200CertificatesOneOf4Retirement_epoch :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200CertificatesOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200CertificatesOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200CertificatesOneOf4" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200CertificatesOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "retirement_epoch"))
-- | Create a new 'ListByronTransactionsResponseBody200CertificatesOneOf4' with all required fields.
mkListByronTransactionsResponseBody200CertificatesOneOf4 :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf4Pool_id'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf4Retirement_epoch'
  -> ListByronTransactionsResponseBody200CertificatesOneOf4
mkListByronTransactionsResponseBody200CertificatesOneOf4 listByronTransactionsResponseBody200CertificatesOneOf4Pool_id listByronTransactionsResponseBody200CertificatesOneOf4Retirement_epoch = ListByronTransactionsResponseBody200CertificatesOneOf4{listByronTransactionsResponseBody200CertificatesOneOf4Pool_id = listByronTransactionsResponseBody200CertificatesOneOf4Pool_id,
                                                                                                                                                                                                                                                       listByronTransactionsResponseBody200CertificatesOneOf4Retirement_epoch = listByronTransactionsResponseBody200CertificatesOneOf4Retirement_epoch}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200CertificatesOneOf5 = ListByronTransactionsResponseBody200CertificatesOneOf5 {
  -- | certificate_type
  listByronTransactionsResponseBody200CertificatesOneOf5Certificate_type :: ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_type
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200CertificatesOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200CertificatesOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200CertificatesOneOf5" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200CertificatesOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type"))
-- | Create a new 'ListByronTransactionsResponseBody200CertificatesOneOf5' with all required fields.
mkListByronTransactionsResponseBody200CertificatesOneOf5 :: ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_type -- ^ 'listByronTransactionsResponseBody200CertificatesOneOf5Certificate_type'
  -> ListByronTransactionsResponseBody200CertificatesOneOf5
mkListByronTransactionsResponseBody200CertificatesOneOf5 listByronTransactionsResponseBody200CertificatesOneOf5Certificate_type = ListByronTransactionsResponseBody200CertificatesOneOf5{listByronTransactionsResponseBody200CertificatesOneOf5Certificate_type = listByronTransactionsResponseBody200CertificatesOneOf5Certificate_type}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_type =
   ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumMir -- ^ Represents the JSON value @"mir"@
  | ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumGenesis -- ^ Represents the JSON value @"genesis"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_type
    where toJSON (ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_typeOther val) = val
          toJSON (ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumMir) = "mir"
          toJSON (ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumGenesis) = "genesis"
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "mir" -> ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumMir
                                            | val GHC.Classes.== "genesis" -> ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumGenesis
                                            | GHC.Base.otherwise -> ListByronTransactionsResponseBody200CertificatesOneOf5Certificate_typeOther val)
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- Any certificate that could occur in an arbitrary transaction:
-- might be related to delegation, pool activities, genesis or MIR.
data ListByronTransactionsResponseBody200CertificatesVariants =
   ListByronTransactionsResponseBody200CertificatesVariant1 ListByronTransactionsResponseBody200CertificatesOneOf1
  | ListByronTransactionsResponseBody200CertificatesVariant2 ListByronTransactionsResponseBody200CertificatesOneOf2
  | ListByronTransactionsResponseBody200CertificatesVariant3 ListByronTransactionsResponseBody200CertificatesOneOf3
  | ListByronTransactionsResponseBody200CertificatesVariant4 ListByronTransactionsResponseBody200CertificatesOneOf4
  | ListByronTransactionsResponseBody200CertificatesVariant5 ListByronTransactionsResponseBody200CertificatesOneOf5
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200CertificatesVariants
    where toJSON (ListByronTransactionsResponseBody200CertificatesVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200CertificatesVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200CertificatesVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200CertificatesVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200CertificatesVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200CertificatesVariants
    where parseJSON val = case (ListByronTransactionsResponseBody200CertificatesVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200CertificatesVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200CertificatesVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200CertificatesVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200CertificatesVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.collateral.items@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200Collateral = ListByronTransactionsResponseBody200Collateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  listByronTransactionsResponseBody200CollateralAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listByronTransactionsResponseBody200CollateralAmount :: (GHC.Maybe.Maybe ListByronTransactionsResponseBody200CollateralAmount)
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , listByronTransactionsResponseBody200CollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200CollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Collateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Collateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Collateral" (\obj -> (((GHC.Base.pure ListByronTransactionsResponseBody200Collateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListByronTransactionsResponseBody200Collateral' with all required fields.
mkListByronTransactionsResponseBody200Collateral :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200CollateralId'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200CollateralIndex'
  -> ListByronTransactionsResponseBody200Collateral
mkListByronTransactionsResponseBody200Collateral listByronTransactionsResponseBody200CollateralId listByronTransactionsResponseBody200CollateralIndex = ListByronTransactionsResponseBody200Collateral{listByronTransactionsResponseBody200CollateralAddress = GHC.Maybe.Nothing,
                                                                                                                                                                                                       listByronTransactionsResponseBody200CollateralAmount = GHC.Maybe.Nothing,
                                                                                                                                                                                                       listByronTransactionsResponseBody200CollateralId = listByronTransactionsResponseBody200CollateralId,
                                                                                                                                                                                                       listByronTransactionsResponseBody200CollateralIndex = listByronTransactionsResponseBody200CollateralIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListByronTransactionsResponseBody200CollateralAmount = ListByronTransactionsResponseBody200CollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200CollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200CollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200CollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200CollateralAmount" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200CollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200CollateralAmount' with all required fields.
mkListByronTransactionsResponseBody200CollateralAmount :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200CollateralAmountQuantity'
  -> ListByronTransactionsResponseBody200CollateralAmount
mkListByronTransactionsResponseBody200CollateralAmount listByronTransactionsResponseBody200CollateralAmountQuantity = ListByronTransactionsResponseBody200CollateralAmount{listByronTransactionsResponseBody200CollateralAmountQuantity = listByronTransactionsResponseBody200CollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.collateral_outputs.items@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200Collateral_outputs = ListByronTransactionsResponseBody200Collateral_outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  listByronTransactionsResponseBody200Collateral_outputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listByronTransactionsResponseBody200Collateral_outputsAmount :: ListByronTransactionsResponseBody200Collateral_outputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , listByronTransactionsResponseBody200Collateral_outputsAssets :: (GHC.Maybe.Maybe ([ListByronTransactionsResponseBody200Collateral_outputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Collateral_outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Collateral_outputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200Collateral_outputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Collateral_outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Collateral_outputs" (\obj -> ((GHC.Base.pure ListByronTransactionsResponseBody200Collateral_outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'ListByronTransactionsResponseBody200Collateral_outputs' with all required fields.
mkListByronTransactionsResponseBody200Collateral_outputs :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200Collateral_outputsAddress'
  -> ListByronTransactionsResponseBody200Collateral_outputsAmount -- ^ 'listByronTransactionsResponseBody200Collateral_outputsAmount'
  -> ListByronTransactionsResponseBody200Collateral_outputs
mkListByronTransactionsResponseBody200Collateral_outputs listByronTransactionsResponseBody200Collateral_outputsAddress listByronTransactionsResponseBody200Collateral_outputsAmount = ListByronTransactionsResponseBody200Collateral_outputs{listByronTransactionsResponseBody200Collateral_outputsAddress = listByronTransactionsResponseBody200Collateral_outputsAddress,
                                                                                                                                                                                                                                             listByronTransactionsResponseBody200Collateral_outputsAmount = listByronTransactionsResponseBody200Collateral_outputsAmount,
                                                                                                                                                                                                                                             listByronTransactionsResponseBody200Collateral_outputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.collateral_outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListByronTransactionsResponseBody200Collateral_outputsAmount = ListByronTransactionsResponseBody200Collateral_outputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200Collateral_outputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Collateral_outputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Collateral_outputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Collateral_outputsAmount" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200Collateral_outputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200Collateral_outputsAmount' with all required fields.
mkListByronTransactionsResponseBody200Collateral_outputsAmount :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Collateral_outputsAmountQuantity'
  -> ListByronTransactionsResponseBody200Collateral_outputsAmount
mkListByronTransactionsResponseBody200Collateral_outputsAmount listByronTransactionsResponseBody200Collateral_outputsAmountQuantity = ListByronTransactionsResponseBody200Collateral_outputsAmount{listByronTransactionsResponseBody200Collateral_outputsAmountQuantity = listByronTransactionsResponseBody200Collateral_outputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.collateral_outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ListByronTransactionsResponseBody200Collateral_outputsAssets = ListByronTransactionsResponseBody200Collateral_outputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listByronTransactionsResponseBody200Collateral_outputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listByronTransactionsResponseBody200Collateral_outputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200Collateral_outputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Collateral_outputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Collateral_outputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Collateral_outputsAssets" (\obj -> ((GHC.Base.pure ListByronTransactionsResponseBody200Collateral_outputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200Collateral_outputsAssets' with all required fields.
mkListByronTransactionsResponseBody200Collateral_outputsAssets :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200Collateral_outputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200Collateral_outputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Collateral_outputsAssetsQuantity'
  -> ListByronTransactionsResponseBody200Collateral_outputsAssets
mkListByronTransactionsResponseBody200Collateral_outputsAssets listByronTransactionsResponseBody200Collateral_outputsAssetsAsset_name listByronTransactionsResponseBody200Collateral_outputsAssetsPolicy_id listByronTransactionsResponseBody200Collateral_outputsAssetsQuantity = ListByronTransactionsResponseBody200Collateral_outputsAssets{listByronTransactionsResponseBody200Collateral_outputsAssetsAsset_name = listByronTransactionsResponseBody200Collateral_outputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                                listByronTransactionsResponseBody200Collateral_outputsAssetsPolicy_id = listByronTransactionsResponseBody200Collateral_outputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                                listByronTransactionsResponseBody200Collateral_outputsAssetsQuantity = listByronTransactionsResponseBody200Collateral_outputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.deposit_returned@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListByronTransactionsResponseBody200Deposit_returned = ListByronTransactionsResponseBody200Deposit_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200Deposit_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Deposit_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Deposit_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Deposit_returned" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200Deposit_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200Deposit_returned' with all required fields.
mkListByronTransactionsResponseBody200Deposit_returned :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Deposit_returnedQuantity'
  -> ListByronTransactionsResponseBody200Deposit_returned
mkListByronTransactionsResponseBody200Deposit_returned listByronTransactionsResponseBody200Deposit_returnedQuantity = ListByronTransactionsResponseBody200Deposit_returned{listByronTransactionsResponseBody200Deposit_returnedQuantity = listByronTransactionsResponseBody200Deposit_returnedQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.deposit_taken@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListByronTransactionsResponseBody200Deposit_taken = ListByronTransactionsResponseBody200Deposit_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200Deposit_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Deposit_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Deposit_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Deposit_taken" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200Deposit_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200Deposit_taken' with all required fields.
mkListByronTransactionsResponseBody200Deposit_taken :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Deposit_takenQuantity'
  -> ListByronTransactionsResponseBody200Deposit_taken
mkListByronTransactionsResponseBody200Deposit_taken listByronTransactionsResponseBody200Deposit_takenQuantity = ListByronTransactionsResponseBody200Deposit_taken{listByronTransactionsResponseBody200Deposit_takenQuantity = listByronTransactionsResponseBody200Deposit_takenQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.depth@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Current depth of the transaction in the local chain
data ListByronTransactionsResponseBody200Depth = ListByronTransactionsResponseBody200Depth {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200DepthQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Depth
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Depth
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Depth" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200Depth GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200Depth' with all required fields.
mkListByronTransactionsResponseBody200Depth :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200DepthQuantity'
  -> ListByronTransactionsResponseBody200Depth
mkListByronTransactionsResponseBody200Depth listByronTransactionsResponseBody200DepthQuantity = ListByronTransactionsResponseBody200Depth{listByronTransactionsResponseBody200DepthQuantity = listByronTransactionsResponseBody200DepthQuantity}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.direction@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200Direction =
   ListByronTransactionsResponseBody200DirectionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListByronTransactionsResponseBody200DirectionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListByronTransactionsResponseBody200DirectionEnumOutgoing -- ^ Represents the JSON value @"outgoing"@
  | ListByronTransactionsResponseBody200DirectionEnumIncoming -- ^ Represents the JSON value @"incoming"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Direction
    where toJSON (ListByronTransactionsResponseBody200DirectionOther val) = val
          toJSON (ListByronTransactionsResponseBody200DirectionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListByronTransactionsResponseBody200DirectionEnumOutgoing) = "outgoing"
          toJSON (ListByronTransactionsResponseBody200DirectionEnumIncoming) = "incoming"
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Direction
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "outgoing" -> ListByronTransactionsResponseBody200DirectionEnumOutgoing
                                            | val GHC.Classes.== "incoming" -> ListByronTransactionsResponseBody200DirectionEnumIncoming
                                            | GHC.Base.otherwise -> ListByronTransactionsResponseBody200DirectionOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.expires_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending OR status == expired
-- \<\/span>\<br\/>
-- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
data ListByronTransactionsResponseBody200Expires_at = ListByronTransactionsResponseBody200Expires_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200Expires_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200Expires_atEpoch_number :: GHC.Types.Int
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200Expires_atSlot_number :: GHC.Types.Int
  -- | time
  , listByronTransactionsResponseBody200Expires_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Expires_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Expires_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Expires_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Expires_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Expires_at" (\obj -> (((GHC.Base.pure ListByronTransactionsResponseBody200Expires_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'ListByronTransactionsResponseBody200Expires_at' with all required fields.
mkListByronTransactionsResponseBody200Expires_at :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Expires_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Expires_atEpoch_number'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Expires_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200Expires_atTime'
  -> ListByronTransactionsResponseBody200Expires_at
mkListByronTransactionsResponseBody200Expires_at listByronTransactionsResponseBody200Expires_atAbsolute_slot_number listByronTransactionsResponseBody200Expires_atEpoch_number listByronTransactionsResponseBody200Expires_atSlot_number listByronTransactionsResponseBody200Expires_atTime = ListByronTransactionsResponseBody200Expires_at{listByronTransactionsResponseBody200Expires_atAbsolute_slot_number = listByronTransactionsResponseBody200Expires_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                             listByronTransactionsResponseBody200Expires_atEpoch_number = listByronTransactionsResponseBody200Expires_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                             listByronTransactionsResponseBody200Expires_atSlot_number = listByronTransactionsResponseBody200Expires_atSlot_number,
                                                                                                                                                                                                                                                                                                                                             listByronTransactionsResponseBody200Expires_atTime = listByronTransactionsResponseBody200Expires_atTime}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.fee@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListByronTransactionsResponseBody200Fee = ListByronTransactionsResponseBody200Fee {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200FeeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Fee
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Fee
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Fee" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200Fee GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200Fee' with all required fields.
mkListByronTransactionsResponseBody200Fee :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200FeeQuantity'
  -> ListByronTransactionsResponseBody200Fee
mkListByronTransactionsResponseBody200Fee listByronTransactionsResponseBody200FeeQuantity = ListByronTransactionsResponseBody200Fee{listByronTransactionsResponseBody200FeeQuantity = listByronTransactionsResponseBody200FeeQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.inputs.items@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200Inputs = ListByronTransactionsResponseBody200Inputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  listByronTransactionsResponseBody200InputsAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listByronTransactionsResponseBody200InputsAmount :: (GHC.Maybe.Maybe ListByronTransactionsResponseBody200InputsAmount)
  -- | assets: A flat list of assets (possibly empty).
  , listByronTransactionsResponseBody200InputsAssets :: (GHC.Maybe.Maybe ([ListByronTransactionsResponseBody200InputsAssets]))
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , listByronTransactionsResponseBody200InputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200InputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Inputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200InputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200InputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Inputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Inputs" (\obj -> ((((GHC.Base.pure ListByronTransactionsResponseBody200Inputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListByronTransactionsResponseBody200Inputs' with all required fields.
mkListByronTransactionsResponseBody200Inputs :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200InputsId'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200InputsIndex'
  -> ListByronTransactionsResponseBody200Inputs
mkListByronTransactionsResponseBody200Inputs listByronTransactionsResponseBody200InputsId listByronTransactionsResponseBody200InputsIndex = ListByronTransactionsResponseBody200Inputs{listByronTransactionsResponseBody200InputsAddress = GHC.Maybe.Nothing,
                                                                                                                                                                                       listByronTransactionsResponseBody200InputsAmount = GHC.Maybe.Nothing,
                                                                                                                                                                                       listByronTransactionsResponseBody200InputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                                                       listByronTransactionsResponseBody200InputsId = listByronTransactionsResponseBody200InputsId,
                                                                                                                                                                                       listByronTransactionsResponseBody200InputsIndex = listByronTransactionsResponseBody200InputsIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListByronTransactionsResponseBody200InputsAmount = ListByronTransactionsResponseBody200InputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200InputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200InputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200InputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200InputsAmount" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200InputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200InputsAmount' with all required fields.
mkListByronTransactionsResponseBody200InputsAmount :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200InputsAmountQuantity'
  -> ListByronTransactionsResponseBody200InputsAmount
mkListByronTransactionsResponseBody200InputsAmount listByronTransactionsResponseBody200InputsAmountQuantity = ListByronTransactionsResponseBody200InputsAmount{listByronTransactionsResponseBody200InputsAmountQuantity = listByronTransactionsResponseBody200InputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ListByronTransactionsResponseBody200InputsAssets = ListByronTransactionsResponseBody200InputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listByronTransactionsResponseBody200InputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listByronTransactionsResponseBody200InputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200InputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200InputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200InputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200InputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200InputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200InputsAssets" (\obj -> ((GHC.Base.pure ListByronTransactionsResponseBody200InputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200InputsAssets' with all required fields.
mkListByronTransactionsResponseBody200InputsAssets :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200InputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200InputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200InputsAssetsQuantity'
  -> ListByronTransactionsResponseBody200InputsAssets
mkListByronTransactionsResponseBody200InputsAssets listByronTransactionsResponseBody200InputsAssetsAsset_name listByronTransactionsResponseBody200InputsAssetsPolicy_id listByronTransactionsResponseBody200InputsAssetsQuantity = ListByronTransactionsResponseBody200InputsAssets{listByronTransactionsResponseBody200InputsAssetsAsset_name = listByronTransactionsResponseBody200InputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                    listByronTransactionsResponseBody200InputsAssetsPolicy_id = listByronTransactionsResponseBody200InputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                    listByronTransactionsResponseBody200InputsAssetsQuantity = listByronTransactionsResponseBody200InputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.inserted_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Absolute time at which the transaction was inserted in a block.
data ListByronTransactionsResponseBody200Inserted_at = ListByronTransactionsResponseBody200Inserted_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200Inserted_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200Inserted_atEpoch_number :: GHC.Types.Int
  -- | height
  , listByronTransactionsResponseBody200Inserted_atHeight :: ListByronTransactionsResponseBody200Inserted_atHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200Inserted_atSlot_number :: GHC.Types.Int
  -- | time
  , listByronTransactionsResponseBody200Inserted_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Inserted_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Inserted_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Inserted_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Inserted_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Inserted_at" (\obj -> ((((GHC.Base.pure ListByronTransactionsResponseBody200Inserted_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'ListByronTransactionsResponseBody200Inserted_at' with all required fields.
mkListByronTransactionsResponseBody200Inserted_at :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Inserted_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Inserted_atEpoch_number'
  -> ListByronTransactionsResponseBody200Inserted_atHeight -- ^ 'listByronTransactionsResponseBody200Inserted_atHeight'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Inserted_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200Inserted_atTime'
  -> ListByronTransactionsResponseBody200Inserted_at
mkListByronTransactionsResponseBody200Inserted_at listByronTransactionsResponseBody200Inserted_atAbsolute_slot_number listByronTransactionsResponseBody200Inserted_atEpoch_number listByronTransactionsResponseBody200Inserted_atHeight listByronTransactionsResponseBody200Inserted_atSlot_number listByronTransactionsResponseBody200Inserted_atTime = ListByronTransactionsResponseBody200Inserted_at{listByronTransactionsResponseBody200Inserted_atAbsolute_slot_number = listByronTransactionsResponseBody200Inserted_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                                                         listByronTransactionsResponseBody200Inserted_atEpoch_number = listByronTransactionsResponseBody200Inserted_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                                                         listByronTransactionsResponseBody200Inserted_atHeight = listByronTransactionsResponseBody200Inserted_atHeight,
                                                                                                                                                                                                                                                                                                                                                                                                         listByronTransactionsResponseBody200Inserted_atSlot_number = listByronTransactionsResponseBody200Inserted_atSlot_number,
                                                                                                                                                                                                                                                                                                                                                                                                         listByronTransactionsResponseBody200Inserted_atTime = listByronTransactionsResponseBody200Inserted_atTime}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.inserted_at.properties.height@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200Inserted_atHeight = ListByronTransactionsResponseBody200Inserted_atHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200Inserted_atHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Inserted_atHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Inserted_atHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Inserted_atHeight" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200Inserted_atHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200Inserted_atHeight' with all required fields.
mkListByronTransactionsResponseBody200Inserted_atHeight :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Inserted_atHeightQuantity'
  -> ListByronTransactionsResponseBody200Inserted_atHeight
mkListByronTransactionsResponseBody200Inserted_atHeight listByronTransactionsResponseBody200Inserted_atHeightQuantity = ListByronTransactionsResponseBody200Inserted_atHeight{listByronTransactionsResponseBody200Inserted_atHeightQuantity = listByronTransactionsResponseBody200Inserted_atHeightQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200Mint = ListByronTransactionsResponseBody200Mint {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  listByronTransactionsResponseBody200MintTokens :: ([ListByronTransactionsResponseBody200MintTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , listByronTransactionsResponseBody200MintWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , listByronTransactionsResponseBody200MintWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Mint
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200MintWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200MintWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Mint
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Mint" (\obj -> ((GHC.Base.pure ListByronTransactionsResponseBody200Mint GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'ListByronTransactionsResponseBody200Mint' with all required fields.
mkListByronTransactionsResponseBody200Mint :: [ListByronTransactionsResponseBody200MintTokens] -- ^ 'listByronTransactionsResponseBody200MintTokens'
  -> ListByronTransactionsResponseBody200Mint
mkListByronTransactionsResponseBody200Mint listByronTransactionsResponseBody200MintTokens = ListByronTransactionsResponseBody200Mint{listByronTransactionsResponseBody200MintTokens = listByronTransactionsResponseBody200MintTokens,
                                                                                                                                     listByronTransactionsResponseBody200MintWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                                     listByronTransactionsResponseBody200MintWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200MintTokens = ListByronTransactionsResponseBody200MintTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listByronTransactionsResponseBody200MintTokensAssets :: ([ListByronTransactionsResponseBody200MintTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listByronTransactionsResponseBody200MintTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , listByronTransactionsResponseBody200MintTokensPolicy_script :: ListByronTransactionsResponseBody200MintTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200MintTokens" (\obj -> ((GHC.Base.pure ListByronTransactionsResponseBody200MintTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'ListByronTransactionsResponseBody200MintTokens' with all required fields.
mkListByronTransactionsResponseBody200MintTokens :: [ListByronTransactionsResponseBody200MintTokensAssets] -- ^ 'listByronTransactionsResponseBody200MintTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_id'
  -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptVariants -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_script'
  -> ListByronTransactionsResponseBody200MintTokens
mkListByronTransactionsResponseBody200MintTokens listByronTransactionsResponseBody200MintTokensAssets listByronTransactionsResponseBody200MintTokensPolicy_id listByronTransactionsResponseBody200MintTokensPolicy_script = ListByronTransactionsResponseBody200MintTokens{listByronTransactionsResponseBody200MintTokensAssets = listByronTransactionsResponseBody200MintTokensAssets,
                                                                                                                                                                                                                                                                           listByronTransactionsResponseBody200MintTokensPolicy_id = listByronTransactionsResponseBody200MintTokensPolicy_id,
                                                                                                                                                                                                                                                                           listByronTransactionsResponseBody200MintTokensPolicy_script = listByronTransactionsResponseBody200MintTokensPolicy_script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200MintTokensAssets = ListByronTransactionsResponseBody200MintTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listByronTransactionsResponseBody200MintTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , listByronTransactionsResponseBody200MintTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200MintTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200MintTokensAssets" (\obj -> ((GHC.Base.pure ListByronTransactionsResponseBody200MintTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200MintTokensAssets' with all required fields.
mkListByronTransactionsResponseBody200MintTokensAssets :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200MintTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200MintTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200MintTokensAssetsQuantity'
  -> ListByronTransactionsResponseBody200MintTokensAssets
mkListByronTransactionsResponseBody200MintTokensAssets listByronTransactionsResponseBody200MintTokensAssetsAsset_name listByronTransactionsResponseBody200MintTokensAssetsFingerprint listByronTransactionsResponseBody200MintTokensAssetsQuantity = ListByronTransactionsResponseBody200MintTokensAssets{listByronTransactionsResponseBody200MintTokensAssetsAsset_name = listByronTransactionsResponseBody200MintTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                                          listByronTransactionsResponseBody200MintTokensAssetsFingerprint = listByronTransactionsResponseBody200MintTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                                          listByronTransactionsResponseBody200MintTokensAssetsQuantity = listByronTransactionsResponseBody200MintTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1 = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference)
  -- | script
  , listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script :: ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1' with all required fields.
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1 :: ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script'
  -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1 listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1{listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                                listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference' with all required fields.
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex'
  -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference{listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                                       listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2{listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3{listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 :: ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4{listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some{listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                                        listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5{listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6{listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants =
   ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant2 ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
  | ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant3 ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
  | ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant4 ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
  | ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant5 ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
  | ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant6 ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2 = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info :: ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2' with all required fields.
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2 :: ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info'
  -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2 listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2{listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                                     listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference' with all required fields.
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex'
  -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference{listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                                       listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version :: ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info :: ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info{listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                                                   listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3 = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References :: ([ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3' with all required fields.
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3 :: [ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References] -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash'
  -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3 listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3{listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                                                 listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References' with all required fields.
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex'
  -> ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References
mkListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex = ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References{listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                                           listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex = listByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200MintTokensPolicy_scriptVariants =
   ListByronTransactionsResponseBody200MintTokensPolicy_scriptVariant1 ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf1
  | ListByronTransactionsResponseBody200MintTokensPolicy_scriptVariant2 ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf2
  | ListByronTransactionsResponseBody200MintTokensPolicy_scriptVariant3 ListByronTransactionsResponseBody200MintTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptVariants
    where toJSON (ListByronTransactionsResponseBody200MintTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200MintTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody200MintTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200MintTokensPolicy_scriptVariants
    where parseJSON val = case (ListByronTransactionsResponseBody200MintTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200MintTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody200MintTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.outputs.items@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200Outputs = ListByronTransactionsResponseBody200Outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  listByronTransactionsResponseBody200OutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listByronTransactionsResponseBody200OutputsAmount :: ListByronTransactionsResponseBody200OutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , listByronTransactionsResponseBody200OutputsAssets :: (GHC.Maybe.Maybe ([ListByronTransactionsResponseBody200OutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200OutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listByronTransactionsResponseBody200OutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Outputs" (\obj -> ((GHC.Base.pure ListByronTransactionsResponseBody200Outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'ListByronTransactionsResponseBody200Outputs' with all required fields.
mkListByronTransactionsResponseBody200Outputs :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200OutputsAddress'
  -> ListByronTransactionsResponseBody200OutputsAmount -- ^ 'listByronTransactionsResponseBody200OutputsAmount'
  -> ListByronTransactionsResponseBody200Outputs
mkListByronTransactionsResponseBody200Outputs listByronTransactionsResponseBody200OutputsAddress listByronTransactionsResponseBody200OutputsAmount = ListByronTransactionsResponseBody200Outputs{listByronTransactionsResponseBody200OutputsAddress = listByronTransactionsResponseBody200OutputsAddress,
                                                                                                                                                                                                 listByronTransactionsResponseBody200OutputsAmount = listByronTransactionsResponseBody200OutputsAmount,
                                                                                                                                                                                                 listByronTransactionsResponseBody200OutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListByronTransactionsResponseBody200OutputsAmount = ListByronTransactionsResponseBody200OutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200OutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200OutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200OutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200OutputsAmount" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200OutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200OutputsAmount' with all required fields.
mkListByronTransactionsResponseBody200OutputsAmount :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200OutputsAmountQuantity'
  -> ListByronTransactionsResponseBody200OutputsAmount
mkListByronTransactionsResponseBody200OutputsAmount listByronTransactionsResponseBody200OutputsAmountQuantity = ListByronTransactionsResponseBody200OutputsAmount{listByronTransactionsResponseBody200OutputsAmountQuantity = listByronTransactionsResponseBody200OutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ListByronTransactionsResponseBody200OutputsAssets = ListByronTransactionsResponseBody200OutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listByronTransactionsResponseBody200OutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listByronTransactionsResponseBody200OutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200OutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200OutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200OutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200OutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200OutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200OutputsAssets" (\obj -> ((GHC.Base.pure ListByronTransactionsResponseBody200OutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200OutputsAssets' with all required fields.
mkListByronTransactionsResponseBody200OutputsAssets :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200OutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200OutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200OutputsAssetsQuantity'
  -> ListByronTransactionsResponseBody200OutputsAssets
mkListByronTransactionsResponseBody200OutputsAssets listByronTransactionsResponseBody200OutputsAssetsAsset_name listByronTransactionsResponseBody200OutputsAssetsPolicy_id listByronTransactionsResponseBody200OutputsAssetsQuantity = ListByronTransactionsResponseBody200OutputsAssets{listByronTransactionsResponseBody200OutputsAssetsAsset_name = listByronTransactionsResponseBody200OutputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                         listByronTransactionsResponseBody200OutputsAssetsPolicy_id = listByronTransactionsResponseBody200OutputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                         listByronTransactionsResponseBody200OutputsAssetsQuantity = listByronTransactionsResponseBody200OutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.pending_since@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending
-- \<\/span>\<br\/>
-- The point in time at which a transaction became pending.
data ListByronTransactionsResponseBody200Pending_since = ListByronTransactionsResponseBody200Pending_since {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200Pending_sinceAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200Pending_sinceEpoch_number :: GHC.Types.Int
  -- | height
  , listByronTransactionsResponseBody200Pending_sinceHeight :: ListByronTransactionsResponseBody200Pending_sinceHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronTransactionsResponseBody200Pending_sinceSlot_number :: GHC.Types.Int
  -- | time
  , listByronTransactionsResponseBody200Pending_sinceTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Pending_since
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Pending_sinceTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Pending_sinceTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Pending_since
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Pending_since" (\obj -> ((((GHC.Base.pure ListByronTransactionsResponseBody200Pending_since GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'ListByronTransactionsResponseBody200Pending_since' with all required fields.
mkListByronTransactionsResponseBody200Pending_since :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Pending_sinceAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Pending_sinceEpoch_number'
  -> ListByronTransactionsResponseBody200Pending_sinceHeight -- ^ 'listByronTransactionsResponseBody200Pending_sinceHeight'
  -> GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Pending_sinceSlot_number'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200Pending_sinceTime'
  -> ListByronTransactionsResponseBody200Pending_since
mkListByronTransactionsResponseBody200Pending_since listByronTransactionsResponseBody200Pending_sinceAbsolute_slot_number listByronTransactionsResponseBody200Pending_sinceEpoch_number listByronTransactionsResponseBody200Pending_sinceHeight listByronTransactionsResponseBody200Pending_sinceSlot_number listByronTransactionsResponseBody200Pending_sinceTime = ListByronTransactionsResponseBody200Pending_since{listByronTransactionsResponseBody200Pending_sinceAbsolute_slot_number = listByronTransactionsResponseBody200Pending_sinceAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                                                                       listByronTransactionsResponseBody200Pending_sinceEpoch_number = listByronTransactionsResponseBody200Pending_sinceEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                                                                       listByronTransactionsResponseBody200Pending_sinceHeight = listByronTransactionsResponseBody200Pending_sinceHeight,
                                                                                                                                                                                                                                                                                                                                                                                                                       listByronTransactionsResponseBody200Pending_sinceSlot_number = listByronTransactionsResponseBody200Pending_sinceSlot_number,
                                                                                                                                                                                                                                                                                                                                                                                                                       listByronTransactionsResponseBody200Pending_sinceTime = listByronTransactionsResponseBody200Pending_sinceTime}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.pending_since.properties.height@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200Pending_sinceHeight = ListByronTransactionsResponseBody200Pending_sinceHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200Pending_sinceHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Pending_sinceHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Pending_sinceHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Pending_sinceHeight" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200Pending_sinceHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200Pending_sinceHeight' with all required fields.
mkListByronTransactionsResponseBody200Pending_sinceHeight :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Pending_sinceHeightQuantity'
  -> ListByronTransactionsResponseBody200Pending_sinceHeight
mkListByronTransactionsResponseBody200Pending_sinceHeight listByronTransactionsResponseBody200Pending_sinceHeightQuantity = ListByronTransactionsResponseBody200Pending_sinceHeight{listByronTransactionsResponseBody200Pending_sinceHeightQuantity = listByronTransactionsResponseBody200Pending_sinceHeightQuantity}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.script_validity@ in the specification.
-- 
-- Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
-- used in the transaction validated or not. Validity may be null if this
-- transaction was from an era that doesn\'t support phase-2 monetary policy
-- scripts, or is a pending transaction (we don\'t know if validation passed or
-- failed until the transaction hits the ledger).
data ListByronTransactionsResponseBody200Script_validityNonNullable =
   ListByronTransactionsResponseBody200Script_validityNonNullableOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListByronTransactionsResponseBody200Script_validityNonNullableTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListByronTransactionsResponseBody200Script_validityNonNullableEnumValid -- ^ Represents the JSON value @"valid"@
  | ListByronTransactionsResponseBody200Script_validityNonNullableEnumInvalid -- ^ Represents the JSON value @"invalid"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Script_validityNonNullable
    where toJSON (ListByronTransactionsResponseBody200Script_validityNonNullableOther val) = val
          toJSON (ListByronTransactionsResponseBody200Script_validityNonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListByronTransactionsResponseBody200Script_validityNonNullableEnumValid) = "valid"
          toJSON (ListByronTransactionsResponseBody200Script_validityNonNullableEnumInvalid) = "invalid"
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Script_validityNonNullable
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "valid" -> ListByronTransactionsResponseBody200Script_validityNonNullableEnumValid
                                            | val GHC.Classes.== "invalid" -> ListByronTransactionsResponseBody200Script_validityNonNullableEnumInvalid
                                            | GHC.Base.otherwise -> ListByronTransactionsResponseBody200Script_validityNonNullableOther val)
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.status@ in the specification.
-- 
-- Current transaction status.
-- 
--   \`\`\`
--        *-----------*
--   ---> |  PENDING  |----------------*
--        *-----------*                |
--              |                      |
--              V                      V
--        *-----------*          *-----------*
--        |           |---------->  EXPIRED  |
--        |           |  (ttl)   *-----------*
--        | SUBMITTED |
--        |           \<----------------*
--        |           |                |
--        *-----------*           (rollback)
--               |                     |
--          (in ledger)          *-----------*
--               |               |           |
--               *---------------> IN_LEDGER |
--                               |           |
--                               *-----------*
--   \`\`\`
data ListByronTransactionsResponseBody200Status =
   ListByronTransactionsResponseBody200StatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListByronTransactionsResponseBody200StatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListByronTransactionsResponseBody200StatusEnumPending -- ^ Represents the JSON value @"pending"@
  | ListByronTransactionsResponseBody200StatusEnumSubmitted -- ^ Represents the JSON value @"submitted"@
  | ListByronTransactionsResponseBody200StatusEnumIn_ledger -- ^ Represents the JSON value @"in_ledger"@
  | ListByronTransactionsResponseBody200StatusEnumExpired -- ^ Represents the JSON value @"expired"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Status
    where toJSON (ListByronTransactionsResponseBody200StatusOther val) = val
          toJSON (ListByronTransactionsResponseBody200StatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListByronTransactionsResponseBody200StatusEnumPending) = "pending"
          toJSON (ListByronTransactionsResponseBody200StatusEnumSubmitted) = "submitted"
          toJSON (ListByronTransactionsResponseBody200StatusEnumIn_ledger) = "in_ledger"
          toJSON (ListByronTransactionsResponseBody200StatusEnumExpired) = "expired"
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Status
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "pending" -> ListByronTransactionsResponseBody200StatusEnumPending
                                            | val GHC.Classes.== "submitted" -> ListByronTransactionsResponseBody200StatusEnumSubmitted
                                            | val GHC.Classes.== "in_ledger" -> ListByronTransactionsResponseBody200StatusEnumIn_ledger
                                            | val GHC.Classes.== "expired" -> ListByronTransactionsResponseBody200StatusEnumExpired
                                            | GHC.Base.otherwise -> ListByronTransactionsResponseBody200StatusOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.validity_interval@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200Validity_interval = ListByronTransactionsResponseBody200Validity_interval {
  -- | invalid_before
  listByronTransactionsResponseBody200Validity_intervalInvalid_before :: ListByronTransactionsResponseBody200Validity_intervalInvalid_before
  -- | invalid_hereafter
  , listByronTransactionsResponseBody200Validity_intervalInvalid_hereafter :: ListByronTransactionsResponseBody200Validity_intervalInvalid_hereafter
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Validity_interval
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Validity_interval
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Validity_interval" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200Validity_interval GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_before")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_hereafter"))
-- | Create a new 'ListByronTransactionsResponseBody200Validity_interval' with all required fields.
mkListByronTransactionsResponseBody200Validity_interval :: ListByronTransactionsResponseBody200Validity_intervalInvalid_before -- ^ 'listByronTransactionsResponseBody200Validity_intervalInvalid_before'
  -> ListByronTransactionsResponseBody200Validity_intervalInvalid_hereafter -- ^ 'listByronTransactionsResponseBody200Validity_intervalInvalid_hereafter'
  -> ListByronTransactionsResponseBody200Validity_interval
mkListByronTransactionsResponseBody200Validity_interval listByronTransactionsResponseBody200Validity_intervalInvalid_before listByronTransactionsResponseBody200Validity_intervalInvalid_hereafter = ListByronTransactionsResponseBody200Validity_interval{listByronTransactionsResponseBody200Validity_intervalInvalid_before = listByronTransactionsResponseBody200Validity_intervalInvalid_before,
                                                                                                                                                                                                                                                           listByronTransactionsResponseBody200Validity_intervalInvalid_hereafter = listByronTransactionsResponseBody200Validity_intervalInvalid_hereafter}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.validity_interval.properties.invalid_before@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200Validity_intervalInvalid_before = ListByronTransactionsResponseBody200Validity_intervalInvalid_before {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Validity_intervalInvalid_before
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Validity_intervalInvalid_before
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Validity_intervalInvalid_before" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200Validity_intervalInvalid_before GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200Validity_intervalInvalid_before' with all required fields.
mkListByronTransactionsResponseBody200Validity_intervalInvalid_before :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity'
  -> ListByronTransactionsResponseBody200Validity_intervalInvalid_before
mkListByronTransactionsResponseBody200Validity_intervalInvalid_before listByronTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity = ListByronTransactionsResponseBody200Validity_intervalInvalid_before{listByronTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity = listByronTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.validity_interval.properties.invalid_hereafter@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200Validity_intervalInvalid_hereafter = ListByronTransactionsResponseBody200Validity_intervalInvalid_hereafter {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Validity_intervalInvalid_hereafter
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Validity_intervalInvalid_hereafter
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Validity_intervalInvalid_hereafter" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200Validity_intervalInvalid_hereafter GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200Validity_intervalInvalid_hereafter' with all required fields.
mkListByronTransactionsResponseBody200Validity_intervalInvalid_hereafter :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity'
  -> ListByronTransactionsResponseBody200Validity_intervalInvalid_hereafter
mkListByronTransactionsResponseBody200Validity_intervalInvalid_hereafter listByronTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity = ListByronTransactionsResponseBody200Validity_intervalInvalid_hereafter{listByronTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity = listByronTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.withdrawals.items@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody200Withdrawals = ListByronTransactionsResponseBody200Withdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  listByronTransactionsResponseBody200WithdrawalsAmount :: ListByronTransactionsResponseBody200WithdrawalsAmount
  -- | stake_address
  , listByronTransactionsResponseBody200WithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200Withdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200WithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200WithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200Withdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200Withdrawals" (\obj -> (GHC.Base.pure ListByronTransactionsResponseBody200Withdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'ListByronTransactionsResponseBody200Withdrawals' with all required fields.
mkListByronTransactionsResponseBody200Withdrawals :: ListByronTransactionsResponseBody200WithdrawalsAmount -- ^ 'listByronTransactionsResponseBody200WithdrawalsAmount'
  -> Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody200WithdrawalsStake_address'
  -> ListByronTransactionsResponseBody200Withdrawals
mkListByronTransactionsResponseBody200Withdrawals listByronTransactionsResponseBody200WithdrawalsAmount listByronTransactionsResponseBody200WithdrawalsStake_address = ListByronTransactionsResponseBody200Withdrawals{listByronTransactionsResponseBody200WithdrawalsAmount = listByronTransactionsResponseBody200WithdrawalsAmount,
                                                                                                                                                                                                                       listByronTransactionsResponseBody200WithdrawalsStake_address = listByronTransactionsResponseBody200WithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListByronTransactionsResponseBody200WithdrawalsAmount = ListByronTransactionsResponseBody200WithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronTransactionsResponseBody200WithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody200WithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody200WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody200WithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody200WithdrawalsAmount" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody200WithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronTransactionsResponseBody200WithdrawalsAmount' with all required fields.
mkListByronTransactionsResponseBody200WithdrawalsAmount :: GHC.Types.Int -- ^ 'listByronTransactionsResponseBody200WithdrawalsAmountQuantity'
  -> ListByronTransactionsResponseBody200WithdrawalsAmount
mkListByronTransactionsResponseBody200WithdrawalsAmount listByronTransactionsResponseBody200WithdrawalsAmountQuantity = ListByronTransactionsResponseBody200WithdrawalsAmount{listByronTransactionsResponseBody200WithdrawalsAmountQuantity = listByronTransactionsResponseBody200WithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody400OneOf1 = ListByronTransactionsResponseBody400OneOf1 {
  -- | message: May occur when trying to withdraw less than the minimal UTxO value.
  listByronTransactionsResponseBody400OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody400OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "min_withdrawal_wrong"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "min_withdrawal_wrong"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody400OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody400OneOf1" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody400OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListByronTransactionsResponseBody400OneOf1' with all required fields.
mkListByronTransactionsResponseBody400OneOf1 :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody400OneOf1Message'
  -> ListByronTransactionsResponseBody400OneOf1
mkListByronTransactionsResponseBody400OneOf1 listByronTransactionsResponseBody400OneOf1Message = ListByronTransactionsResponseBody400OneOf1{listByronTransactionsResponseBody400OneOf1Message = listByronTransactionsResponseBody400OneOf1Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody400OneOf2 = ListByronTransactionsResponseBody400OneOf2 {
  -- | message: May occur when a provided time-range is unsound.
  listByronTransactionsResponseBody400OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody400OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody400OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "start_time_later_than_end_time"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody400OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "start_time_later_than_end_time"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody400OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody400OneOf2" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody400OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListByronTransactionsResponseBody400OneOf2' with all required fields.
mkListByronTransactionsResponseBody400OneOf2 :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody400OneOf2Message'
  -> ListByronTransactionsResponseBody400OneOf2
mkListByronTransactionsResponseBody400OneOf2 listByronTransactionsResponseBody400OneOf2Message = ListByronTransactionsResponseBody400OneOf2{listByronTransactionsResponseBody400OneOf2Message = listByronTransactionsResponseBody400OneOf2Message}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody400Variants =
   ListByronTransactionsResponseBody400Variant1 ListByronTransactionsResponseBody400OneOf1
  | ListByronTransactionsResponseBody400Variant2 ListByronTransactionsResponseBody400OneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody400Variants
    where toJSON (ListByronTransactionsResponseBody400Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListByronTransactionsResponseBody400Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody400Variants
    where parseJSON val = case (ListByronTransactionsResponseBody400Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListByronTransactionsResponseBody400Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody404 = ListByronTransactionsResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  listByronTransactionsResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody404" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListByronTransactionsResponseBody404' with all required fields.
mkListByronTransactionsResponseBody404 :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody404Message'
  -> ListByronTransactionsResponseBody404
mkListByronTransactionsResponseBody404 listByronTransactionsResponseBody404Message = ListByronTransactionsResponseBody404{listByronTransactionsResponseBody404Message = listByronTransactionsResponseBody404Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.GET.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data ListByronTransactionsResponseBody406 = ListByronTransactionsResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  listByronTransactionsResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronTransactionsResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listByronTransactionsResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronTransactionsResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronTransactionsResponseBody406" (\obj -> GHC.Base.pure ListByronTransactionsResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListByronTransactionsResponseBody406' with all required fields.
mkListByronTransactionsResponseBody406 :: Data.Text.Internal.Text -- ^ 'listByronTransactionsResponseBody406Message'
  -> ListByronTransactionsResponseBody406
mkListByronTransactionsResponseBody406 listByronTransactionsResponseBody406Message = ListByronTransactionsResponseBody406{listByronTransactionsResponseBody406Message = listByronTransactionsResponseBody406Message}
-- | > GET /byron-wallets/{walletId}/transactions
-- 
-- The same as 'listByronTransactions' but accepts an explicit configuration.
listByronTransactionsWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> ListByronTransactionsParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response ListByronTransactionsResponse) -- ^ Monadic computation which returns the result of the operation
listByronTransactionsWithConfiguration config
                                       parameters = GHC.Base.fmap (\response_5 -> GHC.Base.fmap (Data.Either.either ListByronTransactionsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ListByronTransactionsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                         ([ListByronTransactionsResponseBody200]))
                                                                                                                                                                                                    | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> ListByronTransactionsResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                         ListByronTransactionsResponseBody400Variants)
                                                                                                                                                                                                    | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> ListByronTransactionsResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                         ListByronTransactionsResponseBody404)
                                                                                                                                                                                                    | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ListByronTransactionsResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                         ListByronTransactionsResponseBody406)
                                                                                                                                                                                                    | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_5) response_5) (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listByronTransactionsParametersPathWalletId parameters))) GHC.Base.<> "/transactions")) [Wallet.Common.QueryParameter (Data.Text.pack "start") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryStart parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Wallet.Common.QueryParameter (Data.Text.pack "end") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryEnd parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Wallet.Common.QueryParameter (Data.Text.pack "order") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryOrder parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             Wallet.Common.QueryParameter (Data.Text.pack "max_count") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryMax_count parameters) (Data.Text.pack "form") GHC.Types.False])
-- | > GET /byron-wallets/{walletId}/transactions
-- 
-- The same as 'listByronTransactions' but returns the raw 'Data.ByteString.ByteString'.
listByronTransactionsRaw :: forall m . Wallet.Common.MonadHTTP m => ListByronTransactionsParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
listByronTransactionsRaw parameters = GHC.Base.id (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listByronTransactionsParametersPathWalletId parameters))) GHC.Base.<> "/transactions")) [Wallet.Common.QueryParameter (Data.Text.pack "start") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryStart parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                   Wallet.Common.QueryParameter (Data.Text.pack "end") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryEnd parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                   Wallet.Common.QueryParameter (Data.Text.pack "order") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryOrder parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                   Wallet.Common.QueryParameter (Data.Text.pack "max_count") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryMax_count parameters) (Data.Text.pack "form") GHC.Types.False])
-- | > GET /byron-wallets/{walletId}/transactions
-- 
-- The same as 'listByronTransactions' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
listByronTransactionsWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> ListByronTransactionsParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
listByronTransactionsWithConfigurationRaw config
                                          parameters = GHC.Base.id (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listByronTransactionsParametersPathWalletId parameters))) GHC.Base.<> "/transactions")) [Wallet.Common.QueryParameter (Data.Text.pack "start") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryStart parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                          Wallet.Common.QueryParameter (Data.Text.pack "end") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryEnd parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                          Wallet.Common.QueryParameter (Data.Text.pack "order") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryOrder parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                          Wallet.Common.QueryParameter (Data.Text.pack "max_count") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listByronTransactionsParametersQueryMax_count parameters) (Data.Text.pack "form") GHC.Types.False])
