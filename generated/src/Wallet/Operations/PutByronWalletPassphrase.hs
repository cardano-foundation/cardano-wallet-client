-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation putByronWalletPassphrase
module Wallet.Operations.PutByronWalletPassphrase where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > PUT /byron-wallets/{walletId}/passphrase
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
putByronWalletPassphrase :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutByronWalletPassphraseRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response PutByronWalletPassphraseResponse) -- ^ Monadic computation which returns the result of the operation
putByronWalletPassphrase walletId
                         body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PutByronWalletPassphraseResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 204) (Network.HTTP.Client.Types.responseStatus response) -> Data.Either.Right PutByronWalletPassphraseResponse204
                                                                                                                                                                                   | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletPassphraseResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                           PutByronWalletPassphraseResponseBody400)
                                                                                                                                                                                   | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletPassphraseResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                           PutByronWalletPassphraseResponseBody403Variants)
                                                                                                                                                                                   | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletPassphraseResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                           PutByronWalletPassphraseResponseBody404)
                                                                                                                                                                                   | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletPassphraseResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                           PutByronWalletPassphraseResponseBody406)
                                                                                                                                                                                   | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletPassphraseResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                           PutByronWalletPassphraseResponseBody415)
                                                                                                                                                                                   | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/passphrase")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/passphrase.PUT.requestBody.content.application\/json.schema@ in the specification.
-- 
-- 
data PutByronWalletPassphraseRequestBody = PutByronWalletPassphraseRequestBody {
  -- | new_passphrase: A master passphrase to lock and protect the wallet for sensitive operation (e.g. sending funds).
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 10
  putByronWalletPassphraseRequestBodyNew_passphrase :: Data.Text.Internal.Text
  -- | old_passphrase: The current passphrase if present.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 0
  , putByronWalletPassphraseRequestBodyOld_passphrase :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletPassphraseRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["new_passphrase" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseRequestBodyNew_passphrase obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("old_passphrase" Data.Aeson.Types.ToJSON..=)) (putByronWalletPassphraseRequestBodyOld_passphrase obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["new_passphrase" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseRequestBodyNew_passphrase obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("old_passphrase" Data.Aeson.Types.ToJSON..=)) (putByronWalletPassphraseRequestBodyOld_passphrase obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletPassphraseRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletPassphraseRequestBody" (\obj -> (GHC.Base.pure PutByronWalletPassphraseRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "new_passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "old_passphrase"))
-- | Create a new 'PutByronWalletPassphraseRequestBody' with all required fields.
mkPutByronWalletPassphraseRequestBody :: Data.Text.Internal.Text -- ^ 'putByronWalletPassphraseRequestBodyNew_passphrase'
  -> PutByronWalletPassphraseRequestBody
mkPutByronWalletPassphraseRequestBody putByronWalletPassphraseRequestBodyNew_passphrase = PutByronWalletPassphraseRequestBody{putByronWalletPassphraseRequestBodyNew_passphrase = putByronWalletPassphraseRequestBodyNew_passphrase,
                                                                                                                              putByronWalletPassphraseRequestBodyOld_passphrase = GHC.Maybe.Nothing}
-- | Represents a response of the operation 'putByronWalletPassphrase'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PutByronWalletPassphraseResponseError' is used.
data PutByronWalletPassphraseResponse =
   PutByronWalletPassphraseResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | PutByronWalletPassphraseResponse204 -- ^ No Content
  | PutByronWalletPassphraseResponse400 PutByronWalletPassphraseResponseBody400 -- ^ Bad Request
  | PutByronWalletPassphraseResponse403 PutByronWalletPassphraseResponseBody403Variants -- ^ Forbidden
  | PutByronWalletPassphraseResponse404 PutByronWalletPassphraseResponseBody404 -- ^ Not Found
  | PutByronWalletPassphraseResponse406 PutByronWalletPassphraseResponseBody406 -- ^ Not Acceptable
  | PutByronWalletPassphraseResponse415 PutByronWalletPassphraseResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/passphrase.PUT.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data PutByronWalletPassphraseResponseBody400 = PutByronWalletPassphraseResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  putByronWalletPassphraseResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletPassphraseResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletPassphraseResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletPassphraseResponseBody400" (\obj -> GHC.Base.pure PutByronWalletPassphraseResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutByronWalletPassphraseResponseBody400' with all required fields.
mkPutByronWalletPassphraseResponseBody400 :: Data.Text.Internal.Text -- ^ 'putByronWalletPassphraseResponseBody400Message'
  -> PutByronWalletPassphraseResponseBody400
mkPutByronWalletPassphraseResponseBody400 putByronWalletPassphraseResponseBody400Message = PutByronWalletPassphraseResponseBody400{putByronWalletPassphraseResponseBody400Message = putByronWalletPassphraseResponseBody400Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/passphrase.PUT.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PutByronWalletPassphraseResponseBody403OneOf1 = PutByronWalletPassphraseResponseBody403OneOf1 {
  -- | message: May occur when an action require a signing key but the wallet has only access to verification keys.
  putByronWalletPassphraseResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletPassphraseResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletPassphraseResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletPassphraseResponseBody403OneOf1" (\obj -> GHC.Base.pure PutByronWalletPassphraseResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutByronWalletPassphraseResponseBody403OneOf1' with all required fields.
mkPutByronWalletPassphraseResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'putByronWalletPassphraseResponseBody403OneOf1Message'
  -> PutByronWalletPassphraseResponseBody403OneOf1
mkPutByronWalletPassphraseResponseBody403OneOf1 putByronWalletPassphraseResponseBody403OneOf1Message = PutByronWalletPassphraseResponseBody403OneOf1{putByronWalletPassphraseResponseBody403OneOf1Message = putByronWalletPassphraseResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/passphrase.PUT.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PutByronWalletPassphraseResponseBody403OneOf2 = PutByronWalletPassphraseResponseBody403OneOf2 {
  -- | message: May occur when the given spending passphrase is wrong.
  putByronWalletPassphraseResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletPassphraseResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletPassphraseResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletPassphraseResponseBody403OneOf2" (\obj -> GHC.Base.pure PutByronWalletPassphraseResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutByronWalletPassphraseResponseBody403OneOf2' with all required fields.
mkPutByronWalletPassphraseResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'putByronWalletPassphraseResponseBody403OneOf2Message'
  -> PutByronWalletPassphraseResponseBody403OneOf2
mkPutByronWalletPassphraseResponseBody403OneOf2 putByronWalletPassphraseResponseBody403OneOf2Message = PutByronWalletPassphraseResponseBody403OneOf2{putByronWalletPassphraseResponseBody403OneOf2Message = putByronWalletPassphraseResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/passphrase.PUT.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PutByronWalletPassphraseResponseBody403OneOf3 = PutByronWalletPassphraseResponseBody403OneOf3 {
  -- | message: May occur when the given mnemonic is wrong.
  putByronWalletPassphraseResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletPassphraseResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_mnemonic"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_mnemonic"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletPassphraseResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletPassphraseResponseBody403OneOf3" (\obj -> GHC.Base.pure PutByronWalletPassphraseResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutByronWalletPassphraseResponseBody403OneOf3' with all required fields.
mkPutByronWalletPassphraseResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'putByronWalletPassphraseResponseBody403OneOf3Message'
  -> PutByronWalletPassphraseResponseBody403OneOf3
mkPutByronWalletPassphraseResponseBody403OneOf3 putByronWalletPassphraseResponseBody403OneOf3Message = PutByronWalletPassphraseResponseBody403OneOf3{putByronWalletPassphraseResponseBody403OneOf3Message = putByronWalletPassphraseResponseBody403OneOf3Message}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/passphrase.PUT.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PutByronWalletPassphraseResponseBody403Variants =
   PutByronWalletPassphraseResponseBody403Variant1 PutByronWalletPassphraseResponseBody403OneOf1
  | PutByronWalletPassphraseResponseBody403Variant2 PutByronWalletPassphraseResponseBody403OneOf2
  | PutByronWalletPassphraseResponseBody403Variant3 PutByronWalletPassphraseResponseBody403OneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletPassphraseResponseBody403Variants
    where toJSON (PutByronWalletPassphraseResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PutByronWalletPassphraseResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PutByronWalletPassphraseResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletPassphraseResponseBody403Variants
    where parseJSON val = case (PutByronWalletPassphraseResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PutByronWalletPassphraseResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PutByronWalletPassphraseResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/passphrase.PUT.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data PutByronWalletPassphraseResponseBody404 = PutByronWalletPassphraseResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  putByronWalletPassphraseResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletPassphraseResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletPassphraseResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletPassphraseResponseBody404" (\obj -> GHC.Base.pure PutByronWalletPassphraseResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutByronWalletPassphraseResponseBody404' with all required fields.
mkPutByronWalletPassphraseResponseBody404 :: Data.Text.Internal.Text -- ^ 'putByronWalletPassphraseResponseBody404Message'
  -> PutByronWalletPassphraseResponseBody404
mkPutByronWalletPassphraseResponseBody404 putByronWalletPassphraseResponseBody404Message = PutByronWalletPassphraseResponseBody404{putByronWalletPassphraseResponseBody404Message = putByronWalletPassphraseResponseBody404Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/passphrase.PUT.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data PutByronWalletPassphraseResponseBody406 = PutByronWalletPassphraseResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  putByronWalletPassphraseResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletPassphraseResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletPassphraseResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletPassphraseResponseBody406" (\obj -> GHC.Base.pure PutByronWalletPassphraseResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutByronWalletPassphraseResponseBody406' with all required fields.
mkPutByronWalletPassphraseResponseBody406 :: Data.Text.Internal.Text -- ^ 'putByronWalletPassphraseResponseBody406Message'
  -> PutByronWalletPassphraseResponseBody406
mkPutByronWalletPassphraseResponseBody406 putByronWalletPassphraseResponseBody406Message = PutByronWalletPassphraseResponseBody406{putByronWalletPassphraseResponseBody406Message = putByronWalletPassphraseResponseBody406Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/passphrase.PUT.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data PutByronWalletPassphraseResponseBody415 = PutByronWalletPassphraseResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  putByronWalletPassphraseResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletPassphraseResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletPassphraseResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletPassphraseResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletPassphraseResponseBody415" (\obj -> GHC.Base.pure PutByronWalletPassphraseResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutByronWalletPassphraseResponseBody415' with all required fields.
mkPutByronWalletPassphraseResponseBody415 :: Data.Text.Internal.Text -- ^ 'putByronWalletPassphraseResponseBody415Message'
  -> PutByronWalletPassphraseResponseBody415
mkPutByronWalletPassphraseResponseBody415 putByronWalletPassphraseResponseBody415Message = PutByronWalletPassphraseResponseBody415{putByronWalletPassphraseResponseBody415Message = putByronWalletPassphraseResponseBody415Message}
-- | > PUT /byron-wallets/{walletId}/passphrase
-- 
-- The same as 'putByronWalletPassphrase' but accepts an explicit configuration.
putByronWalletPassphraseWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutByronWalletPassphraseRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response PutByronWalletPassphraseResponse) -- ^ Monadic computation which returns the result of the operation
putByronWalletPassphraseWithConfiguration config
                                          walletId
                                          body = GHC.Base.fmap (\response_7 -> GHC.Base.fmap (Data.Either.either PutByronWalletPassphraseResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 204) (Network.HTTP.Client.Types.responseStatus response) -> Data.Either.Right PutByronWalletPassphraseResponse204
                                                                                                                                                                                                    | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletPassphraseResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                            PutByronWalletPassphraseResponseBody400)
                                                                                                                                                                                                    | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletPassphraseResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                              PutByronWalletPassphraseResponseBody403Variants)
                                                                                                                                                                                                    | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletPassphraseResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                              PutByronWalletPassphraseResponseBody404)
                                                                                                                                                                                                    | (\status_12 -> Network.HTTP.Types.Status.statusCode status_12 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletPassphraseResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                              PutByronWalletPassphraseResponseBody406)
                                                                                                                                                                                                    | (\status_13 -> Network.HTTP.Types.Status.statusCode status_13 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletPassphraseResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                              PutByronWalletPassphraseResponseBody415)
                                                                                                                                                                                                    | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_7) response_7) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/passphrase")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > PUT /byron-wallets/{walletId}/passphrase
-- 
-- The same as 'putByronWalletPassphrase' but returns the raw 'Data.ByteString.ByteString'.
putByronWalletPassphraseRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutByronWalletPassphraseRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
putByronWalletPassphraseRaw walletId
                            body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/passphrase")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > PUT /byron-wallets/{walletId}/passphrase
-- 
-- The same as 'putByronWalletPassphrase' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
putByronWalletPassphraseWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutByronWalletPassphraseRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
putByronWalletPassphraseWithConfigurationRaw config
                                             walletId
                                             body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/passphrase")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
