-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation listWallets
module Wallet.Operations.ListWallets where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > GET /wallets
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Return a list of known wallets, ordered from oldest to newest.
listWallets :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response ListWalletsResponse) -- ^ Monadic computation which returns the result of the operation
listWallets = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either ListWalletsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ListWalletsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                               ([ListWalletsResponseBody200]))
                                                                                                                                                    | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ListWalletsResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                               ListWalletsResponseBody406)
                                                                                                                                                    | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") "/wallets" GHC.Base.mempty)
-- | Represents a response of the operation 'listWallets'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'ListWalletsResponseError' is used.
data ListWalletsResponse =
   ListWalletsResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | ListWalletsResponse200 ([ListWalletsResponseBody200]) -- ^ Ok
  | ListWalletsResponse406 ListWalletsResponseBody406 -- ^ Not Acceptable
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items@ in the specification.
-- 
-- 
data ListWalletsResponseBody200 = ListWalletsResponseBody200 {
  -- | address_pool_gap: Number of consecutive unused addresses allowed.
  -- 
  -- **IMPORTANT DISCLAIMER:** Using values other than \`20\` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
  -- your wallet in a different software which is strictly following BIP-44.
  -- 
  -- Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
  -- 
  -- **IMPORTANT DISCLAIMER 2:** There is no way to \`import\` addresses generated outside (e.g. using cardano-addresses) into the wallet.
  -- Wallet only discovers transactions on its used and unused addresses that are within its currently seen \`address_pool_gap\`.
  -- Transactions on addresses that \"belong\" to the wallet but happen to be beyond its \`address_pool_gap\` will not be visible to the wallet.
  -- This is a technical limitation of the industry standard [BIP-44](https:\/\/github.com\/bitcoin\/bips\/blob\/master\/bip-0044.mediawiki). See also [CIP-1852](https:\/\/github.com\/cardano-foundation\/CIPs\/blob\/master\/CIP-1852\/CIP-1852.md).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100000.0
  -- * Minimum  of 10.0
  listWalletsResponseBody200Address_pool_gap :: GHC.Types.Int
  -- | assets: Current non-Ada asset holdings of the wallet.
  -- 
  -- The amount of assets available to spend may be less than the total
  -- unspent assets due to transaction change amounts which are yet to
  -- be fully confirmed (pending).
  , listWalletsResponseBody200Assets :: ListWalletsResponseBody200Assets
  -- | balance: Wallet current Ada balance(s).
  , listWalletsResponseBody200Balance :: ListWalletsResponseBody200Balance
  -- | delegation: Delegation settings
  , listWalletsResponseBody200Delegation :: ListWalletsResponseBody200Delegation
  -- | id: A unique identifier for the wallet
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  , listWalletsResponseBody200Id :: Data.Text.Internal.Text
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , listWalletsResponseBody200Name :: Data.Text.Internal.Text
  -- | passphrase: Information about the wallet\'s passphrase
  , listWalletsResponseBody200Passphrase :: (GHC.Maybe.Maybe ListWalletsResponseBody200Passphrase)
  -- | state: Whether a wallet is ready to use or still syncing
  , listWalletsResponseBody200State :: ListWalletsResponseBody200State
  -- | tip: A reference to a particular time slot, and the block height at that point.
  , listWalletsResponseBody200Tip :: ListWalletsResponseBody200Tip
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address_pool_gap" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200Address_pool_gap obj] : ["assets" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200Balance obj] : ["delegation" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200Delegation obj] : ["id" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200Id obj] : ["name" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (listWalletsResponseBody200Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200State obj] : ["tip" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200Tip obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address_pool_gap" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200Address_pool_gap obj] : ["assets" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200Balance obj] : ["delegation" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200Delegation obj] : ["id" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200Id obj] : ["name" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (listWalletsResponseBody200Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200State obj] : ["tip" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200Tip obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200" (\obj -> ((((((((GHC.Base.pure ListWalletsResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address_pool_gap")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "balance")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delegation")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "state")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tip"))
-- | Create a new 'ListWalletsResponseBody200' with all required fields.
mkListWalletsResponseBody200 :: GHC.Types.Int -- ^ 'listWalletsResponseBody200Address_pool_gap'
  -> ListWalletsResponseBody200Assets -- ^ 'listWalletsResponseBody200Assets'
  -> ListWalletsResponseBody200Balance -- ^ 'listWalletsResponseBody200Balance'
  -> ListWalletsResponseBody200Delegation -- ^ 'listWalletsResponseBody200Delegation'
  -> Data.Text.Internal.Text -- ^ 'listWalletsResponseBody200Id'
  -> Data.Text.Internal.Text -- ^ 'listWalletsResponseBody200Name'
  -> ListWalletsResponseBody200State -- ^ 'listWalletsResponseBody200State'
  -> ListWalletsResponseBody200Tip -- ^ 'listWalletsResponseBody200Tip'
  -> ListWalletsResponseBody200
mkListWalletsResponseBody200 listWalletsResponseBody200Address_pool_gap listWalletsResponseBody200Assets listWalletsResponseBody200Balance listWalletsResponseBody200Delegation listWalletsResponseBody200Id listWalletsResponseBody200Name listWalletsResponseBody200State listWalletsResponseBody200Tip = ListWalletsResponseBody200{listWalletsResponseBody200Address_pool_gap = listWalletsResponseBody200Address_pool_gap,
                                                                                                                                                                                                                                                                                                                                       listWalletsResponseBody200Assets = listWalletsResponseBody200Assets,
                                                                                                                                                                                                                                                                                                                                       listWalletsResponseBody200Balance = listWalletsResponseBody200Balance,
                                                                                                                                                                                                                                                                                                                                       listWalletsResponseBody200Delegation = listWalletsResponseBody200Delegation,
                                                                                                                                                                                                                                                                                                                                       listWalletsResponseBody200Id = listWalletsResponseBody200Id,
                                                                                                                                                                                                                                                                                                                                       listWalletsResponseBody200Name = listWalletsResponseBody200Name,
                                                                                                                                                                                                                                                                                                                                       listWalletsResponseBody200Passphrase = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                       listWalletsResponseBody200State = listWalletsResponseBody200State,
                                                                                                                                                                                                                                                                                                                                       listWalletsResponseBody200Tip = listWalletsResponseBody200Tip}
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.assets@ in the specification.
-- 
-- Current non-Ada asset holdings of the wallet.
-- 
-- The amount of assets available to spend may be less than the total
-- unspent assets due to transaction change amounts which are yet to
-- be fully confirmed (pending).
data ListWalletsResponseBody200Assets = ListWalletsResponseBody200Assets {
  -- | available: Available UTxO asset balances (funds that can be spent without
  -- condition).
  listWalletsResponseBody200AssetsAvailable :: ([ListWalletsResponseBody200AssetsAvailable])
  -- | total: Total asset balances (available balances plus pending change balances).
  , listWalletsResponseBody200AssetsTotal :: ([ListWalletsResponseBody200AssetsTotal])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200Assets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200Assets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200Assets" (\obj -> (GHC.Base.pure ListWalletsResponseBody200Assets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'ListWalletsResponseBody200Assets' with all required fields.
mkListWalletsResponseBody200Assets :: [ListWalletsResponseBody200AssetsAvailable] -- ^ 'listWalletsResponseBody200AssetsAvailable'
  -> [ListWalletsResponseBody200AssetsTotal] -- ^ 'listWalletsResponseBody200AssetsTotal'
  -> ListWalletsResponseBody200Assets
mkListWalletsResponseBody200Assets listWalletsResponseBody200AssetsAvailable listWalletsResponseBody200AssetsTotal = ListWalletsResponseBody200Assets{listWalletsResponseBody200AssetsAvailable = listWalletsResponseBody200AssetsAvailable,
                                                                                                                                                      listWalletsResponseBody200AssetsTotal = listWalletsResponseBody200AssetsTotal}
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.assets.properties.available.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ListWalletsResponseBody200AssetsAvailable = ListWalletsResponseBody200AssetsAvailable {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listWalletsResponseBody200AssetsAvailableAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listWalletsResponseBody200AssetsAvailablePolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listWalletsResponseBody200AssetsAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200AssetsAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsAvailableQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsAvailableQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200AssetsAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200AssetsAvailable" (\obj -> ((GHC.Base.pure ListWalletsResponseBody200AssetsAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListWalletsResponseBody200AssetsAvailable' with all required fields.
mkListWalletsResponseBody200AssetsAvailable :: Data.Text.Internal.Text -- ^ 'listWalletsResponseBody200AssetsAvailableAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listWalletsResponseBody200AssetsAvailablePolicy_id'
  -> GHC.Types.Int -- ^ 'listWalletsResponseBody200AssetsAvailableQuantity'
  -> ListWalletsResponseBody200AssetsAvailable
mkListWalletsResponseBody200AssetsAvailable listWalletsResponseBody200AssetsAvailableAsset_name listWalletsResponseBody200AssetsAvailablePolicy_id listWalletsResponseBody200AssetsAvailableQuantity = ListWalletsResponseBody200AssetsAvailable{listWalletsResponseBody200AssetsAvailableAsset_name = listWalletsResponseBody200AssetsAvailableAsset_name,
                                                                                                                                                                                                                                                 listWalletsResponseBody200AssetsAvailablePolicy_id = listWalletsResponseBody200AssetsAvailablePolicy_id,
                                                                                                                                                                                                                                                 listWalletsResponseBody200AssetsAvailableQuantity = listWalletsResponseBody200AssetsAvailableQuantity}
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.assets.properties.total.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ListWalletsResponseBody200AssetsTotal = ListWalletsResponseBody200AssetsTotal {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listWalletsResponseBody200AssetsTotalAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listWalletsResponseBody200AssetsTotalPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listWalletsResponseBody200AssetsTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200AssetsTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsTotalQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200AssetsTotalQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200AssetsTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200AssetsTotal" (\obj -> ((GHC.Base.pure ListWalletsResponseBody200AssetsTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListWalletsResponseBody200AssetsTotal' with all required fields.
mkListWalletsResponseBody200AssetsTotal :: Data.Text.Internal.Text -- ^ 'listWalletsResponseBody200AssetsTotalAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listWalletsResponseBody200AssetsTotalPolicy_id'
  -> GHC.Types.Int -- ^ 'listWalletsResponseBody200AssetsTotalQuantity'
  -> ListWalletsResponseBody200AssetsTotal
mkListWalletsResponseBody200AssetsTotal listWalletsResponseBody200AssetsTotalAsset_name listWalletsResponseBody200AssetsTotalPolicy_id listWalletsResponseBody200AssetsTotalQuantity = ListWalletsResponseBody200AssetsTotal{listWalletsResponseBody200AssetsTotalAsset_name = listWalletsResponseBody200AssetsTotalAsset_name,
                                                                                                                                                                                                                             listWalletsResponseBody200AssetsTotalPolicy_id = listWalletsResponseBody200AssetsTotalPolicy_id,
                                                                                                                                                                                                                             listWalletsResponseBody200AssetsTotalQuantity = listWalletsResponseBody200AssetsTotalQuantity}
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.balance@ in the specification.
-- 
-- Wallet current Ada balance(s).
data ListWalletsResponseBody200Balance = ListWalletsResponseBody200Balance {
  -- | available: Available Ada UTxO balance (funds that can be spent without condition).
  listWalletsResponseBody200BalanceAvailable :: ListWalletsResponseBody200BalanceAvailable
  -- | reward: The Ada balance of the reward account for this wallet.
  , listWalletsResponseBody200BalanceReward :: ListWalletsResponseBody200BalanceReward
  -- | total: Total Ada balance (available balance plus pending change and reward balance).
  , listWalletsResponseBody200BalanceTotal :: ListWalletsResponseBody200BalanceTotal
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200Balance
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200BalanceAvailable obj] : ["reward" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200BalanceReward obj] : ["total" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200BalanceTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200BalanceAvailable obj] : ["reward" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200BalanceReward obj] : ["total" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200BalanceTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200Balance
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200Balance" (\obj -> ((GHC.Base.pure ListWalletsResponseBody200Balance GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'ListWalletsResponseBody200Balance' with all required fields.
mkListWalletsResponseBody200Balance :: ListWalletsResponseBody200BalanceAvailable -- ^ 'listWalletsResponseBody200BalanceAvailable'
  -> ListWalletsResponseBody200BalanceReward -- ^ 'listWalletsResponseBody200BalanceReward'
  -> ListWalletsResponseBody200BalanceTotal -- ^ 'listWalletsResponseBody200BalanceTotal'
  -> ListWalletsResponseBody200Balance
mkListWalletsResponseBody200Balance listWalletsResponseBody200BalanceAvailable listWalletsResponseBody200BalanceReward listWalletsResponseBody200BalanceTotal = ListWalletsResponseBody200Balance{listWalletsResponseBody200BalanceAvailable = listWalletsResponseBody200BalanceAvailable,
                                                                                                                                                                                                  listWalletsResponseBody200BalanceReward = listWalletsResponseBody200BalanceReward,
                                                                                                                                                                                                  listWalletsResponseBody200BalanceTotal = listWalletsResponseBody200BalanceTotal}
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.balance.properties.available@ in the specification.
-- 
-- Available Ada UTxO balance (funds that can be spent without condition).
data ListWalletsResponseBody200BalanceAvailable = ListWalletsResponseBody200BalanceAvailable {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listWalletsResponseBody200BalanceAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200BalanceAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200BalanceAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200BalanceAvailable" (\obj -> GHC.Base.pure ListWalletsResponseBody200BalanceAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListWalletsResponseBody200BalanceAvailable' with all required fields.
mkListWalletsResponseBody200BalanceAvailable :: GHC.Types.Int -- ^ 'listWalletsResponseBody200BalanceAvailableQuantity'
  -> ListWalletsResponseBody200BalanceAvailable
mkListWalletsResponseBody200BalanceAvailable listWalletsResponseBody200BalanceAvailableQuantity = ListWalletsResponseBody200BalanceAvailable{listWalletsResponseBody200BalanceAvailableQuantity = listWalletsResponseBody200BalanceAvailableQuantity}
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.balance.properties.reward@ in the specification.
-- 
-- The Ada balance of the reward account for this wallet.
data ListWalletsResponseBody200BalanceReward = ListWalletsResponseBody200BalanceReward {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listWalletsResponseBody200BalanceRewardQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200BalanceReward
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200BalanceRewardQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200BalanceRewardQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200BalanceReward
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200BalanceReward" (\obj -> GHC.Base.pure ListWalletsResponseBody200BalanceReward GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListWalletsResponseBody200BalanceReward' with all required fields.
mkListWalletsResponseBody200BalanceReward :: GHC.Types.Int -- ^ 'listWalletsResponseBody200BalanceRewardQuantity'
  -> ListWalletsResponseBody200BalanceReward
mkListWalletsResponseBody200BalanceReward listWalletsResponseBody200BalanceRewardQuantity = ListWalletsResponseBody200BalanceReward{listWalletsResponseBody200BalanceRewardQuantity = listWalletsResponseBody200BalanceRewardQuantity}
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.balance.properties.total@ in the specification.
-- 
-- Total Ada balance (available balance plus pending change and reward balance).
data ListWalletsResponseBody200BalanceTotal = ListWalletsResponseBody200BalanceTotal {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listWalletsResponseBody200BalanceTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200BalanceTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200BalanceTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200BalanceTotal" (\obj -> GHC.Base.pure ListWalletsResponseBody200BalanceTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListWalletsResponseBody200BalanceTotal' with all required fields.
mkListWalletsResponseBody200BalanceTotal :: GHC.Types.Int -- ^ 'listWalletsResponseBody200BalanceTotalQuantity'
  -> ListWalletsResponseBody200BalanceTotal
mkListWalletsResponseBody200BalanceTotal listWalletsResponseBody200BalanceTotalQuantity = ListWalletsResponseBody200BalanceTotal{listWalletsResponseBody200BalanceTotalQuantity = listWalletsResponseBody200BalanceTotalQuantity}
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.delegation@ in the specification.
-- 
-- Delegation settings
data ListWalletsResponseBody200Delegation = ListWalletsResponseBody200Delegation {
  -- | active: Currently active delegation status.
  listWalletsResponseBody200DelegationActive :: ListWalletsResponseBody200DelegationActive
  -- | next
  , listWalletsResponseBody200DelegationNext :: ([ListWalletsResponseBody200DelegationNext])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200Delegation
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200DelegationActive obj] : ["next" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200DelegationNext obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200DelegationActive obj] : ["next" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200DelegationNext obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200Delegation
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200Delegation" (\obj -> (GHC.Base.pure ListWalletsResponseBody200Delegation GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "next"))
-- | Create a new 'ListWalletsResponseBody200Delegation' with all required fields.
mkListWalletsResponseBody200Delegation :: ListWalletsResponseBody200DelegationActive -- ^ 'listWalletsResponseBody200DelegationActive'
  -> [ListWalletsResponseBody200DelegationNext] -- ^ 'listWalletsResponseBody200DelegationNext'
  -> ListWalletsResponseBody200Delegation
mkListWalletsResponseBody200Delegation listWalletsResponseBody200DelegationActive listWalletsResponseBody200DelegationNext = ListWalletsResponseBody200Delegation{listWalletsResponseBody200DelegationActive = listWalletsResponseBody200DelegationActive,
                                                                                                                                                                  listWalletsResponseBody200DelegationNext = listWalletsResponseBody200DelegationNext}
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.delegation.properties.active@ in the specification.
-- 
-- Currently active delegation status.
data ListWalletsResponseBody200DelegationActive = ListWalletsResponseBody200DelegationActive {
  -- | status
  listWalletsResponseBody200DelegationActiveStatus :: ListWalletsResponseBody200DelegationActiveStatus
  -- | target: A unique Stake-Pool identifier (present only if status = \`delegating\`)
  , listWalletsResponseBody200DelegationActiveTarget :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200DelegationActive
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["status" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200DelegationActiveStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (listWalletsResponseBody200DelegationActiveTarget obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["status" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200DelegationActiveStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (listWalletsResponseBody200DelegationActiveTarget obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200DelegationActive
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200DelegationActive" (\obj -> (GHC.Base.pure ListWalletsResponseBody200DelegationActive GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "target"))
-- | Create a new 'ListWalletsResponseBody200DelegationActive' with all required fields.
mkListWalletsResponseBody200DelegationActive :: ListWalletsResponseBody200DelegationActiveStatus -- ^ 'listWalletsResponseBody200DelegationActiveStatus'
  -> ListWalletsResponseBody200DelegationActive
mkListWalletsResponseBody200DelegationActive listWalletsResponseBody200DelegationActiveStatus = ListWalletsResponseBody200DelegationActive{listWalletsResponseBody200DelegationActiveStatus = listWalletsResponseBody200DelegationActiveStatus,
                                                                                                                                           listWalletsResponseBody200DelegationActiveTarget = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.delegation.properties.active.properties.status@ in the specification.
-- 
-- 
data ListWalletsResponseBody200DelegationActiveStatus =
   ListWalletsResponseBody200DelegationActiveStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListWalletsResponseBody200DelegationActiveStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListWalletsResponseBody200DelegationActiveStatusEnumNot_delegating -- ^ Represents the JSON value @"not_delegating"@
  | ListWalletsResponseBody200DelegationActiveStatusEnumDelegating -- ^ Represents the JSON value @"delegating"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200DelegationActiveStatus
    where toJSON (ListWalletsResponseBody200DelegationActiveStatusOther val) = val
          toJSON (ListWalletsResponseBody200DelegationActiveStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListWalletsResponseBody200DelegationActiveStatusEnumNot_delegating) = "not_delegating"
          toJSON (ListWalletsResponseBody200DelegationActiveStatusEnumDelegating) = "delegating"
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200DelegationActiveStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "not_delegating" -> ListWalletsResponseBody200DelegationActiveStatusEnumNot_delegating
                                            | val GHC.Classes.== "delegating" -> ListWalletsResponseBody200DelegationActiveStatusEnumDelegating
                                            | GHC.Base.otherwise -> ListWalletsResponseBody200DelegationActiveStatusOther val)
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.delegation.properties.next.items@ in the specification.
-- 
-- Next delegation status becomes active at the start of the second epoch after the corresponding delegation certificate was discovered. The exact moment is specified by changes_at
data ListWalletsResponseBody200DelegationNext = ListWalletsResponseBody200DelegationNext {
  -- | changes_at
  listWalletsResponseBody200DelegationNextChanges_at :: ListWalletsResponseBody200DelegationNextChanges_at
  -- | status
  , listWalletsResponseBody200DelegationNextStatus :: ListWalletsResponseBody200DelegationNextStatus
  -- | target: A unique Stake-Pool identifier (present only if status = \`delegating\`)
  , listWalletsResponseBody200DelegationNextTarget :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200DelegationNext
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["changes_at" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200DelegationNextChanges_at obj] : ["status" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200DelegationNextStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (listWalletsResponseBody200DelegationNextTarget obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["changes_at" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200DelegationNextChanges_at obj] : ["status" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200DelegationNextStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (listWalletsResponseBody200DelegationNextTarget obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200DelegationNext
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200DelegationNext" (\obj -> ((GHC.Base.pure ListWalletsResponseBody200DelegationNext GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "changes_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "target"))
-- | Create a new 'ListWalletsResponseBody200DelegationNext' with all required fields.
mkListWalletsResponseBody200DelegationNext :: ListWalletsResponseBody200DelegationNextChanges_at -- ^ 'listWalletsResponseBody200DelegationNextChanges_at'
  -> ListWalletsResponseBody200DelegationNextStatus -- ^ 'listWalletsResponseBody200DelegationNextStatus'
  -> ListWalletsResponseBody200DelegationNext
mkListWalletsResponseBody200DelegationNext listWalletsResponseBody200DelegationNextChanges_at listWalletsResponseBody200DelegationNextStatus = ListWalletsResponseBody200DelegationNext{listWalletsResponseBody200DelegationNextChanges_at = listWalletsResponseBody200DelegationNextChanges_at,
                                                                                                                                                                                        listWalletsResponseBody200DelegationNextStatus = listWalletsResponseBody200DelegationNextStatus,
                                                                                                                                                                                        listWalletsResponseBody200DelegationNextTarget = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.delegation.properties.next.items.properties.changes_at@ in the specification.
-- 
-- 
data ListWalletsResponseBody200DelegationNextChanges_at = ListWalletsResponseBody200DelegationNextChanges_at {
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listWalletsResponseBody200DelegationNextChanges_atEpoch_number :: GHC.Types.Int
  -- | epoch_start_time
  , listWalletsResponseBody200DelegationNextChanges_atEpoch_start_time :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200DelegationNextChanges_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["epoch_number" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200DelegationNextChanges_atEpoch_number obj] : ["epoch_start_time" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200DelegationNextChanges_atEpoch_start_time obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["epoch_number" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200DelegationNextChanges_atEpoch_number obj] : ["epoch_start_time" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200DelegationNextChanges_atEpoch_start_time obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200DelegationNextChanges_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200DelegationNextChanges_at" (\obj -> (GHC.Base.pure ListWalletsResponseBody200DelegationNextChanges_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_start_time"))
-- | Create a new 'ListWalletsResponseBody200DelegationNextChanges_at' with all required fields.
mkListWalletsResponseBody200DelegationNextChanges_at :: GHC.Types.Int -- ^ 'listWalletsResponseBody200DelegationNextChanges_atEpoch_number'
  -> Data.Text.Internal.Text -- ^ 'listWalletsResponseBody200DelegationNextChanges_atEpoch_start_time'
  -> ListWalletsResponseBody200DelegationNextChanges_at
mkListWalletsResponseBody200DelegationNextChanges_at listWalletsResponseBody200DelegationNextChanges_atEpoch_number listWalletsResponseBody200DelegationNextChanges_atEpoch_start_time = ListWalletsResponseBody200DelegationNextChanges_at{listWalletsResponseBody200DelegationNextChanges_atEpoch_number = listWalletsResponseBody200DelegationNextChanges_atEpoch_number,
                                                                                                                                                                                                                                            listWalletsResponseBody200DelegationNextChanges_atEpoch_start_time = listWalletsResponseBody200DelegationNextChanges_atEpoch_start_time}
-- | Defines the enum schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.delegation.properties.next.items.properties.status@ in the specification.
-- 
-- 
data ListWalletsResponseBody200DelegationNextStatus =
   ListWalletsResponseBody200DelegationNextStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListWalletsResponseBody200DelegationNextStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListWalletsResponseBody200DelegationNextStatusEnumNot_delegating -- ^ Represents the JSON value @"not_delegating"@
  | ListWalletsResponseBody200DelegationNextStatusEnumDelegating -- ^ Represents the JSON value @"delegating"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200DelegationNextStatus
    where toJSON (ListWalletsResponseBody200DelegationNextStatusOther val) = val
          toJSON (ListWalletsResponseBody200DelegationNextStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListWalletsResponseBody200DelegationNextStatusEnumNot_delegating) = "not_delegating"
          toJSON (ListWalletsResponseBody200DelegationNextStatusEnumDelegating) = "delegating"
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200DelegationNextStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "not_delegating" -> ListWalletsResponseBody200DelegationNextStatusEnumNot_delegating
                                            | val GHC.Classes.== "delegating" -> ListWalletsResponseBody200DelegationNextStatusEnumDelegating
                                            | GHC.Base.otherwise -> ListWalletsResponseBody200DelegationNextStatusOther val)
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.passphrase@ in the specification.
-- 
-- Information about the wallet\'s passphrase
data ListWalletsResponseBody200Passphrase = ListWalletsResponseBody200Passphrase {
  -- | last_updated_at
  listWalletsResponseBody200PassphraseLast_updated_at :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200Passphrase
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200PassphraseLast_updated_at obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200PassphraseLast_updated_at obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200Passphrase
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200Passphrase" (\obj -> GHC.Base.pure ListWalletsResponseBody200Passphrase GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "last_updated_at"))
-- | Create a new 'ListWalletsResponseBody200Passphrase' with all required fields.
mkListWalletsResponseBody200Passphrase :: Data.Text.Internal.Text -- ^ 'listWalletsResponseBody200PassphraseLast_updated_at'
  -> ListWalletsResponseBody200Passphrase
mkListWalletsResponseBody200Passphrase listWalletsResponseBody200PassphraseLast_updated_at = ListWalletsResponseBody200Passphrase{listWalletsResponseBody200PassphraseLast_updated_at = listWalletsResponseBody200PassphraseLast_updated_at}
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.state@ in the specification.
-- 
-- Whether a wallet is ready to use or still syncing
data ListWalletsResponseBody200State = ListWalletsResponseBody200State {
  -- | progress: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == syncing
  -- \<\/span>\<br\/>
  listWalletsResponseBody200StateProgress :: (GHC.Maybe.Maybe ListWalletsResponseBody200StateProgress)
  -- | status
  , listWalletsResponseBody200StateStatus :: ListWalletsResponseBody200StateStatus
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200State
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (listWalletsResponseBody200StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200StateStatus obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (listWalletsResponseBody200StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200StateStatus obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200State
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200State" (\obj -> (GHC.Base.pure ListWalletsResponseBody200State GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "progress")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status"))
-- | Create a new 'ListWalletsResponseBody200State' with all required fields.
mkListWalletsResponseBody200State :: ListWalletsResponseBody200StateStatus -- ^ 'listWalletsResponseBody200StateStatus'
  -> ListWalletsResponseBody200State
mkListWalletsResponseBody200State listWalletsResponseBody200StateStatus = ListWalletsResponseBody200State{listWalletsResponseBody200StateProgress = GHC.Maybe.Nothing,
                                                                                                          listWalletsResponseBody200StateStatus = listWalletsResponseBody200StateStatus}
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.state.properties.progress@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == syncing
-- \<\/span>\<br\/>
data ListWalletsResponseBody200StateProgress = ListWalletsResponseBody200StateProgress {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  listWalletsResponseBody200StateProgressQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200StateProgress
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200StateProgress
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200StateProgress" (\obj -> GHC.Base.pure ListWalletsResponseBody200StateProgress GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListWalletsResponseBody200StateProgress' with all required fields.
mkListWalletsResponseBody200StateProgress :: GHC.Types.Double -- ^ 'listWalletsResponseBody200StateProgressQuantity'
  -> ListWalletsResponseBody200StateProgress
mkListWalletsResponseBody200StateProgress listWalletsResponseBody200StateProgressQuantity = ListWalletsResponseBody200StateProgress{listWalletsResponseBody200StateProgressQuantity = listWalletsResponseBody200StateProgressQuantity}
-- | Defines the enum schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.state.properties.status@ in the specification.
-- 
-- 
data ListWalletsResponseBody200StateStatus =
   ListWalletsResponseBody200StateStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListWalletsResponseBody200StateStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListWalletsResponseBody200StateStatusEnumReady -- ^ Represents the JSON value @"ready"@
  | ListWalletsResponseBody200StateStatusEnumSyncing -- ^ Represents the JSON value @"syncing"@
  | ListWalletsResponseBody200StateStatusEnumNot_responding -- ^ Represents the JSON value @"not_responding"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200StateStatus
    where toJSON (ListWalletsResponseBody200StateStatusOther val) = val
          toJSON (ListWalletsResponseBody200StateStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListWalletsResponseBody200StateStatusEnumReady) = "ready"
          toJSON (ListWalletsResponseBody200StateStatusEnumSyncing) = "syncing"
          toJSON (ListWalletsResponseBody200StateStatusEnumNot_responding) = "not_responding"
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200StateStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "ready" -> ListWalletsResponseBody200StateStatusEnumReady
                                            | val GHC.Classes.== "syncing" -> ListWalletsResponseBody200StateStatusEnumSyncing
                                            | val GHC.Classes.== "not_responding" -> ListWalletsResponseBody200StateStatusEnumNot_responding
                                            | GHC.Base.otherwise -> ListWalletsResponseBody200StateStatusOther val)
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.tip@ in the specification.
-- 
-- A reference to a particular time slot, and the block height at that point.
data ListWalletsResponseBody200Tip = ListWalletsResponseBody200Tip {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listWalletsResponseBody200TipAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listWalletsResponseBody200TipEpoch_number :: GHC.Types.Int
  -- | height
  , listWalletsResponseBody200TipHeight :: ListWalletsResponseBody200TipHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listWalletsResponseBody200TipSlot_number :: GHC.Types.Int
  -- | time
  , listWalletsResponseBody200TipTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200Tip
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200TipTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200TipTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200Tip
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200Tip" (\obj -> ((((GHC.Base.pure ListWalletsResponseBody200Tip GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'ListWalletsResponseBody200Tip' with all required fields.
mkListWalletsResponseBody200Tip :: GHC.Types.Int -- ^ 'listWalletsResponseBody200TipAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'listWalletsResponseBody200TipEpoch_number'
  -> ListWalletsResponseBody200TipHeight -- ^ 'listWalletsResponseBody200TipHeight'
  -> GHC.Types.Int -- ^ 'listWalletsResponseBody200TipSlot_number'
  -> Data.Text.Internal.Text -- ^ 'listWalletsResponseBody200TipTime'
  -> ListWalletsResponseBody200Tip
mkListWalletsResponseBody200Tip listWalletsResponseBody200TipAbsolute_slot_number listWalletsResponseBody200TipEpoch_number listWalletsResponseBody200TipHeight listWalletsResponseBody200TipSlot_number listWalletsResponseBody200TipTime = ListWalletsResponseBody200Tip{listWalletsResponseBody200TipAbsolute_slot_number = listWalletsResponseBody200TipAbsolute_slot_number,
                                                                                                                                                                                                                                                                           listWalletsResponseBody200TipEpoch_number = listWalletsResponseBody200TipEpoch_number,
                                                                                                                                                                                                                                                                           listWalletsResponseBody200TipHeight = listWalletsResponseBody200TipHeight,
                                                                                                                                                                                                                                                                           listWalletsResponseBody200TipSlot_number = listWalletsResponseBody200TipSlot_number,
                                                                                                                                                                                                                                                                           listWalletsResponseBody200TipTime = listWalletsResponseBody200TipTime}
-- | Defines the object schema located at @paths.\/wallets.GET.responses.200.content.application\/json.schema.items.properties.tip.properties.height@ in the specification.
-- 
-- 
data ListWalletsResponseBody200TipHeight = ListWalletsResponseBody200TipHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listWalletsResponseBody200TipHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody200TipHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listWalletsResponseBody200TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody200TipHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody200TipHeight" (\obj -> GHC.Base.pure ListWalletsResponseBody200TipHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListWalletsResponseBody200TipHeight' with all required fields.
mkListWalletsResponseBody200TipHeight :: GHC.Types.Int -- ^ 'listWalletsResponseBody200TipHeightQuantity'
  -> ListWalletsResponseBody200TipHeight
mkListWalletsResponseBody200TipHeight listWalletsResponseBody200TipHeightQuantity = ListWalletsResponseBody200TipHeight{listWalletsResponseBody200TipHeightQuantity = listWalletsResponseBody200TipHeightQuantity}
-- | Defines the object schema located at @paths.\/wallets.GET.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data ListWalletsResponseBody406 = ListWalletsResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  listWalletsResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListWalletsResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listWalletsResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listWalletsResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListWalletsResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListWalletsResponseBody406" (\obj -> GHC.Base.pure ListWalletsResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListWalletsResponseBody406' with all required fields.
mkListWalletsResponseBody406 :: Data.Text.Internal.Text -- ^ 'listWalletsResponseBody406Message'
  -> ListWalletsResponseBody406
mkListWalletsResponseBody406 listWalletsResponseBody406Message = ListWalletsResponseBody406{listWalletsResponseBody406Message = listWalletsResponseBody406Message}
-- | > GET /wallets
-- 
-- The same as 'listWallets' but accepts an explicit configuration.
listWalletsWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> m (Network.HTTP.Client.Types.Response ListWalletsResponse) -- ^ Monadic computation which returns the result of the operation
listWalletsWithConfiguration config = GHC.Base.fmap (\response_3 -> GHC.Base.fmap (Data.Either.either ListWalletsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ListWalletsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                       ([ListWalletsResponseBody200]))
                                                                                                                                                                            | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ListWalletsResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                       ListWalletsResponseBody406)
                                                                                                                                                                            | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_3) response_3) (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") "/wallets" GHC.Base.mempty)
-- | > GET /wallets
-- 
-- The same as 'listWallets' but returns the raw 'Data.ByteString.ByteString'.
listWalletsRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
listWalletsRaw = GHC.Base.id (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") "/wallets" GHC.Base.mempty)
-- | > GET /wallets
-- 
-- The same as 'listWallets' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
listWalletsWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
listWalletsWithConfigurationRaw config = GHC.Base.id (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") "/wallets" GHC.Base.mempty)
