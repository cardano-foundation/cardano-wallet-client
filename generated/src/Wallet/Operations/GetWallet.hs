-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation getWallet
module Wallet.Operations.GetWallet where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > GET /wallets/{walletId}
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
getWallet :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response GetWalletResponse) -- ^ Monadic computation which returns the result of the operation
getWallet walletId = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either GetWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetWalletResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                  GetWalletResponseBody200)
                                                                                                                                                         | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> GetWalletResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                  GetWalletResponseBody400)
                                                                                                                                                         | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> GetWalletResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                  GetWalletResponseBody404)
                                                                                                                                                         | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> GetWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                  GetWalletResponseBody406)
                                                                                                                                                         | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty)
-- | Represents a response of the operation 'getWallet'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'GetWalletResponseError' is used.
data GetWalletResponse =
   GetWalletResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | GetWalletResponse200 GetWalletResponseBody200 -- ^ Ok
  | GetWalletResponse400 GetWalletResponseBody400 -- ^ Bad Request
  | GetWalletResponse404 GetWalletResponseBody404 -- ^ Not Found
  | GetWalletResponse406 GetWalletResponseBody406 -- ^ Not Acceptable
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema@ in the specification.
-- 
-- 
data GetWalletResponseBody200 = GetWalletResponseBody200 {
  -- | address_pool_gap: Number of consecutive unused addresses allowed.
  -- 
  -- **IMPORTANT DISCLAIMER:** Using values other than \`20\` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
  -- your wallet in a different software which is strictly following BIP-44.
  -- 
  -- Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
  -- 
  -- **IMPORTANT DISCLAIMER 2:** There is no way to \`import\` addresses generated outside (e.g. using cardano-addresses) into the wallet.
  -- Wallet only discovers transactions on its used and unused addresses that are within its currently seen \`address_pool_gap\`.
  -- Transactions on addresses that \"belong\" to the wallet but happen to be beyond its \`address_pool_gap\` will not be visible to the wallet.
  -- This is a technical limitation of the industry standard [BIP-44](https:\/\/github.com\/bitcoin\/bips\/blob\/master\/bip-0044.mediawiki). See also [CIP-1852](https:\/\/github.com\/cardano-foundation\/CIPs\/blob\/master\/CIP-1852\/CIP-1852.md).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100000.0
  -- * Minimum  of 10.0
  getWalletResponseBody200Address_pool_gap :: GHC.Types.Int
  -- | assets: Current non-Ada asset holdings of the wallet.
  -- 
  -- The amount of assets available to spend may be less than the total
  -- unspent assets due to transaction change amounts which are yet to
  -- be fully confirmed (pending).
  , getWalletResponseBody200Assets :: GetWalletResponseBody200Assets
  -- | balance: Wallet current Ada balance(s).
  , getWalletResponseBody200Balance :: GetWalletResponseBody200Balance
  -- | delegation: Delegation settings
  , getWalletResponseBody200Delegation :: GetWalletResponseBody200Delegation
  -- | id: A unique identifier for the wallet
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  , getWalletResponseBody200Id :: Data.Text.Internal.Text
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , getWalletResponseBody200Name :: Data.Text.Internal.Text
  -- | passphrase: Information about the wallet\'s passphrase
  , getWalletResponseBody200Passphrase :: (GHC.Maybe.Maybe GetWalletResponseBody200Passphrase)
  -- | state: Whether a wallet is ready to use or still syncing
  , getWalletResponseBody200State :: GetWalletResponseBody200State
  -- | tip: A reference to a particular time slot, and the block height at that point.
  , getWalletResponseBody200Tip :: GetWalletResponseBody200Tip
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address_pool_gap" Data.Aeson.Types.ToJSON..= getWalletResponseBody200Address_pool_gap obj] : ["assets" Data.Aeson.Types.ToJSON..= getWalletResponseBody200Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= getWalletResponseBody200Balance obj] : ["delegation" Data.Aeson.Types.ToJSON..= getWalletResponseBody200Delegation obj] : ["id" Data.Aeson.Types.ToJSON..= getWalletResponseBody200Id obj] : ["name" Data.Aeson.Types.ToJSON..= getWalletResponseBody200Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (getWalletResponseBody200Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= getWalletResponseBody200State obj] : ["tip" Data.Aeson.Types.ToJSON..= getWalletResponseBody200Tip obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address_pool_gap" Data.Aeson.Types.ToJSON..= getWalletResponseBody200Address_pool_gap obj] : ["assets" Data.Aeson.Types.ToJSON..= getWalletResponseBody200Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= getWalletResponseBody200Balance obj] : ["delegation" Data.Aeson.Types.ToJSON..= getWalletResponseBody200Delegation obj] : ["id" Data.Aeson.Types.ToJSON..= getWalletResponseBody200Id obj] : ["name" Data.Aeson.Types.ToJSON..= getWalletResponseBody200Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (getWalletResponseBody200Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= getWalletResponseBody200State obj] : ["tip" Data.Aeson.Types.ToJSON..= getWalletResponseBody200Tip obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200" (\obj -> ((((((((GHC.Base.pure GetWalletResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address_pool_gap")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "balance")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delegation")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "state")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tip"))
-- | Create a new 'GetWalletResponseBody200' with all required fields.
mkGetWalletResponseBody200 :: GHC.Types.Int -- ^ 'getWalletResponseBody200Address_pool_gap'
  -> GetWalletResponseBody200Assets -- ^ 'getWalletResponseBody200Assets'
  -> GetWalletResponseBody200Balance -- ^ 'getWalletResponseBody200Balance'
  -> GetWalletResponseBody200Delegation -- ^ 'getWalletResponseBody200Delegation'
  -> Data.Text.Internal.Text -- ^ 'getWalletResponseBody200Id'
  -> Data.Text.Internal.Text -- ^ 'getWalletResponseBody200Name'
  -> GetWalletResponseBody200State -- ^ 'getWalletResponseBody200State'
  -> GetWalletResponseBody200Tip -- ^ 'getWalletResponseBody200Tip'
  -> GetWalletResponseBody200
mkGetWalletResponseBody200 getWalletResponseBody200Address_pool_gap getWalletResponseBody200Assets getWalletResponseBody200Balance getWalletResponseBody200Delegation getWalletResponseBody200Id getWalletResponseBody200Name getWalletResponseBody200State getWalletResponseBody200Tip = GetWalletResponseBody200{getWalletResponseBody200Address_pool_gap = getWalletResponseBody200Address_pool_gap,
                                                                                                                                                                                                                                                                                                                   getWalletResponseBody200Assets = getWalletResponseBody200Assets,
                                                                                                                                                                                                                                                                                                                   getWalletResponseBody200Balance = getWalletResponseBody200Balance,
                                                                                                                                                                                                                                                                                                                   getWalletResponseBody200Delegation = getWalletResponseBody200Delegation,
                                                                                                                                                                                                                                                                                                                   getWalletResponseBody200Id = getWalletResponseBody200Id,
                                                                                                                                                                                                                                                                                                                   getWalletResponseBody200Name = getWalletResponseBody200Name,
                                                                                                                                                                                                                                                                                                                   getWalletResponseBody200Passphrase = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                   getWalletResponseBody200State = getWalletResponseBody200State,
                                                                                                                                                                                                                                                                                                                   getWalletResponseBody200Tip = getWalletResponseBody200Tip}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.assets@ in the specification.
-- 
-- Current non-Ada asset holdings of the wallet.
-- 
-- The amount of assets available to spend may be less than the total
-- unspent assets due to transaction change amounts which are yet to
-- be fully confirmed (pending).
data GetWalletResponseBody200Assets = GetWalletResponseBody200Assets {
  -- | available: Available UTxO asset balances (funds that can be spent without
  -- condition).
  getWalletResponseBody200AssetsAvailable :: ([GetWalletResponseBody200AssetsAvailable])
  -- | total: Total asset balances (available balances plus pending change balances).
  , getWalletResponseBody200AssetsTotal :: ([GetWalletResponseBody200AssetsTotal])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200Assets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200Assets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200Assets" (\obj -> (GHC.Base.pure GetWalletResponseBody200Assets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'GetWalletResponseBody200Assets' with all required fields.
mkGetWalletResponseBody200Assets :: [GetWalletResponseBody200AssetsAvailable] -- ^ 'getWalletResponseBody200AssetsAvailable'
  -> [GetWalletResponseBody200AssetsTotal] -- ^ 'getWalletResponseBody200AssetsTotal'
  -> GetWalletResponseBody200Assets
mkGetWalletResponseBody200Assets getWalletResponseBody200AssetsAvailable getWalletResponseBody200AssetsTotal = GetWalletResponseBody200Assets{getWalletResponseBody200AssetsAvailable = getWalletResponseBody200AssetsAvailable,
                                                                                                                                              getWalletResponseBody200AssetsTotal = getWalletResponseBody200AssetsTotal}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.assets.properties.available.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data GetWalletResponseBody200AssetsAvailable = GetWalletResponseBody200AssetsAvailable {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getWalletResponseBody200AssetsAvailableAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getWalletResponseBody200AssetsAvailablePolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getWalletResponseBody200AssetsAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200AssetsAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsAvailableQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsAvailableQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200AssetsAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200AssetsAvailable" (\obj -> ((GHC.Base.pure GetWalletResponseBody200AssetsAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetWalletResponseBody200AssetsAvailable' with all required fields.
mkGetWalletResponseBody200AssetsAvailable :: Data.Text.Internal.Text -- ^ 'getWalletResponseBody200AssetsAvailableAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getWalletResponseBody200AssetsAvailablePolicy_id'
  -> GHC.Types.Int -- ^ 'getWalletResponseBody200AssetsAvailableQuantity'
  -> GetWalletResponseBody200AssetsAvailable
mkGetWalletResponseBody200AssetsAvailable getWalletResponseBody200AssetsAvailableAsset_name getWalletResponseBody200AssetsAvailablePolicy_id getWalletResponseBody200AssetsAvailableQuantity = GetWalletResponseBody200AssetsAvailable{getWalletResponseBody200AssetsAvailableAsset_name = getWalletResponseBody200AssetsAvailableAsset_name,
                                                                                                                                                                                                                                       getWalletResponseBody200AssetsAvailablePolicy_id = getWalletResponseBody200AssetsAvailablePolicy_id,
                                                                                                                                                                                                                                       getWalletResponseBody200AssetsAvailableQuantity = getWalletResponseBody200AssetsAvailableQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.assets.properties.total.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data GetWalletResponseBody200AssetsTotal = GetWalletResponseBody200AssetsTotal {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getWalletResponseBody200AssetsTotalAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getWalletResponseBody200AssetsTotalPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getWalletResponseBody200AssetsTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200AssetsTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsTotalQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getWalletResponseBody200AssetsTotalQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200AssetsTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200AssetsTotal" (\obj -> ((GHC.Base.pure GetWalletResponseBody200AssetsTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetWalletResponseBody200AssetsTotal' with all required fields.
mkGetWalletResponseBody200AssetsTotal :: Data.Text.Internal.Text -- ^ 'getWalletResponseBody200AssetsTotalAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getWalletResponseBody200AssetsTotalPolicy_id'
  -> GHC.Types.Int -- ^ 'getWalletResponseBody200AssetsTotalQuantity'
  -> GetWalletResponseBody200AssetsTotal
mkGetWalletResponseBody200AssetsTotal getWalletResponseBody200AssetsTotalAsset_name getWalletResponseBody200AssetsTotalPolicy_id getWalletResponseBody200AssetsTotalQuantity = GetWalletResponseBody200AssetsTotal{getWalletResponseBody200AssetsTotalAsset_name = getWalletResponseBody200AssetsTotalAsset_name,
                                                                                                                                                                                                                   getWalletResponseBody200AssetsTotalPolicy_id = getWalletResponseBody200AssetsTotalPolicy_id,
                                                                                                                                                                                                                   getWalletResponseBody200AssetsTotalQuantity = getWalletResponseBody200AssetsTotalQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.balance@ in the specification.
-- 
-- Wallet current Ada balance(s).
data GetWalletResponseBody200Balance = GetWalletResponseBody200Balance {
  -- | available: Available Ada UTxO balance (funds that can be spent without condition).
  getWalletResponseBody200BalanceAvailable :: GetWalletResponseBody200BalanceAvailable
  -- | reward: The Ada balance of the reward account for this wallet.
  , getWalletResponseBody200BalanceReward :: GetWalletResponseBody200BalanceReward
  -- | total: Total Ada balance (available balance plus pending change and reward balance).
  , getWalletResponseBody200BalanceTotal :: GetWalletResponseBody200BalanceTotal
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200Balance
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= getWalletResponseBody200BalanceAvailable obj] : ["reward" Data.Aeson.Types.ToJSON..= getWalletResponseBody200BalanceReward obj] : ["total" Data.Aeson.Types.ToJSON..= getWalletResponseBody200BalanceTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= getWalletResponseBody200BalanceAvailable obj] : ["reward" Data.Aeson.Types.ToJSON..= getWalletResponseBody200BalanceReward obj] : ["total" Data.Aeson.Types.ToJSON..= getWalletResponseBody200BalanceTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200Balance
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200Balance" (\obj -> ((GHC.Base.pure GetWalletResponseBody200Balance GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'GetWalletResponseBody200Balance' with all required fields.
mkGetWalletResponseBody200Balance :: GetWalletResponseBody200BalanceAvailable -- ^ 'getWalletResponseBody200BalanceAvailable'
  -> GetWalletResponseBody200BalanceReward -- ^ 'getWalletResponseBody200BalanceReward'
  -> GetWalletResponseBody200BalanceTotal -- ^ 'getWalletResponseBody200BalanceTotal'
  -> GetWalletResponseBody200Balance
mkGetWalletResponseBody200Balance getWalletResponseBody200BalanceAvailable getWalletResponseBody200BalanceReward getWalletResponseBody200BalanceTotal = GetWalletResponseBody200Balance{getWalletResponseBody200BalanceAvailable = getWalletResponseBody200BalanceAvailable,
                                                                                                                                                                                        getWalletResponseBody200BalanceReward = getWalletResponseBody200BalanceReward,
                                                                                                                                                                                        getWalletResponseBody200BalanceTotal = getWalletResponseBody200BalanceTotal}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.balance.properties.available@ in the specification.
-- 
-- Available Ada UTxO balance (funds that can be spent without condition).
data GetWalletResponseBody200BalanceAvailable = GetWalletResponseBody200BalanceAvailable {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getWalletResponseBody200BalanceAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200BalanceAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getWalletResponseBody200BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getWalletResponseBody200BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200BalanceAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200BalanceAvailable" (\obj -> GHC.Base.pure GetWalletResponseBody200BalanceAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetWalletResponseBody200BalanceAvailable' with all required fields.
mkGetWalletResponseBody200BalanceAvailable :: GHC.Types.Int -- ^ 'getWalletResponseBody200BalanceAvailableQuantity'
  -> GetWalletResponseBody200BalanceAvailable
mkGetWalletResponseBody200BalanceAvailable getWalletResponseBody200BalanceAvailableQuantity = GetWalletResponseBody200BalanceAvailable{getWalletResponseBody200BalanceAvailableQuantity = getWalletResponseBody200BalanceAvailableQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.balance.properties.reward@ in the specification.
-- 
-- The Ada balance of the reward account for this wallet.
data GetWalletResponseBody200BalanceReward = GetWalletResponseBody200BalanceReward {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getWalletResponseBody200BalanceRewardQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200BalanceReward
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getWalletResponseBody200BalanceRewardQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getWalletResponseBody200BalanceRewardQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200BalanceReward
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200BalanceReward" (\obj -> GHC.Base.pure GetWalletResponseBody200BalanceReward GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetWalletResponseBody200BalanceReward' with all required fields.
mkGetWalletResponseBody200BalanceReward :: GHC.Types.Int -- ^ 'getWalletResponseBody200BalanceRewardQuantity'
  -> GetWalletResponseBody200BalanceReward
mkGetWalletResponseBody200BalanceReward getWalletResponseBody200BalanceRewardQuantity = GetWalletResponseBody200BalanceReward{getWalletResponseBody200BalanceRewardQuantity = getWalletResponseBody200BalanceRewardQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.balance.properties.total@ in the specification.
-- 
-- Total Ada balance (available balance plus pending change and reward balance).
data GetWalletResponseBody200BalanceTotal = GetWalletResponseBody200BalanceTotal {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getWalletResponseBody200BalanceTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200BalanceTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getWalletResponseBody200BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getWalletResponseBody200BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200BalanceTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200BalanceTotal" (\obj -> GHC.Base.pure GetWalletResponseBody200BalanceTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetWalletResponseBody200BalanceTotal' with all required fields.
mkGetWalletResponseBody200BalanceTotal :: GHC.Types.Int -- ^ 'getWalletResponseBody200BalanceTotalQuantity'
  -> GetWalletResponseBody200BalanceTotal
mkGetWalletResponseBody200BalanceTotal getWalletResponseBody200BalanceTotalQuantity = GetWalletResponseBody200BalanceTotal{getWalletResponseBody200BalanceTotalQuantity = getWalletResponseBody200BalanceTotalQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.delegation@ in the specification.
-- 
-- Delegation settings
data GetWalletResponseBody200Delegation = GetWalletResponseBody200Delegation {
  -- | active: Currently active delegation status.
  getWalletResponseBody200DelegationActive :: GetWalletResponseBody200DelegationActive
  -- | next
  , getWalletResponseBody200DelegationNext :: ([GetWalletResponseBody200DelegationNext])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200Delegation
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= getWalletResponseBody200DelegationActive obj] : ["next" Data.Aeson.Types.ToJSON..= getWalletResponseBody200DelegationNext obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= getWalletResponseBody200DelegationActive obj] : ["next" Data.Aeson.Types.ToJSON..= getWalletResponseBody200DelegationNext obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200Delegation
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200Delegation" (\obj -> (GHC.Base.pure GetWalletResponseBody200Delegation GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "next"))
-- | Create a new 'GetWalletResponseBody200Delegation' with all required fields.
mkGetWalletResponseBody200Delegation :: GetWalletResponseBody200DelegationActive -- ^ 'getWalletResponseBody200DelegationActive'
  -> [GetWalletResponseBody200DelegationNext] -- ^ 'getWalletResponseBody200DelegationNext'
  -> GetWalletResponseBody200Delegation
mkGetWalletResponseBody200Delegation getWalletResponseBody200DelegationActive getWalletResponseBody200DelegationNext = GetWalletResponseBody200Delegation{getWalletResponseBody200DelegationActive = getWalletResponseBody200DelegationActive,
                                                                                                                                                          getWalletResponseBody200DelegationNext = getWalletResponseBody200DelegationNext}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.delegation.properties.active@ in the specification.
-- 
-- Currently active delegation status.
data GetWalletResponseBody200DelegationActive = GetWalletResponseBody200DelegationActive {
  -- | status
  getWalletResponseBody200DelegationActiveStatus :: GetWalletResponseBody200DelegationActiveStatus
  -- | target: A unique Stake-Pool identifier (present only if status = \`delegating\`)
  , getWalletResponseBody200DelegationActiveTarget :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200DelegationActive
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["status" Data.Aeson.Types.ToJSON..= getWalletResponseBody200DelegationActiveStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (getWalletResponseBody200DelegationActiveTarget obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["status" Data.Aeson.Types.ToJSON..= getWalletResponseBody200DelegationActiveStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (getWalletResponseBody200DelegationActiveTarget obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200DelegationActive
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200DelegationActive" (\obj -> (GHC.Base.pure GetWalletResponseBody200DelegationActive GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "target"))
-- | Create a new 'GetWalletResponseBody200DelegationActive' with all required fields.
mkGetWalletResponseBody200DelegationActive :: GetWalletResponseBody200DelegationActiveStatus -- ^ 'getWalletResponseBody200DelegationActiveStatus'
  -> GetWalletResponseBody200DelegationActive
mkGetWalletResponseBody200DelegationActive getWalletResponseBody200DelegationActiveStatus = GetWalletResponseBody200DelegationActive{getWalletResponseBody200DelegationActiveStatus = getWalletResponseBody200DelegationActiveStatus,
                                                                                                                                     getWalletResponseBody200DelegationActiveTarget = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.delegation.properties.active.properties.status@ in the specification.
-- 
-- 
data GetWalletResponseBody200DelegationActiveStatus =
   GetWalletResponseBody200DelegationActiveStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetWalletResponseBody200DelegationActiveStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetWalletResponseBody200DelegationActiveStatusEnumNot_delegating -- ^ Represents the JSON value @"not_delegating"@
  | GetWalletResponseBody200DelegationActiveStatusEnumDelegating -- ^ Represents the JSON value @"delegating"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200DelegationActiveStatus
    where toJSON (GetWalletResponseBody200DelegationActiveStatusOther val) = val
          toJSON (GetWalletResponseBody200DelegationActiveStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetWalletResponseBody200DelegationActiveStatusEnumNot_delegating) = "not_delegating"
          toJSON (GetWalletResponseBody200DelegationActiveStatusEnumDelegating) = "delegating"
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200DelegationActiveStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "not_delegating" -> GetWalletResponseBody200DelegationActiveStatusEnumNot_delegating
                                            | val GHC.Classes.== "delegating" -> GetWalletResponseBody200DelegationActiveStatusEnumDelegating
                                            | GHC.Base.otherwise -> GetWalletResponseBody200DelegationActiveStatusOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.delegation.properties.next.items@ in the specification.
-- 
-- Next delegation status becomes active at the start of the second epoch after the corresponding delegation certificate was discovered. The exact moment is specified by changes_at
data GetWalletResponseBody200DelegationNext = GetWalletResponseBody200DelegationNext {
  -- | changes_at
  getWalletResponseBody200DelegationNextChanges_at :: GetWalletResponseBody200DelegationNextChanges_at
  -- | status
  , getWalletResponseBody200DelegationNextStatus :: GetWalletResponseBody200DelegationNextStatus
  -- | target: A unique Stake-Pool identifier (present only if status = \`delegating\`)
  , getWalletResponseBody200DelegationNextTarget :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200DelegationNext
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["changes_at" Data.Aeson.Types.ToJSON..= getWalletResponseBody200DelegationNextChanges_at obj] : ["status" Data.Aeson.Types.ToJSON..= getWalletResponseBody200DelegationNextStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (getWalletResponseBody200DelegationNextTarget obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["changes_at" Data.Aeson.Types.ToJSON..= getWalletResponseBody200DelegationNextChanges_at obj] : ["status" Data.Aeson.Types.ToJSON..= getWalletResponseBody200DelegationNextStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (getWalletResponseBody200DelegationNextTarget obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200DelegationNext
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200DelegationNext" (\obj -> ((GHC.Base.pure GetWalletResponseBody200DelegationNext GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "changes_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "target"))
-- | Create a new 'GetWalletResponseBody200DelegationNext' with all required fields.
mkGetWalletResponseBody200DelegationNext :: GetWalletResponseBody200DelegationNextChanges_at -- ^ 'getWalletResponseBody200DelegationNextChanges_at'
  -> GetWalletResponseBody200DelegationNextStatus -- ^ 'getWalletResponseBody200DelegationNextStatus'
  -> GetWalletResponseBody200DelegationNext
mkGetWalletResponseBody200DelegationNext getWalletResponseBody200DelegationNextChanges_at getWalletResponseBody200DelegationNextStatus = GetWalletResponseBody200DelegationNext{getWalletResponseBody200DelegationNextChanges_at = getWalletResponseBody200DelegationNextChanges_at,
                                                                                                                                                                                getWalletResponseBody200DelegationNextStatus = getWalletResponseBody200DelegationNextStatus,
                                                                                                                                                                                getWalletResponseBody200DelegationNextTarget = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.delegation.properties.next.items.properties.changes_at@ in the specification.
-- 
-- 
data GetWalletResponseBody200DelegationNextChanges_at = GetWalletResponseBody200DelegationNextChanges_at {
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getWalletResponseBody200DelegationNextChanges_atEpoch_number :: GHC.Types.Int
  -- | epoch_start_time
  , getWalletResponseBody200DelegationNextChanges_atEpoch_start_time :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200DelegationNextChanges_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["epoch_number" Data.Aeson.Types.ToJSON..= getWalletResponseBody200DelegationNextChanges_atEpoch_number obj] : ["epoch_start_time" Data.Aeson.Types.ToJSON..= getWalletResponseBody200DelegationNextChanges_atEpoch_start_time obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["epoch_number" Data.Aeson.Types.ToJSON..= getWalletResponseBody200DelegationNextChanges_atEpoch_number obj] : ["epoch_start_time" Data.Aeson.Types.ToJSON..= getWalletResponseBody200DelegationNextChanges_atEpoch_start_time obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200DelegationNextChanges_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200DelegationNextChanges_at" (\obj -> (GHC.Base.pure GetWalletResponseBody200DelegationNextChanges_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_start_time"))
-- | Create a new 'GetWalletResponseBody200DelegationNextChanges_at' with all required fields.
mkGetWalletResponseBody200DelegationNextChanges_at :: GHC.Types.Int -- ^ 'getWalletResponseBody200DelegationNextChanges_atEpoch_number'
  -> Data.Text.Internal.Text -- ^ 'getWalletResponseBody200DelegationNextChanges_atEpoch_start_time'
  -> GetWalletResponseBody200DelegationNextChanges_at
mkGetWalletResponseBody200DelegationNextChanges_at getWalletResponseBody200DelegationNextChanges_atEpoch_number getWalletResponseBody200DelegationNextChanges_atEpoch_start_time = GetWalletResponseBody200DelegationNextChanges_at{getWalletResponseBody200DelegationNextChanges_atEpoch_number = getWalletResponseBody200DelegationNextChanges_atEpoch_number,
                                                                                                                                                                                                                                    getWalletResponseBody200DelegationNextChanges_atEpoch_start_time = getWalletResponseBody200DelegationNextChanges_atEpoch_start_time}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.delegation.properties.next.items.properties.status@ in the specification.
-- 
-- 
data GetWalletResponseBody200DelegationNextStatus =
   GetWalletResponseBody200DelegationNextStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetWalletResponseBody200DelegationNextStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetWalletResponseBody200DelegationNextStatusEnumNot_delegating -- ^ Represents the JSON value @"not_delegating"@
  | GetWalletResponseBody200DelegationNextStatusEnumDelegating -- ^ Represents the JSON value @"delegating"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200DelegationNextStatus
    where toJSON (GetWalletResponseBody200DelegationNextStatusOther val) = val
          toJSON (GetWalletResponseBody200DelegationNextStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetWalletResponseBody200DelegationNextStatusEnumNot_delegating) = "not_delegating"
          toJSON (GetWalletResponseBody200DelegationNextStatusEnumDelegating) = "delegating"
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200DelegationNextStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "not_delegating" -> GetWalletResponseBody200DelegationNextStatusEnumNot_delegating
                                            | val GHC.Classes.== "delegating" -> GetWalletResponseBody200DelegationNextStatusEnumDelegating
                                            | GHC.Base.otherwise -> GetWalletResponseBody200DelegationNextStatusOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.passphrase@ in the specification.
-- 
-- Information about the wallet\'s passphrase
data GetWalletResponseBody200Passphrase = GetWalletResponseBody200Passphrase {
  -- | last_updated_at
  getWalletResponseBody200PassphraseLast_updated_at :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200Passphrase
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= getWalletResponseBody200PassphraseLast_updated_at obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= getWalletResponseBody200PassphraseLast_updated_at obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200Passphrase
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200Passphrase" (\obj -> GHC.Base.pure GetWalletResponseBody200Passphrase GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "last_updated_at"))
-- | Create a new 'GetWalletResponseBody200Passphrase' with all required fields.
mkGetWalletResponseBody200Passphrase :: Data.Text.Internal.Text -- ^ 'getWalletResponseBody200PassphraseLast_updated_at'
  -> GetWalletResponseBody200Passphrase
mkGetWalletResponseBody200Passphrase getWalletResponseBody200PassphraseLast_updated_at = GetWalletResponseBody200Passphrase{getWalletResponseBody200PassphraseLast_updated_at = getWalletResponseBody200PassphraseLast_updated_at}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.state@ in the specification.
-- 
-- Whether a wallet is ready to use or still syncing
data GetWalletResponseBody200State = GetWalletResponseBody200State {
  -- | progress: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == syncing
  -- \<\/span>\<br\/>
  getWalletResponseBody200StateProgress :: (GHC.Maybe.Maybe GetWalletResponseBody200StateProgress)
  -- | status
  , getWalletResponseBody200StateStatus :: GetWalletResponseBody200StateStatus
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200State
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (getWalletResponseBody200StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= getWalletResponseBody200StateStatus obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (getWalletResponseBody200StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= getWalletResponseBody200StateStatus obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200State
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200State" (\obj -> (GHC.Base.pure GetWalletResponseBody200State GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "progress")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status"))
-- | Create a new 'GetWalletResponseBody200State' with all required fields.
mkGetWalletResponseBody200State :: GetWalletResponseBody200StateStatus -- ^ 'getWalletResponseBody200StateStatus'
  -> GetWalletResponseBody200State
mkGetWalletResponseBody200State getWalletResponseBody200StateStatus = GetWalletResponseBody200State{getWalletResponseBody200StateProgress = GHC.Maybe.Nothing,
                                                                                                    getWalletResponseBody200StateStatus = getWalletResponseBody200StateStatus}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.state.properties.progress@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == syncing
-- \<\/span>\<br\/>
data GetWalletResponseBody200StateProgress = GetWalletResponseBody200StateProgress {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  getWalletResponseBody200StateProgressQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200StateProgress
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getWalletResponseBody200StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getWalletResponseBody200StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200StateProgress
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200StateProgress" (\obj -> GHC.Base.pure GetWalletResponseBody200StateProgress GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetWalletResponseBody200StateProgress' with all required fields.
mkGetWalletResponseBody200StateProgress :: GHC.Types.Double -- ^ 'getWalletResponseBody200StateProgressQuantity'
  -> GetWalletResponseBody200StateProgress
mkGetWalletResponseBody200StateProgress getWalletResponseBody200StateProgressQuantity = GetWalletResponseBody200StateProgress{getWalletResponseBody200StateProgressQuantity = getWalletResponseBody200StateProgressQuantity}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.state.properties.status@ in the specification.
-- 
-- 
data GetWalletResponseBody200StateStatus =
   GetWalletResponseBody200StateStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetWalletResponseBody200StateStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetWalletResponseBody200StateStatusEnumReady -- ^ Represents the JSON value @"ready"@
  | GetWalletResponseBody200StateStatusEnumSyncing -- ^ Represents the JSON value @"syncing"@
  | GetWalletResponseBody200StateStatusEnumNot_responding -- ^ Represents the JSON value @"not_responding"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200StateStatus
    where toJSON (GetWalletResponseBody200StateStatusOther val) = val
          toJSON (GetWalletResponseBody200StateStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetWalletResponseBody200StateStatusEnumReady) = "ready"
          toJSON (GetWalletResponseBody200StateStatusEnumSyncing) = "syncing"
          toJSON (GetWalletResponseBody200StateStatusEnumNot_responding) = "not_responding"
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200StateStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "ready" -> GetWalletResponseBody200StateStatusEnumReady
                                            | val GHC.Classes.== "syncing" -> GetWalletResponseBody200StateStatusEnumSyncing
                                            | val GHC.Classes.== "not_responding" -> GetWalletResponseBody200StateStatusEnumNot_responding
                                            | GHC.Base.otherwise -> GetWalletResponseBody200StateStatusOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.tip@ in the specification.
-- 
-- A reference to a particular time slot, and the block height at that point.
data GetWalletResponseBody200Tip = GetWalletResponseBody200Tip {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getWalletResponseBody200TipAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getWalletResponseBody200TipEpoch_number :: GHC.Types.Int
  -- | height
  , getWalletResponseBody200TipHeight :: GetWalletResponseBody200TipHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getWalletResponseBody200TipSlot_number :: GHC.Types.Int
  -- | time
  , getWalletResponseBody200TipTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200Tip
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getWalletResponseBody200TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getWalletResponseBody200TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= getWalletResponseBody200TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getWalletResponseBody200TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getWalletResponseBody200TipTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getWalletResponseBody200TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getWalletResponseBody200TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= getWalletResponseBody200TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getWalletResponseBody200TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getWalletResponseBody200TipTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200Tip
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200Tip" (\obj -> ((((GHC.Base.pure GetWalletResponseBody200Tip GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'GetWalletResponseBody200Tip' with all required fields.
mkGetWalletResponseBody200Tip :: GHC.Types.Int -- ^ 'getWalletResponseBody200TipAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'getWalletResponseBody200TipEpoch_number'
  -> GetWalletResponseBody200TipHeight -- ^ 'getWalletResponseBody200TipHeight'
  -> GHC.Types.Int -- ^ 'getWalletResponseBody200TipSlot_number'
  -> Data.Text.Internal.Text -- ^ 'getWalletResponseBody200TipTime'
  -> GetWalletResponseBody200Tip
mkGetWalletResponseBody200Tip getWalletResponseBody200TipAbsolute_slot_number getWalletResponseBody200TipEpoch_number getWalletResponseBody200TipHeight getWalletResponseBody200TipSlot_number getWalletResponseBody200TipTime = GetWalletResponseBody200Tip{getWalletResponseBody200TipAbsolute_slot_number = getWalletResponseBody200TipAbsolute_slot_number,
                                                                                                                                                                                                                                                             getWalletResponseBody200TipEpoch_number = getWalletResponseBody200TipEpoch_number,
                                                                                                                                                                                                                                                             getWalletResponseBody200TipHeight = getWalletResponseBody200TipHeight,
                                                                                                                                                                                                                                                             getWalletResponseBody200TipSlot_number = getWalletResponseBody200TipSlot_number,
                                                                                                                                                                                                                                                             getWalletResponseBody200TipTime = getWalletResponseBody200TipTime}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.tip.properties.height@ in the specification.
-- 
-- 
data GetWalletResponseBody200TipHeight = GetWalletResponseBody200TipHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getWalletResponseBody200TipHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody200TipHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getWalletResponseBody200TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getWalletResponseBody200TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody200TipHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody200TipHeight" (\obj -> GHC.Base.pure GetWalletResponseBody200TipHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetWalletResponseBody200TipHeight' with all required fields.
mkGetWalletResponseBody200TipHeight :: GHC.Types.Int -- ^ 'getWalletResponseBody200TipHeightQuantity'
  -> GetWalletResponseBody200TipHeight
mkGetWalletResponseBody200TipHeight getWalletResponseBody200TipHeightQuantity = GetWalletResponseBody200TipHeight{getWalletResponseBody200TipHeightQuantity = getWalletResponseBody200TipHeightQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data GetWalletResponseBody400 = GetWalletResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  getWalletResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getWalletResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getWalletResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody400" (\obj -> GHC.Base.pure GetWalletResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetWalletResponseBody400' with all required fields.
mkGetWalletResponseBody400 :: Data.Text.Internal.Text -- ^ 'getWalletResponseBody400Message'
  -> GetWalletResponseBody400
mkGetWalletResponseBody400 getWalletResponseBody400Message = GetWalletResponseBody400{getWalletResponseBody400Message = getWalletResponseBody400Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data GetWalletResponseBody404 = GetWalletResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  getWalletResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getWalletResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getWalletResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody404" (\obj -> GHC.Base.pure GetWalletResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetWalletResponseBody404' with all required fields.
mkGetWalletResponseBody404 :: Data.Text.Internal.Text -- ^ 'getWalletResponseBody404Message'
  -> GetWalletResponseBody404
mkGetWalletResponseBody404 getWalletResponseBody404Message = GetWalletResponseBody404{getWalletResponseBody404Message = getWalletResponseBody404Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.GET.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data GetWalletResponseBody406 = GetWalletResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  getWalletResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetWalletResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetWalletResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetWalletResponseBody406" (\obj -> GHC.Base.pure GetWalletResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetWalletResponseBody406' with all required fields.
mkGetWalletResponseBody406 :: Data.Text.Internal.Text -- ^ 'getWalletResponseBody406Message'
  -> GetWalletResponseBody406
mkGetWalletResponseBody406 getWalletResponseBody406Message = GetWalletResponseBody406{getWalletResponseBody406Message = getWalletResponseBody406Message}
-- | > GET /wallets/{walletId}
-- 
-- The same as 'getWallet' but accepts an explicit configuration.
getWalletWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> m (Network.HTTP.Client.Types.Response GetWalletResponse) -- ^ Monadic computation which returns the result of the operation
getWalletWithConfiguration config
                           walletId = GHC.Base.fmap (\response_5 -> GHC.Base.fmap (Data.Either.either GetWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetWalletResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                   GetWalletResponseBody200)
                                                                                                                                                                          | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> GetWalletResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                   GetWalletResponseBody400)
                                                                                                                                                                          | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> GetWalletResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                   GetWalletResponseBody404)
                                                                                                                                                                          | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> GetWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                   GetWalletResponseBody406)
                                                                                                                                                                          | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_5) response_5) (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty)
-- | > GET /wallets/{walletId}
-- 
-- The same as 'getWallet' but returns the raw 'Data.ByteString.ByteString'.
getWalletRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
getWalletRaw walletId = GHC.Base.id (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty)
-- | > GET /wallets/{walletId}
-- 
-- The same as 'getWallet' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
getWalletWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
getWalletWithConfigurationRaw config
                              walletId = GHC.Base.id (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty)
