-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation quitStakePool
module Wallet.Operations.QuitStakePool where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > DELETE /stake-pools/*/wallets/{walletId}
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Stop delegating completely. The wallet\'s stake will become inactive.
-- 
-- Any current rewards will automatically withdrawn.
-- 
-- > ⚠️  Disclaimer ⚠️
-- >
-- > This endpoint historically use to take a stake pool id as a path parameter.
-- > However, retiring from delegation is ubiquitous and not tied to a particular
-- > stake pool. For backward-compatibility reasons, sending stake pool ids as path
-- > parameter will still be accepted by the server but new integrations are
-- > encouraged to provide a placeholder asterisk \`*\` instead.
quitStakePool :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> QuitStakePoolRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response QuitStakePoolResponse) -- ^ Monadic computation which returns the result of the operation
quitStakePool walletId
              body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either QuitStakePoolResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> QuitStakePoolResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                          QuitStakePoolResponseBody202)
                                                                                                                                                             | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> QuitStakePoolResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                          QuitStakePoolResponseBody400)
                                                                                                                                                             | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> QuitStakePoolResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                          QuitStakePoolResponseBody403Variants)
                                                                                                                                                             | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> QuitStakePoolResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                          QuitStakePoolResponseBody404)
                                                                                                                                                             | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> QuitStakePoolResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                          QuitStakePoolResponseBody406)
                                                                                                                                                             | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> QuitStakePoolResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                          QuitStakePoolResponseBody415)
                                                                                                                                                             | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "DELETE") ("/stake-pools/*/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.requestBody.content.application\/json.schema@ in the specification.
-- 
-- 
data QuitStakePoolRequestBody = QuitStakePoolRequestBody {
  -- | passphrase: The source wallet\'s master passphrase.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 0
  quitStakePoolRequestBodyPassphrase :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["passphrase" Data.Aeson.Types.ToJSON..= quitStakePoolRequestBodyPassphrase obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["passphrase" Data.Aeson.Types.ToJSON..= quitStakePoolRequestBodyPassphrase obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolRequestBody" (\obj -> GHC.Base.pure QuitStakePoolRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "passphrase"))
-- | Create a new 'QuitStakePoolRequestBody' with all required fields.
mkQuitStakePoolRequestBody :: Data.Text.Internal.Text -- ^ 'quitStakePoolRequestBodyPassphrase'
  -> QuitStakePoolRequestBody
mkQuitStakePoolRequestBody quitStakePoolRequestBodyPassphrase = QuitStakePoolRequestBody{quitStakePoolRequestBodyPassphrase = quitStakePoolRequestBodyPassphrase}
-- | Represents a response of the operation 'quitStakePool'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'QuitStakePoolResponseError' is used.
data QuitStakePoolResponse =
   QuitStakePoolResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | QuitStakePoolResponse202 QuitStakePoolResponseBody202 -- ^ Accepted
  | QuitStakePoolResponse400 QuitStakePoolResponseBody400 -- ^ Bad Request
  | QuitStakePoolResponse403 QuitStakePoolResponseBody403Variants -- ^ Forbidden
  | QuitStakePoolResponse404 QuitStakePoolResponseBody404 -- ^ Not Found
  | QuitStakePoolResponse406 QuitStakePoolResponseBody406 -- ^ Not Acceptable
  | QuitStakePoolResponse415 QuitStakePoolResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202 = QuitStakePoolResponseBody202 {
  -- | amount: An amount of Ada spent or received, from the perspective of the wallet.
  -- 
  -- That is, for outgoing transaction, it represents the amount of Ada consumed
  -- as inputs including the amount of Ada spent as fees or deposits.
  -- 
  -- For incoming transaction, it represents the total amount of Ada received to
  -- addresses that belong to the wallet.
  quitStakePoolResponseBody202Amount :: QuitStakePoolResponseBody202Amount
  -- | burn
  , quitStakePoolResponseBody202Burn :: (GHC.Maybe.Maybe QuitStakePoolResponseBody202Burn)
  -- | certificates
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , quitStakePoolResponseBody202Certificates :: (GHC.Maybe.Maybe ([QuitStakePoolResponseBody202CertificatesVariants]))
  -- | collateral: A list of transaction inputs used for collateral.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , quitStakePoolResponseBody202Collateral :: (GHC.Maybe.Maybe ([QuitStakePoolResponseBody202Collateral]))
  -- | collateral_outputs: A list of collateral return outputs with amounts specified.
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 1 items
  -- * Must have a minimum of 0 items
  , quitStakePoolResponseBody202Collateral_outputs :: (GHC.Maybe.Maybe ([QuitStakePoolResponseBody202Collateral_outputs]))
  -- | deposit_returned: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , quitStakePoolResponseBody202Deposit_returned :: QuitStakePoolResponseBody202Deposit_returned
  -- | deposit_taken: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , quitStakePoolResponseBody202Deposit_taken :: QuitStakePoolResponseBody202Deposit_taken
  -- | depth: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Current depth of the transaction in the local chain
  , quitStakePoolResponseBody202Depth :: (GHC.Maybe.Maybe QuitStakePoolResponseBody202Depth)
  -- | direction
  , quitStakePoolResponseBody202Direction :: QuitStakePoolResponseBody202Direction
  -- | expires_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending OR status == expired
  -- \<\/span>\<br\/>
  -- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
  , quitStakePoolResponseBody202Expires_at :: (GHC.Maybe.Maybe QuitStakePoolResponseBody202Expires_at)
  -- | extra_signatures
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , quitStakePoolResponseBody202Extra_signatures :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | fee: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , quitStakePoolResponseBody202Fee :: QuitStakePoolResponseBody202Fee
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , quitStakePoolResponseBody202Id :: Data.Text.Internal.Text
  -- | inputs: A list of transaction inputs.
  -- 
  -- \`assets\` and \`address\` are always present for \`outgoing\`
  -- transactions but generally absent for \`incoming\`
  -- transactions. This information is present on the Cardano explorer,
  -- but is not tracked by the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , quitStakePoolResponseBody202Inputs :: ([QuitStakePoolResponseBody202Inputs])
  -- | inserted_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Absolute time at which the transaction was inserted in a block.
  , quitStakePoolResponseBody202Inserted_at :: (GHC.Maybe.Maybe QuitStakePoolResponseBody202Inserted_at)
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  , quitStakePoolResponseBody202Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | mint
  , quitStakePoolResponseBody202Mint :: (GHC.Maybe.Maybe QuitStakePoolResponseBody202Mint)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , quitStakePoolResponseBody202Outputs :: ([QuitStakePoolResponseBody202Outputs])
  -- | pending_since: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending
  -- \<\/span>\<br\/>
  -- The point in time at which a transaction became pending.
  , quitStakePoolResponseBody202Pending_since :: (GHC.Maybe.Maybe QuitStakePoolResponseBody202Pending_since)
  -- | script_integrity: A script data integrity hash - 32 bytes
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^(script_data)1[0-9a-z]*\$\'
  , quitStakePoolResponseBody202Script_integrity :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | script_validity: Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
  -- used in the transaction validated or not. Validity may be null if this
  -- transaction was from an era that doesn\'t support phase-2 monetary policy
  -- scripts, or is a pending transaction (we don\'t know if validation passed or
  -- failed until the transaction hits the ledger).
  , quitStakePoolResponseBody202Script_validity :: (GHC.Maybe.Maybe (Wallet.Common.Nullable QuitStakePoolResponseBody202Script_validityNonNullable))
  -- | status: Current transaction status.
  -- 
  --   \`\`\`
  --        *-----------*
  --   ---> |  PENDING  |----------------*
  --        *-----------*                |
  --              |                      |
  --              V                      V
  --        *-----------*          *-----------*
  --        |           |---------->  EXPIRED  |
  --        |           |  (ttl)   *-----------*
  --        | SUBMITTED |
  --        |           \<----------------*
  --        |           |                |
  --        *-----------*           (rollback)
  --               |                     |
  --          (in ledger)          *-----------*
  --               |               |           |
  --               *---------------> IN_LEDGER |
  --                               |           |
  --                               *-----------*
  --   \`\`\`
  , quitStakePoolResponseBody202Status :: QuitStakePoolResponseBody202Status
  -- | validity_interval
  , quitStakePoolResponseBody202Validity_interval :: (GHC.Maybe.Maybe QuitStakePoolResponseBody202Validity_interval)
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , quitStakePoolResponseBody202Withdrawals :: ([QuitStakePoolResponseBody202Withdrawals])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Fee obj] : ["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Withdrawals obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Fee obj] : ["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Withdrawals obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202" (\obj -> (((((((((((((((((((((((GHC.Base.pure QuitStakePoolResponseBody202 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "burn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral_outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "depth")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "direction")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "expires_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "extra_signatures")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fee")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "inserted_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pending_since")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_integrity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_validity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "validity_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "withdrawals"))
-- | Create a new 'QuitStakePoolResponseBody202' with all required fields.
mkQuitStakePoolResponseBody202 :: QuitStakePoolResponseBody202Amount -- ^ 'quitStakePoolResponseBody202Amount'
  -> QuitStakePoolResponseBody202Deposit_returned -- ^ 'quitStakePoolResponseBody202Deposit_returned'
  -> QuitStakePoolResponseBody202Deposit_taken -- ^ 'quitStakePoolResponseBody202Deposit_taken'
  -> QuitStakePoolResponseBody202Direction -- ^ 'quitStakePoolResponseBody202Direction'
  -> QuitStakePoolResponseBody202Fee -- ^ 'quitStakePoolResponseBody202Fee'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202Id'
  -> [QuitStakePoolResponseBody202Inputs] -- ^ 'quitStakePoolResponseBody202Inputs'
  -> [QuitStakePoolResponseBody202Outputs] -- ^ 'quitStakePoolResponseBody202Outputs'
  -> QuitStakePoolResponseBody202Status -- ^ 'quitStakePoolResponseBody202Status'
  -> [QuitStakePoolResponseBody202Withdrawals] -- ^ 'quitStakePoolResponseBody202Withdrawals'
  -> QuitStakePoolResponseBody202
mkQuitStakePoolResponseBody202 quitStakePoolResponseBody202Amount quitStakePoolResponseBody202Deposit_returned quitStakePoolResponseBody202Deposit_taken quitStakePoolResponseBody202Direction quitStakePoolResponseBody202Fee quitStakePoolResponseBody202Id quitStakePoolResponseBody202Inputs quitStakePoolResponseBody202Outputs quitStakePoolResponseBody202Status quitStakePoolResponseBody202Withdrawals = QuitStakePoolResponseBody202{quitStakePoolResponseBody202Amount = quitStakePoolResponseBody202Amount,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Burn = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Certificates = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Collateral = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Collateral_outputs = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Deposit_returned = quitStakePoolResponseBody202Deposit_returned,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Deposit_taken = quitStakePoolResponseBody202Deposit_taken,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Depth = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Direction = quitStakePoolResponseBody202Direction,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Expires_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Extra_signatures = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Fee = quitStakePoolResponseBody202Fee,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Id = quitStakePoolResponseBody202Id,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Inputs = quitStakePoolResponseBody202Inputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Inserted_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Mint = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Outputs = quitStakePoolResponseBody202Outputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Pending_since = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Script_integrity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Script_validity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Status = quitStakePoolResponseBody202Status,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Validity_interval = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Withdrawals = quitStakePoolResponseBody202Withdrawals}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.amount@ in the specification.
-- 
-- An amount of Ada spent or received, from the perspective of the wallet.
-- 
-- That is, for outgoing transaction, it represents the amount of Ada consumed
-- as inputs including the amount of Ada spent as fees or deposits.
-- 
-- For incoming transaction, it represents the total amount of Ada received to
-- addresses that belong to the wallet.
data QuitStakePoolResponseBody202Amount = QuitStakePoolResponseBody202Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Amount" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202Amount' with all required fields.
mkQuitStakePoolResponseBody202Amount :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202AmountQuantity'
  -> QuitStakePoolResponseBody202Amount
mkQuitStakePoolResponseBody202Amount quitStakePoolResponseBody202AmountQuantity = QuitStakePoolResponseBody202Amount{quitStakePoolResponseBody202AmountQuantity = quitStakePoolResponseBody202AmountQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202Burn = QuitStakePoolResponseBody202Burn {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  quitStakePoolResponseBody202BurnTokens :: ([QuitStakePoolResponseBody202BurnTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , quitStakePoolResponseBody202BurnWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , quitStakePoolResponseBody202BurnWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202BurnWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202BurnWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Burn" (\obj -> ((GHC.Base.pure QuitStakePoolResponseBody202Burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'QuitStakePoolResponseBody202Burn' with all required fields.
mkQuitStakePoolResponseBody202Burn :: [QuitStakePoolResponseBody202BurnTokens] -- ^ 'quitStakePoolResponseBody202BurnTokens'
  -> QuitStakePoolResponseBody202Burn
mkQuitStakePoolResponseBody202Burn quitStakePoolResponseBody202BurnTokens = QuitStakePoolResponseBody202Burn{quitStakePoolResponseBody202BurnTokens = quitStakePoolResponseBody202BurnTokens,
                                                                                                             quitStakePoolResponseBody202BurnWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                             quitStakePoolResponseBody202BurnWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202BurnTokens = QuitStakePoolResponseBody202BurnTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  quitStakePoolResponseBody202BurnTokensAssets :: ([QuitStakePoolResponseBody202BurnTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , quitStakePoolResponseBody202BurnTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , quitStakePoolResponseBody202BurnTokensPolicy_script :: QuitStakePoolResponseBody202BurnTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202BurnTokens" (\obj -> ((GHC.Base.pure QuitStakePoolResponseBody202BurnTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'QuitStakePoolResponseBody202BurnTokens' with all required fields.
mkQuitStakePoolResponseBody202BurnTokens :: [QuitStakePoolResponseBody202BurnTokensAssets] -- ^ 'quitStakePoolResponseBody202BurnTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_id'
  -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptVariants -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_script'
  -> QuitStakePoolResponseBody202BurnTokens
mkQuitStakePoolResponseBody202BurnTokens quitStakePoolResponseBody202BurnTokensAssets quitStakePoolResponseBody202BurnTokensPolicy_id quitStakePoolResponseBody202BurnTokensPolicy_script = QuitStakePoolResponseBody202BurnTokens{quitStakePoolResponseBody202BurnTokensAssets = quitStakePoolResponseBody202BurnTokensAssets,
                                                                                                                                                                                                                                   quitStakePoolResponseBody202BurnTokensPolicy_id = quitStakePoolResponseBody202BurnTokensPolicy_id,
                                                                                                                                                                                                                                   quitStakePoolResponseBody202BurnTokensPolicy_script = quitStakePoolResponseBody202BurnTokensPolicy_script}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202BurnTokensAssets = QuitStakePoolResponseBody202BurnTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  quitStakePoolResponseBody202BurnTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , quitStakePoolResponseBody202BurnTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202BurnTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202BurnTokensAssets" (\obj -> ((GHC.Base.pure QuitStakePoolResponseBody202BurnTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202BurnTokensAssets' with all required fields.
mkQuitStakePoolResponseBody202BurnTokensAssets :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202BurnTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202BurnTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202BurnTokensAssetsQuantity'
  -> QuitStakePoolResponseBody202BurnTokensAssets
mkQuitStakePoolResponseBody202BurnTokensAssets quitStakePoolResponseBody202BurnTokensAssetsAsset_name quitStakePoolResponseBody202BurnTokensAssetsFingerprint quitStakePoolResponseBody202BurnTokensAssetsQuantity = QuitStakePoolResponseBody202BurnTokensAssets{quitStakePoolResponseBody202BurnTokensAssetsAsset_name = quitStakePoolResponseBody202BurnTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                  quitStakePoolResponseBody202BurnTokensAssetsFingerprint = quitStakePoolResponseBody202BurnTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                  quitStakePoolResponseBody202BurnTokensAssetsQuantity = quitStakePoolResponseBody202BurnTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1 = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference)
  -- | script
  , quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Script :: QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1' with all required fields.
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1 :: QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Script'
  -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1 quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Script = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1{quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                        quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Script = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference' with all required fields.
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex'
  -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference{quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                       quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2{quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3{quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 :: QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4{quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some{quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                        quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5{quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6{quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants =
   QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
  | QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
  | QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
  | QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
  | QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2 = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info :: QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2' with all required fields.
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2 :: QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info'
  -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2 quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2{quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                             quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference' with all required fields.
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex'
  -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference{quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                       quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version :: QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info :: QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info{quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                   quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3 = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References :: ([QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3' with all required fields.
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3 :: [QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References] -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash'
  -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3 quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3{quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                 quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References' with all required fields.
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex'
  -> QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References
mkQuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex = QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References{quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                           quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex = quitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202BurnTokensPolicy_scriptVariants =
   QuitStakePoolResponseBody202BurnTokensPolicy_scriptVariant1 QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1
  | QuitStakePoolResponseBody202BurnTokensPolicy_scriptVariant2 QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2
  | QuitStakePoolResponseBody202BurnTokensPolicy_scriptVariant3 QuitStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptVariants
    where toJSON (QuitStakePoolResponseBody202BurnTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202BurnTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202BurnTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202BurnTokensPolicy_scriptVariants
    where parseJSON val = case (QuitStakePoolResponseBody202BurnTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202BurnTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202BurnTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data QuitStakePoolResponseBody202CertificatesOneOf1 = QuitStakePoolResponseBody202CertificatesOneOf1 {
  -- | certificate_type
  quitStakePoolResponseBody202CertificatesOneOf1Certificate_type :: QuitStakePoolResponseBody202CertificatesOneOf1Certificate_type
  -- | pool: A unique identifier for the pool.
  , quitStakePoolResponseBody202CertificatesOneOf1Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , quitStakePoolResponseBody202CertificatesOneOf1Reward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202CertificatesOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202CertificatesOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202CertificatesOneOf1" (\obj -> ((GHC.Base.pure QuitStakePoolResponseBody202CertificatesOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'QuitStakePoolResponseBody202CertificatesOneOf1' with all required fields.
mkQuitStakePoolResponseBody202CertificatesOneOf1 :: QuitStakePoolResponseBody202CertificatesOneOf1Certificate_type -- ^ 'quitStakePoolResponseBody202CertificatesOneOf1Certificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'quitStakePoolResponseBody202CertificatesOneOf1Reward_account_path'
  -> QuitStakePoolResponseBody202CertificatesOneOf1
mkQuitStakePoolResponseBody202CertificatesOneOf1 quitStakePoolResponseBody202CertificatesOneOf1Certificate_type quitStakePoolResponseBody202CertificatesOneOf1Reward_account_path = QuitStakePoolResponseBody202CertificatesOneOf1{quitStakePoolResponseBody202CertificatesOneOf1Certificate_type = quitStakePoolResponseBody202CertificatesOneOf1Certificate_type,
                                                                                                                                                                                                                                   quitStakePoolResponseBody202CertificatesOneOf1Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                   quitStakePoolResponseBody202CertificatesOneOf1Reward_account_path = quitStakePoolResponseBody202CertificatesOneOf1Reward_account_path}
-- | Defines the enum schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202CertificatesOneOf1Certificate_type =
   QuitStakePoolResponseBody202CertificatesOneOf1Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | QuitStakePoolResponseBody202CertificatesOneOf1Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | QuitStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | QuitStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | QuitStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202CertificatesOneOf1Certificate_type
    where toJSON (QuitStakePoolResponseBody202CertificatesOneOf1Certificate_typeOther val) = val
          toJSON (QuitStakePoolResponseBody202CertificatesOneOf1Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (QuitStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool) = "join_pool"
          toJSON (QuitStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (QuitStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202CertificatesOneOf1Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> QuitStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> QuitStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> QuitStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> QuitStakePoolResponseBody202CertificatesOneOf1Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate not belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data QuitStakePoolResponseBody202CertificatesOneOf2 = QuitStakePoolResponseBody202CertificatesOneOf2 {
  -- | certificate_type
  quitStakePoolResponseBody202CertificatesOneOf2Certificate_type :: QuitStakePoolResponseBody202CertificatesOneOf2Certificate_type
  -- | pool: A unique identifier for the pool.
  , quitStakePoolResponseBody202CertificatesOneOf2Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account
  , quitStakePoolResponseBody202CertificatesOneOf2Reward_account :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202CertificatesOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf2Reward_account obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf2Reward_account obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202CertificatesOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202CertificatesOneOf2" (\obj -> ((GHC.Base.pure QuitStakePoolResponseBody202CertificatesOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account"))
-- | Create a new 'QuitStakePoolResponseBody202CertificatesOneOf2' with all required fields.
mkQuitStakePoolResponseBody202CertificatesOneOf2 :: QuitStakePoolResponseBody202CertificatesOneOf2Certificate_type -- ^ 'quitStakePoolResponseBody202CertificatesOneOf2Certificate_type'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202CertificatesOneOf2Reward_account'
  -> QuitStakePoolResponseBody202CertificatesOneOf2
mkQuitStakePoolResponseBody202CertificatesOneOf2 quitStakePoolResponseBody202CertificatesOneOf2Certificate_type quitStakePoolResponseBody202CertificatesOneOf2Reward_account = QuitStakePoolResponseBody202CertificatesOneOf2{quitStakePoolResponseBody202CertificatesOneOf2Certificate_type = quitStakePoolResponseBody202CertificatesOneOf2Certificate_type,
                                                                                                                                                                                                                              quitStakePoolResponseBody202CertificatesOneOf2Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                              quitStakePoolResponseBody202CertificatesOneOf2Reward_account = quitStakePoolResponseBody202CertificatesOneOf2Reward_account}
-- | Defines the enum schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202CertificatesOneOf2Certificate_type =
   QuitStakePoolResponseBody202CertificatesOneOf2Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | QuitStakePoolResponseBody202CertificatesOneOf2Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | QuitStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external -- ^ Represents the JSON value @"join_pool_external"@
  | QuitStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external -- ^ Represents the JSON value @"quit_pool_external"@
  | QuitStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external -- ^ Represents the JSON value @"register_reward_account_external"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202CertificatesOneOf2Certificate_type
    where toJSON (QuitStakePoolResponseBody202CertificatesOneOf2Certificate_typeOther val) = val
          toJSON (QuitStakePoolResponseBody202CertificatesOneOf2Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (QuitStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external) = "join_pool_external"
          toJSON (QuitStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external) = "quit_pool_external"
          toJSON (QuitStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external) = "register_reward_account_external"
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202CertificatesOneOf2Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool_external" -> QuitStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external
                                            | val GHC.Classes.== "quit_pool_external" -> QuitStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external
                                            | val GHC.Classes.== "register_reward_account_external" -> QuitStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external
                                            | GHC.Base.otherwise -> QuitStakePoolResponseBody202CertificatesOneOf2Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202CertificatesOneOf3 = QuitStakePoolResponseBody202CertificatesOneOf3 {
  -- | pool_cost: Estimated cost set by the pool operator when registering his pool.
  -- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  quitStakePoolResponseBody202CertificatesOneOf3Pool_cost :: QuitStakePoolResponseBody202CertificatesOneOf3Pool_cost
  -- | pool_id: A unique identifier for the pool.
  , quitStakePoolResponseBody202CertificatesOneOf3Pool_id :: Data.Text.Internal.Text
  -- | pool_margin: Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , quitStakePoolResponseBody202CertificatesOneOf3Pool_margin :: QuitStakePoolResponseBody202CertificatesOneOf3Pool_margin
  -- | pool_metadata
  , quitStakePoolResponseBody202CertificatesOneOf3Pool_metadata :: (GHC.Maybe.Maybe QuitStakePoolResponseBody202CertificatesOneOf3Pool_metadata)
  -- | pool_owners
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , quitStakePoolResponseBody202CertificatesOneOf3Pool_owners :: ([Data.Text.Internal.Text])
  -- | pool_pledge: Minimal stake amount that a stake pool is willing to honor.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , quitStakePoolResponseBody202CertificatesOneOf3Pool_pledge :: QuitStakePoolResponseBody202CertificatesOneOf3Pool_pledge
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202CertificatesOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202CertificatesOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202CertificatesOneOf3" (\obj -> (((((GHC.Base.pure QuitStakePoolResponseBody202CertificatesOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_cost")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_margin")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool_metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_owners")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_pledge"))
-- | Create a new 'QuitStakePoolResponseBody202CertificatesOneOf3' with all required fields.
mkQuitStakePoolResponseBody202CertificatesOneOf3 :: QuitStakePoolResponseBody202CertificatesOneOf3Pool_cost -- ^ 'quitStakePoolResponseBody202CertificatesOneOf3Pool_cost'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202CertificatesOneOf3Pool_id'
  -> QuitStakePoolResponseBody202CertificatesOneOf3Pool_margin -- ^ 'quitStakePoolResponseBody202CertificatesOneOf3Pool_margin'
  -> [Data.Text.Internal.Text] -- ^ 'quitStakePoolResponseBody202CertificatesOneOf3Pool_owners'
  -> QuitStakePoolResponseBody202CertificatesOneOf3Pool_pledge -- ^ 'quitStakePoolResponseBody202CertificatesOneOf3Pool_pledge'
  -> QuitStakePoolResponseBody202CertificatesOneOf3
mkQuitStakePoolResponseBody202CertificatesOneOf3 quitStakePoolResponseBody202CertificatesOneOf3Pool_cost quitStakePoolResponseBody202CertificatesOneOf3Pool_id quitStakePoolResponseBody202CertificatesOneOf3Pool_margin quitStakePoolResponseBody202CertificatesOneOf3Pool_owners quitStakePoolResponseBody202CertificatesOneOf3Pool_pledge = QuitStakePoolResponseBody202CertificatesOneOf3{quitStakePoolResponseBody202CertificatesOneOf3Pool_cost = quitStakePoolResponseBody202CertificatesOneOf3Pool_cost,
                                                                                                                                                                                                                                                                                                                                                                                              quitStakePoolResponseBody202CertificatesOneOf3Pool_id = quitStakePoolResponseBody202CertificatesOneOf3Pool_id,
                                                                                                                                                                                                                                                                                                                                                                                              quitStakePoolResponseBody202CertificatesOneOf3Pool_margin = quitStakePoolResponseBody202CertificatesOneOf3Pool_margin,
                                                                                                                                                                                                                                                                                                                                                                                              quitStakePoolResponseBody202CertificatesOneOf3Pool_metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                              quitStakePoolResponseBody202CertificatesOneOf3Pool_owners = quitStakePoolResponseBody202CertificatesOneOf3Pool_owners,
                                                                                                                                                                                                                                                                                                                                                                                              quitStakePoolResponseBody202CertificatesOneOf3Pool_pledge = quitStakePoolResponseBody202CertificatesOneOf3Pool_pledge}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_cost@ in the specification.
-- 
-- Estimated cost set by the pool operator when registering his pool.
-- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data QuitStakePoolResponseBody202CertificatesOneOf3Pool_cost = QuitStakePoolResponseBody202CertificatesOneOf3Pool_cost {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202CertificatesOneOf3Pool_costQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202CertificatesOneOf3Pool_cost
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202CertificatesOneOf3Pool_cost
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202CertificatesOneOf3Pool_cost" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202CertificatesOneOf3Pool_cost GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202CertificatesOneOf3Pool_cost' with all required fields.
mkQuitStakePoolResponseBody202CertificatesOneOf3Pool_cost :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202CertificatesOneOf3Pool_costQuantity'
  -> QuitStakePoolResponseBody202CertificatesOneOf3Pool_cost
mkQuitStakePoolResponseBody202CertificatesOneOf3Pool_cost quitStakePoolResponseBody202CertificatesOneOf3Pool_costQuantity = QuitStakePoolResponseBody202CertificatesOneOf3Pool_cost{quitStakePoolResponseBody202CertificatesOneOf3Pool_costQuantity = quitStakePoolResponseBody202CertificatesOneOf3Pool_costQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_margin@ in the specification.
-- 
-- Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data QuitStakePoolResponseBody202CertificatesOneOf3Pool_margin = QuitStakePoolResponseBody202CertificatesOneOf3Pool_margin {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202CertificatesOneOf3Pool_marginQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202CertificatesOneOf3Pool_margin
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202CertificatesOneOf3Pool_margin
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202CertificatesOneOf3Pool_margin" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202CertificatesOneOf3Pool_margin GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202CertificatesOneOf3Pool_margin' with all required fields.
mkQuitStakePoolResponseBody202CertificatesOneOf3Pool_margin :: GHC.Types.Double -- ^ 'quitStakePoolResponseBody202CertificatesOneOf3Pool_marginQuantity'
  -> QuitStakePoolResponseBody202CertificatesOneOf3Pool_margin
mkQuitStakePoolResponseBody202CertificatesOneOf3Pool_margin quitStakePoolResponseBody202CertificatesOneOf3Pool_marginQuantity = QuitStakePoolResponseBody202CertificatesOneOf3Pool_margin{quitStakePoolResponseBody202CertificatesOneOf3Pool_marginQuantity = quitStakePoolResponseBody202CertificatesOneOf3Pool_marginQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_metadata@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202CertificatesOneOf3Pool_metadata = QuitStakePoolResponseBody202CertificatesOneOf3Pool_metadata {
  -- | hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  quitStakePoolResponseBody202CertificatesOneOf3Pool_metadataHash :: Data.Text.Internal.Text
  -- | url: A URL to the stake pool\'s website.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 250
  -- * Must match pattern \'^https:\/\/.+\'
  , quitStakePoolResponseBody202CertificatesOneOf3Pool_metadataUrl :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202CertificatesOneOf3Pool_metadata
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202CertificatesOneOf3Pool_metadata
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202CertificatesOneOf3Pool_metadata" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202CertificatesOneOf3Pool_metadata GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))
-- | Create a new 'QuitStakePoolResponseBody202CertificatesOneOf3Pool_metadata' with all required fields.
mkQuitStakePoolResponseBody202CertificatesOneOf3Pool_metadata :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202CertificatesOneOf3Pool_metadataHash'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202CertificatesOneOf3Pool_metadataUrl'
  -> QuitStakePoolResponseBody202CertificatesOneOf3Pool_metadata
mkQuitStakePoolResponseBody202CertificatesOneOf3Pool_metadata quitStakePoolResponseBody202CertificatesOneOf3Pool_metadataHash quitStakePoolResponseBody202CertificatesOneOf3Pool_metadataUrl = QuitStakePoolResponseBody202CertificatesOneOf3Pool_metadata{quitStakePoolResponseBody202CertificatesOneOf3Pool_metadataHash = quitStakePoolResponseBody202CertificatesOneOf3Pool_metadataHash,
                                                                                                                                                                                                                                                           quitStakePoolResponseBody202CertificatesOneOf3Pool_metadataUrl = quitStakePoolResponseBody202CertificatesOneOf3Pool_metadataUrl}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_pledge@ in the specification.
-- 
-- Minimal stake amount that a stake pool is willing to honor.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data QuitStakePoolResponseBody202CertificatesOneOf3Pool_pledge = QuitStakePoolResponseBody202CertificatesOneOf3Pool_pledge {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202CertificatesOneOf3Pool_pledgeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202CertificatesOneOf3Pool_pledge
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202CertificatesOneOf3Pool_pledge
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202CertificatesOneOf3Pool_pledge" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202CertificatesOneOf3Pool_pledge GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202CertificatesOneOf3Pool_pledge' with all required fields.
mkQuitStakePoolResponseBody202CertificatesOneOf3Pool_pledge :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202CertificatesOneOf3Pool_pledgeQuantity'
  -> QuitStakePoolResponseBody202CertificatesOneOf3Pool_pledge
mkQuitStakePoolResponseBody202CertificatesOneOf3Pool_pledge quitStakePoolResponseBody202CertificatesOneOf3Pool_pledgeQuantity = QuitStakePoolResponseBody202CertificatesOneOf3Pool_pledge{quitStakePoolResponseBody202CertificatesOneOf3Pool_pledgeQuantity = quitStakePoolResponseBody202CertificatesOneOf3Pool_pledgeQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202CertificatesOneOf4 = QuitStakePoolResponseBody202CertificatesOneOf4 {
  -- | pool_id: A unique identifier for the pool.
  quitStakePoolResponseBody202CertificatesOneOf4Pool_id :: Data.Text.Internal.Text
  -- | retirement_epoch: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202CertificatesOneOf4Retirement_epoch :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202CertificatesOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202CertificatesOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202CertificatesOneOf4" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202CertificatesOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "retirement_epoch"))
-- | Create a new 'QuitStakePoolResponseBody202CertificatesOneOf4' with all required fields.
mkQuitStakePoolResponseBody202CertificatesOneOf4 :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202CertificatesOneOf4Pool_id'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202CertificatesOneOf4Retirement_epoch'
  -> QuitStakePoolResponseBody202CertificatesOneOf4
mkQuitStakePoolResponseBody202CertificatesOneOf4 quitStakePoolResponseBody202CertificatesOneOf4Pool_id quitStakePoolResponseBody202CertificatesOneOf4Retirement_epoch = QuitStakePoolResponseBody202CertificatesOneOf4{quitStakePoolResponseBody202CertificatesOneOf4Pool_id = quitStakePoolResponseBody202CertificatesOneOf4Pool_id,
                                                                                                                                                                                                                       quitStakePoolResponseBody202CertificatesOneOf4Retirement_epoch = quitStakePoolResponseBody202CertificatesOneOf4Retirement_epoch}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202CertificatesOneOf5 = QuitStakePoolResponseBody202CertificatesOneOf5 {
  -- | certificate_type
  quitStakePoolResponseBody202CertificatesOneOf5Certificate_type :: QuitStakePoolResponseBody202CertificatesOneOf5Certificate_type
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202CertificatesOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202CertificatesOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202CertificatesOneOf5" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202CertificatesOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type"))
-- | Create a new 'QuitStakePoolResponseBody202CertificatesOneOf5' with all required fields.
mkQuitStakePoolResponseBody202CertificatesOneOf5 :: QuitStakePoolResponseBody202CertificatesOneOf5Certificate_type -- ^ 'quitStakePoolResponseBody202CertificatesOneOf5Certificate_type'
  -> QuitStakePoolResponseBody202CertificatesOneOf5
mkQuitStakePoolResponseBody202CertificatesOneOf5 quitStakePoolResponseBody202CertificatesOneOf5Certificate_type = QuitStakePoolResponseBody202CertificatesOneOf5{quitStakePoolResponseBody202CertificatesOneOf5Certificate_type = quitStakePoolResponseBody202CertificatesOneOf5Certificate_type}
-- | Defines the enum schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202CertificatesOneOf5Certificate_type =
   QuitStakePoolResponseBody202CertificatesOneOf5Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | QuitStakePoolResponseBody202CertificatesOneOf5Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | QuitStakePoolResponseBody202CertificatesOneOf5Certificate_typeEnumMir -- ^ Represents the JSON value @"mir"@
  | QuitStakePoolResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis -- ^ Represents the JSON value @"genesis"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202CertificatesOneOf5Certificate_type
    where toJSON (QuitStakePoolResponseBody202CertificatesOneOf5Certificate_typeOther val) = val
          toJSON (QuitStakePoolResponseBody202CertificatesOneOf5Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (QuitStakePoolResponseBody202CertificatesOneOf5Certificate_typeEnumMir) = "mir"
          toJSON (QuitStakePoolResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis) = "genesis"
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202CertificatesOneOf5Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "mir" -> QuitStakePoolResponseBody202CertificatesOneOf5Certificate_typeEnumMir
                                            | val GHC.Classes.== "genesis" -> QuitStakePoolResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis
                                            | GHC.Base.otherwise -> QuitStakePoolResponseBody202CertificatesOneOf5Certificate_typeOther val)
-- | Defines the oneOf schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- Any certificate that could occur in an arbitrary transaction:
-- might be related to delegation, pool activities, genesis or MIR.
data QuitStakePoolResponseBody202CertificatesVariants =
   QuitStakePoolResponseBody202CertificatesVariant1 QuitStakePoolResponseBody202CertificatesOneOf1
  | QuitStakePoolResponseBody202CertificatesVariant2 QuitStakePoolResponseBody202CertificatesOneOf2
  | QuitStakePoolResponseBody202CertificatesVariant3 QuitStakePoolResponseBody202CertificatesOneOf3
  | QuitStakePoolResponseBody202CertificatesVariant4 QuitStakePoolResponseBody202CertificatesOneOf4
  | QuitStakePoolResponseBody202CertificatesVariant5 QuitStakePoolResponseBody202CertificatesOneOf5
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202CertificatesVariants
    where toJSON (QuitStakePoolResponseBody202CertificatesVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202CertificatesVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202CertificatesVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202CertificatesVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202CertificatesVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202CertificatesVariants
    where parseJSON val = case (QuitStakePoolResponseBody202CertificatesVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202CertificatesVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202CertificatesVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202CertificatesVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202CertificatesVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.collateral.items@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202Collateral = QuitStakePoolResponseBody202Collateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  quitStakePoolResponseBody202CollateralAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , quitStakePoolResponseBody202CollateralAmount :: (GHC.Maybe.Maybe QuitStakePoolResponseBody202CollateralAmount)
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , quitStakePoolResponseBody202CollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202CollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Collateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Collateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Collateral" (\obj -> (((GHC.Base.pure QuitStakePoolResponseBody202Collateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'QuitStakePoolResponseBody202Collateral' with all required fields.
mkQuitStakePoolResponseBody202Collateral :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202CollateralId'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202CollateralIndex'
  -> QuitStakePoolResponseBody202Collateral
mkQuitStakePoolResponseBody202Collateral quitStakePoolResponseBody202CollateralId quitStakePoolResponseBody202CollateralIndex = QuitStakePoolResponseBody202Collateral{quitStakePoolResponseBody202CollateralAddress = GHC.Maybe.Nothing,
                                                                                                                                                                       quitStakePoolResponseBody202CollateralAmount = GHC.Maybe.Nothing,
                                                                                                                                                                       quitStakePoolResponseBody202CollateralId = quitStakePoolResponseBody202CollateralId,
                                                                                                                                                                       quitStakePoolResponseBody202CollateralIndex = quitStakePoolResponseBody202CollateralIndex}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data QuitStakePoolResponseBody202CollateralAmount = QuitStakePoolResponseBody202CollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202CollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202CollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202CollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202CollateralAmount" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202CollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202CollateralAmount' with all required fields.
mkQuitStakePoolResponseBody202CollateralAmount :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202CollateralAmountQuantity'
  -> QuitStakePoolResponseBody202CollateralAmount
mkQuitStakePoolResponseBody202CollateralAmount quitStakePoolResponseBody202CollateralAmountQuantity = QuitStakePoolResponseBody202CollateralAmount{quitStakePoolResponseBody202CollateralAmountQuantity = quitStakePoolResponseBody202CollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.collateral_outputs.items@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202Collateral_outputs = QuitStakePoolResponseBody202Collateral_outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  quitStakePoolResponseBody202Collateral_outputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , quitStakePoolResponseBody202Collateral_outputsAmount :: QuitStakePoolResponseBody202Collateral_outputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , quitStakePoolResponseBody202Collateral_outputsAssets :: (GHC.Maybe.Maybe ([QuitStakePoolResponseBody202Collateral_outputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Collateral_outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Collateral_outputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202Collateral_outputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Collateral_outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Collateral_outputs" (\obj -> ((GHC.Base.pure QuitStakePoolResponseBody202Collateral_outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'QuitStakePoolResponseBody202Collateral_outputs' with all required fields.
mkQuitStakePoolResponseBody202Collateral_outputs :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202Collateral_outputsAddress'
  -> QuitStakePoolResponseBody202Collateral_outputsAmount -- ^ 'quitStakePoolResponseBody202Collateral_outputsAmount'
  -> QuitStakePoolResponseBody202Collateral_outputs
mkQuitStakePoolResponseBody202Collateral_outputs quitStakePoolResponseBody202Collateral_outputsAddress quitStakePoolResponseBody202Collateral_outputsAmount = QuitStakePoolResponseBody202Collateral_outputs{quitStakePoolResponseBody202Collateral_outputsAddress = quitStakePoolResponseBody202Collateral_outputsAddress,
                                                                                                                                                                                                             quitStakePoolResponseBody202Collateral_outputsAmount = quitStakePoolResponseBody202Collateral_outputsAmount,
                                                                                                                                                                                                             quitStakePoolResponseBody202Collateral_outputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.collateral_outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data QuitStakePoolResponseBody202Collateral_outputsAmount = QuitStakePoolResponseBody202Collateral_outputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202Collateral_outputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Collateral_outputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Collateral_outputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Collateral_outputsAmount" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202Collateral_outputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202Collateral_outputsAmount' with all required fields.
mkQuitStakePoolResponseBody202Collateral_outputsAmount :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Collateral_outputsAmountQuantity'
  -> QuitStakePoolResponseBody202Collateral_outputsAmount
mkQuitStakePoolResponseBody202Collateral_outputsAmount quitStakePoolResponseBody202Collateral_outputsAmountQuantity = QuitStakePoolResponseBody202Collateral_outputsAmount{quitStakePoolResponseBody202Collateral_outputsAmountQuantity = quitStakePoolResponseBody202Collateral_outputsAmountQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.collateral_outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data QuitStakePoolResponseBody202Collateral_outputsAssets = QuitStakePoolResponseBody202Collateral_outputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  quitStakePoolResponseBody202Collateral_outputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , quitStakePoolResponseBody202Collateral_outputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202Collateral_outputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Collateral_outputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Collateral_outputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Collateral_outputsAssets" (\obj -> ((GHC.Base.pure QuitStakePoolResponseBody202Collateral_outputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202Collateral_outputsAssets' with all required fields.
mkQuitStakePoolResponseBody202Collateral_outputsAssets :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202Collateral_outputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202Collateral_outputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Collateral_outputsAssetsQuantity'
  -> QuitStakePoolResponseBody202Collateral_outputsAssets
mkQuitStakePoolResponseBody202Collateral_outputsAssets quitStakePoolResponseBody202Collateral_outputsAssetsAsset_name quitStakePoolResponseBody202Collateral_outputsAssetsPolicy_id quitStakePoolResponseBody202Collateral_outputsAssetsQuantity = QuitStakePoolResponseBody202Collateral_outputsAssets{quitStakePoolResponseBody202Collateral_outputsAssetsAsset_name = quitStakePoolResponseBody202Collateral_outputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                        quitStakePoolResponseBody202Collateral_outputsAssetsPolicy_id = quitStakePoolResponseBody202Collateral_outputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                        quitStakePoolResponseBody202Collateral_outputsAssetsQuantity = quitStakePoolResponseBody202Collateral_outputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.deposit_returned@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data QuitStakePoolResponseBody202Deposit_returned = QuitStakePoolResponseBody202Deposit_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202Deposit_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Deposit_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Deposit_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Deposit_returned" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202Deposit_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202Deposit_returned' with all required fields.
mkQuitStakePoolResponseBody202Deposit_returned :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Deposit_returnedQuantity'
  -> QuitStakePoolResponseBody202Deposit_returned
mkQuitStakePoolResponseBody202Deposit_returned quitStakePoolResponseBody202Deposit_returnedQuantity = QuitStakePoolResponseBody202Deposit_returned{quitStakePoolResponseBody202Deposit_returnedQuantity = quitStakePoolResponseBody202Deposit_returnedQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.deposit_taken@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data QuitStakePoolResponseBody202Deposit_taken = QuitStakePoolResponseBody202Deposit_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202Deposit_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Deposit_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Deposit_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Deposit_taken" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202Deposit_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202Deposit_taken' with all required fields.
mkQuitStakePoolResponseBody202Deposit_taken :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Deposit_takenQuantity'
  -> QuitStakePoolResponseBody202Deposit_taken
mkQuitStakePoolResponseBody202Deposit_taken quitStakePoolResponseBody202Deposit_takenQuantity = QuitStakePoolResponseBody202Deposit_taken{quitStakePoolResponseBody202Deposit_takenQuantity = quitStakePoolResponseBody202Deposit_takenQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.depth@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Current depth of the transaction in the local chain
data QuitStakePoolResponseBody202Depth = QuitStakePoolResponseBody202Depth {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202DepthQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Depth
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Depth
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Depth" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202Depth GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202Depth' with all required fields.
mkQuitStakePoolResponseBody202Depth :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202DepthQuantity'
  -> QuitStakePoolResponseBody202Depth
mkQuitStakePoolResponseBody202Depth quitStakePoolResponseBody202DepthQuantity = QuitStakePoolResponseBody202Depth{quitStakePoolResponseBody202DepthQuantity = quitStakePoolResponseBody202DepthQuantity}
-- | Defines the enum schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.direction@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202Direction =
   QuitStakePoolResponseBody202DirectionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | QuitStakePoolResponseBody202DirectionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | QuitStakePoolResponseBody202DirectionEnumOutgoing -- ^ Represents the JSON value @"outgoing"@
  | QuitStakePoolResponseBody202DirectionEnumIncoming -- ^ Represents the JSON value @"incoming"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Direction
    where toJSON (QuitStakePoolResponseBody202DirectionOther val) = val
          toJSON (QuitStakePoolResponseBody202DirectionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (QuitStakePoolResponseBody202DirectionEnumOutgoing) = "outgoing"
          toJSON (QuitStakePoolResponseBody202DirectionEnumIncoming) = "incoming"
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Direction
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "outgoing" -> QuitStakePoolResponseBody202DirectionEnumOutgoing
                                            | val GHC.Classes.== "incoming" -> QuitStakePoolResponseBody202DirectionEnumIncoming
                                            | GHC.Base.otherwise -> QuitStakePoolResponseBody202DirectionOther val)
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.expires_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending OR status == expired
-- \<\/span>\<br\/>
-- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
data QuitStakePoolResponseBody202Expires_at = QuitStakePoolResponseBody202Expires_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202Expires_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202Expires_atEpoch_number :: GHC.Types.Int
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202Expires_atSlot_number :: GHC.Types.Int
  -- | time
  , quitStakePoolResponseBody202Expires_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Expires_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Expires_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Expires_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Expires_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Expires_at" (\obj -> (((GHC.Base.pure QuitStakePoolResponseBody202Expires_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'QuitStakePoolResponseBody202Expires_at' with all required fields.
mkQuitStakePoolResponseBody202Expires_at :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Expires_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Expires_atEpoch_number'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Expires_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202Expires_atTime'
  -> QuitStakePoolResponseBody202Expires_at
mkQuitStakePoolResponseBody202Expires_at quitStakePoolResponseBody202Expires_atAbsolute_slot_number quitStakePoolResponseBody202Expires_atEpoch_number quitStakePoolResponseBody202Expires_atSlot_number quitStakePoolResponseBody202Expires_atTime = QuitStakePoolResponseBody202Expires_at{quitStakePoolResponseBody202Expires_atAbsolute_slot_number = quitStakePoolResponseBody202Expires_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                             quitStakePoolResponseBody202Expires_atEpoch_number = quitStakePoolResponseBody202Expires_atEpoch_number,
                                                                                                                                                                                                                                                                                             quitStakePoolResponseBody202Expires_atSlot_number = quitStakePoolResponseBody202Expires_atSlot_number,
                                                                                                                                                                                                                                                                                             quitStakePoolResponseBody202Expires_atTime = quitStakePoolResponseBody202Expires_atTime}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.fee@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data QuitStakePoolResponseBody202Fee = QuitStakePoolResponseBody202Fee {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202FeeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Fee
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Fee
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Fee" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202Fee GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202Fee' with all required fields.
mkQuitStakePoolResponseBody202Fee :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202FeeQuantity'
  -> QuitStakePoolResponseBody202Fee
mkQuitStakePoolResponseBody202Fee quitStakePoolResponseBody202FeeQuantity = QuitStakePoolResponseBody202Fee{quitStakePoolResponseBody202FeeQuantity = quitStakePoolResponseBody202FeeQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.inputs.items@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202Inputs = QuitStakePoolResponseBody202Inputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  quitStakePoolResponseBody202InputsAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , quitStakePoolResponseBody202InputsAmount :: (GHC.Maybe.Maybe QuitStakePoolResponseBody202InputsAmount)
  -- | assets: A flat list of assets (possibly empty).
  , quitStakePoolResponseBody202InputsAssets :: (GHC.Maybe.Maybe ([QuitStakePoolResponseBody202InputsAssets]))
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , quitStakePoolResponseBody202InputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202InputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Inputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202InputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202InputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Inputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Inputs" (\obj -> ((((GHC.Base.pure QuitStakePoolResponseBody202Inputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'QuitStakePoolResponseBody202Inputs' with all required fields.
mkQuitStakePoolResponseBody202Inputs :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202InputsId'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202InputsIndex'
  -> QuitStakePoolResponseBody202Inputs
mkQuitStakePoolResponseBody202Inputs quitStakePoolResponseBody202InputsId quitStakePoolResponseBody202InputsIndex = QuitStakePoolResponseBody202Inputs{quitStakePoolResponseBody202InputsAddress = GHC.Maybe.Nothing,
                                                                                                                                                       quitStakePoolResponseBody202InputsAmount = GHC.Maybe.Nothing,
                                                                                                                                                       quitStakePoolResponseBody202InputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                       quitStakePoolResponseBody202InputsId = quitStakePoolResponseBody202InputsId,
                                                                                                                                                       quitStakePoolResponseBody202InputsIndex = quitStakePoolResponseBody202InputsIndex}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data QuitStakePoolResponseBody202InputsAmount = QuitStakePoolResponseBody202InputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202InputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202InputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202InputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202InputsAmount" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202InputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202InputsAmount' with all required fields.
mkQuitStakePoolResponseBody202InputsAmount :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202InputsAmountQuantity'
  -> QuitStakePoolResponseBody202InputsAmount
mkQuitStakePoolResponseBody202InputsAmount quitStakePoolResponseBody202InputsAmountQuantity = QuitStakePoolResponseBody202InputsAmount{quitStakePoolResponseBody202InputsAmountQuantity = quitStakePoolResponseBody202InputsAmountQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data QuitStakePoolResponseBody202InputsAssets = QuitStakePoolResponseBody202InputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  quitStakePoolResponseBody202InputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , quitStakePoolResponseBody202InputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202InputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202InputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202InputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202InputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202InputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202InputsAssets" (\obj -> ((GHC.Base.pure QuitStakePoolResponseBody202InputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202InputsAssets' with all required fields.
mkQuitStakePoolResponseBody202InputsAssets :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202InputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202InputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202InputsAssetsQuantity'
  -> QuitStakePoolResponseBody202InputsAssets
mkQuitStakePoolResponseBody202InputsAssets quitStakePoolResponseBody202InputsAssetsAsset_name quitStakePoolResponseBody202InputsAssetsPolicy_id quitStakePoolResponseBody202InputsAssetsQuantity = QuitStakePoolResponseBody202InputsAssets{quitStakePoolResponseBody202InputsAssetsAsset_name = quitStakePoolResponseBody202InputsAssetsAsset_name,
                                                                                                                                                                                                                                            quitStakePoolResponseBody202InputsAssetsPolicy_id = quitStakePoolResponseBody202InputsAssetsPolicy_id,
                                                                                                                                                                                                                                            quitStakePoolResponseBody202InputsAssetsQuantity = quitStakePoolResponseBody202InputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.inserted_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Absolute time at which the transaction was inserted in a block.
data QuitStakePoolResponseBody202Inserted_at = QuitStakePoolResponseBody202Inserted_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202Inserted_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202Inserted_atEpoch_number :: GHC.Types.Int
  -- | height
  , quitStakePoolResponseBody202Inserted_atHeight :: QuitStakePoolResponseBody202Inserted_atHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202Inserted_atSlot_number :: GHC.Types.Int
  -- | time
  , quitStakePoolResponseBody202Inserted_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Inserted_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Inserted_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Inserted_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Inserted_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Inserted_at" (\obj -> ((((GHC.Base.pure QuitStakePoolResponseBody202Inserted_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'QuitStakePoolResponseBody202Inserted_at' with all required fields.
mkQuitStakePoolResponseBody202Inserted_at :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Inserted_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Inserted_atEpoch_number'
  -> QuitStakePoolResponseBody202Inserted_atHeight -- ^ 'quitStakePoolResponseBody202Inserted_atHeight'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Inserted_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202Inserted_atTime'
  -> QuitStakePoolResponseBody202Inserted_at
mkQuitStakePoolResponseBody202Inserted_at quitStakePoolResponseBody202Inserted_atAbsolute_slot_number quitStakePoolResponseBody202Inserted_atEpoch_number quitStakePoolResponseBody202Inserted_atHeight quitStakePoolResponseBody202Inserted_atSlot_number quitStakePoolResponseBody202Inserted_atTime = QuitStakePoolResponseBody202Inserted_at{quitStakePoolResponseBody202Inserted_atAbsolute_slot_number = quitStakePoolResponseBody202Inserted_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                 quitStakePoolResponseBody202Inserted_atEpoch_number = quitStakePoolResponseBody202Inserted_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                                 quitStakePoolResponseBody202Inserted_atHeight = quitStakePoolResponseBody202Inserted_atHeight,
                                                                                                                                                                                                                                                                                                                                                 quitStakePoolResponseBody202Inserted_atSlot_number = quitStakePoolResponseBody202Inserted_atSlot_number,
                                                                                                                                                                                                                                                                                                                                                 quitStakePoolResponseBody202Inserted_atTime = quitStakePoolResponseBody202Inserted_atTime}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.inserted_at.properties.height@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202Inserted_atHeight = QuitStakePoolResponseBody202Inserted_atHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202Inserted_atHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Inserted_atHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Inserted_atHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Inserted_atHeight" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202Inserted_atHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202Inserted_atHeight' with all required fields.
mkQuitStakePoolResponseBody202Inserted_atHeight :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Inserted_atHeightQuantity'
  -> QuitStakePoolResponseBody202Inserted_atHeight
mkQuitStakePoolResponseBody202Inserted_atHeight quitStakePoolResponseBody202Inserted_atHeightQuantity = QuitStakePoolResponseBody202Inserted_atHeight{quitStakePoolResponseBody202Inserted_atHeightQuantity = quitStakePoolResponseBody202Inserted_atHeightQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202Mint = QuitStakePoolResponseBody202Mint {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  quitStakePoolResponseBody202MintTokens :: ([QuitStakePoolResponseBody202MintTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , quitStakePoolResponseBody202MintWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , quitStakePoolResponseBody202MintWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Mint
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202MintWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202MintWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Mint
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Mint" (\obj -> ((GHC.Base.pure QuitStakePoolResponseBody202Mint GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'QuitStakePoolResponseBody202Mint' with all required fields.
mkQuitStakePoolResponseBody202Mint :: [QuitStakePoolResponseBody202MintTokens] -- ^ 'quitStakePoolResponseBody202MintTokens'
  -> QuitStakePoolResponseBody202Mint
mkQuitStakePoolResponseBody202Mint quitStakePoolResponseBody202MintTokens = QuitStakePoolResponseBody202Mint{quitStakePoolResponseBody202MintTokens = quitStakePoolResponseBody202MintTokens,
                                                                                                             quitStakePoolResponseBody202MintWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                             quitStakePoolResponseBody202MintWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202MintTokens = QuitStakePoolResponseBody202MintTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  quitStakePoolResponseBody202MintTokensAssets :: ([QuitStakePoolResponseBody202MintTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , quitStakePoolResponseBody202MintTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , quitStakePoolResponseBody202MintTokensPolicy_script :: QuitStakePoolResponseBody202MintTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202MintTokens" (\obj -> ((GHC.Base.pure QuitStakePoolResponseBody202MintTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'QuitStakePoolResponseBody202MintTokens' with all required fields.
mkQuitStakePoolResponseBody202MintTokens :: [QuitStakePoolResponseBody202MintTokensAssets] -- ^ 'quitStakePoolResponseBody202MintTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_id'
  -> QuitStakePoolResponseBody202MintTokensPolicy_scriptVariants -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_script'
  -> QuitStakePoolResponseBody202MintTokens
mkQuitStakePoolResponseBody202MintTokens quitStakePoolResponseBody202MintTokensAssets quitStakePoolResponseBody202MintTokensPolicy_id quitStakePoolResponseBody202MintTokensPolicy_script = QuitStakePoolResponseBody202MintTokens{quitStakePoolResponseBody202MintTokensAssets = quitStakePoolResponseBody202MintTokensAssets,
                                                                                                                                                                                                                                   quitStakePoolResponseBody202MintTokensPolicy_id = quitStakePoolResponseBody202MintTokensPolicy_id,
                                                                                                                                                                                                                                   quitStakePoolResponseBody202MintTokensPolicy_script = quitStakePoolResponseBody202MintTokensPolicy_script}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202MintTokensAssets = QuitStakePoolResponseBody202MintTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  quitStakePoolResponseBody202MintTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , quitStakePoolResponseBody202MintTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202MintTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202MintTokensAssets" (\obj -> ((GHC.Base.pure QuitStakePoolResponseBody202MintTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202MintTokensAssets' with all required fields.
mkQuitStakePoolResponseBody202MintTokensAssets :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202MintTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202MintTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202MintTokensAssetsQuantity'
  -> QuitStakePoolResponseBody202MintTokensAssets
mkQuitStakePoolResponseBody202MintTokensAssets quitStakePoolResponseBody202MintTokensAssetsAsset_name quitStakePoolResponseBody202MintTokensAssetsFingerprint quitStakePoolResponseBody202MintTokensAssetsQuantity = QuitStakePoolResponseBody202MintTokensAssets{quitStakePoolResponseBody202MintTokensAssetsAsset_name = quitStakePoolResponseBody202MintTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                  quitStakePoolResponseBody202MintTokensAssetsFingerprint = quitStakePoolResponseBody202MintTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                  quitStakePoolResponseBody202MintTokensAssetsQuantity = quitStakePoolResponseBody202MintTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1 = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference)
  -- | script
  , quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Script :: QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1' with all required fields.
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1 :: QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Script'
  -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1 quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Script = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1{quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                        quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Script = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference' with all required fields.
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex'
  -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference{quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                       quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2{quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3{quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 :: QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4{quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some{quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                        quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5{quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6{quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants =
   QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
  | QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
  | QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
  | QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
  | QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2 = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info :: QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2' with all required fields.
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2 :: QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info'
  -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2 quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2{quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                             quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference' with all required fields.
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex'
  -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference{quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                       quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version :: QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info :: QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info{quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                   quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3 = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References :: ([QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3' with all required fields.
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3 :: [QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References] -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3Script_hash'
  -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3 quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3Script_hash = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3{quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                 quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3Script_hash = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References' with all required fields.
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex'
  -> QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References
mkQuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex = QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References{quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                           quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex = quitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202MintTokensPolicy_scriptVariants =
   QuitStakePoolResponseBody202MintTokensPolicy_scriptVariant1 QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf1
  | QuitStakePoolResponseBody202MintTokensPolicy_scriptVariant2 QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf2
  | QuitStakePoolResponseBody202MintTokensPolicy_scriptVariant3 QuitStakePoolResponseBody202MintTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptVariants
    where toJSON (QuitStakePoolResponseBody202MintTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202MintTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody202MintTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202MintTokensPolicy_scriptVariants
    where parseJSON val = case (QuitStakePoolResponseBody202MintTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202MintTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody202MintTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.outputs.items@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202Outputs = QuitStakePoolResponseBody202Outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  quitStakePoolResponseBody202OutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , quitStakePoolResponseBody202OutputsAmount :: QuitStakePoolResponseBody202OutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , quitStakePoolResponseBody202OutputsAssets :: (GHC.Maybe.Maybe ([QuitStakePoolResponseBody202OutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202OutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (quitStakePoolResponseBody202OutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Outputs" (\obj -> ((GHC.Base.pure QuitStakePoolResponseBody202Outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'QuitStakePoolResponseBody202Outputs' with all required fields.
mkQuitStakePoolResponseBody202Outputs :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202OutputsAddress'
  -> QuitStakePoolResponseBody202OutputsAmount -- ^ 'quitStakePoolResponseBody202OutputsAmount'
  -> QuitStakePoolResponseBody202Outputs
mkQuitStakePoolResponseBody202Outputs quitStakePoolResponseBody202OutputsAddress quitStakePoolResponseBody202OutputsAmount = QuitStakePoolResponseBody202Outputs{quitStakePoolResponseBody202OutputsAddress = quitStakePoolResponseBody202OutputsAddress,
                                                                                                                                                                 quitStakePoolResponseBody202OutputsAmount = quitStakePoolResponseBody202OutputsAmount,
                                                                                                                                                                 quitStakePoolResponseBody202OutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data QuitStakePoolResponseBody202OutputsAmount = QuitStakePoolResponseBody202OutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202OutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202OutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202OutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202OutputsAmount" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202OutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202OutputsAmount' with all required fields.
mkQuitStakePoolResponseBody202OutputsAmount :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202OutputsAmountQuantity'
  -> QuitStakePoolResponseBody202OutputsAmount
mkQuitStakePoolResponseBody202OutputsAmount quitStakePoolResponseBody202OutputsAmountQuantity = QuitStakePoolResponseBody202OutputsAmount{quitStakePoolResponseBody202OutputsAmountQuantity = quitStakePoolResponseBody202OutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data QuitStakePoolResponseBody202OutputsAssets = QuitStakePoolResponseBody202OutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  quitStakePoolResponseBody202OutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , quitStakePoolResponseBody202OutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202OutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202OutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202OutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202OutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202OutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202OutputsAssets" (\obj -> ((GHC.Base.pure QuitStakePoolResponseBody202OutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202OutputsAssets' with all required fields.
mkQuitStakePoolResponseBody202OutputsAssets :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202OutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202OutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202OutputsAssetsQuantity'
  -> QuitStakePoolResponseBody202OutputsAssets
mkQuitStakePoolResponseBody202OutputsAssets quitStakePoolResponseBody202OutputsAssetsAsset_name quitStakePoolResponseBody202OutputsAssetsPolicy_id quitStakePoolResponseBody202OutputsAssetsQuantity = QuitStakePoolResponseBody202OutputsAssets{quitStakePoolResponseBody202OutputsAssetsAsset_name = quitStakePoolResponseBody202OutputsAssetsAsset_name,
                                                                                                                                                                                                                                                 quitStakePoolResponseBody202OutputsAssetsPolicy_id = quitStakePoolResponseBody202OutputsAssetsPolicy_id,
                                                                                                                                                                                                                                                 quitStakePoolResponseBody202OutputsAssetsQuantity = quitStakePoolResponseBody202OutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.pending_since@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending
-- \<\/span>\<br\/>
-- The point in time at which a transaction became pending.
data QuitStakePoolResponseBody202Pending_since = QuitStakePoolResponseBody202Pending_since {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202Pending_sinceAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202Pending_sinceEpoch_number :: GHC.Types.Int
  -- | height
  , quitStakePoolResponseBody202Pending_sinceHeight :: QuitStakePoolResponseBody202Pending_sinceHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , quitStakePoolResponseBody202Pending_sinceSlot_number :: GHC.Types.Int
  -- | time
  , quitStakePoolResponseBody202Pending_sinceTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Pending_since
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Pending_sinceTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Pending_sinceTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Pending_since
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Pending_since" (\obj -> ((((GHC.Base.pure QuitStakePoolResponseBody202Pending_since GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'QuitStakePoolResponseBody202Pending_since' with all required fields.
mkQuitStakePoolResponseBody202Pending_since :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Pending_sinceAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Pending_sinceEpoch_number'
  -> QuitStakePoolResponseBody202Pending_sinceHeight -- ^ 'quitStakePoolResponseBody202Pending_sinceHeight'
  -> GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Pending_sinceSlot_number'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202Pending_sinceTime'
  -> QuitStakePoolResponseBody202Pending_since
mkQuitStakePoolResponseBody202Pending_since quitStakePoolResponseBody202Pending_sinceAbsolute_slot_number quitStakePoolResponseBody202Pending_sinceEpoch_number quitStakePoolResponseBody202Pending_sinceHeight quitStakePoolResponseBody202Pending_sinceSlot_number quitStakePoolResponseBody202Pending_sinceTime = QuitStakePoolResponseBody202Pending_since{quitStakePoolResponseBody202Pending_sinceAbsolute_slot_number = quitStakePoolResponseBody202Pending_sinceAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Pending_sinceEpoch_number = quitStakePoolResponseBody202Pending_sinceEpoch_number,
                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Pending_sinceHeight = quitStakePoolResponseBody202Pending_sinceHeight,
                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Pending_sinceSlot_number = quitStakePoolResponseBody202Pending_sinceSlot_number,
                                                                                                                                                                                                                                                                                                                                                               quitStakePoolResponseBody202Pending_sinceTime = quitStakePoolResponseBody202Pending_sinceTime}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.pending_since.properties.height@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202Pending_sinceHeight = QuitStakePoolResponseBody202Pending_sinceHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202Pending_sinceHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Pending_sinceHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Pending_sinceHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Pending_sinceHeight" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202Pending_sinceHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202Pending_sinceHeight' with all required fields.
mkQuitStakePoolResponseBody202Pending_sinceHeight :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Pending_sinceHeightQuantity'
  -> QuitStakePoolResponseBody202Pending_sinceHeight
mkQuitStakePoolResponseBody202Pending_sinceHeight quitStakePoolResponseBody202Pending_sinceHeightQuantity = QuitStakePoolResponseBody202Pending_sinceHeight{quitStakePoolResponseBody202Pending_sinceHeightQuantity = quitStakePoolResponseBody202Pending_sinceHeightQuantity}
-- | Defines the enum schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.script_validity@ in the specification.
-- 
-- Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
-- used in the transaction validated or not. Validity may be null if this
-- transaction was from an era that doesn\'t support phase-2 monetary policy
-- scripts, or is a pending transaction (we don\'t know if validation passed or
-- failed until the transaction hits the ledger).
data QuitStakePoolResponseBody202Script_validityNonNullable =
   QuitStakePoolResponseBody202Script_validityNonNullableOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | QuitStakePoolResponseBody202Script_validityNonNullableTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | QuitStakePoolResponseBody202Script_validityNonNullableEnumValid -- ^ Represents the JSON value @"valid"@
  | QuitStakePoolResponseBody202Script_validityNonNullableEnumInvalid -- ^ Represents the JSON value @"invalid"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Script_validityNonNullable
    where toJSON (QuitStakePoolResponseBody202Script_validityNonNullableOther val) = val
          toJSON (QuitStakePoolResponseBody202Script_validityNonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (QuitStakePoolResponseBody202Script_validityNonNullableEnumValid) = "valid"
          toJSON (QuitStakePoolResponseBody202Script_validityNonNullableEnumInvalid) = "invalid"
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Script_validityNonNullable
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "valid" -> QuitStakePoolResponseBody202Script_validityNonNullableEnumValid
                                            | val GHC.Classes.== "invalid" -> QuitStakePoolResponseBody202Script_validityNonNullableEnumInvalid
                                            | GHC.Base.otherwise -> QuitStakePoolResponseBody202Script_validityNonNullableOther val)
-- | Defines the enum schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.status@ in the specification.
-- 
-- Current transaction status.
-- 
--   \`\`\`
--        *-----------*
--   ---> |  PENDING  |----------------*
--        *-----------*                |
--              |                      |
--              V                      V
--        *-----------*          *-----------*
--        |           |---------->  EXPIRED  |
--        |           |  (ttl)   *-----------*
--        | SUBMITTED |
--        |           \<----------------*
--        |           |                |
--        *-----------*           (rollback)
--               |                     |
--          (in ledger)          *-----------*
--               |               |           |
--               *---------------> IN_LEDGER |
--                               |           |
--                               *-----------*
--   \`\`\`
data QuitStakePoolResponseBody202Status =
   QuitStakePoolResponseBody202StatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | QuitStakePoolResponseBody202StatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | QuitStakePoolResponseBody202StatusEnumPending -- ^ Represents the JSON value @"pending"@
  | QuitStakePoolResponseBody202StatusEnumSubmitted -- ^ Represents the JSON value @"submitted"@
  | QuitStakePoolResponseBody202StatusEnumIn_ledger -- ^ Represents the JSON value @"in_ledger"@
  | QuitStakePoolResponseBody202StatusEnumExpired -- ^ Represents the JSON value @"expired"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Status
    where toJSON (QuitStakePoolResponseBody202StatusOther val) = val
          toJSON (QuitStakePoolResponseBody202StatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (QuitStakePoolResponseBody202StatusEnumPending) = "pending"
          toJSON (QuitStakePoolResponseBody202StatusEnumSubmitted) = "submitted"
          toJSON (QuitStakePoolResponseBody202StatusEnumIn_ledger) = "in_ledger"
          toJSON (QuitStakePoolResponseBody202StatusEnumExpired) = "expired"
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Status
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "pending" -> QuitStakePoolResponseBody202StatusEnumPending
                                            | val GHC.Classes.== "submitted" -> QuitStakePoolResponseBody202StatusEnumSubmitted
                                            | val GHC.Classes.== "in_ledger" -> QuitStakePoolResponseBody202StatusEnumIn_ledger
                                            | val GHC.Classes.== "expired" -> QuitStakePoolResponseBody202StatusEnumExpired
                                            | GHC.Base.otherwise -> QuitStakePoolResponseBody202StatusOther val)
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.validity_interval@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202Validity_interval = QuitStakePoolResponseBody202Validity_interval {
  -- | invalid_before
  quitStakePoolResponseBody202Validity_intervalInvalid_before :: QuitStakePoolResponseBody202Validity_intervalInvalid_before
  -- | invalid_hereafter
  , quitStakePoolResponseBody202Validity_intervalInvalid_hereafter :: QuitStakePoolResponseBody202Validity_intervalInvalid_hereafter
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Validity_interval
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Validity_interval
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Validity_interval" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202Validity_interval GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_before")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_hereafter"))
-- | Create a new 'QuitStakePoolResponseBody202Validity_interval' with all required fields.
mkQuitStakePoolResponseBody202Validity_interval :: QuitStakePoolResponseBody202Validity_intervalInvalid_before -- ^ 'quitStakePoolResponseBody202Validity_intervalInvalid_before'
  -> QuitStakePoolResponseBody202Validity_intervalInvalid_hereafter -- ^ 'quitStakePoolResponseBody202Validity_intervalInvalid_hereafter'
  -> QuitStakePoolResponseBody202Validity_interval
mkQuitStakePoolResponseBody202Validity_interval quitStakePoolResponseBody202Validity_intervalInvalid_before quitStakePoolResponseBody202Validity_intervalInvalid_hereafter = QuitStakePoolResponseBody202Validity_interval{quitStakePoolResponseBody202Validity_intervalInvalid_before = quitStakePoolResponseBody202Validity_intervalInvalid_before,
                                                                                                                                                                                                                           quitStakePoolResponseBody202Validity_intervalInvalid_hereafter = quitStakePoolResponseBody202Validity_intervalInvalid_hereafter}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.validity_interval.properties.invalid_before@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202Validity_intervalInvalid_before = QuitStakePoolResponseBody202Validity_intervalInvalid_before {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202Validity_intervalInvalid_beforeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Validity_intervalInvalid_before
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Validity_intervalInvalid_before
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Validity_intervalInvalid_before" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202Validity_intervalInvalid_before GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202Validity_intervalInvalid_before' with all required fields.
mkQuitStakePoolResponseBody202Validity_intervalInvalid_before :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Validity_intervalInvalid_beforeQuantity'
  -> QuitStakePoolResponseBody202Validity_intervalInvalid_before
mkQuitStakePoolResponseBody202Validity_intervalInvalid_before quitStakePoolResponseBody202Validity_intervalInvalid_beforeQuantity = QuitStakePoolResponseBody202Validity_intervalInvalid_before{quitStakePoolResponseBody202Validity_intervalInvalid_beforeQuantity = quitStakePoolResponseBody202Validity_intervalInvalid_beforeQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.validity_interval.properties.invalid_hereafter@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202Validity_intervalInvalid_hereafter = QuitStakePoolResponseBody202Validity_intervalInvalid_hereafter {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202Validity_intervalInvalid_hereafterQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Validity_intervalInvalid_hereafter
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Validity_intervalInvalid_hereafter
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Validity_intervalInvalid_hereafter" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202Validity_intervalInvalid_hereafter GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202Validity_intervalInvalid_hereafter' with all required fields.
mkQuitStakePoolResponseBody202Validity_intervalInvalid_hereafter :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202Validity_intervalInvalid_hereafterQuantity'
  -> QuitStakePoolResponseBody202Validity_intervalInvalid_hereafter
mkQuitStakePoolResponseBody202Validity_intervalInvalid_hereafter quitStakePoolResponseBody202Validity_intervalInvalid_hereafterQuantity = QuitStakePoolResponseBody202Validity_intervalInvalid_hereafter{quitStakePoolResponseBody202Validity_intervalInvalid_hereafterQuantity = quitStakePoolResponseBody202Validity_intervalInvalid_hereafterQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.withdrawals.items@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody202Withdrawals = QuitStakePoolResponseBody202Withdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  quitStakePoolResponseBody202WithdrawalsAmount :: QuitStakePoolResponseBody202WithdrawalsAmount
  -- | stake_address
  , quitStakePoolResponseBody202WithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202Withdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202WithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202WithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202Withdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202Withdrawals" (\obj -> (GHC.Base.pure QuitStakePoolResponseBody202Withdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'QuitStakePoolResponseBody202Withdrawals' with all required fields.
mkQuitStakePoolResponseBody202Withdrawals :: QuitStakePoolResponseBody202WithdrawalsAmount -- ^ 'quitStakePoolResponseBody202WithdrawalsAmount'
  -> Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody202WithdrawalsStake_address'
  -> QuitStakePoolResponseBody202Withdrawals
mkQuitStakePoolResponseBody202Withdrawals quitStakePoolResponseBody202WithdrawalsAmount quitStakePoolResponseBody202WithdrawalsStake_address = QuitStakePoolResponseBody202Withdrawals{quitStakePoolResponseBody202WithdrawalsAmount = quitStakePoolResponseBody202WithdrawalsAmount,
                                                                                                                                                                                       quitStakePoolResponseBody202WithdrawalsStake_address = quitStakePoolResponseBody202WithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.202.content.application\/json.schema.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data QuitStakePoolResponseBody202WithdrawalsAmount = QuitStakePoolResponseBody202WithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  quitStakePoolResponseBody202WithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody202WithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody202WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody202WithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody202WithdrawalsAmount" (\obj -> GHC.Base.pure QuitStakePoolResponseBody202WithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'QuitStakePoolResponseBody202WithdrawalsAmount' with all required fields.
mkQuitStakePoolResponseBody202WithdrawalsAmount :: GHC.Types.Int -- ^ 'quitStakePoolResponseBody202WithdrawalsAmountQuantity'
  -> QuitStakePoolResponseBody202WithdrawalsAmount
mkQuitStakePoolResponseBody202WithdrawalsAmount quitStakePoolResponseBody202WithdrawalsAmountQuantity = QuitStakePoolResponseBody202WithdrawalsAmount{quitStakePoolResponseBody202WithdrawalsAmountQuantity = quitStakePoolResponseBody202WithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody400 = QuitStakePoolResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  quitStakePoolResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody400" (\obj -> GHC.Base.pure QuitStakePoolResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'QuitStakePoolResponseBody400' with all required fields.
mkQuitStakePoolResponseBody400 :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody400Message'
  -> QuitStakePoolResponseBody400
mkQuitStakePoolResponseBody400 quitStakePoolResponseBody400Message = QuitStakePoolResponseBody400{quitStakePoolResponseBody400Message = quitStakePoolResponseBody400Message}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody403OneOf1 = QuitStakePoolResponseBody403OneOf1 {
  -- | message: May occur when a transaction can\'t be balanced for fees.
  quitStakePoolResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody403OneOf1" (\obj -> GHC.Base.pure QuitStakePoolResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'QuitStakePoolResponseBody403OneOf1' with all required fields.
mkQuitStakePoolResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody403OneOf1Message'
  -> QuitStakePoolResponseBody403OneOf1
mkQuitStakePoolResponseBody403OneOf1 quitStakePoolResponseBody403OneOf1Message = QuitStakePoolResponseBody403OneOf1{quitStakePoolResponseBody403OneOf1Message = quitStakePoolResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody403OneOf2 = QuitStakePoolResponseBody403OneOf2 {
  -- | message: May occur when an action require a signing key but the wallet has only access to verification keys.
  quitStakePoolResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody403OneOf2" (\obj -> GHC.Base.pure QuitStakePoolResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'QuitStakePoolResponseBody403OneOf2' with all required fields.
mkQuitStakePoolResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody403OneOf2Message'
  -> QuitStakePoolResponseBody403OneOf2
mkQuitStakePoolResponseBody403OneOf2 quitStakePoolResponseBody403OneOf2Message = QuitStakePoolResponseBody403OneOf2{quitStakePoolResponseBody403OneOf2Message = quitStakePoolResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody403OneOf3 = QuitStakePoolResponseBody403OneOf3 {
  -- | message: May occur when the given spending passphrase is wrong.
  quitStakePoolResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody403OneOf3" (\obj -> GHC.Base.pure QuitStakePoolResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'QuitStakePoolResponseBody403OneOf3' with all required fields.
mkQuitStakePoolResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody403OneOf3Message'
  -> QuitStakePoolResponseBody403OneOf3
mkQuitStakePoolResponseBody403OneOf3 quitStakePoolResponseBody403OneOf3Message = QuitStakePoolResponseBody403OneOf3{quitStakePoolResponseBody403OneOf3Message = quitStakePoolResponseBody403OneOf3Message}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody403OneOf4 = QuitStakePoolResponseBody403OneOf4 {
  -- | message: May occur when trying to quit a pool on an account that isn\'t delegating.
  quitStakePoolResponseBody403OneOf4Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody403OneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_delegating_to"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_delegating_to"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody403OneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody403OneOf4" (\obj -> GHC.Base.pure QuitStakePoolResponseBody403OneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'QuitStakePoolResponseBody403OneOf4' with all required fields.
mkQuitStakePoolResponseBody403OneOf4 :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody403OneOf4Message'
  -> QuitStakePoolResponseBody403OneOf4
mkQuitStakePoolResponseBody403OneOf4 quitStakePoolResponseBody403OneOf4Message = QuitStakePoolResponseBody403OneOf4{quitStakePoolResponseBody403OneOf4Message = quitStakePoolResponseBody403OneOf4Message}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody403OneOf5 = QuitStakePoolResponseBody403OneOf5 {
  -- | message: May occur when trying to unregister a stake key that still has rewards attached to it.
  quitStakePoolResponseBody403OneOf5Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody403OneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "non_null_rewards"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "non_null_rewards"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody403OneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody403OneOf5" (\obj -> GHC.Base.pure QuitStakePoolResponseBody403OneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'QuitStakePoolResponseBody403OneOf5' with all required fields.
mkQuitStakePoolResponseBody403OneOf5 :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody403OneOf5Message'
  -> QuitStakePoolResponseBody403OneOf5
mkQuitStakePoolResponseBody403OneOf5 quitStakePoolResponseBody403OneOf5Message = QuitStakePoolResponseBody403OneOf5{quitStakePoolResponseBody403OneOf5Message = quitStakePoolResponseBody403OneOf5Message}
-- | Defines the oneOf schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody403Variants =
   QuitStakePoolResponseBody403Variant1 QuitStakePoolResponseBody403OneOf1
  | QuitStakePoolResponseBody403Variant2 QuitStakePoolResponseBody403OneOf2
  | QuitStakePoolResponseBody403Variant3 QuitStakePoolResponseBody403OneOf3
  | QuitStakePoolResponseBody403Variant4 QuitStakePoolResponseBody403OneOf4
  | QuitStakePoolResponseBody403Variant5 QuitStakePoolResponseBody403OneOf5
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody403Variants
    where toJSON (QuitStakePoolResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody403Variant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (QuitStakePoolResponseBody403Variant5 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody403Variants
    where parseJSON val = case (QuitStakePoolResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody403Variant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((QuitStakePoolResponseBody403Variant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody404 = QuitStakePoolResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  quitStakePoolResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody404" (\obj -> GHC.Base.pure QuitStakePoolResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'QuitStakePoolResponseBody404' with all required fields.
mkQuitStakePoolResponseBody404 :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody404Message'
  -> QuitStakePoolResponseBody404
mkQuitStakePoolResponseBody404 quitStakePoolResponseBody404Message = QuitStakePoolResponseBody404{quitStakePoolResponseBody404Message = quitStakePoolResponseBody404Message}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody406 = QuitStakePoolResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  quitStakePoolResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody406" (\obj -> GHC.Base.pure QuitStakePoolResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'QuitStakePoolResponseBody406' with all required fields.
mkQuitStakePoolResponseBody406 :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody406Message'
  -> QuitStakePoolResponseBody406
mkQuitStakePoolResponseBody406 quitStakePoolResponseBody406Message = QuitStakePoolResponseBody406{quitStakePoolResponseBody406Message = quitStakePoolResponseBody406Message}
-- | Defines the object schema located at @paths.\/stake-pools\/*\/wallets\/{walletId}.DELETE.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data QuitStakePoolResponseBody415 = QuitStakePoolResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  quitStakePoolResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON QuitStakePoolResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= quitStakePoolResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON QuitStakePoolResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "QuitStakePoolResponseBody415" (\obj -> GHC.Base.pure QuitStakePoolResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'QuitStakePoolResponseBody415' with all required fields.
mkQuitStakePoolResponseBody415 :: Data.Text.Internal.Text -- ^ 'quitStakePoolResponseBody415Message'
  -> QuitStakePoolResponseBody415
mkQuitStakePoolResponseBody415 quitStakePoolResponseBody415Message = QuitStakePoolResponseBody415{quitStakePoolResponseBody415Message = quitStakePoolResponseBody415Message}
-- | > DELETE /stake-pools/*/wallets/{walletId}
-- 
-- The same as 'quitStakePool' but accepts an explicit configuration.
quitStakePoolWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> QuitStakePoolRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response QuitStakePoolResponse) -- ^ Monadic computation which returns the result of the operation
quitStakePoolWithConfiguration config
                               walletId
                               body = GHC.Base.fmap (\response_7 -> GHC.Base.fmap (Data.Either.either QuitStakePoolResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> QuitStakePoolResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                           QuitStakePoolResponseBody202)
                                                                                                                                                                              | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> QuitStakePoolResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                           QuitStakePoolResponseBody400)
                                                                                                                                                                              | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> QuitStakePoolResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                             QuitStakePoolResponseBody403Variants)
                                                                                                                                                                              | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> QuitStakePoolResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                             QuitStakePoolResponseBody404)
                                                                                                                                                                              | (\status_12 -> Network.HTTP.Types.Status.statusCode status_12 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> QuitStakePoolResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                             QuitStakePoolResponseBody406)
                                                                                                                                                                              | (\status_13 -> Network.HTTP.Types.Status.statusCode status_13 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> QuitStakePoolResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                             QuitStakePoolResponseBody415)
                                                                                                                                                                              | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_7) response_7) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "DELETE") ("/stake-pools/*/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > DELETE /stake-pools/*/wallets/{walletId}
-- 
-- The same as 'quitStakePool' but returns the raw 'Data.ByteString.ByteString'.
quitStakePoolRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> QuitStakePoolRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
quitStakePoolRaw walletId
                 body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "DELETE") ("/stake-pools/*/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > DELETE /stake-pools/*/wallets/{walletId}
-- 
-- The same as 'quitStakePool' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
quitStakePoolWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> QuitStakePoolRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
quitStakePoolWithConfigurationRaw config
                                  walletId
                                  body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "DELETE") ("/stake-pools/*/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
