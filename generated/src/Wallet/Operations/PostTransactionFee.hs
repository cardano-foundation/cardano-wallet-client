-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation postTransactionFee
module Wallet.Operations.PostTransactionFee where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /wallets/{walletId}/payment-fees
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Estimate fee for the transaction. The estimate is made by
-- assembling multiple transactions and analyzing the
-- distribution of their fees. The estimated_max is the highest
-- fee observed, and the estimated_min is the fee which is lower
-- than at least 90% of the fees observed.
postTransactionFee :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostTransactionFeeRequestBodyVariants -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response PostTransactionFeeResponse) -- ^ Monadic computation which returns the result of the operation
postTransactionFee walletId
                   body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PostTransactionFeeResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionFeeResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         PostTransactionFeeResponseBody202)
                                                                                                                                                                       | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionFeeResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         PostTransactionFeeResponseBody400Variants)
                                                                                                                                                                       | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionFeeResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         PostTransactionFeeResponseBody403Variants)
                                                                                                                                                                       | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionFeeResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         PostTransactionFeeResponseBody404)
                                                                                                                                                                       | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionFeeResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         PostTransactionFeeResponseBody406)
                                                                                                                                                                       | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionFeeResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         PostTransactionFeeResponseBody415)
                                                                                                                                                                       | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/payment-fees")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeRequestBodyOneOf1 = PostTransactionFeeRequestBodyOneOf1 {
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  postTransactionFeeRequestBodyOneOf1Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | payments: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postTransactionFeeRequestBodyOneOf1Payments :: ([PostTransactionFeeRequestBodyOneOf1Payments])
  -- | time_to_live: The TTL (time to live) is the time period in which the transaction
  -- will be accepted into node mempools.
  -- 
  -- After the TTL has lapsed, the transaction is considered
  -- expired. At this point, nodes will give up on broadcasting the
  -- transaction, and the wallet will release the funds allocated to
  -- the transaction so they can be used for other payments.
  -- 
  -- The TTL should be long enough that the transaction has time to be
  -- propagated through the network and confirmed, but short enough so
  -- that - in the event of failures - UTxO are returned to the wallet
  -- in a timely manner.
  -- 
  -- The TTL value is given in seconds. It will be converted to a slot
  -- number internally.
  -- 
  -- If the TTL is not provided for a payment, a reasonable default
  -- value will be used.
  , postTransactionFeeRequestBodyOneOf1Time_to_live :: (GHC.Maybe.Maybe PostTransactionFeeRequestBodyOneOf1Time_to_live)
  -- | withdrawal: When provided, instruments the server to automatically withdraw rewards from the source wallet when they are deemed
  -- sufficient (i.e. they contribute to the balance for at least as much as they cost).
  -- 
  -- As a consequence, the resulting transaction may or may not have a withdrawal object. Summarizing:
  -- 
  -- withdrawal field | reward balance | result
  -- ---              | ---            | ---
  -- \`null\`           | too small      | ✓ no withdrawals generated
  -- \`null\`           | big enough     | ✓ no withdrawals generated
  -- \`\"self\"\`         | too small      | ✓ no withdrawals generated
  -- \`\"self\"\`         | big enough     | ✓ withdrawal generated
  , postTransactionFeeRequestBodyOneOf1Withdrawal :: (GHC.Maybe.Maybe PostTransactionFeeRequestBodyOneOf1Withdrawal)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeRequestBodyOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (postTransactionFeeRequestBodyOneOf1Metadata obj) : ["payments" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1Payments obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("time_to_live" Data.Aeson.Types.ToJSON..=)) (postTransactionFeeRequestBodyOneOf1Time_to_live obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawal" Data.Aeson.Types.ToJSON..=)) (postTransactionFeeRequestBodyOneOf1Withdrawal obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (postTransactionFeeRequestBodyOneOf1Metadata obj) : ["payments" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1Payments obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("time_to_live" Data.Aeson.Types.ToJSON..=)) (postTransactionFeeRequestBodyOneOf1Time_to_live obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawal" Data.Aeson.Types.ToJSON..=)) (postTransactionFeeRequestBodyOneOf1Withdrawal obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeRequestBodyOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeRequestBodyOneOf1" (\obj -> (((GHC.Base.pure PostTransactionFeeRequestBodyOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "payments")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "time_to_live")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "withdrawal"))
-- | Create a new 'PostTransactionFeeRequestBodyOneOf1' with all required fields.
mkPostTransactionFeeRequestBodyOneOf1 :: [PostTransactionFeeRequestBodyOneOf1Payments] -- ^ 'postTransactionFeeRequestBodyOneOf1Payments'
  -> PostTransactionFeeRequestBodyOneOf1
mkPostTransactionFeeRequestBodyOneOf1 postTransactionFeeRequestBodyOneOf1Payments = PostTransactionFeeRequestBodyOneOf1{postTransactionFeeRequestBodyOneOf1Metadata = GHC.Maybe.Nothing,
                                                                                                                        postTransactionFeeRequestBodyOneOf1Payments = postTransactionFeeRequestBodyOneOf1Payments,
                                                                                                                        postTransactionFeeRequestBodyOneOf1Time_to_live = GHC.Maybe.Nothing,
                                                                                                                        postTransactionFeeRequestBodyOneOf1Withdrawal = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items@ in the specification.
-- 
-- 
data PostTransactionFeeRequestBodyOneOf1Payments = PostTransactionFeeRequestBodyOneOf1Payments {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  postTransactionFeeRequestBodyOneOf1PaymentsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionFeeRequestBodyOneOf1PaymentsAmount :: PostTransactionFeeRequestBodyOneOf1PaymentsAmount
  -- | assets: A flat list of assets (possibly empty).
  , postTransactionFeeRequestBodyOneOf1PaymentsAssets :: (GHC.Maybe.Maybe ([PostTransactionFeeRequestBodyOneOf1PaymentsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeRequestBodyOneOf1Payments
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1PaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1PaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postTransactionFeeRequestBodyOneOf1PaymentsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1PaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1PaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postTransactionFeeRequestBodyOneOf1PaymentsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeRequestBodyOneOf1Payments
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeRequestBodyOneOf1Payments" (\obj -> ((GHC.Base.pure PostTransactionFeeRequestBodyOneOf1Payments GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'PostTransactionFeeRequestBodyOneOf1Payments' with all required fields.
mkPostTransactionFeeRequestBodyOneOf1Payments :: Data.Text.Internal.Text -- ^ 'postTransactionFeeRequestBodyOneOf1PaymentsAddress'
  -> PostTransactionFeeRequestBodyOneOf1PaymentsAmount -- ^ 'postTransactionFeeRequestBodyOneOf1PaymentsAmount'
  -> PostTransactionFeeRequestBodyOneOf1Payments
mkPostTransactionFeeRequestBodyOneOf1Payments postTransactionFeeRequestBodyOneOf1PaymentsAddress postTransactionFeeRequestBodyOneOf1PaymentsAmount = PostTransactionFeeRequestBodyOneOf1Payments{postTransactionFeeRequestBodyOneOf1PaymentsAddress = postTransactionFeeRequestBodyOneOf1PaymentsAddress,
                                                                                                                                                                                                 postTransactionFeeRequestBodyOneOf1PaymentsAmount = postTransactionFeeRequestBodyOneOf1PaymentsAmount,
                                                                                                                                                                                                 postTransactionFeeRequestBodyOneOf1PaymentsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionFeeRequestBodyOneOf1PaymentsAmount = PostTransactionFeeRequestBodyOneOf1PaymentsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionFeeRequestBodyOneOf1PaymentsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeRequestBodyOneOf1PaymentsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1PaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1PaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeRequestBodyOneOf1PaymentsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeRequestBodyOneOf1PaymentsAmount" (\obj -> GHC.Base.pure PostTransactionFeeRequestBodyOneOf1PaymentsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionFeeRequestBodyOneOf1PaymentsAmount' with all required fields.
mkPostTransactionFeeRequestBodyOneOf1PaymentsAmount :: GHC.Types.Int -- ^ 'postTransactionFeeRequestBodyOneOf1PaymentsAmountQuantity'
  -> PostTransactionFeeRequestBodyOneOf1PaymentsAmount
mkPostTransactionFeeRequestBodyOneOf1PaymentsAmount postTransactionFeeRequestBodyOneOf1PaymentsAmountQuantity = PostTransactionFeeRequestBodyOneOf1PaymentsAmount{postTransactionFeeRequestBodyOneOf1PaymentsAmountQuantity = postTransactionFeeRequestBodyOneOf1PaymentsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostTransactionFeeRequestBodyOneOf1PaymentsAssets = PostTransactionFeeRequestBodyOneOf1PaymentsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postTransactionFeeRequestBodyOneOf1PaymentsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postTransactionFeeRequestBodyOneOf1PaymentsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionFeeRequestBodyOneOf1PaymentsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeRequestBodyOneOf1PaymentsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1PaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1PaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1PaymentsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1PaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1PaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1PaymentsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeRequestBodyOneOf1PaymentsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeRequestBodyOneOf1PaymentsAssets" (\obj -> ((GHC.Base.pure PostTransactionFeeRequestBodyOneOf1PaymentsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionFeeRequestBodyOneOf1PaymentsAssets' with all required fields.
mkPostTransactionFeeRequestBodyOneOf1PaymentsAssets :: Data.Text.Internal.Text -- ^ 'postTransactionFeeRequestBodyOneOf1PaymentsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postTransactionFeeRequestBodyOneOf1PaymentsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'postTransactionFeeRequestBodyOneOf1PaymentsAssetsQuantity'
  -> PostTransactionFeeRequestBodyOneOf1PaymentsAssets
mkPostTransactionFeeRequestBodyOneOf1PaymentsAssets postTransactionFeeRequestBodyOneOf1PaymentsAssetsAsset_name postTransactionFeeRequestBodyOneOf1PaymentsAssetsPolicy_id postTransactionFeeRequestBodyOneOf1PaymentsAssetsQuantity = PostTransactionFeeRequestBodyOneOf1PaymentsAssets{postTransactionFeeRequestBodyOneOf1PaymentsAssetsAsset_name = postTransactionFeeRequestBodyOneOf1PaymentsAssetsAsset_name,
                                                                                                                                                                                                                                                                                         postTransactionFeeRequestBodyOneOf1PaymentsAssetsPolicy_id = postTransactionFeeRequestBodyOneOf1PaymentsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                         postTransactionFeeRequestBodyOneOf1PaymentsAssetsQuantity = postTransactionFeeRequestBodyOneOf1PaymentsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.requestBody.content.application\/json.schema.oneOf.properties.time_to_live@ in the specification.
-- 
-- The TTL (time to live) is the time period in which the transaction
-- will be accepted into node mempools.
-- 
-- After the TTL has lapsed, the transaction is considered
-- expired. At this point, nodes will give up on broadcasting the
-- transaction, and the wallet will release the funds allocated to
-- the transaction so they can be used for other payments.
-- 
-- The TTL should be long enough that the transaction has time to be
-- propagated through the network and confirmed, but short enough so
-- that - in the event of failures - UTxO are returned to the wallet
-- in a timely manner.
-- 
-- The TTL value is given in seconds. It will be converted to a slot
-- number internally.
-- 
-- If the TTL is not provided for a payment, a reasonable default
-- value will be used.
data PostTransactionFeeRequestBodyOneOf1Time_to_live = PostTransactionFeeRequestBodyOneOf1Time_to_live {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionFeeRequestBodyOneOf1Time_to_liveQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeRequestBodyOneOf1Time_to_live
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1Time_to_liveQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "second"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf1Time_to_liveQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "second"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeRequestBodyOneOf1Time_to_live
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeRequestBodyOneOf1Time_to_live" (\obj -> GHC.Base.pure PostTransactionFeeRequestBodyOneOf1Time_to_live GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionFeeRequestBodyOneOf1Time_to_live' with all required fields.
mkPostTransactionFeeRequestBodyOneOf1Time_to_live :: GHC.Types.Double -- ^ 'postTransactionFeeRequestBodyOneOf1Time_to_liveQuantity'
  -> PostTransactionFeeRequestBodyOneOf1Time_to_live
mkPostTransactionFeeRequestBodyOneOf1Time_to_live postTransactionFeeRequestBodyOneOf1Time_to_liveQuantity = PostTransactionFeeRequestBodyOneOf1Time_to_live{postTransactionFeeRequestBodyOneOf1Time_to_liveQuantity = postTransactionFeeRequestBodyOneOf1Time_to_liveQuantity}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.requestBody.content.application\/json.schema.oneOf.properties.withdrawal@ in the specification.
-- 
-- When provided, instruments the server to automatically withdraw rewards from the source wallet when they are deemed
-- sufficient (i.e. they contribute to the balance for at least as much as they cost).
-- 
-- As a consequence, the resulting transaction may or may not have a withdrawal object. Summarizing:
-- 
-- withdrawal field | reward balance | result
-- ---              | ---            | ---
-- \`null\`           | too small      | ✓ no withdrawals generated
-- \`null\`           | big enough     | ✓ no withdrawals generated
-- \`\"self\"\`         | too small      | ✓ no withdrawals generated
-- \`\"self\"\`         | big enough     | ✓ withdrawal generated
data PostTransactionFeeRequestBodyOneOf1Withdrawal =
   PostTransactionFeeRequestBodyOneOf1WithdrawalOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostTransactionFeeRequestBodyOneOf1WithdrawalTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostTransactionFeeRequestBodyOneOf1WithdrawalEnumSelf -- ^ Represents the JSON value @"self"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeRequestBodyOneOf1Withdrawal
    where toJSON (PostTransactionFeeRequestBodyOneOf1WithdrawalOther val) = val
          toJSON (PostTransactionFeeRequestBodyOneOf1WithdrawalTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostTransactionFeeRequestBodyOneOf1WithdrawalEnumSelf) = "self"
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeRequestBodyOneOf1Withdrawal
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "self" -> PostTransactionFeeRequestBodyOneOf1WithdrawalEnumSelf
                                            | GHC.Base.otherwise -> PostTransactionFeeRequestBodyOneOf1WithdrawalOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeRequestBodyOneOf2 = PostTransactionFeeRequestBodyOneOf2 {
  -- | payments: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  postTransactionFeeRequestBodyOneOf2Payments :: ([PostTransactionFeeRequestBodyOneOf2Payments])
  -- | withdrawal: When provided, attempts to withdraw rewards from the default stake address
  -- corresponding to the given mnemonic.
  -- 
  -- Should the rewards be null or too small to be worth withdrawing (i.e. the
  -- cost of adding them into the transaction is more than their own intrinsic
  -- value), the server will reject the request with a
  -- \`withdrawal_not_beneficial\` error.
  -- 
  -- withdrawal field    | reward balance | result
  -- ---                 | ---            | ---
  -- any recovery phrase | too small      | x Error 403 \`withdrawal_not_beneficial\`
  -- any recovery phrase | big enough     | ✓ withdrawal generated
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 24 items
  -- * Must have a minimum of 15 items
  , postTransactionFeeRequestBodyOneOf2Withdrawal :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeRequestBodyOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["payments" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2Payments obj] : ["withdrawal" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2Withdrawal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["payments" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2Payments obj] : ["withdrawal" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2Withdrawal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeRequestBodyOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeRequestBodyOneOf2" (\obj -> (GHC.Base.pure PostTransactionFeeRequestBodyOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "payments")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "withdrawal"))
-- | Create a new 'PostTransactionFeeRequestBodyOneOf2' with all required fields.
mkPostTransactionFeeRequestBodyOneOf2 :: [PostTransactionFeeRequestBodyOneOf2Payments] -- ^ 'postTransactionFeeRequestBodyOneOf2Payments'
  -> [Data.Text.Internal.Text] -- ^ 'postTransactionFeeRequestBodyOneOf2Withdrawal'
  -> PostTransactionFeeRequestBodyOneOf2
mkPostTransactionFeeRequestBodyOneOf2 postTransactionFeeRequestBodyOneOf2Payments postTransactionFeeRequestBodyOneOf2Withdrawal = PostTransactionFeeRequestBodyOneOf2{postTransactionFeeRequestBodyOneOf2Payments = postTransactionFeeRequestBodyOneOf2Payments,
                                                                                                                                                                      postTransactionFeeRequestBodyOneOf2Withdrawal = postTransactionFeeRequestBodyOneOf2Withdrawal}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items@ in the specification.
-- 
-- 
data PostTransactionFeeRequestBodyOneOf2Payments = PostTransactionFeeRequestBodyOneOf2Payments {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  postTransactionFeeRequestBodyOneOf2PaymentsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionFeeRequestBodyOneOf2PaymentsAmount :: PostTransactionFeeRequestBodyOneOf2PaymentsAmount
  -- | assets: A flat list of assets (possibly empty).
  , postTransactionFeeRequestBodyOneOf2PaymentsAssets :: (GHC.Maybe.Maybe ([PostTransactionFeeRequestBodyOneOf2PaymentsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeRequestBodyOneOf2Payments
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2PaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2PaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postTransactionFeeRequestBodyOneOf2PaymentsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2PaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2PaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postTransactionFeeRequestBodyOneOf2PaymentsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeRequestBodyOneOf2Payments
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeRequestBodyOneOf2Payments" (\obj -> ((GHC.Base.pure PostTransactionFeeRequestBodyOneOf2Payments GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'PostTransactionFeeRequestBodyOneOf2Payments' with all required fields.
mkPostTransactionFeeRequestBodyOneOf2Payments :: Data.Text.Internal.Text -- ^ 'postTransactionFeeRequestBodyOneOf2PaymentsAddress'
  -> PostTransactionFeeRequestBodyOneOf2PaymentsAmount -- ^ 'postTransactionFeeRequestBodyOneOf2PaymentsAmount'
  -> PostTransactionFeeRequestBodyOneOf2Payments
mkPostTransactionFeeRequestBodyOneOf2Payments postTransactionFeeRequestBodyOneOf2PaymentsAddress postTransactionFeeRequestBodyOneOf2PaymentsAmount = PostTransactionFeeRequestBodyOneOf2Payments{postTransactionFeeRequestBodyOneOf2PaymentsAddress = postTransactionFeeRequestBodyOneOf2PaymentsAddress,
                                                                                                                                                                                                 postTransactionFeeRequestBodyOneOf2PaymentsAmount = postTransactionFeeRequestBodyOneOf2PaymentsAmount,
                                                                                                                                                                                                 postTransactionFeeRequestBodyOneOf2PaymentsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionFeeRequestBodyOneOf2PaymentsAmount = PostTransactionFeeRequestBodyOneOf2PaymentsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionFeeRequestBodyOneOf2PaymentsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeRequestBodyOneOf2PaymentsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2PaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2PaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeRequestBodyOneOf2PaymentsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeRequestBodyOneOf2PaymentsAmount" (\obj -> GHC.Base.pure PostTransactionFeeRequestBodyOneOf2PaymentsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionFeeRequestBodyOneOf2PaymentsAmount' with all required fields.
mkPostTransactionFeeRequestBodyOneOf2PaymentsAmount :: GHC.Types.Int -- ^ 'postTransactionFeeRequestBodyOneOf2PaymentsAmountQuantity'
  -> PostTransactionFeeRequestBodyOneOf2PaymentsAmount
mkPostTransactionFeeRequestBodyOneOf2PaymentsAmount postTransactionFeeRequestBodyOneOf2PaymentsAmountQuantity = PostTransactionFeeRequestBodyOneOf2PaymentsAmount{postTransactionFeeRequestBodyOneOf2PaymentsAmountQuantity = postTransactionFeeRequestBodyOneOf2PaymentsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostTransactionFeeRequestBodyOneOf2PaymentsAssets = PostTransactionFeeRequestBodyOneOf2PaymentsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postTransactionFeeRequestBodyOneOf2PaymentsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postTransactionFeeRequestBodyOneOf2PaymentsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionFeeRequestBodyOneOf2PaymentsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeRequestBodyOneOf2PaymentsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2PaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2PaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2PaymentsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2PaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2PaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeRequestBodyOneOf2PaymentsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeRequestBodyOneOf2PaymentsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeRequestBodyOneOf2PaymentsAssets" (\obj -> ((GHC.Base.pure PostTransactionFeeRequestBodyOneOf2PaymentsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionFeeRequestBodyOneOf2PaymentsAssets' with all required fields.
mkPostTransactionFeeRequestBodyOneOf2PaymentsAssets :: Data.Text.Internal.Text -- ^ 'postTransactionFeeRequestBodyOneOf2PaymentsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postTransactionFeeRequestBodyOneOf2PaymentsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'postTransactionFeeRequestBodyOneOf2PaymentsAssetsQuantity'
  -> PostTransactionFeeRequestBodyOneOf2PaymentsAssets
mkPostTransactionFeeRequestBodyOneOf2PaymentsAssets postTransactionFeeRequestBodyOneOf2PaymentsAssetsAsset_name postTransactionFeeRequestBodyOneOf2PaymentsAssetsPolicy_id postTransactionFeeRequestBodyOneOf2PaymentsAssetsQuantity = PostTransactionFeeRequestBodyOneOf2PaymentsAssets{postTransactionFeeRequestBodyOneOf2PaymentsAssetsAsset_name = postTransactionFeeRequestBodyOneOf2PaymentsAssetsAsset_name,
                                                                                                                                                                                                                                                                                         postTransactionFeeRequestBodyOneOf2PaymentsAssetsPolicy_id = postTransactionFeeRequestBodyOneOf2PaymentsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                         postTransactionFeeRequestBodyOneOf2PaymentsAssetsQuantity = postTransactionFeeRequestBodyOneOf2PaymentsAssetsQuantity}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeRequestBodyVariants =
   PostTransactionFeeRequestBodyVariant1 PostTransactionFeeRequestBodyOneOf1
  | PostTransactionFeeRequestBodyVariant2 PostTransactionFeeRequestBodyOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeRequestBodyVariants
    where toJSON (PostTransactionFeeRequestBodyVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionFeeRequestBodyVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeRequestBodyVariants
    where parseJSON val = case (PostTransactionFeeRequestBodyVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionFeeRequestBodyVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Represents a response of the operation 'postTransactionFee'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PostTransactionFeeResponseError' is used.
data PostTransactionFeeResponse =
   PostTransactionFeeResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | PostTransactionFeeResponse202 PostTransactionFeeResponseBody202 -- ^ Accepted
  | PostTransactionFeeResponse400 PostTransactionFeeResponseBody400Variants -- ^ Bad Request
  | PostTransactionFeeResponse403 PostTransactionFeeResponseBody403Variants -- ^ Forbidden
  | PostTransactionFeeResponse404 PostTransactionFeeResponseBody404 -- ^ Not Found
  | PostTransactionFeeResponse406 PostTransactionFeeResponseBody406 -- ^ Not Acceptable
  | PostTransactionFeeResponse415 PostTransactionFeeResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.202.content.application\/json.schema@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody202 = PostTransactionFeeResponseBody202 {
  -- | deposit: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  postTransactionFeeResponseBody202Deposit :: PostTransactionFeeResponseBody202Deposit
  -- | estimated_max: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionFeeResponseBody202Estimated_max :: PostTransactionFeeResponseBody202Estimated_max
  -- | estimated_min: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionFeeResponseBody202Estimated_min :: PostTransactionFeeResponseBody202Estimated_min
  -- | minimum_coins: A list of minimum coin values that each output in a payment must satisfy. The values themselves depends on two things:
  -- 
  --   - (a) Some updatable protocol parameters fixed by the network.
  --   - (b) The nature of the outputs (i.e. the kind of assets it includes).
  -- 
  -- The list is a direct 1:1 mapping of the requested outputs. Said differently, it has the **same number of items** and **items
  -- are ordered in the same way** as **requested outputs** are ordered. In the case where there\'s no explicitly requested outputs (e.g.
  -- when calculating fee for delegation), this list is empty.
  -- 
  -- For example, an output containing only \`Ada\` may require to be of at least \`1 Ada\`. An output containing only an hypothetical \`AppleCoin\`
  -- may require to also carry a minimum of \`1.2 Ada\`. Note that no matter what, a minimum coin value is always given in Lovelace \/ Ada.
  -- 
  -- > ℹ️ This mechanism is used by the protocol to protect against flooding of the network with worthless assets. By requiring a minimum coin value to every
  -- UTxO, they are given an intrinsic value indexed itself on the value of Ada.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postTransactionFeeResponseBody202Minimum_coins :: ([PostTransactionFeeResponseBody202Minimum_coins])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody202
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["deposit" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202Deposit obj] : ["estimated_max" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202Estimated_max obj] : ["estimated_min" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202Estimated_min obj] : ["minimum_coins" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202Minimum_coins obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["deposit" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202Deposit obj] : ["estimated_max" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202Estimated_max obj] : ["estimated_min" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202Estimated_min obj] : ["minimum_coins" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202Minimum_coins obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody202
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody202" (\obj -> (((GHC.Base.pure PostTransactionFeeResponseBody202 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "estimated_max")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "estimated_min")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "minimum_coins"))
-- | Create a new 'PostTransactionFeeResponseBody202' with all required fields.
mkPostTransactionFeeResponseBody202 :: PostTransactionFeeResponseBody202Deposit -- ^ 'postTransactionFeeResponseBody202Deposit'
  -> PostTransactionFeeResponseBody202Estimated_max -- ^ 'postTransactionFeeResponseBody202Estimated_max'
  -> PostTransactionFeeResponseBody202Estimated_min -- ^ 'postTransactionFeeResponseBody202Estimated_min'
  -> [PostTransactionFeeResponseBody202Minimum_coins] -- ^ 'postTransactionFeeResponseBody202Minimum_coins'
  -> PostTransactionFeeResponseBody202
mkPostTransactionFeeResponseBody202 postTransactionFeeResponseBody202Deposit postTransactionFeeResponseBody202Estimated_max postTransactionFeeResponseBody202Estimated_min postTransactionFeeResponseBody202Minimum_coins = PostTransactionFeeResponseBody202{postTransactionFeeResponseBody202Deposit = postTransactionFeeResponseBody202Deposit,
                                                                                                                                                                                                                                                              postTransactionFeeResponseBody202Estimated_max = postTransactionFeeResponseBody202Estimated_max,
                                                                                                                                                                                                                                                              postTransactionFeeResponseBody202Estimated_min = postTransactionFeeResponseBody202Estimated_min,
                                                                                                                                                                                                                                                              postTransactionFeeResponseBody202Minimum_coins = postTransactionFeeResponseBody202Minimum_coins}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.202.content.application\/json.schema.properties.deposit@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionFeeResponseBody202Deposit = PostTransactionFeeResponseBody202Deposit {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionFeeResponseBody202DepositQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody202Deposit
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202DepositQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202DepositQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody202Deposit
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody202Deposit" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody202Deposit GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionFeeResponseBody202Deposit' with all required fields.
mkPostTransactionFeeResponseBody202Deposit :: GHC.Types.Int -- ^ 'postTransactionFeeResponseBody202DepositQuantity'
  -> PostTransactionFeeResponseBody202Deposit
mkPostTransactionFeeResponseBody202Deposit postTransactionFeeResponseBody202DepositQuantity = PostTransactionFeeResponseBody202Deposit{postTransactionFeeResponseBody202DepositQuantity = postTransactionFeeResponseBody202DepositQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.202.content.application\/json.schema.properties.estimated_max@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionFeeResponseBody202Estimated_max = PostTransactionFeeResponseBody202Estimated_max {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionFeeResponseBody202Estimated_maxQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody202Estimated_max
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202Estimated_maxQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202Estimated_maxQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody202Estimated_max
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody202Estimated_max" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody202Estimated_max GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionFeeResponseBody202Estimated_max' with all required fields.
mkPostTransactionFeeResponseBody202Estimated_max :: GHC.Types.Int -- ^ 'postTransactionFeeResponseBody202Estimated_maxQuantity'
  -> PostTransactionFeeResponseBody202Estimated_max
mkPostTransactionFeeResponseBody202Estimated_max postTransactionFeeResponseBody202Estimated_maxQuantity = PostTransactionFeeResponseBody202Estimated_max{postTransactionFeeResponseBody202Estimated_maxQuantity = postTransactionFeeResponseBody202Estimated_maxQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.202.content.application\/json.schema.properties.estimated_min@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionFeeResponseBody202Estimated_min = PostTransactionFeeResponseBody202Estimated_min {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionFeeResponseBody202Estimated_minQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody202Estimated_min
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202Estimated_minQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202Estimated_minQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody202Estimated_min
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody202Estimated_min" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody202Estimated_min GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionFeeResponseBody202Estimated_min' with all required fields.
mkPostTransactionFeeResponseBody202Estimated_min :: GHC.Types.Int -- ^ 'postTransactionFeeResponseBody202Estimated_minQuantity'
  -> PostTransactionFeeResponseBody202Estimated_min
mkPostTransactionFeeResponseBody202Estimated_min postTransactionFeeResponseBody202Estimated_minQuantity = PostTransactionFeeResponseBody202Estimated_min{postTransactionFeeResponseBody202Estimated_minQuantity = postTransactionFeeResponseBody202Estimated_minQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.202.content.application\/json.schema.properties.minimum_coins.items@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionFeeResponseBody202Minimum_coins = PostTransactionFeeResponseBody202Minimum_coins {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionFeeResponseBody202Minimum_coinsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody202Minimum_coins
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202Minimum_coinsQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody202Minimum_coinsQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody202Minimum_coins
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody202Minimum_coins" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody202Minimum_coins GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionFeeResponseBody202Minimum_coins' with all required fields.
mkPostTransactionFeeResponseBody202Minimum_coins :: GHC.Types.Int -- ^ 'postTransactionFeeResponseBody202Minimum_coinsQuantity'
  -> PostTransactionFeeResponseBody202Minimum_coins
mkPostTransactionFeeResponseBody202Minimum_coins postTransactionFeeResponseBody202Minimum_coinsQuantity = PostTransactionFeeResponseBody202Minimum_coins{postTransactionFeeResponseBody202Minimum_coinsQuantity = postTransactionFeeResponseBody202Minimum_coinsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody400OneOf1 = PostTransactionFeeResponseBody400OneOf1 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  postTransactionFeeResponseBody400OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody400OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody400OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody400OneOf1" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody400OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionFeeResponseBody400OneOf1' with all required fields.
mkPostTransactionFeeResponseBody400OneOf1 :: Data.Text.Internal.Text -- ^ 'postTransactionFeeResponseBody400OneOf1Message'
  -> PostTransactionFeeResponseBody400OneOf1
mkPostTransactionFeeResponseBody400OneOf1 postTransactionFeeResponseBody400OneOf1Message = PostTransactionFeeResponseBody400OneOf1{postTransactionFeeResponseBody400OneOf1Message = postTransactionFeeResponseBody400OneOf1Message}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody400Variants =
   PostTransactionFeeResponseBody400Variant1 PostTransactionFeeResponseBody400OneOf1
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody400Variants
    where toJSON (PostTransactionFeeResponseBody400Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody400Variants
    where parseJSON val = case (PostTransactionFeeResponseBody400Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched" of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody403OneOf1 = PostTransactionFeeResponseBody403OneOf1 {
  -- | message: May occur when trying to perform an operation not supported by this type of wallet.
  postTransactionFeeResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody403OneOf1" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionFeeResponseBody403OneOf1' with all required fields.
mkPostTransactionFeeResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'postTransactionFeeResponseBody403OneOf1Message'
  -> PostTransactionFeeResponseBody403OneOf1
mkPostTransactionFeeResponseBody403OneOf1 postTransactionFeeResponseBody403OneOf1Message = PostTransactionFeeResponseBody403OneOf1{postTransactionFeeResponseBody403OneOf1Message = postTransactionFeeResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody403OneOf2 = PostTransactionFeeResponseBody403OneOf2 {
  -- | message: May occur when submitting a withdrawal while another withdrawal is pending.
  postTransactionFeeResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody403OneOf2" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionFeeResponseBody403OneOf2' with all required fields.
mkPostTransactionFeeResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'postTransactionFeeResponseBody403OneOf2Message'
  -> PostTransactionFeeResponseBody403OneOf2
mkPostTransactionFeeResponseBody403OneOf2 postTransactionFeeResponseBody403OneOf2Message = PostTransactionFeeResponseBody403OneOf2{postTransactionFeeResponseBody403OneOf2Message = postTransactionFeeResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody403OneOf3 = PostTransactionFeeResponseBody403OneOf3 {
  -- | info
  postTransactionFeeResponseBody403OneOf3Info :: (GHC.Maybe.Maybe PostTransactionFeeResponseBody403OneOf3Info)
  -- | message: Occurs when a requested output has a quantity of lovelace that is below the minimum required by the ledger.
  , postTransactionFeeResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (postTransactionFeeResponseBody403OneOf3Info obj) : ["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (postTransactionFeeResponseBody403OneOf3Info obj) : ["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody403OneOf3" (\obj -> (GHC.Base.pure PostTransactionFeeResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "info")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionFeeResponseBody403OneOf3' with all required fields.
mkPostTransactionFeeResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'postTransactionFeeResponseBody403OneOf3Message'
  -> PostTransactionFeeResponseBody403OneOf3
mkPostTransactionFeeResponseBody403OneOf3 postTransactionFeeResponseBody403OneOf3Message = PostTransactionFeeResponseBody403OneOf3{postTransactionFeeResponseBody403OneOf3Info = GHC.Maybe.Nothing,
                                                                                                                                   postTransactionFeeResponseBody403OneOf3Message = postTransactionFeeResponseBody403OneOf3Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf.properties.info@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody403OneOf3Info = PostTransactionFeeResponseBody403OneOf3Info {
  -- | tx_output_index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionFeeResponseBody403OneOf3InfoTx_output_index :: GHC.Types.Int
  -- | tx_output_lovelace_required_minimum: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum :: PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
  -- | tx_output_lovelace_specified: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified :: PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody403OneOf3Info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf3InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf3InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody403OneOf3Info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody403OneOf3Info" (\obj -> ((GHC.Base.pure PostTransactionFeeResponseBody403OneOf3Info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_index")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_required_minimum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_specified"))
-- | Create a new 'PostTransactionFeeResponseBody403OneOf3Info' with all required fields.
mkPostTransactionFeeResponseBody403OneOf3Info :: GHC.Types.Int -- ^ 'postTransactionFeeResponseBody403OneOf3InfoTx_output_index'
  -> PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum -- ^ 'postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum'
  -> PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified -- ^ 'postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified'
  -> PostTransactionFeeResponseBody403OneOf3Info
mkPostTransactionFeeResponseBody403OneOf3Info postTransactionFeeResponseBody403OneOf3InfoTx_output_index postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified = PostTransactionFeeResponseBody403OneOf3Info{postTransactionFeeResponseBody403OneOf3InfoTx_output_index = postTransactionFeeResponseBody403OneOf3InfoTx_output_index,
                                                                                                                                                                                                                                                                                                              postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum = postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum,
                                                                                                                                                                                                                                                                                                              postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified = postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_required_minimum@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum = PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum' with all required fields.
mkPostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum :: GHC.Types.Int -- ^ 'postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity'
  -> PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
mkPostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity = PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum{postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity = postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_specified@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified = PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified' with all required fields.
mkPostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified :: GHC.Types.Int -- ^ 'postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity'
  -> PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified
mkPostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity = PostTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified{postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity = postTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody403OneOf4 = PostTransactionFeeResponseBody403OneOf4 {
  -- | message: May occur when a transaction can\'t be balanced for fees.
  postTransactionFeeResponseBody403OneOf4Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody403OneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody403OneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody403OneOf4" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody403OneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionFeeResponseBody403OneOf4' with all required fields.
mkPostTransactionFeeResponseBody403OneOf4 :: Data.Text.Internal.Text -- ^ 'postTransactionFeeResponseBody403OneOf4Message'
  -> PostTransactionFeeResponseBody403OneOf4
mkPostTransactionFeeResponseBody403OneOf4 postTransactionFeeResponseBody403OneOf4Message = PostTransactionFeeResponseBody403OneOf4{postTransactionFeeResponseBody403OneOf4Message = postTransactionFeeResponseBody403OneOf4Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody403OneOf5 = PostTransactionFeeResponseBody403OneOf5 {
  -- | message: May occur when there\'s not enough money in the wallet to cover a requested payment.
  postTransactionFeeResponseBody403OneOf5Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody403OneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody403OneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody403OneOf5" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody403OneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionFeeResponseBody403OneOf5' with all required fields.
mkPostTransactionFeeResponseBody403OneOf5 :: Data.Text.Internal.Text -- ^ 'postTransactionFeeResponseBody403OneOf5Message'
  -> PostTransactionFeeResponseBody403OneOf5
mkPostTransactionFeeResponseBody403OneOf5 postTransactionFeeResponseBody403OneOf5Message = PostTransactionFeeResponseBody403OneOf5{postTransactionFeeResponseBody403OneOf5Message = postTransactionFeeResponseBody403OneOf5Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody403OneOf6 = PostTransactionFeeResponseBody403OneOf6 {
  -- | message: May occur when the total balance of pure ada UTxOs in the wallet is
  -- insufficient to cover the minimum collateral amount required for a
  -- transaction requiring collateral.
  postTransactionFeeResponseBody403OneOf6Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody403OneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody403OneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody403OneOf6" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody403OneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionFeeResponseBody403OneOf6' with all required fields.
mkPostTransactionFeeResponseBody403OneOf6 :: Data.Text.Internal.Text -- ^ 'postTransactionFeeResponseBody403OneOf6Message'
  -> PostTransactionFeeResponseBody403OneOf6
mkPostTransactionFeeResponseBody403OneOf6 postTransactionFeeResponseBody403OneOf6Message = PostTransactionFeeResponseBody403OneOf6{postTransactionFeeResponseBody403OneOf6Message = postTransactionFeeResponseBody403OneOf6Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody403OneOf7 = PostTransactionFeeResponseBody403OneOf7 {
  -- | message: May occur when there\'s enough money to pay for a payment, but not enough UTxO to allow for paying each output independently.
  postTransactionFeeResponseBody403OneOf7Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody403OneOf7
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "inputs_depleted"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "inputs_depleted"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody403OneOf7
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody403OneOf7" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody403OneOf7 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionFeeResponseBody403OneOf7' with all required fields.
mkPostTransactionFeeResponseBody403OneOf7 :: Data.Text.Internal.Text -- ^ 'postTransactionFeeResponseBody403OneOf7Message'
  -> PostTransactionFeeResponseBody403OneOf7
mkPostTransactionFeeResponseBody403OneOf7 postTransactionFeeResponseBody403OneOf7Message = PostTransactionFeeResponseBody403OneOf7{postTransactionFeeResponseBody403OneOf7Message = postTransactionFeeResponseBody403OneOf7Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody403OneOf8 = PostTransactionFeeResponseBody403OneOf8 {
  -- | message: Should never happen unless the server screwed up with the creation of a coin selection.
  postTransactionFeeResponseBody403OneOf8Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody403OneOf8
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_coin_selection"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_coin_selection"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody403OneOf8
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody403OneOf8" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody403OneOf8 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionFeeResponseBody403OneOf8' with all required fields.
mkPostTransactionFeeResponseBody403OneOf8 :: Data.Text.Internal.Text -- ^ 'postTransactionFeeResponseBody403OneOf8Message'
  -> PostTransactionFeeResponseBody403OneOf8
mkPostTransactionFeeResponseBody403OneOf8 postTransactionFeeResponseBody403OneOf8Message = PostTransactionFeeResponseBody403OneOf8{postTransactionFeeResponseBody403OneOf8Message = postTransactionFeeResponseBody403OneOf8Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody403OneOf9 = PostTransactionFeeResponseBody403OneOf9 {
  -- | message: Returned when a user-specified transaction output contains, for some
  -- asset, a token quantity that exceeds the limit supported by the
  -- protocol.
  postTransactionFeeResponseBody403OneOf9Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody403OneOf9
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_quantity_exceeds_limit"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_quantity_exceeds_limit"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody403OneOf9
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody403OneOf9" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody403OneOf9 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionFeeResponseBody403OneOf9' with all required fields.
mkPostTransactionFeeResponseBody403OneOf9 :: Data.Text.Internal.Text -- ^ 'postTransactionFeeResponseBody403OneOf9Message'
  -> PostTransactionFeeResponseBody403OneOf9
mkPostTransactionFeeResponseBody403OneOf9 postTransactionFeeResponseBody403OneOf9Message = PostTransactionFeeResponseBody403OneOf9{postTransactionFeeResponseBody403OneOf9Message = postTransactionFeeResponseBody403OneOf9Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody403OneOf10 = PostTransactionFeeResponseBody403OneOf10 {
  -- | message: Returned when a user-specified transaction output contains a token
  -- bundle whose serialized length exceeds the limit supported by the
  -- protocol.
  postTransactionFeeResponseBody403OneOf10Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody403OneOf10
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf10Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_bundle_size_exceeds_limit"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf10Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_bundle_size_exceeds_limit"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody403OneOf10
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody403OneOf10" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody403OneOf10 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionFeeResponseBody403OneOf10' with all required fields.
mkPostTransactionFeeResponseBody403OneOf10 :: Data.Text.Internal.Text -- ^ 'postTransactionFeeResponseBody403OneOf10Message'
  -> PostTransactionFeeResponseBody403OneOf10
mkPostTransactionFeeResponseBody403OneOf10 postTransactionFeeResponseBody403OneOf10Message = PostTransactionFeeResponseBody403OneOf10{postTransactionFeeResponseBody403OneOf10Message = postTransactionFeeResponseBody403OneOf10Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody403OneOf11 = PostTransactionFeeResponseBody403OneOf11 {
  -- | message: May occur when the wallet can\'t cover for all requested outputs without making the transaction too large.
  postTransactionFeeResponseBody403OneOf11Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody403OneOf11
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf11Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_is_too_big"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody403OneOf11Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_is_too_big"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody403OneOf11
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody403OneOf11" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody403OneOf11 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionFeeResponseBody403OneOf11' with all required fields.
mkPostTransactionFeeResponseBody403OneOf11 :: Data.Text.Internal.Text -- ^ 'postTransactionFeeResponseBody403OneOf11Message'
  -> PostTransactionFeeResponseBody403OneOf11
mkPostTransactionFeeResponseBody403OneOf11 postTransactionFeeResponseBody403OneOf11Message = PostTransactionFeeResponseBody403OneOf11{postTransactionFeeResponseBody403OneOf11Message = postTransactionFeeResponseBody403OneOf11Message}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody403Variants =
   PostTransactionFeeResponseBody403Variant1 PostTransactionFeeResponseBody403OneOf1
  | PostTransactionFeeResponseBody403Variant2 PostTransactionFeeResponseBody403OneOf2
  | PostTransactionFeeResponseBody403Variant3 PostTransactionFeeResponseBody403OneOf3
  | PostTransactionFeeResponseBody403Variant4 PostTransactionFeeResponseBody403OneOf4
  | PostTransactionFeeResponseBody403Variant5 PostTransactionFeeResponseBody403OneOf5
  | PostTransactionFeeResponseBody403Variant6 PostTransactionFeeResponseBody403OneOf6
  | PostTransactionFeeResponseBody403Variant7 PostTransactionFeeResponseBody403OneOf7
  | PostTransactionFeeResponseBody403Variant8 PostTransactionFeeResponseBody403OneOf8
  | PostTransactionFeeResponseBody403Variant9 PostTransactionFeeResponseBody403OneOf9
  | PostTransactionFeeResponseBody403Variant10 PostTransactionFeeResponseBody403OneOf10
  | PostTransactionFeeResponseBody403Variant11 PostTransactionFeeResponseBody403OneOf11
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody403Variants
    where toJSON (PostTransactionFeeResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionFeeResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionFeeResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionFeeResponseBody403Variant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionFeeResponseBody403Variant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionFeeResponseBody403Variant6 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionFeeResponseBody403Variant7 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionFeeResponseBody403Variant8 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionFeeResponseBody403Variant9 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionFeeResponseBody403Variant10 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionFeeResponseBody403Variant11 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody403Variants
    where parseJSON val = case (PostTransactionFeeResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionFeeResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionFeeResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionFeeResponseBody403Variant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionFeeResponseBody403Variant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionFeeResponseBody403Variant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionFeeResponseBody403Variant7 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionFeeResponseBody403Variant8 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionFeeResponseBody403Variant9 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionFeeResponseBody403Variant10 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionFeeResponseBody403Variant11 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))))))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody404 = PostTransactionFeeResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  postTransactionFeeResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody404" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionFeeResponseBody404' with all required fields.
mkPostTransactionFeeResponseBody404 :: Data.Text.Internal.Text -- ^ 'postTransactionFeeResponseBody404Message'
  -> PostTransactionFeeResponseBody404
mkPostTransactionFeeResponseBody404 postTransactionFeeResponseBody404Message = PostTransactionFeeResponseBody404{postTransactionFeeResponseBody404Message = postTransactionFeeResponseBody404Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody406 = PostTransactionFeeResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  postTransactionFeeResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody406" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionFeeResponseBody406' with all required fields.
mkPostTransactionFeeResponseBody406 :: Data.Text.Internal.Text -- ^ 'postTransactionFeeResponseBody406Message'
  -> PostTransactionFeeResponseBody406
mkPostTransactionFeeResponseBody406 postTransactionFeeResponseBody406Message = PostTransactionFeeResponseBody406{postTransactionFeeResponseBody406Message = postTransactionFeeResponseBody406Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/payment-fees.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data PostTransactionFeeResponseBody415 = PostTransactionFeeResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  postTransactionFeeResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionFeeResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionFeeResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionFeeResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionFeeResponseBody415" (\obj -> GHC.Base.pure PostTransactionFeeResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionFeeResponseBody415' with all required fields.
mkPostTransactionFeeResponseBody415 :: Data.Text.Internal.Text -- ^ 'postTransactionFeeResponseBody415Message'
  -> PostTransactionFeeResponseBody415
mkPostTransactionFeeResponseBody415 postTransactionFeeResponseBody415Message = PostTransactionFeeResponseBody415{postTransactionFeeResponseBody415Message = postTransactionFeeResponseBody415Message}
-- | > POST /wallets/{walletId}/payment-fees
-- 
-- The same as 'postTransactionFee' but accepts an explicit configuration.
postTransactionFeeWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostTransactionFeeRequestBodyVariants -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response PostTransactionFeeResponse) -- ^ Monadic computation which returns the result of the operation
postTransactionFeeWithConfiguration config
                                    walletId
                                    body = GHC.Base.fmap (\response_7 -> GHC.Base.fmap (Data.Either.either PostTransactionFeeResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionFeeResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                          PostTransactionFeeResponseBody202)
                                                                                                                                                                                        | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionFeeResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                          PostTransactionFeeResponseBody400Variants)
                                                                                                                                                                                        | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionFeeResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                            PostTransactionFeeResponseBody403Variants)
                                                                                                                                                                                        | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionFeeResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                            PostTransactionFeeResponseBody404)
                                                                                                                                                                                        | (\status_12 -> Network.HTTP.Types.Status.statusCode status_12 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionFeeResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                            PostTransactionFeeResponseBody406)
                                                                                                                                                                                        | (\status_13 -> Network.HTTP.Types.Status.statusCode status_13 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionFeeResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                            PostTransactionFeeResponseBody415)
                                                                                                                                                                                        | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_7) response_7) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/payment-fees")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/payment-fees
-- 
-- The same as 'postTransactionFee' but returns the raw 'Data.ByteString.ByteString'.
postTransactionFeeRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostTransactionFeeRequestBodyVariants -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postTransactionFeeRaw walletId
                      body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/payment-fees")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/payment-fees
-- 
-- The same as 'postTransactionFee' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
postTransactionFeeWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostTransactionFeeRequestBodyVariants -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postTransactionFeeWithConfigurationRaw config
                                       walletId
                                       body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/payment-fees")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
