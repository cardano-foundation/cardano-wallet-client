-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation selectCoins
module Wallet.Operations.SelectCoins where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /wallets/{walletId}/coin-selections/random
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Select coins to cover the given set of payments.
-- 
-- Uses the \<a href=\"https:\/\/iohk.io\/blog\/self-organisation-in-coin-selection\/\">
-- Random-Improve coin selection algorithm\<\/a>.
selectCoins :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> SelectCoinsRequestBodyVariants -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response SelectCoinsResponse) -- ^ Monadic computation which returns the result of the operation
selectCoins walletId
            body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either SelectCoinsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> SelectCoinsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                    SelectCoinsResponseBody200)
                                                                                                                                                         | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> SelectCoinsResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                    SelectCoinsResponseBody400)
                                                                                                                                                         | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> SelectCoinsResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                    SelectCoinsResponseBody403Variants)
                                                                                                                                                         | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> SelectCoinsResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                    SelectCoinsResponseBody404)
                                                                                                                                                         | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> SelectCoinsResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                    SelectCoinsResponseBody406)
                                                                                                                                                         | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> SelectCoinsResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                    SelectCoinsResponseBody415)
                                                                                                                                                         | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/coin-selections/random")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data SelectCoinsRequestBodyOneOf1 = SelectCoinsRequestBodyOneOf1 {
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  selectCoinsRequestBodyOneOf1Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | payments: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , selectCoinsRequestBodyOneOf1Payments :: ([SelectCoinsRequestBodyOneOf1Payments])
  -- | withdrawal: When provided, instruments the server to automatically withdraw rewards from the source wallet when they are deemed
  -- sufficient (i.e. they contribute to the balance for at least as much as they cost).
  -- 
  -- As a consequence, the resulting transaction may or may not have a withdrawal object. Summarizing:
  -- 
  -- withdrawal field | reward balance | result
  -- ---              | ---            | ---
  -- \`null\`           | too small      | ✓ no withdrawals generated
  -- \`null\`           | big enough     | ✓ no withdrawals generated
  -- \`\"self\"\`         | too small      | ✓ no withdrawals generated
  -- \`\"self\"\`         | big enough     | ✓ withdrawal generated
  , selectCoinsRequestBodyOneOf1Withdrawal :: (GHC.Maybe.Maybe SelectCoinsRequestBodyOneOf1Withdrawal)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsRequestBodyOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (selectCoinsRequestBodyOneOf1Metadata obj) : ["payments" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf1Payments obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawal" Data.Aeson.Types.ToJSON..=)) (selectCoinsRequestBodyOneOf1Withdrawal obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (selectCoinsRequestBodyOneOf1Metadata obj) : ["payments" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf1Payments obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawal" Data.Aeson.Types.ToJSON..=)) (selectCoinsRequestBodyOneOf1Withdrawal obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsRequestBodyOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsRequestBodyOneOf1" (\obj -> ((GHC.Base.pure SelectCoinsRequestBodyOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "payments")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "withdrawal"))
-- | Create a new 'SelectCoinsRequestBodyOneOf1' with all required fields.
mkSelectCoinsRequestBodyOneOf1 :: [SelectCoinsRequestBodyOneOf1Payments] -- ^ 'selectCoinsRequestBodyOneOf1Payments'
  -> SelectCoinsRequestBodyOneOf1
mkSelectCoinsRequestBodyOneOf1 selectCoinsRequestBodyOneOf1Payments = SelectCoinsRequestBodyOneOf1{selectCoinsRequestBodyOneOf1Metadata = GHC.Maybe.Nothing,
                                                                                                   selectCoinsRequestBodyOneOf1Payments = selectCoinsRequestBodyOneOf1Payments,
                                                                                                   selectCoinsRequestBodyOneOf1Withdrawal = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items@ in the specification.
-- 
-- 
data SelectCoinsRequestBodyOneOf1Payments = SelectCoinsRequestBodyOneOf1Payments {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  selectCoinsRequestBodyOneOf1PaymentsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , selectCoinsRequestBodyOneOf1PaymentsAmount :: SelectCoinsRequestBodyOneOf1PaymentsAmount
  -- | assets: A flat list of assets (possibly empty).
  , selectCoinsRequestBodyOneOf1PaymentsAssets :: (GHC.Maybe.Maybe ([SelectCoinsRequestBodyOneOf1PaymentsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsRequestBodyOneOf1Payments
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf1PaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf1PaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (selectCoinsRequestBodyOneOf1PaymentsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf1PaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf1PaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (selectCoinsRequestBodyOneOf1PaymentsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsRequestBodyOneOf1Payments
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsRequestBodyOneOf1Payments" (\obj -> ((GHC.Base.pure SelectCoinsRequestBodyOneOf1Payments GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'SelectCoinsRequestBodyOneOf1Payments' with all required fields.
mkSelectCoinsRequestBodyOneOf1Payments :: Data.Text.Internal.Text -- ^ 'selectCoinsRequestBodyOneOf1PaymentsAddress'
  -> SelectCoinsRequestBodyOneOf1PaymentsAmount -- ^ 'selectCoinsRequestBodyOneOf1PaymentsAmount'
  -> SelectCoinsRequestBodyOneOf1Payments
mkSelectCoinsRequestBodyOneOf1Payments selectCoinsRequestBodyOneOf1PaymentsAddress selectCoinsRequestBodyOneOf1PaymentsAmount = SelectCoinsRequestBodyOneOf1Payments{selectCoinsRequestBodyOneOf1PaymentsAddress = selectCoinsRequestBodyOneOf1PaymentsAddress,
                                                                                                                                                                     selectCoinsRequestBodyOneOf1PaymentsAmount = selectCoinsRequestBodyOneOf1PaymentsAmount,
                                                                                                                                                                     selectCoinsRequestBodyOneOf1PaymentsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data SelectCoinsRequestBodyOneOf1PaymentsAmount = SelectCoinsRequestBodyOneOf1PaymentsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  selectCoinsRequestBodyOneOf1PaymentsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsRequestBodyOneOf1PaymentsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf1PaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf1PaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsRequestBodyOneOf1PaymentsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsRequestBodyOneOf1PaymentsAmount" (\obj -> GHC.Base.pure SelectCoinsRequestBodyOneOf1PaymentsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsRequestBodyOneOf1PaymentsAmount' with all required fields.
mkSelectCoinsRequestBodyOneOf1PaymentsAmount :: GHC.Types.Int -- ^ 'selectCoinsRequestBodyOneOf1PaymentsAmountQuantity'
  -> SelectCoinsRequestBodyOneOf1PaymentsAmount
mkSelectCoinsRequestBodyOneOf1PaymentsAmount selectCoinsRequestBodyOneOf1PaymentsAmountQuantity = SelectCoinsRequestBodyOneOf1PaymentsAmount{selectCoinsRequestBodyOneOf1PaymentsAmountQuantity = selectCoinsRequestBodyOneOf1PaymentsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data SelectCoinsRequestBodyOneOf1PaymentsAssets = SelectCoinsRequestBodyOneOf1PaymentsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  selectCoinsRequestBodyOneOf1PaymentsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , selectCoinsRequestBodyOneOf1PaymentsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , selectCoinsRequestBodyOneOf1PaymentsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsRequestBodyOneOf1PaymentsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf1PaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf1PaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf1PaymentsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf1PaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf1PaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf1PaymentsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsRequestBodyOneOf1PaymentsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsRequestBodyOneOf1PaymentsAssets" (\obj -> ((GHC.Base.pure SelectCoinsRequestBodyOneOf1PaymentsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsRequestBodyOneOf1PaymentsAssets' with all required fields.
mkSelectCoinsRequestBodyOneOf1PaymentsAssets :: Data.Text.Internal.Text -- ^ 'selectCoinsRequestBodyOneOf1PaymentsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'selectCoinsRequestBodyOneOf1PaymentsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'selectCoinsRequestBodyOneOf1PaymentsAssetsQuantity'
  -> SelectCoinsRequestBodyOneOf1PaymentsAssets
mkSelectCoinsRequestBodyOneOf1PaymentsAssets selectCoinsRequestBodyOneOf1PaymentsAssetsAsset_name selectCoinsRequestBodyOneOf1PaymentsAssetsPolicy_id selectCoinsRequestBodyOneOf1PaymentsAssetsQuantity = SelectCoinsRequestBodyOneOf1PaymentsAssets{selectCoinsRequestBodyOneOf1PaymentsAssetsAsset_name = selectCoinsRequestBodyOneOf1PaymentsAssetsAsset_name,
                                                                                                                                                                                                                                                      selectCoinsRequestBodyOneOf1PaymentsAssetsPolicy_id = selectCoinsRequestBodyOneOf1PaymentsAssetsPolicy_id,
                                                                                                                                                                                                                                                      selectCoinsRequestBodyOneOf1PaymentsAssetsQuantity = selectCoinsRequestBodyOneOf1PaymentsAssetsQuantity}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.oneOf.properties.withdrawal@ in the specification.
-- 
-- When provided, instruments the server to automatically withdraw rewards from the source wallet when they are deemed
-- sufficient (i.e. they contribute to the balance for at least as much as they cost).
-- 
-- As a consequence, the resulting transaction may or may not have a withdrawal object. Summarizing:
-- 
-- withdrawal field | reward balance | result
-- ---              | ---            | ---
-- \`null\`           | too small      | ✓ no withdrawals generated
-- \`null\`           | big enough     | ✓ no withdrawals generated
-- \`\"self\"\`         | too small      | ✓ no withdrawals generated
-- \`\"self\"\`         | big enough     | ✓ withdrawal generated
data SelectCoinsRequestBodyOneOf1Withdrawal =
   SelectCoinsRequestBodyOneOf1WithdrawalOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | SelectCoinsRequestBodyOneOf1WithdrawalTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | SelectCoinsRequestBodyOneOf1WithdrawalEnumSelf -- ^ Represents the JSON value @"self"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsRequestBodyOneOf1Withdrawal
    where toJSON (SelectCoinsRequestBodyOneOf1WithdrawalOther val) = val
          toJSON (SelectCoinsRequestBodyOneOf1WithdrawalTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (SelectCoinsRequestBodyOneOf1WithdrawalEnumSelf) = "self"
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsRequestBodyOneOf1Withdrawal
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "self" -> SelectCoinsRequestBodyOneOf1WithdrawalEnumSelf
                                            | GHC.Base.otherwise -> SelectCoinsRequestBodyOneOf1WithdrawalOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data SelectCoinsRequestBodyOneOf2 = SelectCoinsRequestBodyOneOf2 {
  -- | delegation_action: A delegation action.
  -- 
  -- Pool id is only required for \"join\".
  selectCoinsRequestBodyOneOf2Delegation_action :: SelectCoinsRequestBodyOneOf2Delegation_action
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsRequestBodyOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["delegation_action" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf2Delegation_action obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["delegation_action" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf2Delegation_action obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsRequestBodyOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsRequestBodyOneOf2" (\obj -> GHC.Base.pure SelectCoinsRequestBodyOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delegation_action"))
-- | Create a new 'SelectCoinsRequestBodyOneOf2' with all required fields.
mkSelectCoinsRequestBodyOneOf2 :: SelectCoinsRequestBodyOneOf2Delegation_action -- ^ 'selectCoinsRequestBodyOneOf2Delegation_action'
  -> SelectCoinsRequestBodyOneOf2
mkSelectCoinsRequestBodyOneOf2 selectCoinsRequestBodyOneOf2Delegation_action = SelectCoinsRequestBodyOneOf2{selectCoinsRequestBodyOneOf2Delegation_action = selectCoinsRequestBodyOneOf2Delegation_action}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.oneOf.properties.delegation_action@ in the specification.
-- 
-- A delegation action.
-- 
-- Pool id is only required for \"join\".
data SelectCoinsRequestBodyOneOf2Delegation_action = SelectCoinsRequestBodyOneOf2Delegation_action {
  -- | action
  selectCoinsRequestBodyOneOf2Delegation_actionAction :: SelectCoinsRequestBodyOneOf2Delegation_actionAction
  -- | pool: A unique identifier for the pool.
  , selectCoinsRequestBodyOneOf2Delegation_actionPool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsRequestBodyOneOf2Delegation_action
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["action" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf2Delegation_actionAction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (selectCoinsRequestBodyOneOf2Delegation_actionPool obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["action" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf2Delegation_actionAction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (selectCoinsRequestBodyOneOf2Delegation_actionPool obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsRequestBodyOneOf2Delegation_action
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsRequestBodyOneOf2Delegation_action" (\obj -> (GHC.Base.pure SelectCoinsRequestBodyOneOf2Delegation_action GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "action")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool"))
-- | Create a new 'SelectCoinsRequestBodyOneOf2Delegation_action' with all required fields.
mkSelectCoinsRequestBodyOneOf2Delegation_action :: SelectCoinsRequestBodyOneOf2Delegation_actionAction -- ^ 'selectCoinsRequestBodyOneOf2Delegation_actionAction'
  -> SelectCoinsRequestBodyOneOf2Delegation_action
mkSelectCoinsRequestBodyOneOf2Delegation_action selectCoinsRequestBodyOneOf2Delegation_actionAction = SelectCoinsRequestBodyOneOf2Delegation_action{selectCoinsRequestBodyOneOf2Delegation_actionAction = selectCoinsRequestBodyOneOf2Delegation_actionAction,
                                                                                                                                                    selectCoinsRequestBodyOneOf2Delegation_actionPool = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.oneOf.properties.delegation_action.properties.action@ in the specification.
-- 
-- 
data SelectCoinsRequestBodyOneOf2Delegation_actionAction =
   SelectCoinsRequestBodyOneOf2Delegation_actionActionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | SelectCoinsRequestBodyOneOf2Delegation_actionActionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | SelectCoinsRequestBodyOneOf2Delegation_actionActionEnumQuit -- ^ Represents the JSON value @"quit"@
  | SelectCoinsRequestBodyOneOf2Delegation_actionActionEnumJoin -- ^ Represents the JSON value @"join"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsRequestBodyOneOf2Delegation_actionAction
    where toJSON (SelectCoinsRequestBodyOneOf2Delegation_actionActionOther val) = val
          toJSON (SelectCoinsRequestBodyOneOf2Delegation_actionActionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (SelectCoinsRequestBodyOneOf2Delegation_actionActionEnumQuit) = "quit"
          toJSON (SelectCoinsRequestBodyOneOf2Delegation_actionActionEnumJoin) = "join"
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsRequestBodyOneOf2Delegation_actionAction
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "quit" -> SelectCoinsRequestBodyOneOf2Delegation_actionActionEnumQuit
                                            | val GHC.Classes.== "join" -> SelectCoinsRequestBodyOneOf2Delegation_actionActionEnumJoin
                                            | GHC.Base.otherwise -> SelectCoinsRequestBodyOneOf2Delegation_actionActionOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data SelectCoinsRequestBodyOneOf3 = SelectCoinsRequestBodyOneOf3 {
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  selectCoinsRequestBodyOneOf3Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | payments: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , selectCoinsRequestBodyOneOf3Payments :: ([SelectCoinsRequestBodyOneOf3Payments])
  -- | withdrawal: When provided, attempts to withdraw rewards from the default stake address
  -- corresponding to the given mnemonic.
  -- 
  -- Should the rewards be null or too small to be worth withdrawing (i.e. the
  -- cost of adding them into the transaction is more than their own intrinsic
  -- value), the server will reject the request with a
  -- \`withdrawal_not_beneficial\` error.
  -- 
  -- withdrawal field    | reward balance | result
  -- ---                 | ---            | ---
  -- any recovery phrase | too small      | x Error 403 \`withdrawal_not_beneficial\`
  -- any recovery phrase | big enough     | ✓ withdrawal generated
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 24 items
  -- * Must have a minimum of 15 items
  , selectCoinsRequestBodyOneOf3Withdrawal :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsRequestBodyOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (selectCoinsRequestBodyOneOf3Metadata obj) : ["payments" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3Payments obj] : ["withdrawal" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3Withdrawal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (selectCoinsRequestBodyOneOf3Metadata obj) : ["payments" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3Payments obj] : ["withdrawal" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3Withdrawal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsRequestBodyOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsRequestBodyOneOf3" (\obj -> ((GHC.Base.pure SelectCoinsRequestBodyOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "payments")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "withdrawal"))
-- | Create a new 'SelectCoinsRequestBodyOneOf3' with all required fields.
mkSelectCoinsRequestBodyOneOf3 :: [SelectCoinsRequestBodyOneOf3Payments] -- ^ 'selectCoinsRequestBodyOneOf3Payments'
  -> [Data.Text.Internal.Text] -- ^ 'selectCoinsRequestBodyOneOf3Withdrawal'
  -> SelectCoinsRequestBodyOneOf3
mkSelectCoinsRequestBodyOneOf3 selectCoinsRequestBodyOneOf3Payments selectCoinsRequestBodyOneOf3Withdrawal = SelectCoinsRequestBodyOneOf3{selectCoinsRequestBodyOneOf3Metadata = GHC.Maybe.Nothing,
                                                                                                                                          selectCoinsRequestBodyOneOf3Payments = selectCoinsRequestBodyOneOf3Payments,
                                                                                                                                          selectCoinsRequestBodyOneOf3Withdrawal = selectCoinsRequestBodyOneOf3Withdrawal}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items@ in the specification.
-- 
-- 
data SelectCoinsRequestBodyOneOf3Payments = SelectCoinsRequestBodyOneOf3Payments {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  selectCoinsRequestBodyOneOf3PaymentsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , selectCoinsRequestBodyOneOf3PaymentsAmount :: SelectCoinsRequestBodyOneOf3PaymentsAmount
  -- | assets: A flat list of assets (possibly empty).
  , selectCoinsRequestBodyOneOf3PaymentsAssets :: (GHC.Maybe.Maybe ([SelectCoinsRequestBodyOneOf3PaymentsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsRequestBodyOneOf3Payments
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3PaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3PaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (selectCoinsRequestBodyOneOf3PaymentsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3PaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3PaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (selectCoinsRequestBodyOneOf3PaymentsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsRequestBodyOneOf3Payments
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsRequestBodyOneOf3Payments" (\obj -> ((GHC.Base.pure SelectCoinsRequestBodyOneOf3Payments GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'SelectCoinsRequestBodyOneOf3Payments' with all required fields.
mkSelectCoinsRequestBodyOneOf3Payments :: Data.Text.Internal.Text -- ^ 'selectCoinsRequestBodyOneOf3PaymentsAddress'
  -> SelectCoinsRequestBodyOneOf3PaymentsAmount -- ^ 'selectCoinsRequestBodyOneOf3PaymentsAmount'
  -> SelectCoinsRequestBodyOneOf3Payments
mkSelectCoinsRequestBodyOneOf3Payments selectCoinsRequestBodyOneOf3PaymentsAddress selectCoinsRequestBodyOneOf3PaymentsAmount = SelectCoinsRequestBodyOneOf3Payments{selectCoinsRequestBodyOneOf3PaymentsAddress = selectCoinsRequestBodyOneOf3PaymentsAddress,
                                                                                                                                                                     selectCoinsRequestBodyOneOf3PaymentsAmount = selectCoinsRequestBodyOneOf3PaymentsAmount,
                                                                                                                                                                     selectCoinsRequestBodyOneOf3PaymentsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data SelectCoinsRequestBodyOneOf3PaymentsAmount = SelectCoinsRequestBodyOneOf3PaymentsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  selectCoinsRequestBodyOneOf3PaymentsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsRequestBodyOneOf3PaymentsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3PaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3PaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsRequestBodyOneOf3PaymentsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsRequestBodyOneOf3PaymentsAmount" (\obj -> GHC.Base.pure SelectCoinsRequestBodyOneOf3PaymentsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsRequestBodyOneOf3PaymentsAmount' with all required fields.
mkSelectCoinsRequestBodyOneOf3PaymentsAmount :: GHC.Types.Int -- ^ 'selectCoinsRequestBodyOneOf3PaymentsAmountQuantity'
  -> SelectCoinsRequestBodyOneOf3PaymentsAmount
mkSelectCoinsRequestBodyOneOf3PaymentsAmount selectCoinsRequestBodyOneOf3PaymentsAmountQuantity = SelectCoinsRequestBodyOneOf3PaymentsAmount{selectCoinsRequestBodyOneOf3PaymentsAmountQuantity = selectCoinsRequestBodyOneOf3PaymentsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data SelectCoinsRequestBodyOneOf3PaymentsAssets = SelectCoinsRequestBodyOneOf3PaymentsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  selectCoinsRequestBodyOneOf3PaymentsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , selectCoinsRequestBodyOneOf3PaymentsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , selectCoinsRequestBodyOneOf3PaymentsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsRequestBodyOneOf3PaymentsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3PaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3PaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3PaymentsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3PaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3PaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= selectCoinsRequestBodyOneOf3PaymentsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsRequestBodyOneOf3PaymentsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsRequestBodyOneOf3PaymentsAssets" (\obj -> ((GHC.Base.pure SelectCoinsRequestBodyOneOf3PaymentsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsRequestBodyOneOf3PaymentsAssets' with all required fields.
mkSelectCoinsRequestBodyOneOf3PaymentsAssets :: Data.Text.Internal.Text -- ^ 'selectCoinsRequestBodyOneOf3PaymentsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'selectCoinsRequestBodyOneOf3PaymentsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'selectCoinsRequestBodyOneOf3PaymentsAssetsQuantity'
  -> SelectCoinsRequestBodyOneOf3PaymentsAssets
mkSelectCoinsRequestBodyOneOf3PaymentsAssets selectCoinsRequestBodyOneOf3PaymentsAssetsAsset_name selectCoinsRequestBodyOneOf3PaymentsAssetsPolicy_id selectCoinsRequestBodyOneOf3PaymentsAssetsQuantity = SelectCoinsRequestBodyOneOf3PaymentsAssets{selectCoinsRequestBodyOneOf3PaymentsAssetsAsset_name = selectCoinsRequestBodyOneOf3PaymentsAssetsAsset_name,
                                                                                                                                                                                                                                                      selectCoinsRequestBodyOneOf3PaymentsAssetsPolicy_id = selectCoinsRequestBodyOneOf3PaymentsAssetsPolicy_id,
                                                                                                                                                                                                                                                      selectCoinsRequestBodyOneOf3PaymentsAssetsQuantity = selectCoinsRequestBodyOneOf3PaymentsAssetsQuantity}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data SelectCoinsRequestBodyVariants =
   SelectCoinsRequestBodyVariant1 SelectCoinsRequestBodyOneOf1
  | SelectCoinsRequestBodyVariant2 SelectCoinsRequestBodyOneOf2
  | SelectCoinsRequestBodyVariant3 SelectCoinsRequestBodyOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsRequestBodyVariants
    where toJSON (SelectCoinsRequestBodyVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (SelectCoinsRequestBodyVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (SelectCoinsRequestBodyVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsRequestBodyVariants
    where parseJSON val = case (SelectCoinsRequestBodyVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SelectCoinsRequestBodyVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SelectCoinsRequestBodyVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Represents a response of the operation 'selectCoins'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'SelectCoinsResponseError' is used.
data SelectCoinsResponse =
   SelectCoinsResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | SelectCoinsResponse200 SelectCoinsResponseBody200 -- ^ OK
  | SelectCoinsResponse400 SelectCoinsResponseBody400 -- ^ Bad Request
  | SelectCoinsResponse403 SelectCoinsResponseBody403Variants -- ^ Forbidden
  | SelectCoinsResponse404 SelectCoinsResponseBody404 -- ^ Not Found
  | SelectCoinsResponse406 SelectCoinsResponseBody406 -- ^ Not Acceptable
  | SelectCoinsResponse415 SelectCoinsResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema@ in the specification.
-- 
-- 
data SelectCoinsResponseBody200 = SelectCoinsResponseBody200 {
  -- | certificates
  selectCoinsResponseBody200Certificates :: (GHC.Maybe.Maybe ([SelectCoinsResponseBody200Certificates]))
  -- | change: A list of transaction change outputs.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , selectCoinsResponseBody200Change :: ([SelectCoinsResponseBody200Change])
  -- | collateral: A list of transaction inputs used for collateral
  , selectCoinsResponseBody200Collateral :: (GHC.Maybe.Maybe ([SelectCoinsResponseBody200Collateral]))
  -- | deposits_returned: A list of deposits associated with a transaction.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , selectCoinsResponseBody200Deposits_returned :: (GHC.Maybe.Maybe ([SelectCoinsResponseBody200Deposits_returned]))
  -- | deposits_taken: A list of deposits associated with a transaction.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , selectCoinsResponseBody200Deposits_taken :: (GHC.Maybe.Maybe ([SelectCoinsResponseBody200Deposits_taken]))
  -- | inputs: A list of transaction inputs
  , selectCoinsResponseBody200Inputs :: ([SelectCoinsResponseBody200Inputs])
  -- | metadata: Transaction metadata, serialized according to the expected on-chain binary format, base64-encoded.
  , selectCoinsResponseBody200Metadata :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , selectCoinsResponseBody200Outputs :: ([SelectCoinsResponseBody200Outputs])
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , selectCoinsResponseBody200Withdrawals :: (GHC.Maybe.Maybe ([SelectCoinsResponseBody200Withdrawals]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200Certificates obj) : ["change" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200Change obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_returned" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200Deposits_returned obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_taken" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200Deposits_taken obj) : ["inputs" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200Metadata obj) : ["outputs" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawals" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200Withdrawals obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200Certificates obj) : ["change" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200Change obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_returned" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200Deposits_returned obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_taken" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200Deposits_taken obj) : ["inputs" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200Metadata obj) : ["outputs" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawals" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200Withdrawals obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200" (\obj -> ((((((((GHC.Base.pure SelectCoinsResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "change")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "deposits_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "deposits_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "withdrawals"))
-- | Create a new 'SelectCoinsResponseBody200' with all required fields.
mkSelectCoinsResponseBody200 :: [SelectCoinsResponseBody200Change] -- ^ 'selectCoinsResponseBody200Change'
  -> [SelectCoinsResponseBody200Inputs] -- ^ 'selectCoinsResponseBody200Inputs'
  -> [SelectCoinsResponseBody200Outputs] -- ^ 'selectCoinsResponseBody200Outputs'
  -> SelectCoinsResponseBody200
mkSelectCoinsResponseBody200 selectCoinsResponseBody200Change selectCoinsResponseBody200Inputs selectCoinsResponseBody200Outputs = SelectCoinsResponseBody200{selectCoinsResponseBody200Certificates = GHC.Maybe.Nothing,
                                                                                                                                                              selectCoinsResponseBody200Change = selectCoinsResponseBody200Change,
                                                                                                                                                              selectCoinsResponseBody200Collateral = GHC.Maybe.Nothing,
                                                                                                                                                              selectCoinsResponseBody200Deposits_returned = GHC.Maybe.Nothing,
                                                                                                                                                              selectCoinsResponseBody200Deposits_taken = GHC.Maybe.Nothing,
                                                                                                                                                              selectCoinsResponseBody200Inputs = selectCoinsResponseBody200Inputs,
                                                                                                                                                              selectCoinsResponseBody200Metadata = GHC.Maybe.Nothing,
                                                                                                                                                              selectCoinsResponseBody200Outputs = selectCoinsResponseBody200Outputs,
                                                                                                                                                              selectCoinsResponseBody200Withdrawals = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.certificates.items@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data SelectCoinsResponseBody200Certificates = SelectCoinsResponseBody200Certificates {
  -- | certificate_type
  selectCoinsResponseBody200CertificatesCertificate_type :: SelectCoinsResponseBody200CertificatesCertificate_type
  -- | pool: A unique identifier for the pool.
  , selectCoinsResponseBody200CertificatesPool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , selectCoinsResponseBody200CertificatesReward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200Certificates
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CertificatesCertificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200CertificatesPool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CertificatesReward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CertificatesCertificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200CertificatesPool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CertificatesReward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200Certificates
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200Certificates" (\obj -> ((GHC.Base.pure SelectCoinsResponseBody200Certificates GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'SelectCoinsResponseBody200Certificates' with all required fields.
mkSelectCoinsResponseBody200Certificates :: SelectCoinsResponseBody200CertificatesCertificate_type -- ^ 'selectCoinsResponseBody200CertificatesCertificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'selectCoinsResponseBody200CertificatesReward_account_path'
  -> SelectCoinsResponseBody200Certificates
mkSelectCoinsResponseBody200Certificates selectCoinsResponseBody200CertificatesCertificate_type selectCoinsResponseBody200CertificatesReward_account_path = SelectCoinsResponseBody200Certificates{selectCoinsResponseBody200CertificatesCertificate_type = selectCoinsResponseBody200CertificatesCertificate_type,
                                                                                                                                                                                                   selectCoinsResponseBody200CertificatesPool = GHC.Maybe.Nothing,
                                                                                                                                                                                                   selectCoinsResponseBody200CertificatesReward_account_path = selectCoinsResponseBody200CertificatesReward_account_path}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.certificates.items.properties.certificate_type@ in the specification.
-- 
-- 
data SelectCoinsResponseBody200CertificatesCertificate_type =
   SelectCoinsResponseBody200CertificatesCertificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | SelectCoinsResponseBody200CertificatesCertificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | SelectCoinsResponseBody200CertificatesCertificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | SelectCoinsResponseBody200CertificatesCertificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | SelectCoinsResponseBody200CertificatesCertificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200CertificatesCertificate_type
    where toJSON (SelectCoinsResponseBody200CertificatesCertificate_typeOther val) = val
          toJSON (SelectCoinsResponseBody200CertificatesCertificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (SelectCoinsResponseBody200CertificatesCertificate_typeEnumJoin_pool) = "join_pool"
          toJSON (SelectCoinsResponseBody200CertificatesCertificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (SelectCoinsResponseBody200CertificatesCertificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200CertificatesCertificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> SelectCoinsResponseBody200CertificatesCertificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> SelectCoinsResponseBody200CertificatesCertificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> SelectCoinsResponseBody200CertificatesCertificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> SelectCoinsResponseBody200CertificatesCertificate_typeOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.change.items@ in the specification.
-- 
-- 
data SelectCoinsResponseBody200Change = SelectCoinsResponseBody200Change {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  selectCoinsResponseBody200ChangeAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , selectCoinsResponseBody200ChangeAmount :: SelectCoinsResponseBody200ChangeAmount
  -- | assets: A flat list of assets (possibly empty).
  , selectCoinsResponseBody200ChangeAssets :: (GHC.Maybe.Maybe ([SelectCoinsResponseBody200ChangeAssets]))
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , selectCoinsResponseBody200ChangeDerivation_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200Change
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200ChangeAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200ChangeAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200ChangeAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200ChangeDerivation_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200ChangeAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200ChangeAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200ChangeAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200ChangeDerivation_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200Change
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200Change" (\obj -> (((GHC.Base.pure SelectCoinsResponseBody200Change GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path"))
-- | Create a new 'SelectCoinsResponseBody200Change' with all required fields.
mkSelectCoinsResponseBody200Change :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody200ChangeAddress'
  -> SelectCoinsResponseBody200ChangeAmount -- ^ 'selectCoinsResponseBody200ChangeAmount'
  -> [Data.Text.Internal.Text] -- ^ 'selectCoinsResponseBody200ChangeDerivation_path'
  -> SelectCoinsResponseBody200Change
mkSelectCoinsResponseBody200Change selectCoinsResponseBody200ChangeAddress selectCoinsResponseBody200ChangeAmount selectCoinsResponseBody200ChangeDerivation_path = SelectCoinsResponseBody200Change{selectCoinsResponseBody200ChangeAddress = selectCoinsResponseBody200ChangeAddress,
                                                                                                                                                                                                     selectCoinsResponseBody200ChangeAmount = selectCoinsResponseBody200ChangeAmount,
                                                                                                                                                                                                     selectCoinsResponseBody200ChangeAssets = GHC.Maybe.Nothing,
                                                                                                                                                                                                     selectCoinsResponseBody200ChangeDerivation_path = selectCoinsResponseBody200ChangeDerivation_path}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.change.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data SelectCoinsResponseBody200ChangeAmount = SelectCoinsResponseBody200ChangeAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  selectCoinsResponseBody200ChangeAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200ChangeAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200ChangeAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200ChangeAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200ChangeAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200ChangeAmount" (\obj -> GHC.Base.pure SelectCoinsResponseBody200ChangeAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsResponseBody200ChangeAmount' with all required fields.
mkSelectCoinsResponseBody200ChangeAmount :: GHC.Types.Int -- ^ 'selectCoinsResponseBody200ChangeAmountQuantity'
  -> SelectCoinsResponseBody200ChangeAmount
mkSelectCoinsResponseBody200ChangeAmount selectCoinsResponseBody200ChangeAmountQuantity = SelectCoinsResponseBody200ChangeAmount{selectCoinsResponseBody200ChangeAmountQuantity = selectCoinsResponseBody200ChangeAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.change.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data SelectCoinsResponseBody200ChangeAssets = SelectCoinsResponseBody200ChangeAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  selectCoinsResponseBody200ChangeAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , selectCoinsResponseBody200ChangeAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , selectCoinsResponseBody200ChangeAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200ChangeAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200ChangeAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200ChangeAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200ChangeAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200ChangeAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200ChangeAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200ChangeAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200ChangeAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200ChangeAssets" (\obj -> ((GHC.Base.pure SelectCoinsResponseBody200ChangeAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsResponseBody200ChangeAssets' with all required fields.
mkSelectCoinsResponseBody200ChangeAssets :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody200ChangeAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody200ChangeAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'selectCoinsResponseBody200ChangeAssetsQuantity'
  -> SelectCoinsResponseBody200ChangeAssets
mkSelectCoinsResponseBody200ChangeAssets selectCoinsResponseBody200ChangeAssetsAsset_name selectCoinsResponseBody200ChangeAssetsPolicy_id selectCoinsResponseBody200ChangeAssetsQuantity = SelectCoinsResponseBody200ChangeAssets{selectCoinsResponseBody200ChangeAssetsAsset_name = selectCoinsResponseBody200ChangeAssetsAsset_name,
                                                                                                                                                                                                                                  selectCoinsResponseBody200ChangeAssetsPolicy_id = selectCoinsResponseBody200ChangeAssetsPolicy_id,
                                                                                                                                                                                                                                  selectCoinsResponseBody200ChangeAssetsQuantity = selectCoinsResponseBody200ChangeAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.collateral.items@ in the specification.
-- 
-- 
data SelectCoinsResponseBody200Collateral = SelectCoinsResponseBody200Collateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  selectCoinsResponseBody200CollateralAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , selectCoinsResponseBody200CollateralAmount :: SelectCoinsResponseBody200CollateralAmount
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , selectCoinsResponseBody200CollateralDerivation_path :: ([Data.Text.Internal.Text])
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , selectCoinsResponseBody200CollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , selectCoinsResponseBody200CollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200Collateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CollateralAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CollateralAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CollateralDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CollateralAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CollateralAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CollateralDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200Collateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200Collateral" (\obj -> ((((GHC.Base.pure SelectCoinsResponseBody200Collateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'SelectCoinsResponseBody200Collateral' with all required fields.
mkSelectCoinsResponseBody200Collateral :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody200CollateralAddress'
  -> SelectCoinsResponseBody200CollateralAmount -- ^ 'selectCoinsResponseBody200CollateralAmount'
  -> [Data.Text.Internal.Text] -- ^ 'selectCoinsResponseBody200CollateralDerivation_path'
  -> Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody200CollateralId'
  -> GHC.Types.Int -- ^ 'selectCoinsResponseBody200CollateralIndex'
  -> SelectCoinsResponseBody200Collateral
mkSelectCoinsResponseBody200Collateral selectCoinsResponseBody200CollateralAddress selectCoinsResponseBody200CollateralAmount selectCoinsResponseBody200CollateralDerivation_path selectCoinsResponseBody200CollateralId selectCoinsResponseBody200CollateralIndex = SelectCoinsResponseBody200Collateral{selectCoinsResponseBody200CollateralAddress = selectCoinsResponseBody200CollateralAddress,
                                                                                                                                                                                                                                                                                                          selectCoinsResponseBody200CollateralAmount = selectCoinsResponseBody200CollateralAmount,
                                                                                                                                                                                                                                                                                                          selectCoinsResponseBody200CollateralDerivation_path = selectCoinsResponseBody200CollateralDerivation_path,
                                                                                                                                                                                                                                                                                                          selectCoinsResponseBody200CollateralId = selectCoinsResponseBody200CollateralId,
                                                                                                                                                                                                                                                                                                          selectCoinsResponseBody200CollateralIndex = selectCoinsResponseBody200CollateralIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data SelectCoinsResponseBody200CollateralAmount = SelectCoinsResponseBody200CollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  selectCoinsResponseBody200CollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200CollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200CollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200CollateralAmount" (\obj -> GHC.Base.pure SelectCoinsResponseBody200CollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsResponseBody200CollateralAmount' with all required fields.
mkSelectCoinsResponseBody200CollateralAmount :: GHC.Types.Int -- ^ 'selectCoinsResponseBody200CollateralAmountQuantity'
  -> SelectCoinsResponseBody200CollateralAmount
mkSelectCoinsResponseBody200CollateralAmount selectCoinsResponseBody200CollateralAmountQuantity = SelectCoinsResponseBody200CollateralAmount{selectCoinsResponseBody200CollateralAmountQuantity = selectCoinsResponseBody200CollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.deposits_returned.items@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data SelectCoinsResponseBody200Deposits_returned = SelectCoinsResponseBody200Deposits_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  selectCoinsResponseBody200Deposits_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200Deposits_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200Deposits_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200Deposits_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200Deposits_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200Deposits_returned" (\obj -> GHC.Base.pure SelectCoinsResponseBody200Deposits_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsResponseBody200Deposits_returned' with all required fields.
mkSelectCoinsResponseBody200Deposits_returned :: GHC.Types.Int -- ^ 'selectCoinsResponseBody200Deposits_returnedQuantity'
  -> SelectCoinsResponseBody200Deposits_returned
mkSelectCoinsResponseBody200Deposits_returned selectCoinsResponseBody200Deposits_returnedQuantity = SelectCoinsResponseBody200Deposits_returned{selectCoinsResponseBody200Deposits_returnedQuantity = selectCoinsResponseBody200Deposits_returnedQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.deposits_taken.items@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data SelectCoinsResponseBody200Deposits_taken = SelectCoinsResponseBody200Deposits_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  selectCoinsResponseBody200Deposits_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200Deposits_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200Deposits_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200Deposits_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200Deposits_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200Deposits_taken" (\obj -> GHC.Base.pure SelectCoinsResponseBody200Deposits_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsResponseBody200Deposits_taken' with all required fields.
mkSelectCoinsResponseBody200Deposits_taken :: GHC.Types.Int -- ^ 'selectCoinsResponseBody200Deposits_takenQuantity'
  -> SelectCoinsResponseBody200Deposits_taken
mkSelectCoinsResponseBody200Deposits_taken selectCoinsResponseBody200Deposits_takenQuantity = SelectCoinsResponseBody200Deposits_taken{selectCoinsResponseBody200Deposits_takenQuantity = selectCoinsResponseBody200Deposits_takenQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.inputs.items@ in the specification.
-- 
-- 
data SelectCoinsResponseBody200Inputs = SelectCoinsResponseBody200Inputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  selectCoinsResponseBody200InputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , selectCoinsResponseBody200InputsAmount :: SelectCoinsResponseBody200InputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , selectCoinsResponseBody200InputsAssets :: (GHC.Maybe.Maybe ([SelectCoinsResponseBody200InputsAssets]))
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , selectCoinsResponseBody200InputsDerivation_path :: ([Data.Text.Internal.Text])
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , selectCoinsResponseBody200InputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , selectCoinsResponseBody200InputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200Inputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200InputsAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200InputsAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200Inputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200Inputs" (\obj -> (((((GHC.Base.pure SelectCoinsResponseBody200Inputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'SelectCoinsResponseBody200Inputs' with all required fields.
mkSelectCoinsResponseBody200Inputs :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody200InputsAddress'
  -> SelectCoinsResponseBody200InputsAmount -- ^ 'selectCoinsResponseBody200InputsAmount'
  -> [Data.Text.Internal.Text] -- ^ 'selectCoinsResponseBody200InputsDerivation_path'
  -> Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody200InputsId'
  -> GHC.Types.Int -- ^ 'selectCoinsResponseBody200InputsIndex'
  -> SelectCoinsResponseBody200Inputs
mkSelectCoinsResponseBody200Inputs selectCoinsResponseBody200InputsAddress selectCoinsResponseBody200InputsAmount selectCoinsResponseBody200InputsDerivation_path selectCoinsResponseBody200InputsId selectCoinsResponseBody200InputsIndex = SelectCoinsResponseBody200Inputs{selectCoinsResponseBody200InputsAddress = selectCoinsResponseBody200InputsAddress,
                                                                                                                                                                                                                                                                              selectCoinsResponseBody200InputsAmount = selectCoinsResponseBody200InputsAmount,
                                                                                                                                                                                                                                                                              selectCoinsResponseBody200InputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                              selectCoinsResponseBody200InputsDerivation_path = selectCoinsResponseBody200InputsDerivation_path,
                                                                                                                                                                                                                                                                              selectCoinsResponseBody200InputsId = selectCoinsResponseBody200InputsId,
                                                                                                                                                                                                                                                                              selectCoinsResponseBody200InputsIndex = selectCoinsResponseBody200InputsIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data SelectCoinsResponseBody200InputsAmount = SelectCoinsResponseBody200InputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  selectCoinsResponseBody200InputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200InputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200InputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200InputsAmount" (\obj -> GHC.Base.pure SelectCoinsResponseBody200InputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsResponseBody200InputsAmount' with all required fields.
mkSelectCoinsResponseBody200InputsAmount :: GHC.Types.Int -- ^ 'selectCoinsResponseBody200InputsAmountQuantity'
  -> SelectCoinsResponseBody200InputsAmount
mkSelectCoinsResponseBody200InputsAmount selectCoinsResponseBody200InputsAmountQuantity = SelectCoinsResponseBody200InputsAmount{selectCoinsResponseBody200InputsAmountQuantity = selectCoinsResponseBody200InputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data SelectCoinsResponseBody200InputsAssets = SelectCoinsResponseBody200InputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  selectCoinsResponseBody200InputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , selectCoinsResponseBody200InputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , selectCoinsResponseBody200InputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200InputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200InputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200InputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200InputsAssets" (\obj -> ((GHC.Base.pure SelectCoinsResponseBody200InputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsResponseBody200InputsAssets' with all required fields.
mkSelectCoinsResponseBody200InputsAssets :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody200InputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody200InputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'selectCoinsResponseBody200InputsAssetsQuantity'
  -> SelectCoinsResponseBody200InputsAssets
mkSelectCoinsResponseBody200InputsAssets selectCoinsResponseBody200InputsAssetsAsset_name selectCoinsResponseBody200InputsAssetsPolicy_id selectCoinsResponseBody200InputsAssetsQuantity = SelectCoinsResponseBody200InputsAssets{selectCoinsResponseBody200InputsAssetsAsset_name = selectCoinsResponseBody200InputsAssetsAsset_name,
                                                                                                                                                                                                                                  selectCoinsResponseBody200InputsAssetsPolicy_id = selectCoinsResponseBody200InputsAssetsPolicy_id,
                                                                                                                                                                                                                                  selectCoinsResponseBody200InputsAssetsQuantity = selectCoinsResponseBody200InputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.outputs.items@ in the specification.
-- 
-- 
data SelectCoinsResponseBody200Outputs = SelectCoinsResponseBody200Outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  selectCoinsResponseBody200OutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , selectCoinsResponseBody200OutputsAmount :: SelectCoinsResponseBody200OutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , selectCoinsResponseBody200OutputsAssets :: (GHC.Maybe.Maybe ([SelectCoinsResponseBody200OutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200Outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200OutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody200OutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200Outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200Outputs" (\obj -> ((GHC.Base.pure SelectCoinsResponseBody200Outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'SelectCoinsResponseBody200Outputs' with all required fields.
mkSelectCoinsResponseBody200Outputs :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody200OutputsAddress'
  -> SelectCoinsResponseBody200OutputsAmount -- ^ 'selectCoinsResponseBody200OutputsAmount'
  -> SelectCoinsResponseBody200Outputs
mkSelectCoinsResponseBody200Outputs selectCoinsResponseBody200OutputsAddress selectCoinsResponseBody200OutputsAmount = SelectCoinsResponseBody200Outputs{selectCoinsResponseBody200OutputsAddress = selectCoinsResponseBody200OutputsAddress,
                                                                                                                                                         selectCoinsResponseBody200OutputsAmount = selectCoinsResponseBody200OutputsAmount,
                                                                                                                                                         selectCoinsResponseBody200OutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data SelectCoinsResponseBody200OutputsAmount = SelectCoinsResponseBody200OutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  selectCoinsResponseBody200OutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200OutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200OutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200OutputsAmount" (\obj -> GHC.Base.pure SelectCoinsResponseBody200OutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsResponseBody200OutputsAmount' with all required fields.
mkSelectCoinsResponseBody200OutputsAmount :: GHC.Types.Int -- ^ 'selectCoinsResponseBody200OutputsAmountQuantity'
  -> SelectCoinsResponseBody200OutputsAmount
mkSelectCoinsResponseBody200OutputsAmount selectCoinsResponseBody200OutputsAmountQuantity = SelectCoinsResponseBody200OutputsAmount{selectCoinsResponseBody200OutputsAmountQuantity = selectCoinsResponseBody200OutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data SelectCoinsResponseBody200OutputsAssets = SelectCoinsResponseBody200OutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  selectCoinsResponseBody200OutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , selectCoinsResponseBody200OutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , selectCoinsResponseBody200OutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200OutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200OutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200OutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200OutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200OutputsAssets" (\obj -> ((GHC.Base.pure SelectCoinsResponseBody200OutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsResponseBody200OutputsAssets' with all required fields.
mkSelectCoinsResponseBody200OutputsAssets :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody200OutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody200OutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'selectCoinsResponseBody200OutputsAssetsQuantity'
  -> SelectCoinsResponseBody200OutputsAssets
mkSelectCoinsResponseBody200OutputsAssets selectCoinsResponseBody200OutputsAssetsAsset_name selectCoinsResponseBody200OutputsAssetsPolicy_id selectCoinsResponseBody200OutputsAssetsQuantity = SelectCoinsResponseBody200OutputsAssets{selectCoinsResponseBody200OutputsAssetsAsset_name = selectCoinsResponseBody200OutputsAssetsAsset_name,
                                                                                                                                                                                                                                       selectCoinsResponseBody200OutputsAssetsPolicy_id = selectCoinsResponseBody200OutputsAssetsPolicy_id,
                                                                                                                                                                                                                                       selectCoinsResponseBody200OutputsAssetsQuantity = selectCoinsResponseBody200OutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.withdrawals.items@ in the specification.
-- 
-- 
data SelectCoinsResponseBody200Withdrawals = SelectCoinsResponseBody200Withdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  selectCoinsResponseBody200WithdrawalsAmount :: SelectCoinsResponseBody200WithdrawalsAmount
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , selectCoinsResponseBody200WithdrawalsDerivation_path :: ([Data.Text.Internal.Text])
  -- | stake_address
  , selectCoinsResponseBody200WithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200Withdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200WithdrawalsAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200WithdrawalsDerivation_path obj] : ["stake_address" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200WithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200WithdrawalsAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200WithdrawalsDerivation_path obj] : ["stake_address" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200WithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200Withdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200Withdrawals" (\obj -> ((GHC.Base.pure SelectCoinsResponseBody200Withdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'SelectCoinsResponseBody200Withdrawals' with all required fields.
mkSelectCoinsResponseBody200Withdrawals :: SelectCoinsResponseBody200WithdrawalsAmount -- ^ 'selectCoinsResponseBody200WithdrawalsAmount'
  -> [Data.Text.Internal.Text] -- ^ 'selectCoinsResponseBody200WithdrawalsDerivation_path'
  -> Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody200WithdrawalsStake_address'
  -> SelectCoinsResponseBody200Withdrawals
mkSelectCoinsResponseBody200Withdrawals selectCoinsResponseBody200WithdrawalsAmount selectCoinsResponseBody200WithdrawalsDerivation_path selectCoinsResponseBody200WithdrawalsStake_address = SelectCoinsResponseBody200Withdrawals{selectCoinsResponseBody200WithdrawalsAmount = selectCoinsResponseBody200WithdrawalsAmount,
                                                                                                                                                                                                                                    selectCoinsResponseBody200WithdrawalsDerivation_path = selectCoinsResponseBody200WithdrawalsDerivation_path,
                                                                                                                                                                                                                                    selectCoinsResponseBody200WithdrawalsStake_address = selectCoinsResponseBody200WithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data SelectCoinsResponseBody200WithdrawalsAmount = SelectCoinsResponseBody200WithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  selectCoinsResponseBody200WithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody200WithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody200WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody200WithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody200WithdrawalsAmount" (\obj -> GHC.Base.pure SelectCoinsResponseBody200WithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsResponseBody200WithdrawalsAmount' with all required fields.
mkSelectCoinsResponseBody200WithdrawalsAmount :: GHC.Types.Int -- ^ 'selectCoinsResponseBody200WithdrawalsAmountQuantity'
  -> SelectCoinsResponseBody200WithdrawalsAmount
mkSelectCoinsResponseBody200WithdrawalsAmount selectCoinsResponseBody200WithdrawalsAmountQuantity = SelectCoinsResponseBody200WithdrawalsAmount{selectCoinsResponseBody200WithdrawalsAmountQuantity = selectCoinsResponseBody200WithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data SelectCoinsResponseBody400 = SelectCoinsResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  selectCoinsResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody400" (\obj -> GHC.Base.pure SelectCoinsResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'SelectCoinsResponseBody400' with all required fields.
mkSelectCoinsResponseBody400 :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody400Message'
  -> SelectCoinsResponseBody400
mkSelectCoinsResponseBody400 selectCoinsResponseBody400Message = SelectCoinsResponseBody400{selectCoinsResponseBody400Message = selectCoinsResponseBody400Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data SelectCoinsResponseBody403OneOf1 = SelectCoinsResponseBody403OneOf1 {
  -- | message: May occur when submitting a withdrawal while another withdrawal is pending.
  selectCoinsResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody403OneOf1" (\obj -> GHC.Base.pure SelectCoinsResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'SelectCoinsResponseBody403OneOf1' with all required fields.
mkSelectCoinsResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody403OneOf1Message'
  -> SelectCoinsResponseBody403OneOf1
mkSelectCoinsResponseBody403OneOf1 selectCoinsResponseBody403OneOf1Message = SelectCoinsResponseBody403OneOf1{selectCoinsResponseBody403OneOf1Message = selectCoinsResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data SelectCoinsResponseBody403OneOf2 = SelectCoinsResponseBody403OneOf2 {
  -- | info
  selectCoinsResponseBody403OneOf2Info :: (GHC.Maybe.Maybe SelectCoinsResponseBody403OneOf2Info)
  -- | message: Occurs when a requested output has a quantity of lovelace that is below the minimum required by the ledger.
  , selectCoinsResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody403OneOf2Info obj) : ["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (selectCoinsResponseBody403OneOf2Info obj) : ["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody403OneOf2" (\obj -> (GHC.Base.pure SelectCoinsResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "info")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'SelectCoinsResponseBody403OneOf2' with all required fields.
mkSelectCoinsResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody403OneOf2Message'
  -> SelectCoinsResponseBody403OneOf2
mkSelectCoinsResponseBody403OneOf2 selectCoinsResponseBody403OneOf2Message = SelectCoinsResponseBody403OneOf2{selectCoinsResponseBody403OneOf2Info = GHC.Maybe.Nothing,
                                                                                                              selectCoinsResponseBody403OneOf2Message = selectCoinsResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf.properties.info@ in the specification.
-- 
-- 
data SelectCoinsResponseBody403OneOf2Info = SelectCoinsResponseBody403OneOf2Info {
  -- | tx_output_index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  selectCoinsResponseBody403OneOf2InfoTx_output_index :: GHC.Types.Int
  -- | tx_output_lovelace_required_minimum: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum :: SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum
  -- | tx_output_lovelace_specified: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified :: SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody403OneOf2Info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf2InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf2InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody403OneOf2Info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody403OneOf2Info" (\obj -> ((GHC.Base.pure SelectCoinsResponseBody403OneOf2Info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_index")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_required_minimum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_specified"))
-- | Create a new 'SelectCoinsResponseBody403OneOf2Info' with all required fields.
mkSelectCoinsResponseBody403OneOf2Info :: GHC.Types.Int -- ^ 'selectCoinsResponseBody403OneOf2InfoTx_output_index'
  -> SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum -- ^ 'selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum'
  -> SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified -- ^ 'selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified'
  -> SelectCoinsResponseBody403OneOf2Info
mkSelectCoinsResponseBody403OneOf2Info selectCoinsResponseBody403OneOf2InfoTx_output_index selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified = SelectCoinsResponseBody403OneOf2Info{selectCoinsResponseBody403OneOf2InfoTx_output_index = selectCoinsResponseBody403OneOf2InfoTx_output_index,
                                                                                                                                                                                                                                                                           selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum = selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum,
                                                                                                                                                                                                                                                                           selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified = selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_required_minimum@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum = SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimumQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum" (\obj -> GHC.Base.pure SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum' with all required fields.
mkSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum :: GHC.Types.Int -- ^ 'selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimumQuantity'
  -> SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum
mkSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimumQuantity = SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum{selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimumQuantity = selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimumQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_specified@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified = SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specifiedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified" (\obj -> GHC.Base.pure SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified' with all required fields.
mkSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified :: GHC.Types.Int -- ^ 'selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specifiedQuantity'
  -> SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified
mkSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specifiedQuantity = SelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified{selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specifiedQuantity = selectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specifiedQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data SelectCoinsResponseBody403OneOf3 = SelectCoinsResponseBody403OneOf3 {
  -- | message: May occur when there\'s not enough money in the wallet to cover a requested payment.
  selectCoinsResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody403OneOf3" (\obj -> GHC.Base.pure SelectCoinsResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'SelectCoinsResponseBody403OneOf3' with all required fields.
mkSelectCoinsResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody403OneOf3Message'
  -> SelectCoinsResponseBody403OneOf3
mkSelectCoinsResponseBody403OneOf3 selectCoinsResponseBody403OneOf3Message = SelectCoinsResponseBody403OneOf3{selectCoinsResponseBody403OneOf3Message = selectCoinsResponseBody403OneOf3Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data SelectCoinsResponseBody403OneOf4 = SelectCoinsResponseBody403OneOf4 {
  -- | message: May occur when the total balance of pure ada UTxOs in the wallet is
  -- insufficient to cover the minimum collateral amount required for a
  -- transaction requiring collateral.
  selectCoinsResponseBody403OneOf4Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody403OneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody403OneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody403OneOf4" (\obj -> GHC.Base.pure SelectCoinsResponseBody403OneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'SelectCoinsResponseBody403OneOf4' with all required fields.
mkSelectCoinsResponseBody403OneOf4 :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody403OneOf4Message'
  -> SelectCoinsResponseBody403OneOf4
mkSelectCoinsResponseBody403OneOf4 selectCoinsResponseBody403OneOf4Message = SelectCoinsResponseBody403OneOf4{selectCoinsResponseBody403OneOf4Message = selectCoinsResponseBody403OneOf4Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data SelectCoinsResponseBody403OneOf5 = SelectCoinsResponseBody403OneOf5 {
  -- | message: May occur when a transaction can\'t be balanced for fees.
  selectCoinsResponseBody403OneOf5Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody403OneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody403OneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody403OneOf5" (\obj -> GHC.Base.pure SelectCoinsResponseBody403OneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'SelectCoinsResponseBody403OneOf5' with all required fields.
mkSelectCoinsResponseBody403OneOf5 :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody403OneOf5Message'
  -> SelectCoinsResponseBody403OneOf5
mkSelectCoinsResponseBody403OneOf5 selectCoinsResponseBody403OneOf5Message = SelectCoinsResponseBody403OneOf5{selectCoinsResponseBody403OneOf5Message = selectCoinsResponseBody403OneOf5Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data SelectCoinsResponseBody403OneOf6 = SelectCoinsResponseBody403OneOf6 {
  -- | message: May occur when there\'s enough money to pay for a payment, but not enough UTxO to allow for paying each output independently.
  selectCoinsResponseBody403OneOf6Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody403OneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "inputs_depleted"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "inputs_depleted"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody403OneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody403OneOf6" (\obj -> GHC.Base.pure SelectCoinsResponseBody403OneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'SelectCoinsResponseBody403OneOf6' with all required fields.
mkSelectCoinsResponseBody403OneOf6 :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody403OneOf6Message'
  -> SelectCoinsResponseBody403OneOf6
mkSelectCoinsResponseBody403OneOf6 selectCoinsResponseBody403OneOf6Message = SelectCoinsResponseBody403OneOf6{selectCoinsResponseBody403OneOf6Message = selectCoinsResponseBody403OneOf6Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data SelectCoinsResponseBody403OneOf7 = SelectCoinsResponseBody403OneOf7 {
  -- | message: Should never happen unless the server screwed up with the creation of a coin selection.
  selectCoinsResponseBody403OneOf7Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody403OneOf7
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_coin_selection"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_coin_selection"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody403OneOf7
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody403OneOf7" (\obj -> GHC.Base.pure SelectCoinsResponseBody403OneOf7 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'SelectCoinsResponseBody403OneOf7' with all required fields.
mkSelectCoinsResponseBody403OneOf7 :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody403OneOf7Message'
  -> SelectCoinsResponseBody403OneOf7
mkSelectCoinsResponseBody403OneOf7 selectCoinsResponseBody403OneOf7Message = SelectCoinsResponseBody403OneOf7{selectCoinsResponseBody403OneOf7Message = selectCoinsResponseBody403OneOf7Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data SelectCoinsResponseBody403OneOf8 = SelectCoinsResponseBody403OneOf8 {
  -- | message: Returned when a user-specified transaction output contains, for some
  -- asset, a token quantity that exceeds the limit supported by the
  -- protocol.
  selectCoinsResponseBody403OneOf8Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody403OneOf8
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_quantity_exceeds_limit"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_quantity_exceeds_limit"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody403OneOf8
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody403OneOf8" (\obj -> GHC.Base.pure SelectCoinsResponseBody403OneOf8 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'SelectCoinsResponseBody403OneOf8' with all required fields.
mkSelectCoinsResponseBody403OneOf8 :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody403OneOf8Message'
  -> SelectCoinsResponseBody403OneOf8
mkSelectCoinsResponseBody403OneOf8 selectCoinsResponseBody403OneOf8Message = SelectCoinsResponseBody403OneOf8{selectCoinsResponseBody403OneOf8Message = selectCoinsResponseBody403OneOf8Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data SelectCoinsResponseBody403OneOf9 = SelectCoinsResponseBody403OneOf9 {
  -- | message: Returned when a user-specified transaction output contains a token
  -- bundle whose serialized length exceeds the limit supported by the
  -- protocol.
  selectCoinsResponseBody403OneOf9Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody403OneOf9
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_bundle_size_exceeds_limit"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_bundle_size_exceeds_limit"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody403OneOf9
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody403OneOf9" (\obj -> GHC.Base.pure SelectCoinsResponseBody403OneOf9 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'SelectCoinsResponseBody403OneOf9' with all required fields.
mkSelectCoinsResponseBody403OneOf9 :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody403OneOf9Message'
  -> SelectCoinsResponseBody403OneOf9
mkSelectCoinsResponseBody403OneOf9 selectCoinsResponseBody403OneOf9Message = SelectCoinsResponseBody403OneOf9{selectCoinsResponseBody403OneOf9Message = selectCoinsResponseBody403OneOf9Message}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data SelectCoinsResponseBody403Variants =
   SelectCoinsResponseBody403Variant1 SelectCoinsResponseBody403OneOf1
  | SelectCoinsResponseBody403Variant2 SelectCoinsResponseBody403OneOf2
  | SelectCoinsResponseBody403Variant3 SelectCoinsResponseBody403OneOf3
  | SelectCoinsResponseBody403Variant4 SelectCoinsResponseBody403OneOf4
  | SelectCoinsResponseBody403Variant5 SelectCoinsResponseBody403OneOf5
  | SelectCoinsResponseBody403Variant6 SelectCoinsResponseBody403OneOf6
  | SelectCoinsResponseBody403Variant7 SelectCoinsResponseBody403OneOf7
  | SelectCoinsResponseBody403Variant8 SelectCoinsResponseBody403OneOf8
  | SelectCoinsResponseBody403Variant9 SelectCoinsResponseBody403OneOf9
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody403Variants
    where toJSON (SelectCoinsResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (SelectCoinsResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (SelectCoinsResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (SelectCoinsResponseBody403Variant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (SelectCoinsResponseBody403Variant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (SelectCoinsResponseBody403Variant6 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (SelectCoinsResponseBody403Variant7 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (SelectCoinsResponseBody403Variant8 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (SelectCoinsResponseBody403Variant9 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody403Variants
    where parseJSON val = case (SelectCoinsResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SelectCoinsResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SelectCoinsResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SelectCoinsResponseBody403Variant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SelectCoinsResponseBody403Variant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SelectCoinsResponseBody403Variant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SelectCoinsResponseBody403Variant7 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SelectCoinsResponseBody403Variant8 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((SelectCoinsResponseBody403Variant9 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data SelectCoinsResponseBody404 = SelectCoinsResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  selectCoinsResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody404" (\obj -> GHC.Base.pure SelectCoinsResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'SelectCoinsResponseBody404' with all required fields.
mkSelectCoinsResponseBody404 :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody404Message'
  -> SelectCoinsResponseBody404
mkSelectCoinsResponseBody404 selectCoinsResponseBody404Message = SelectCoinsResponseBody404{selectCoinsResponseBody404Message = selectCoinsResponseBody404Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data SelectCoinsResponseBody406 = SelectCoinsResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  selectCoinsResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody406" (\obj -> GHC.Base.pure SelectCoinsResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'SelectCoinsResponseBody406' with all required fields.
mkSelectCoinsResponseBody406 :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody406Message'
  -> SelectCoinsResponseBody406
mkSelectCoinsResponseBody406 selectCoinsResponseBody406Message = SelectCoinsResponseBody406{selectCoinsResponseBody406Message = selectCoinsResponseBody406Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/coin-selections\/random.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data SelectCoinsResponseBody415 = SelectCoinsResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  selectCoinsResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON SelectCoinsResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= selectCoinsResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON SelectCoinsResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "SelectCoinsResponseBody415" (\obj -> GHC.Base.pure SelectCoinsResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'SelectCoinsResponseBody415' with all required fields.
mkSelectCoinsResponseBody415 :: Data.Text.Internal.Text -- ^ 'selectCoinsResponseBody415Message'
  -> SelectCoinsResponseBody415
mkSelectCoinsResponseBody415 selectCoinsResponseBody415Message = SelectCoinsResponseBody415{selectCoinsResponseBody415Message = selectCoinsResponseBody415Message}
-- | > POST /wallets/{walletId}/coin-selections/random
-- 
-- The same as 'selectCoins' but accepts an explicit configuration.
selectCoinsWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> SelectCoinsRequestBodyVariants -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response SelectCoinsResponse) -- ^ Monadic computation which returns the result of the operation
selectCoinsWithConfiguration config
                             walletId
                             body = GHC.Base.fmap (\response_7 -> GHC.Base.fmap (Data.Either.either SelectCoinsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> SelectCoinsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                     SelectCoinsResponseBody200)
                                                                                                                                                                          | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> SelectCoinsResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                     SelectCoinsResponseBody400)
                                                                                                                                                                          | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> SelectCoinsResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                       SelectCoinsResponseBody403Variants)
                                                                                                                                                                          | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> SelectCoinsResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                       SelectCoinsResponseBody404)
                                                                                                                                                                          | (\status_12 -> Network.HTTP.Types.Status.statusCode status_12 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> SelectCoinsResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                       SelectCoinsResponseBody406)
                                                                                                                                                                          | (\status_13 -> Network.HTTP.Types.Status.statusCode status_13 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> SelectCoinsResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                       SelectCoinsResponseBody415)
                                                                                                                                                                          | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_7) response_7) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/coin-selections/random")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/coin-selections/random
-- 
-- The same as 'selectCoins' but returns the raw 'Data.ByteString.ByteString'.
selectCoinsRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> SelectCoinsRequestBodyVariants -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
selectCoinsRaw walletId
               body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/coin-selections/random")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/coin-selections/random
-- 
-- The same as 'selectCoins' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
selectCoinsWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> SelectCoinsRequestBodyVariants -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
selectCoinsWithConfigurationRaw config
                                walletId
                                body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/coin-selections/random")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
