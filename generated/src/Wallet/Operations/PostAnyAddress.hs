-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation postAnyAddress
module Wallet.Operations.PostAnyAddress where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /addresses
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Construct any address by specyfying credential for payment or delegation.
-- 
-- In Cardano, Addresses are made of three parts:
-- 
-- \`\`\`
-- *---------*---------*-----------*
-- | NETWORK | PAYMENT | DELEGATION |
-- *---------*---------*-----------*
-- \`\`\`
-- 
-- The \`NETWORK\` part allows for distinguishing addresses between different networks like the mainnet or the testnet. It is implicitly
-- handled by the server without you having to worry about it. The \`PAYMENT\` and \`DELEGATION\` parts however can be constructed similarly, using
-- either:
-- 
-- - A public key
-- - A script
-- 
-- The script itself is either constructed out of a public key, one of two timelocks, or one of the three following primitives:
-- 
-- - all
-- - any
-- - some
-- 
-- The timelock can determine validity as respect to the slot. \`active_from slot\` means the script is valid from the specified slot
-- and onward. \`active_until slot\` means the script is valid until (not included) the specified slot.
-- 
-- Each of which contains one or more script(s) that can be either keys or primitives, and so on. Schematically:
-- 
-- \`\`\`
--                                    ┏─────────┓
-- SCRIPT = ──┬───────────────────────┤ pub key ├─────────────────────┬──
--            │                       ┗─────────┛                     │
--            │                       ┏──────────────────┓            │
--            ├───────────────────────┤ ACTIVE_FROM slot ├──── ───────┤
--            │                       ┗──────────────────┛            │
--            │                       ┏───────────────────┓           │
--            ├───────────────────────┤ ACTIVE_UNTIL slot ├───────────┤
--            │                       ┗───────────────────┛           │
--            │                                                       │
--            │  ╭─────╮   ╭────────╮                                 │
--            ├──┤ ALL ├───┤ SCRIPT ├─┬───────────────────────────────┤
--            │  ╰─────╯ ^ ╰────────╯ │                               │
--            │          │   ╭───╮    │                               │
--            │          └───┤ , ├────┘                               │
--            │              ╰───╯                                    │
--            │  ╭─────╮   ╭────────╮                                 │
--            ├──┤ ANY ├───┤ SCRIPT ├─┬───────────────────────────────┤
--            │  ╰─────╯ ^ ╰────────╯ │                               │
--            │          │   ╭───╮    │                               │
--            │          └───┤ , ├────┘                               │
--            │              ╰───╯                                    │
--            │  ╭──────╮ ╭──────────╮ ┏───┓ ╭──────╮   ╭────────╮    │
--            └──┤ SOME ├─┤ AT_LEAST ├─┤ n ├─┤ FROM ├───┤ SCRIPT ├─┬──┘
--               ╰──────╯ ╰──────────╯ ┗───┛ ╰──────╯ ^ ╰────────╯ │
--                                                    │   ╭───╮    │
--                                                    └───┤ , ├────┘
--                                                        ╰───╯
-- \`\`\`
postAnyAddress :: forall m . Wallet.Common.MonadHTTP m => GHC.Maybe.Maybe PostAnyAddressRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response PostAnyAddressResponse) -- ^ Monadic computation which returns the result of the operation
postAnyAddress body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PostAnyAddressResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> PostAnyAddressResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                             PostAnyAddressResponseBody202)
                                                                                                                                                               | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostAnyAddressResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                             PostAnyAddressResponseBody400)
                                                                                                                                                               | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostAnyAddressResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                             PostAnyAddressResponseBody406)
                                                                                                                                                               | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostAnyAddressResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                             PostAnyAddressResponseBody415)
                                                                                                                                                               | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") "/addresses" GHC.Base.mempty body Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema@ in the specification.
-- 
-- 
data PostAnyAddressRequestBody = PostAnyAddressRequestBody {
  -- | payment
  postAnyAddressRequestBodyPayment :: (GHC.Maybe.Maybe PostAnyAddressRequestBodyPaymentVariants)
  -- | stake
  , postAnyAddressRequestBodyStake :: (GHC.Maybe.Maybe PostAnyAddressRequestBodyStakeVariants)
  -- | validation: Script validation level. Required validation sifts off scripts that would not
  -- be accepted by the ledger. Recommended level filters out scripts that do not pass
  -- required validation and additionally when:
  --   * \'all\' is non-empty
  --   * there are redundant timelocks in a given level
  --   * there are no duplicated verification keys in a given level
  --   * \'at_least\' coefficient is positive
  --   * \'all\', \'any\' are non-empty and \`\'at_least\' has no less elements in the list
  --      than the coefficient after timelocks are filtered out.
  , postAnyAddressRequestBodyValidation :: (GHC.Maybe.Maybe PostAnyAddressRequestBodyValidation)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("payment" Data.Aeson.Types.ToJSON..=)) (postAnyAddressRequestBodyPayment obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("stake" Data.Aeson.Types.ToJSON..=)) (postAnyAddressRequestBodyStake obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validation" Data.Aeson.Types.ToJSON..=)) (postAnyAddressRequestBodyValidation obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("payment" Data.Aeson.Types.ToJSON..=)) (postAnyAddressRequestBodyPayment obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("stake" Data.Aeson.Types.ToJSON..=)) (postAnyAddressRequestBodyStake obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validation" Data.Aeson.Types.ToJSON..=)) (postAnyAddressRequestBodyValidation obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressRequestBody" (\obj -> ((GHC.Base.pure PostAnyAddressRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "payment")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "stake")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "validation"))
-- | Create a new 'PostAnyAddressRequestBody' with all required fields.
mkPostAnyAddressRequestBody :: PostAnyAddressRequestBody
mkPostAnyAddressRequestBody = PostAnyAddressRequestBody{postAnyAddressRequestBodyPayment = GHC.Maybe.Nothing,
                                                        postAnyAddressRequestBodyStake = GHC.Maybe.Nothing,
                                                        postAnyAddressRequestBodyValidation = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.payment.oneOf.oneOf@ in the specification.
-- 
-- 
data PostAnyAddressRequestBodyPaymentOneOf4OneOf2 = PostAnyAddressRequestBodyPaymentOneOf4OneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postAnyAddressRequestBodyPaymentOneOf4OneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyPaymentOneOf4OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyPaymentOneOf4OneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyPaymentOneOf4OneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyPaymentOneOf4OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressRequestBodyPaymentOneOf4OneOf2" (\obj -> GHC.Base.pure PostAnyAddressRequestBodyPaymentOneOf4OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'PostAnyAddressRequestBodyPaymentOneOf4OneOf2' with all required fields.
mkPostAnyAddressRequestBodyPaymentOneOf4OneOf2 :: [ScriptValue] -- ^ 'postAnyAddressRequestBodyPaymentOneOf4OneOf2All'
  -> PostAnyAddressRequestBodyPaymentOneOf4OneOf2
mkPostAnyAddressRequestBodyPaymentOneOf4OneOf2 postAnyAddressRequestBodyPaymentOneOf4OneOf2All = PostAnyAddressRequestBodyPaymentOneOf4OneOf2{postAnyAddressRequestBodyPaymentOneOf4OneOf2All = postAnyAddressRequestBodyPaymentOneOf4OneOf2All}
-- | Defines the object schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.payment.oneOf.oneOf@ in the specification.
-- 
-- 
data PostAnyAddressRequestBodyPaymentOneOf4OneOf3 = PostAnyAddressRequestBodyPaymentOneOf4OneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postAnyAddressRequestBodyPaymentOneOf4OneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyPaymentOneOf4OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyPaymentOneOf4OneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyPaymentOneOf4OneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyPaymentOneOf4OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressRequestBodyPaymentOneOf4OneOf3" (\obj -> GHC.Base.pure PostAnyAddressRequestBodyPaymentOneOf4OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'PostAnyAddressRequestBodyPaymentOneOf4OneOf3' with all required fields.
mkPostAnyAddressRequestBodyPaymentOneOf4OneOf3 :: [ScriptValue] -- ^ 'postAnyAddressRequestBodyPaymentOneOf4OneOf3Any'
  -> PostAnyAddressRequestBodyPaymentOneOf4OneOf3
mkPostAnyAddressRequestBodyPaymentOneOf4OneOf3 postAnyAddressRequestBodyPaymentOneOf4OneOf3Any = PostAnyAddressRequestBodyPaymentOneOf4OneOf3{postAnyAddressRequestBodyPaymentOneOf4OneOf3Any = postAnyAddressRequestBodyPaymentOneOf4OneOf3Any}
-- | Defines the object schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.payment.oneOf.oneOf@ in the specification.
-- 
-- 
data PostAnyAddressRequestBodyPaymentOneOf4OneOf4 = PostAnyAddressRequestBodyPaymentOneOf4OneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  postAnyAddressRequestBodyPaymentOneOf4OneOf4Some :: PostAnyAddressRequestBodyPaymentOneOf4OneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyPaymentOneOf4OneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyPaymentOneOf4OneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyPaymentOneOf4OneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyPaymentOneOf4OneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressRequestBodyPaymentOneOf4OneOf4" (\obj -> GHC.Base.pure PostAnyAddressRequestBodyPaymentOneOf4OneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'PostAnyAddressRequestBodyPaymentOneOf4OneOf4' with all required fields.
mkPostAnyAddressRequestBodyPaymentOneOf4OneOf4 :: PostAnyAddressRequestBodyPaymentOneOf4OneOf4Some -- ^ 'postAnyAddressRequestBodyPaymentOneOf4OneOf4Some'
  -> PostAnyAddressRequestBodyPaymentOneOf4OneOf4
mkPostAnyAddressRequestBodyPaymentOneOf4OneOf4 postAnyAddressRequestBodyPaymentOneOf4OneOf4Some = PostAnyAddressRequestBodyPaymentOneOf4OneOf4{postAnyAddressRequestBodyPaymentOneOf4OneOf4Some = postAnyAddressRequestBodyPaymentOneOf4OneOf4Some}
-- | Defines the object schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.payment.oneOf.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data PostAnyAddressRequestBodyPaymentOneOf4OneOf4Some = PostAnyAddressRequestBodyPaymentOneOf4OneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  postAnyAddressRequestBodyPaymentOneOf4OneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , postAnyAddressRequestBodyPaymentOneOf4OneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyPaymentOneOf4OneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyPaymentOneOf4OneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyPaymentOneOf4OneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyPaymentOneOf4OneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyPaymentOneOf4OneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyPaymentOneOf4OneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressRequestBodyPaymentOneOf4OneOf4Some" (\obj -> (GHC.Base.pure PostAnyAddressRequestBodyPaymentOneOf4OneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'PostAnyAddressRequestBodyPaymentOneOf4OneOf4Some' with all required fields.
mkPostAnyAddressRequestBodyPaymentOneOf4OneOf4Some :: GHC.Types.Int -- ^ 'postAnyAddressRequestBodyPaymentOneOf4OneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'postAnyAddressRequestBodyPaymentOneOf4OneOf4SomeFrom'
  -> PostAnyAddressRequestBodyPaymentOneOf4OneOf4Some
mkPostAnyAddressRequestBodyPaymentOneOf4OneOf4Some postAnyAddressRequestBodyPaymentOneOf4OneOf4SomeAt_least postAnyAddressRequestBodyPaymentOneOf4OneOf4SomeFrom = PostAnyAddressRequestBodyPaymentOneOf4OneOf4Some{postAnyAddressRequestBodyPaymentOneOf4OneOf4SomeAt_least = postAnyAddressRequestBodyPaymentOneOf4OneOf4SomeAt_least,
                                                                                                                                                                                                                    postAnyAddressRequestBodyPaymentOneOf4OneOf4SomeFrom = postAnyAddressRequestBodyPaymentOneOf4OneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.payment.oneOf.oneOf@ in the specification.
-- 
-- 
data PostAnyAddressRequestBodyPaymentOneOf4OneOf5 = PostAnyAddressRequestBodyPaymentOneOf4OneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postAnyAddressRequestBodyPaymentOneOf4OneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyPaymentOneOf4OneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyPaymentOneOf4OneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyPaymentOneOf4OneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyPaymentOneOf4OneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressRequestBodyPaymentOneOf4OneOf5" (\obj -> GHC.Base.pure PostAnyAddressRequestBodyPaymentOneOf4OneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'PostAnyAddressRequestBodyPaymentOneOf4OneOf5' with all required fields.
mkPostAnyAddressRequestBodyPaymentOneOf4OneOf5 :: GHC.Types.Int -- ^ 'postAnyAddressRequestBodyPaymentOneOf4OneOf5Active_from'
  -> PostAnyAddressRequestBodyPaymentOneOf4OneOf5
mkPostAnyAddressRequestBodyPaymentOneOf4OneOf5 postAnyAddressRequestBodyPaymentOneOf4OneOf5Active_from = PostAnyAddressRequestBodyPaymentOneOf4OneOf5{postAnyAddressRequestBodyPaymentOneOf4OneOf5Active_from = postAnyAddressRequestBodyPaymentOneOf4OneOf5Active_from}
-- | Defines the object schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.payment.oneOf.oneOf@ in the specification.
-- 
-- 
data PostAnyAddressRequestBodyPaymentOneOf4OneOf6 = PostAnyAddressRequestBodyPaymentOneOf4OneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postAnyAddressRequestBodyPaymentOneOf4OneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyPaymentOneOf4OneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyPaymentOneOf4OneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyPaymentOneOf4OneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyPaymentOneOf4OneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressRequestBodyPaymentOneOf4OneOf6" (\obj -> GHC.Base.pure PostAnyAddressRequestBodyPaymentOneOf4OneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'PostAnyAddressRequestBodyPaymentOneOf4OneOf6' with all required fields.
mkPostAnyAddressRequestBodyPaymentOneOf4OneOf6 :: GHC.Types.Int -- ^ 'postAnyAddressRequestBodyPaymentOneOf4OneOf6Active_until'
  -> PostAnyAddressRequestBodyPaymentOneOf4OneOf6
mkPostAnyAddressRequestBodyPaymentOneOf4OneOf6 postAnyAddressRequestBodyPaymentOneOf4OneOf6Active_until = PostAnyAddressRequestBodyPaymentOneOf4OneOf6{postAnyAddressRequestBodyPaymentOneOf4OneOf6Active_until = postAnyAddressRequestBodyPaymentOneOf4OneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.payment.oneOf.oneOf@ in the specification.
-- 
-- 
data PostAnyAddressRequestBodyPaymentOneOf4Variants =
   PostAnyAddressRequestBodyPaymentOneOf4Variant1 Data.Text.Internal.Text
  | PostAnyAddressRequestBodyPaymentOneOf4Variant2 PostAnyAddressRequestBodyPaymentOneOf4OneOf2
  | PostAnyAddressRequestBodyPaymentOneOf4Variant3 PostAnyAddressRequestBodyPaymentOneOf4OneOf3
  | PostAnyAddressRequestBodyPaymentOneOf4Variant4 PostAnyAddressRequestBodyPaymentOneOf4OneOf4
  | PostAnyAddressRequestBodyPaymentOneOf4Variant5 PostAnyAddressRequestBodyPaymentOneOf4OneOf5
  | PostAnyAddressRequestBodyPaymentOneOf4Variant6 PostAnyAddressRequestBodyPaymentOneOf4OneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyPaymentOneOf4Variants
    where toJSON (PostAnyAddressRequestBodyPaymentOneOf4Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyPaymentOneOf4Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyPaymentOneOf4Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyPaymentOneOf4Variant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyPaymentOneOf4Variant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyPaymentOneOf4Variant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyPaymentOneOf4Variants
    where parseJSON val = case (PostAnyAddressRequestBodyPaymentOneOf4Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyPaymentOneOf4Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyPaymentOneOf4Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyPaymentOneOf4Variant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyPaymentOneOf4Variant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyPaymentOneOf4Variant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the oneOf schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.payment.oneOf@ in the specification.
-- 
-- 
data PostAnyAddressRequestBodyPaymentVariants =
   PostAnyAddressRequestBodyPaymentVariant1 Data.Text.Internal.Text
  | PostAnyAddressRequestBodyPaymentVariant2 Data.Text.Internal.Text
  | PostAnyAddressRequestBodyPaymentVariant3 Data.Text.Internal.Text
  | PostAnyAddressRequestBodyPaymentVariant4 PostAnyAddressRequestBodyPaymentOneOf4Variants
  | PostAnyAddressRequestBodyPaymentVariant5 Data.Text.Internal.Text
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyPaymentVariants
    where toJSON (PostAnyAddressRequestBodyPaymentVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyPaymentVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyPaymentVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyPaymentVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyPaymentVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyPaymentVariants
    where parseJSON val = case (PostAnyAddressRequestBodyPaymentVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyPaymentVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyPaymentVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyPaymentVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyPaymentVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.stake.oneOf.oneOf@ in the specification.
-- 
-- 
data PostAnyAddressRequestBodyStakeOneOf4OneOf2 = PostAnyAddressRequestBodyStakeOneOf4OneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postAnyAddressRequestBodyStakeOneOf4OneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyStakeOneOf4OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyStakeOneOf4OneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyStakeOneOf4OneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyStakeOneOf4OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressRequestBodyStakeOneOf4OneOf2" (\obj -> GHC.Base.pure PostAnyAddressRequestBodyStakeOneOf4OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'PostAnyAddressRequestBodyStakeOneOf4OneOf2' with all required fields.
mkPostAnyAddressRequestBodyStakeOneOf4OneOf2 :: [ScriptValue] -- ^ 'postAnyAddressRequestBodyStakeOneOf4OneOf2All'
  -> PostAnyAddressRequestBodyStakeOneOf4OneOf2
mkPostAnyAddressRequestBodyStakeOneOf4OneOf2 postAnyAddressRequestBodyStakeOneOf4OneOf2All = PostAnyAddressRequestBodyStakeOneOf4OneOf2{postAnyAddressRequestBodyStakeOneOf4OneOf2All = postAnyAddressRequestBodyStakeOneOf4OneOf2All}
-- | Defines the object schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.stake.oneOf.oneOf@ in the specification.
-- 
-- 
data PostAnyAddressRequestBodyStakeOneOf4OneOf3 = PostAnyAddressRequestBodyStakeOneOf4OneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postAnyAddressRequestBodyStakeOneOf4OneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyStakeOneOf4OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyStakeOneOf4OneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyStakeOneOf4OneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyStakeOneOf4OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressRequestBodyStakeOneOf4OneOf3" (\obj -> GHC.Base.pure PostAnyAddressRequestBodyStakeOneOf4OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'PostAnyAddressRequestBodyStakeOneOf4OneOf3' with all required fields.
mkPostAnyAddressRequestBodyStakeOneOf4OneOf3 :: [ScriptValue] -- ^ 'postAnyAddressRequestBodyStakeOneOf4OneOf3Any'
  -> PostAnyAddressRequestBodyStakeOneOf4OneOf3
mkPostAnyAddressRequestBodyStakeOneOf4OneOf3 postAnyAddressRequestBodyStakeOneOf4OneOf3Any = PostAnyAddressRequestBodyStakeOneOf4OneOf3{postAnyAddressRequestBodyStakeOneOf4OneOf3Any = postAnyAddressRequestBodyStakeOneOf4OneOf3Any}
-- | Defines the object schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.stake.oneOf.oneOf@ in the specification.
-- 
-- 
data PostAnyAddressRequestBodyStakeOneOf4OneOf4 = PostAnyAddressRequestBodyStakeOneOf4OneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  postAnyAddressRequestBodyStakeOneOf4OneOf4Some :: PostAnyAddressRequestBodyStakeOneOf4OneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyStakeOneOf4OneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyStakeOneOf4OneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyStakeOneOf4OneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyStakeOneOf4OneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressRequestBodyStakeOneOf4OneOf4" (\obj -> GHC.Base.pure PostAnyAddressRequestBodyStakeOneOf4OneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'PostAnyAddressRequestBodyStakeOneOf4OneOf4' with all required fields.
mkPostAnyAddressRequestBodyStakeOneOf4OneOf4 :: PostAnyAddressRequestBodyStakeOneOf4OneOf4Some -- ^ 'postAnyAddressRequestBodyStakeOneOf4OneOf4Some'
  -> PostAnyAddressRequestBodyStakeOneOf4OneOf4
mkPostAnyAddressRequestBodyStakeOneOf4OneOf4 postAnyAddressRequestBodyStakeOneOf4OneOf4Some = PostAnyAddressRequestBodyStakeOneOf4OneOf4{postAnyAddressRequestBodyStakeOneOf4OneOf4Some = postAnyAddressRequestBodyStakeOneOf4OneOf4Some}
-- | Defines the object schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.stake.oneOf.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data PostAnyAddressRequestBodyStakeOneOf4OneOf4Some = PostAnyAddressRequestBodyStakeOneOf4OneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  postAnyAddressRequestBodyStakeOneOf4OneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , postAnyAddressRequestBodyStakeOneOf4OneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyStakeOneOf4OneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyStakeOneOf4OneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyStakeOneOf4OneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyStakeOneOf4OneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyStakeOneOf4OneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyStakeOneOf4OneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressRequestBodyStakeOneOf4OneOf4Some" (\obj -> (GHC.Base.pure PostAnyAddressRequestBodyStakeOneOf4OneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'PostAnyAddressRequestBodyStakeOneOf4OneOf4Some' with all required fields.
mkPostAnyAddressRequestBodyStakeOneOf4OneOf4Some :: GHC.Types.Int -- ^ 'postAnyAddressRequestBodyStakeOneOf4OneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'postAnyAddressRequestBodyStakeOneOf4OneOf4SomeFrom'
  -> PostAnyAddressRequestBodyStakeOneOf4OneOf4Some
mkPostAnyAddressRequestBodyStakeOneOf4OneOf4Some postAnyAddressRequestBodyStakeOneOf4OneOf4SomeAt_least postAnyAddressRequestBodyStakeOneOf4OneOf4SomeFrom = PostAnyAddressRequestBodyStakeOneOf4OneOf4Some{postAnyAddressRequestBodyStakeOneOf4OneOf4SomeAt_least = postAnyAddressRequestBodyStakeOneOf4OneOf4SomeAt_least,
                                                                                                                                                                                                            postAnyAddressRequestBodyStakeOneOf4OneOf4SomeFrom = postAnyAddressRequestBodyStakeOneOf4OneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.stake.oneOf.oneOf@ in the specification.
-- 
-- 
data PostAnyAddressRequestBodyStakeOneOf4OneOf5 = PostAnyAddressRequestBodyStakeOneOf4OneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postAnyAddressRequestBodyStakeOneOf4OneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyStakeOneOf4OneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyStakeOneOf4OneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyStakeOneOf4OneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyStakeOneOf4OneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressRequestBodyStakeOneOf4OneOf5" (\obj -> GHC.Base.pure PostAnyAddressRequestBodyStakeOneOf4OneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'PostAnyAddressRequestBodyStakeOneOf4OneOf5' with all required fields.
mkPostAnyAddressRequestBodyStakeOneOf4OneOf5 :: GHC.Types.Int -- ^ 'postAnyAddressRequestBodyStakeOneOf4OneOf5Active_from'
  -> PostAnyAddressRequestBodyStakeOneOf4OneOf5
mkPostAnyAddressRequestBodyStakeOneOf4OneOf5 postAnyAddressRequestBodyStakeOneOf4OneOf5Active_from = PostAnyAddressRequestBodyStakeOneOf4OneOf5{postAnyAddressRequestBodyStakeOneOf4OneOf5Active_from = postAnyAddressRequestBodyStakeOneOf4OneOf5Active_from}
-- | Defines the object schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.stake.oneOf.oneOf@ in the specification.
-- 
-- 
data PostAnyAddressRequestBodyStakeOneOf4OneOf6 = PostAnyAddressRequestBodyStakeOneOf4OneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postAnyAddressRequestBodyStakeOneOf4OneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyStakeOneOf4OneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyStakeOneOf4OneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= postAnyAddressRequestBodyStakeOneOf4OneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyStakeOneOf4OneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressRequestBodyStakeOneOf4OneOf6" (\obj -> GHC.Base.pure PostAnyAddressRequestBodyStakeOneOf4OneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'PostAnyAddressRequestBodyStakeOneOf4OneOf6' with all required fields.
mkPostAnyAddressRequestBodyStakeOneOf4OneOf6 :: GHC.Types.Int -- ^ 'postAnyAddressRequestBodyStakeOneOf4OneOf6Active_until'
  -> PostAnyAddressRequestBodyStakeOneOf4OneOf6
mkPostAnyAddressRequestBodyStakeOneOf4OneOf6 postAnyAddressRequestBodyStakeOneOf4OneOf6Active_until = PostAnyAddressRequestBodyStakeOneOf4OneOf6{postAnyAddressRequestBodyStakeOneOf4OneOf6Active_until = postAnyAddressRequestBodyStakeOneOf4OneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.stake.oneOf.oneOf@ in the specification.
-- 
-- 
data PostAnyAddressRequestBodyStakeOneOf4Variants =
   PostAnyAddressRequestBodyStakeOneOf4Variant1 Data.Text.Internal.Text
  | PostAnyAddressRequestBodyStakeOneOf4Variant2 PostAnyAddressRequestBodyStakeOneOf4OneOf2
  | PostAnyAddressRequestBodyStakeOneOf4Variant3 PostAnyAddressRequestBodyStakeOneOf4OneOf3
  | PostAnyAddressRequestBodyStakeOneOf4Variant4 PostAnyAddressRequestBodyStakeOneOf4OneOf4
  | PostAnyAddressRequestBodyStakeOneOf4Variant5 PostAnyAddressRequestBodyStakeOneOf4OneOf5
  | PostAnyAddressRequestBodyStakeOneOf4Variant6 PostAnyAddressRequestBodyStakeOneOf4OneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyStakeOneOf4Variants
    where toJSON (PostAnyAddressRequestBodyStakeOneOf4Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyStakeOneOf4Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyStakeOneOf4Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyStakeOneOf4Variant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyStakeOneOf4Variant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyStakeOneOf4Variant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyStakeOneOf4Variants
    where parseJSON val = case (PostAnyAddressRequestBodyStakeOneOf4Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyStakeOneOf4Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyStakeOneOf4Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyStakeOneOf4Variant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyStakeOneOf4Variant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyStakeOneOf4Variant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the oneOf schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.stake.oneOf@ in the specification.
-- 
-- 
data PostAnyAddressRequestBodyStakeVariants =
   PostAnyAddressRequestBodyStakeVariant1 Data.Text.Internal.Text
  | PostAnyAddressRequestBodyStakeVariant2 Data.Text.Internal.Text
  | PostAnyAddressRequestBodyStakeVariant3 Data.Text.Internal.Text
  | PostAnyAddressRequestBodyStakeVariant4 PostAnyAddressRequestBodyStakeOneOf4Variants
  | PostAnyAddressRequestBodyStakeVariant5 Data.Text.Internal.Text
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyStakeVariants
    where toJSON (PostAnyAddressRequestBodyStakeVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyStakeVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyStakeVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyStakeVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostAnyAddressRequestBodyStakeVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyStakeVariants
    where parseJSON val = case (PostAnyAddressRequestBodyStakeVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyStakeVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyStakeVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyStakeVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostAnyAddressRequestBodyStakeVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the enum schema located at @paths.\/addresses.POST.requestBody.content.application\/json.schema.properties.validation@ in the specification.
-- 
-- Script validation level. Required validation sifts off scripts that would not
-- be accepted by the ledger. Recommended level filters out scripts that do not pass
-- required validation and additionally when:
--   * \'all\' is non-empty
--   * there are redundant timelocks in a given level
--   * there are no duplicated verification keys in a given level
--   * \'at_least\' coefficient is positive
--   * \'all\', \'any\' are non-empty and \`\'at_least\' has no less elements in the list
--      than the coefficient after timelocks are filtered out.
data PostAnyAddressRequestBodyValidation =
   PostAnyAddressRequestBodyValidationOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostAnyAddressRequestBodyValidationTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostAnyAddressRequestBodyValidationEnumRequired -- ^ Represents the JSON value @"required"@
  | PostAnyAddressRequestBodyValidationEnumRecommended -- ^ Represents the JSON value @"recommended"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressRequestBodyValidation
    where toJSON (PostAnyAddressRequestBodyValidationOther val) = val
          toJSON (PostAnyAddressRequestBodyValidationTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostAnyAddressRequestBodyValidationEnumRequired) = "required"
          toJSON (PostAnyAddressRequestBodyValidationEnumRecommended) = "recommended"
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressRequestBodyValidation
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "required" -> PostAnyAddressRequestBodyValidationEnumRequired
                                            | val GHC.Classes.== "recommended" -> PostAnyAddressRequestBodyValidationEnumRecommended
                                            | GHC.Base.otherwise -> PostAnyAddressRequestBodyValidationOther val)
-- | Represents a response of the operation 'postAnyAddress'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PostAnyAddressResponseError' is used.
data PostAnyAddressResponse =
   PostAnyAddressResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | PostAnyAddressResponse202 PostAnyAddressResponseBody202 -- ^ Accepted
  | PostAnyAddressResponse400 PostAnyAddressResponseBody400 -- ^ Bad Request
  | PostAnyAddressResponse406 PostAnyAddressResponseBody406 -- ^ Not Acceptable
  | PostAnyAddressResponse415 PostAnyAddressResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/addresses.POST.responses.202.content.application\/json.schema@ in the specification.
-- 
-- 
data PostAnyAddressResponseBody202 = PostAnyAddressResponseBody202 {
  -- | address: A Shelley address representing either enterprise, reward account or delegating address
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((addr)|(stake)|(addr_test)|(stake_test))1[0-9a-z]*\$\'
  postAnyAddressResponseBody202Address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressResponseBody202
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postAnyAddressResponseBody202Address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postAnyAddressResponseBody202Address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressResponseBody202
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressResponseBody202" (\obj -> GHC.Base.pure PostAnyAddressResponseBody202 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address"))
-- | Create a new 'PostAnyAddressResponseBody202' with all required fields.
mkPostAnyAddressResponseBody202 :: Data.Text.Internal.Text -- ^ 'postAnyAddressResponseBody202Address'
  -> PostAnyAddressResponseBody202
mkPostAnyAddressResponseBody202 postAnyAddressResponseBody202Address = PostAnyAddressResponseBody202{postAnyAddressResponseBody202Address = postAnyAddressResponseBody202Address}
-- | Defines the object schema located at @paths.\/addresses.POST.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data PostAnyAddressResponseBody400 = PostAnyAddressResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  postAnyAddressResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postAnyAddressResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postAnyAddressResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressResponseBody400" (\obj -> GHC.Base.pure PostAnyAddressResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostAnyAddressResponseBody400' with all required fields.
mkPostAnyAddressResponseBody400 :: Data.Text.Internal.Text -- ^ 'postAnyAddressResponseBody400Message'
  -> PostAnyAddressResponseBody400
mkPostAnyAddressResponseBody400 postAnyAddressResponseBody400Message = PostAnyAddressResponseBody400{postAnyAddressResponseBody400Message = postAnyAddressResponseBody400Message}
-- | Defines the object schema located at @paths.\/addresses.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data PostAnyAddressResponseBody406 = PostAnyAddressResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  postAnyAddressResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postAnyAddressResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postAnyAddressResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressResponseBody406" (\obj -> GHC.Base.pure PostAnyAddressResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostAnyAddressResponseBody406' with all required fields.
mkPostAnyAddressResponseBody406 :: Data.Text.Internal.Text -- ^ 'postAnyAddressResponseBody406Message'
  -> PostAnyAddressResponseBody406
mkPostAnyAddressResponseBody406 postAnyAddressResponseBody406Message = PostAnyAddressResponseBody406{postAnyAddressResponseBody406Message = postAnyAddressResponseBody406Message}
-- | Defines the object schema located at @paths.\/addresses.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data PostAnyAddressResponseBody415 = PostAnyAddressResponseBody415 {
  -- | code: A specific error code for this error, more precise than HTTP ones.
  postAnyAddressResponseBody415Code :: Data.Text.Internal.Text
  -- | message: A descriptive error message.
  , postAnyAddressResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostAnyAddressResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["code" Data.Aeson.Types.ToJSON..= postAnyAddressResponseBody415Code obj] : ["message" Data.Aeson.Types.ToJSON..= postAnyAddressResponseBody415Message obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["code" Data.Aeson.Types.ToJSON..= postAnyAddressResponseBody415Code obj] : ["message" Data.Aeson.Types.ToJSON..= postAnyAddressResponseBody415Message obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostAnyAddressResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostAnyAddressResponseBody415" (\obj -> (GHC.Base.pure PostAnyAddressResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "code")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostAnyAddressResponseBody415' with all required fields.
mkPostAnyAddressResponseBody415 :: Data.Text.Internal.Text -- ^ 'postAnyAddressResponseBody415Code'
  -> Data.Text.Internal.Text -- ^ 'postAnyAddressResponseBody415Message'
  -> PostAnyAddressResponseBody415
mkPostAnyAddressResponseBody415 postAnyAddressResponseBody415Code postAnyAddressResponseBody415Message = PostAnyAddressResponseBody415{postAnyAddressResponseBody415Code = postAnyAddressResponseBody415Code,
                                                                                                                                       postAnyAddressResponseBody415Message = postAnyAddressResponseBody415Message}
-- | > POST /addresses
-- 
-- The same as 'postAnyAddress' but accepts an explicit configuration.
postAnyAddressWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> GHC.Maybe.Maybe PostAnyAddressRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response PostAnyAddressResponse) -- ^ Monadic computation which returns the result of the operation
postAnyAddressWithConfiguration config
                                body = GHC.Base.fmap (\response_5 -> GHC.Base.fmap (Data.Either.either PostAnyAddressResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> PostAnyAddressResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                              PostAnyAddressResponseBody202)
                                                                                                                                                                                | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostAnyAddressResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                              PostAnyAddressResponseBody400)
                                                                                                                                                                                | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostAnyAddressResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                              PostAnyAddressResponseBody406)
                                                                                                                                                                                | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostAnyAddressResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                              PostAnyAddressResponseBody415)
                                                                                                                                                                                | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_5) response_5) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") "/addresses" GHC.Base.mempty body Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /addresses
-- 
-- The same as 'postAnyAddress' but returns the raw 'Data.ByteString.ByteString'.
postAnyAddressRaw :: forall m . Wallet.Common.MonadHTTP m => GHC.Maybe.Maybe PostAnyAddressRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postAnyAddressRaw body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") "/addresses" GHC.Base.mempty body Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /addresses
-- 
-- The same as 'postAnyAddress' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
postAnyAddressWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> GHC.Maybe.Maybe PostAnyAddressRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postAnyAddressWithConfigurationRaw config
                                   body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") "/addresses" GHC.Base.mempty body Wallet.Common.RequestBodyEncodingJSON)
