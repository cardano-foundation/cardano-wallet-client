-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation listStakeKeys
module Wallet.Operations.ListStakeKeys where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > GET /wallets/{walletId}/stake-keys
-- 
-- \<p align=\"right\">status: \<strong>Experimental\<\/strong>\<\/p>
-- 
-- List stake-keys relevant to the wallet, and how much ada is associated with each.
listStakeKeys :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response ListStakeKeysResponse) -- ^ Monadic computation which returns the result of the operation
listStakeKeys walletId = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either ListStakeKeysResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ListStakeKeysResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                              ListStakeKeysResponseBody200)
                                                                                                                                                                 | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/stake-keys")) GHC.Base.mempty)
-- | Represents a response of the operation 'listStakeKeys'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'ListStakeKeysResponseError' is used.
data ListStakeKeysResponse =
   ListStakeKeysResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | ListStakeKeysResponse200 ListStakeKeysResponseBody200 -- ^ Ok
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/stake-keys.GET.responses.200.content.application\/json.schema@ in the specification.
-- 
-- 
data ListStakeKeysResponseBody200 = ListStakeKeysResponseBody200 {
  -- | foreign: Stake keys found in the wallet\'s UTxO, but does not belong to the wallet.
  listStakeKeysResponseBody200Foreign :: ([ListStakeKeysResponseBody200Foreign])
  -- | none: The absence of a stake key. The \`stake\` field shows how much of the wallet funds
  -- are not associated with an identifiable stake key.
  -- 
  -- Most likely, these funds are associated with enterprise addresses lacking staking rights.
  -- But they \/could\/ also be associate with more rare types of addresses like pointer addresses.
  , listStakeKeysResponseBody200None :: ListStakeKeysResponseBody200None
  -- | ours: Stake keys belonging to the wallet.
  , listStakeKeysResponseBody200Ours :: ([ListStakeKeysResponseBody200Ours])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListStakeKeysResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["foreign" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200Foreign obj] : ["none" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200None obj] : ["ours" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200Ours obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["foreign" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200Foreign obj] : ["none" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200None obj] : ["ours" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200Ours obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListStakeKeysResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListStakeKeysResponseBody200" (\obj -> ((GHC.Base.pure ListStakeKeysResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "foreign")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "none")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ours"))
-- | Create a new 'ListStakeKeysResponseBody200' with all required fields.
mkListStakeKeysResponseBody200 :: [ListStakeKeysResponseBody200Foreign] -- ^ 'listStakeKeysResponseBody200Foreign'
  -> ListStakeKeysResponseBody200None -- ^ 'listStakeKeysResponseBody200None'
  -> [ListStakeKeysResponseBody200Ours] -- ^ 'listStakeKeysResponseBody200Ours'
  -> ListStakeKeysResponseBody200
mkListStakeKeysResponseBody200 listStakeKeysResponseBody200Foreign listStakeKeysResponseBody200None listStakeKeysResponseBody200Ours = ListStakeKeysResponseBody200{listStakeKeysResponseBody200Foreign = listStakeKeysResponseBody200Foreign,
                                                                                                                                                                    listStakeKeysResponseBody200None = listStakeKeysResponseBody200None,
                                                                                                                                                                    listStakeKeysResponseBody200Ours = listStakeKeysResponseBody200Ours}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/stake-keys.GET.responses.200.content.application\/json.schema.properties.foreign.items@ in the specification.
-- 
-- 
data ListStakeKeysResponseBody200Foreign = ListStakeKeysResponseBody200Foreign {
  -- | key
  listStakeKeysResponseBody200ForeignKey :: Data.Text.Internal.Text
  -- | reward_balance: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listStakeKeysResponseBody200ForeignReward_balance :: ListStakeKeysResponseBody200ForeignReward_balance
  -- | stake: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listStakeKeysResponseBody200ForeignStake :: ListStakeKeysResponseBody200ForeignStake
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListStakeKeysResponseBody200Foreign
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["key" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200ForeignKey obj] : ["reward_balance" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200ForeignReward_balance obj] : ["stake" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200ForeignStake obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["key" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200ForeignKey obj] : ["reward_balance" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200ForeignReward_balance obj] : ["stake" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200ForeignStake obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListStakeKeysResponseBody200Foreign
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListStakeKeysResponseBody200Foreign" (\obj -> ((GHC.Base.pure ListStakeKeysResponseBody200Foreign GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "key")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_balance")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake"))
-- | Create a new 'ListStakeKeysResponseBody200Foreign' with all required fields.
mkListStakeKeysResponseBody200Foreign :: Data.Text.Internal.Text -- ^ 'listStakeKeysResponseBody200ForeignKey'
  -> ListStakeKeysResponseBody200ForeignReward_balance -- ^ 'listStakeKeysResponseBody200ForeignReward_balance'
  -> ListStakeKeysResponseBody200ForeignStake -- ^ 'listStakeKeysResponseBody200ForeignStake'
  -> ListStakeKeysResponseBody200Foreign
mkListStakeKeysResponseBody200Foreign listStakeKeysResponseBody200ForeignKey listStakeKeysResponseBody200ForeignReward_balance listStakeKeysResponseBody200ForeignStake = ListStakeKeysResponseBody200Foreign{listStakeKeysResponseBody200ForeignKey = listStakeKeysResponseBody200ForeignKey,
                                                                                                                                                                                                              listStakeKeysResponseBody200ForeignReward_balance = listStakeKeysResponseBody200ForeignReward_balance,
                                                                                                                                                                                                              listStakeKeysResponseBody200ForeignStake = listStakeKeysResponseBody200ForeignStake}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/stake-keys.GET.responses.200.content.application\/json.schema.properties.foreign.items.properties.reward_balance@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListStakeKeysResponseBody200ForeignReward_balance = ListStakeKeysResponseBody200ForeignReward_balance {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listStakeKeysResponseBody200ForeignReward_balanceQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListStakeKeysResponseBody200ForeignReward_balance
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200ForeignReward_balanceQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200ForeignReward_balanceQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListStakeKeysResponseBody200ForeignReward_balance
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListStakeKeysResponseBody200ForeignReward_balance" (\obj -> GHC.Base.pure ListStakeKeysResponseBody200ForeignReward_balance GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListStakeKeysResponseBody200ForeignReward_balance' with all required fields.
mkListStakeKeysResponseBody200ForeignReward_balance :: GHC.Types.Int -- ^ 'listStakeKeysResponseBody200ForeignReward_balanceQuantity'
  -> ListStakeKeysResponseBody200ForeignReward_balance
mkListStakeKeysResponseBody200ForeignReward_balance listStakeKeysResponseBody200ForeignReward_balanceQuantity = ListStakeKeysResponseBody200ForeignReward_balance{listStakeKeysResponseBody200ForeignReward_balanceQuantity = listStakeKeysResponseBody200ForeignReward_balanceQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/stake-keys.GET.responses.200.content.application\/json.schema.properties.foreign.items.properties.stake@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListStakeKeysResponseBody200ForeignStake = ListStakeKeysResponseBody200ForeignStake {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listStakeKeysResponseBody200ForeignStakeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListStakeKeysResponseBody200ForeignStake
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200ForeignStakeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200ForeignStakeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListStakeKeysResponseBody200ForeignStake
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListStakeKeysResponseBody200ForeignStake" (\obj -> GHC.Base.pure ListStakeKeysResponseBody200ForeignStake GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListStakeKeysResponseBody200ForeignStake' with all required fields.
mkListStakeKeysResponseBody200ForeignStake :: GHC.Types.Int -- ^ 'listStakeKeysResponseBody200ForeignStakeQuantity'
  -> ListStakeKeysResponseBody200ForeignStake
mkListStakeKeysResponseBody200ForeignStake listStakeKeysResponseBody200ForeignStakeQuantity = ListStakeKeysResponseBody200ForeignStake{listStakeKeysResponseBody200ForeignStakeQuantity = listStakeKeysResponseBody200ForeignStakeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/stake-keys.GET.responses.200.content.application\/json.schema.properties.none@ in the specification.
-- 
-- The absence of a stake key. The \`stake\` field shows how much of the wallet funds
-- are not associated with an identifiable stake key.
-- 
-- Most likely, these funds are associated with enterprise addresses lacking staking rights.
-- But they \/could\/ also be associate with more rare types of addresses like pointer addresses.
data ListStakeKeysResponseBody200None = ListStakeKeysResponseBody200None {
  -- | stake: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  listStakeKeysResponseBody200NoneStake :: ListStakeKeysResponseBody200NoneStake
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListStakeKeysResponseBody200None
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["stake" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200NoneStake obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["stake" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200NoneStake obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListStakeKeysResponseBody200None
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListStakeKeysResponseBody200None" (\obj -> GHC.Base.pure ListStakeKeysResponseBody200None GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake"))
-- | Create a new 'ListStakeKeysResponseBody200None' with all required fields.
mkListStakeKeysResponseBody200None :: ListStakeKeysResponseBody200NoneStake -- ^ 'listStakeKeysResponseBody200NoneStake'
  -> ListStakeKeysResponseBody200None
mkListStakeKeysResponseBody200None listStakeKeysResponseBody200NoneStake = ListStakeKeysResponseBody200None{listStakeKeysResponseBody200NoneStake = listStakeKeysResponseBody200NoneStake}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/stake-keys.GET.responses.200.content.application\/json.schema.properties.none.properties.stake@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListStakeKeysResponseBody200NoneStake = ListStakeKeysResponseBody200NoneStake {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listStakeKeysResponseBody200NoneStakeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListStakeKeysResponseBody200NoneStake
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200NoneStakeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200NoneStakeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListStakeKeysResponseBody200NoneStake
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListStakeKeysResponseBody200NoneStake" (\obj -> GHC.Base.pure ListStakeKeysResponseBody200NoneStake GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListStakeKeysResponseBody200NoneStake' with all required fields.
mkListStakeKeysResponseBody200NoneStake :: GHC.Types.Int -- ^ 'listStakeKeysResponseBody200NoneStakeQuantity'
  -> ListStakeKeysResponseBody200NoneStake
mkListStakeKeysResponseBody200NoneStake listStakeKeysResponseBody200NoneStakeQuantity = ListStakeKeysResponseBody200NoneStake{listStakeKeysResponseBody200NoneStakeQuantity = listStakeKeysResponseBody200NoneStakeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/stake-keys.GET.responses.200.content.application\/json.schema.properties.ours.items@ in the specification.
-- 
-- 
data ListStakeKeysResponseBody200Ours = ListStakeKeysResponseBody200Ours {
  -- | delegation: Delegation settings
  listStakeKeysResponseBody200OursDelegation :: ListStakeKeysResponseBody200OursDelegation
  -- | index: A soft derivation index.
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 2.1474836e9
  -- * Minimum  of 0.0
  , listStakeKeysResponseBody200OursIndex :: GHC.Types.Int
  -- | key
  , listStakeKeysResponseBody200OursKey :: Data.Text.Internal.Text
  -- | reward_balance: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listStakeKeysResponseBody200OursReward_balance :: ListStakeKeysResponseBody200OursReward_balance
  -- | stake: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listStakeKeysResponseBody200OursStake :: ListStakeKeysResponseBody200OursStake
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListStakeKeysResponseBody200Ours
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["delegation" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegation obj] : ["index" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursIndex obj] : ["key" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursKey obj] : ["reward_balance" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursReward_balance obj] : ["stake" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursStake obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["delegation" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegation obj] : ["index" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursIndex obj] : ["key" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursKey obj] : ["reward_balance" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursReward_balance obj] : ["stake" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursStake obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListStakeKeysResponseBody200Ours
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListStakeKeysResponseBody200Ours" (\obj -> ((((GHC.Base.pure ListStakeKeysResponseBody200Ours GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delegation")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "key")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_balance")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake"))
-- | Create a new 'ListStakeKeysResponseBody200Ours' with all required fields.
mkListStakeKeysResponseBody200Ours :: ListStakeKeysResponseBody200OursDelegation -- ^ 'listStakeKeysResponseBody200OursDelegation'
  -> GHC.Types.Int -- ^ 'listStakeKeysResponseBody200OursIndex'
  -> Data.Text.Internal.Text -- ^ 'listStakeKeysResponseBody200OursKey'
  -> ListStakeKeysResponseBody200OursReward_balance -- ^ 'listStakeKeysResponseBody200OursReward_balance'
  -> ListStakeKeysResponseBody200OursStake -- ^ 'listStakeKeysResponseBody200OursStake'
  -> ListStakeKeysResponseBody200Ours
mkListStakeKeysResponseBody200Ours listStakeKeysResponseBody200OursDelegation listStakeKeysResponseBody200OursIndex listStakeKeysResponseBody200OursKey listStakeKeysResponseBody200OursReward_balance listStakeKeysResponseBody200OursStake = ListStakeKeysResponseBody200Ours{listStakeKeysResponseBody200OursDelegation = listStakeKeysResponseBody200OursDelegation,
                                                                                                                                                                                                                                                                                listStakeKeysResponseBody200OursIndex = listStakeKeysResponseBody200OursIndex,
                                                                                                                                                                                                                                                                                listStakeKeysResponseBody200OursKey = listStakeKeysResponseBody200OursKey,
                                                                                                                                                                                                                                                                                listStakeKeysResponseBody200OursReward_balance = listStakeKeysResponseBody200OursReward_balance,
                                                                                                                                                                                                                                                                                listStakeKeysResponseBody200OursStake = listStakeKeysResponseBody200OursStake}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/stake-keys.GET.responses.200.content.application\/json.schema.properties.ours.items.properties.delegation@ in the specification.
-- 
-- Delegation settings
data ListStakeKeysResponseBody200OursDelegation = ListStakeKeysResponseBody200OursDelegation {
  -- | active: Currently active delegation status.
  listStakeKeysResponseBody200OursDelegationActive :: ListStakeKeysResponseBody200OursDelegationActive
  -- | next
  , listStakeKeysResponseBody200OursDelegationNext :: ([ListStakeKeysResponseBody200OursDelegationNext])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListStakeKeysResponseBody200OursDelegation
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegationActive obj] : ["next" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegationNext obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegationActive obj] : ["next" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegationNext obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListStakeKeysResponseBody200OursDelegation
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListStakeKeysResponseBody200OursDelegation" (\obj -> (GHC.Base.pure ListStakeKeysResponseBody200OursDelegation GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "next"))
-- | Create a new 'ListStakeKeysResponseBody200OursDelegation' with all required fields.
mkListStakeKeysResponseBody200OursDelegation :: ListStakeKeysResponseBody200OursDelegationActive -- ^ 'listStakeKeysResponseBody200OursDelegationActive'
  -> [ListStakeKeysResponseBody200OursDelegationNext] -- ^ 'listStakeKeysResponseBody200OursDelegationNext'
  -> ListStakeKeysResponseBody200OursDelegation
mkListStakeKeysResponseBody200OursDelegation listStakeKeysResponseBody200OursDelegationActive listStakeKeysResponseBody200OursDelegationNext = ListStakeKeysResponseBody200OursDelegation{listStakeKeysResponseBody200OursDelegationActive = listStakeKeysResponseBody200OursDelegationActive,
                                                                                                                                                                                          listStakeKeysResponseBody200OursDelegationNext = listStakeKeysResponseBody200OursDelegationNext}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/stake-keys.GET.responses.200.content.application\/json.schema.properties.ours.items.properties.delegation.properties.active@ in the specification.
-- 
-- Currently active delegation status.
data ListStakeKeysResponseBody200OursDelegationActive = ListStakeKeysResponseBody200OursDelegationActive {
  -- | status
  listStakeKeysResponseBody200OursDelegationActiveStatus :: ListStakeKeysResponseBody200OursDelegationActiveStatus
  -- | target: A unique Stake-Pool identifier (present only if status = \`delegating\`)
  , listStakeKeysResponseBody200OursDelegationActiveTarget :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListStakeKeysResponseBody200OursDelegationActive
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["status" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegationActiveStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (listStakeKeysResponseBody200OursDelegationActiveTarget obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["status" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegationActiveStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (listStakeKeysResponseBody200OursDelegationActiveTarget obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListStakeKeysResponseBody200OursDelegationActive
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListStakeKeysResponseBody200OursDelegationActive" (\obj -> (GHC.Base.pure ListStakeKeysResponseBody200OursDelegationActive GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "target"))
-- | Create a new 'ListStakeKeysResponseBody200OursDelegationActive' with all required fields.
mkListStakeKeysResponseBody200OursDelegationActive :: ListStakeKeysResponseBody200OursDelegationActiveStatus -- ^ 'listStakeKeysResponseBody200OursDelegationActiveStatus'
  -> ListStakeKeysResponseBody200OursDelegationActive
mkListStakeKeysResponseBody200OursDelegationActive listStakeKeysResponseBody200OursDelegationActiveStatus = ListStakeKeysResponseBody200OursDelegationActive{listStakeKeysResponseBody200OursDelegationActiveStatus = listStakeKeysResponseBody200OursDelegationActiveStatus,
                                                                                                                                                             listStakeKeysResponseBody200OursDelegationActiveTarget = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/stake-keys.GET.responses.200.content.application\/json.schema.properties.ours.items.properties.delegation.properties.active.properties.status@ in the specification.
-- 
-- 
data ListStakeKeysResponseBody200OursDelegationActiveStatus =
   ListStakeKeysResponseBody200OursDelegationActiveStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListStakeKeysResponseBody200OursDelegationActiveStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListStakeKeysResponseBody200OursDelegationActiveStatusEnumNot_delegating -- ^ Represents the JSON value @"not_delegating"@
  | ListStakeKeysResponseBody200OursDelegationActiveStatusEnumDelegating -- ^ Represents the JSON value @"delegating"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListStakeKeysResponseBody200OursDelegationActiveStatus
    where toJSON (ListStakeKeysResponseBody200OursDelegationActiveStatusOther val) = val
          toJSON (ListStakeKeysResponseBody200OursDelegationActiveStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListStakeKeysResponseBody200OursDelegationActiveStatusEnumNot_delegating) = "not_delegating"
          toJSON (ListStakeKeysResponseBody200OursDelegationActiveStatusEnumDelegating) = "delegating"
instance Data.Aeson.Types.FromJSON.FromJSON ListStakeKeysResponseBody200OursDelegationActiveStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "not_delegating" -> ListStakeKeysResponseBody200OursDelegationActiveStatusEnumNot_delegating
                                            | val GHC.Classes.== "delegating" -> ListStakeKeysResponseBody200OursDelegationActiveStatusEnumDelegating
                                            | GHC.Base.otherwise -> ListStakeKeysResponseBody200OursDelegationActiveStatusOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/stake-keys.GET.responses.200.content.application\/json.schema.properties.ours.items.properties.delegation.properties.next.items@ in the specification.
-- 
-- Next delegation status becomes active at the start of the second epoch after the corresponding delegation certificate was discovered. The exact moment is specified by changes_at
data ListStakeKeysResponseBody200OursDelegationNext = ListStakeKeysResponseBody200OursDelegationNext {
  -- | changes_at
  listStakeKeysResponseBody200OursDelegationNextChanges_at :: ListStakeKeysResponseBody200OursDelegationNextChanges_at
  -- | status
  , listStakeKeysResponseBody200OursDelegationNextStatus :: ListStakeKeysResponseBody200OursDelegationNextStatus
  -- | target: A unique Stake-Pool identifier (present only if status = \`delegating\`)
  , listStakeKeysResponseBody200OursDelegationNextTarget :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListStakeKeysResponseBody200OursDelegationNext
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["changes_at" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegationNextChanges_at obj] : ["status" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegationNextStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (listStakeKeysResponseBody200OursDelegationNextTarget obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["changes_at" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegationNextChanges_at obj] : ["status" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegationNextStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (listStakeKeysResponseBody200OursDelegationNextTarget obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListStakeKeysResponseBody200OursDelegationNext
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListStakeKeysResponseBody200OursDelegationNext" (\obj -> ((GHC.Base.pure ListStakeKeysResponseBody200OursDelegationNext GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "changes_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "target"))
-- | Create a new 'ListStakeKeysResponseBody200OursDelegationNext' with all required fields.
mkListStakeKeysResponseBody200OursDelegationNext :: ListStakeKeysResponseBody200OursDelegationNextChanges_at -- ^ 'listStakeKeysResponseBody200OursDelegationNextChanges_at'
  -> ListStakeKeysResponseBody200OursDelegationNextStatus -- ^ 'listStakeKeysResponseBody200OursDelegationNextStatus'
  -> ListStakeKeysResponseBody200OursDelegationNext
mkListStakeKeysResponseBody200OursDelegationNext listStakeKeysResponseBody200OursDelegationNextChanges_at listStakeKeysResponseBody200OursDelegationNextStatus = ListStakeKeysResponseBody200OursDelegationNext{listStakeKeysResponseBody200OursDelegationNextChanges_at = listStakeKeysResponseBody200OursDelegationNextChanges_at,
                                                                                                                                                                                                                listStakeKeysResponseBody200OursDelegationNextStatus = listStakeKeysResponseBody200OursDelegationNextStatus,
                                                                                                                                                                                                                listStakeKeysResponseBody200OursDelegationNextTarget = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/stake-keys.GET.responses.200.content.application\/json.schema.properties.ours.items.properties.delegation.properties.next.items.properties.changes_at@ in the specification.
-- 
-- 
data ListStakeKeysResponseBody200OursDelegationNextChanges_at = ListStakeKeysResponseBody200OursDelegationNextChanges_at {
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listStakeKeysResponseBody200OursDelegationNextChanges_atEpoch_number :: GHC.Types.Int
  -- | epoch_start_time
  , listStakeKeysResponseBody200OursDelegationNextChanges_atEpoch_start_time :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListStakeKeysResponseBody200OursDelegationNextChanges_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["epoch_number" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegationNextChanges_atEpoch_number obj] : ["epoch_start_time" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegationNextChanges_atEpoch_start_time obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["epoch_number" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegationNextChanges_atEpoch_number obj] : ["epoch_start_time" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursDelegationNextChanges_atEpoch_start_time obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListStakeKeysResponseBody200OursDelegationNextChanges_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListStakeKeysResponseBody200OursDelegationNextChanges_at" (\obj -> (GHC.Base.pure ListStakeKeysResponseBody200OursDelegationNextChanges_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_start_time"))
-- | Create a new 'ListStakeKeysResponseBody200OursDelegationNextChanges_at' with all required fields.
mkListStakeKeysResponseBody200OursDelegationNextChanges_at :: GHC.Types.Int -- ^ 'listStakeKeysResponseBody200OursDelegationNextChanges_atEpoch_number'
  -> Data.Text.Internal.Text -- ^ 'listStakeKeysResponseBody200OursDelegationNextChanges_atEpoch_start_time'
  -> ListStakeKeysResponseBody200OursDelegationNextChanges_at
mkListStakeKeysResponseBody200OursDelegationNextChanges_at listStakeKeysResponseBody200OursDelegationNextChanges_atEpoch_number listStakeKeysResponseBody200OursDelegationNextChanges_atEpoch_start_time = ListStakeKeysResponseBody200OursDelegationNextChanges_at{listStakeKeysResponseBody200OursDelegationNextChanges_atEpoch_number = listStakeKeysResponseBody200OursDelegationNextChanges_atEpoch_number,
                                                                                                                                                                                                                                                                    listStakeKeysResponseBody200OursDelegationNextChanges_atEpoch_start_time = listStakeKeysResponseBody200OursDelegationNextChanges_atEpoch_start_time}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/stake-keys.GET.responses.200.content.application\/json.schema.properties.ours.items.properties.delegation.properties.next.items.properties.status@ in the specification.
-- 
-- 
data ListStakeKeysResponseBody200OursDelegationNextStatus =
   ListStakeKeysResponseBody200OursDelegationNextStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListStakeKeysResponseBody200OursDelegationNextStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListStakeKeysResponseBody200OursDelegationNextStatusEnumNot_delegating -- ^ Represents the JSON value @"not_delegating"@
  | ListStakeKeysResponseBody200OursDelegationNextStatusEnumDelegating -- ^ Represents the JSON value @"delegating"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListStakeKeysResponseBody200OursDelegationNextStatus
    where toJSON (ListStakeKeysResponseBody200OursDelegationNextStatusOther val) = val
          toJSON (ListStakeKeysResponseBody200OursDelegationNextStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListStakeKeysResponseBody200OursDelegationNextStatusEnumNot_delegating) = "not_delegating"
          toJSON (ListStakeKeysResponseBody200OursDelegationNextStatusEnumDelegating) = "delegating"
instance Data.Aeson.Types.FromJSON.FromJSON ListStakeKeysResponseBody200OursDelegationNextStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "not_delegating" -> ListStakeKeysResponseBody200OursDelegationNextStatusEnumNot_delegating
                                            | val GHC.Classes.== "delegating" -> ListStakeKeysResponseBody200OursDelegationNextStatusEnumDelegating
                                            | GHC.Base.otherwise -> ListStakeKeysResponseBody200OursDelegationNextStatusOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/stake-keys.GET.responses.200.content.application\/json.schema.properties.ours.items.properties.reward_balance@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListStakeKeysResponseBody200OursReward_balance = ListStakeKeysResponseBody200OursReward_balance {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listStakeKeysResponseBody200OursReward_balanceQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListStakeKeysResponseBody200OursReward_balance
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursReward_balanceQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursReward_balanceQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListStakeKeysResponseBody200OursReward_balance
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListStakeKeysResponseBody200OursReward_balance" (\obj -> GHC.Base.pure ListStakeKeysResponseBody200OursReward_balance GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListStakeKeysResponseBody200OursReward_balance' with all required fields.
mkListStakeKeysResponseBody200OursReward_balance :: GHC.Types.Int -- ^ 'listStakeKeysResponseBody200OursReward_balanceQuantity'
  -> ListStakeKeysResponseBody200OursReward_balance
mkListStakeKeysResponseBody200OursReward_balance listStakeKeysResponseBody200OursReward_balanceQuantity = ListStakeKeysResponseBody200OursReward_balance{listStakeKeysResponseBody200OursReward_balanceQuantity = listStakeKeysResponseBody200OursReward_balanceQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/stake-keys.GET.responses.200.content.application\/json.schema.properties.ours.items.properties.stake@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListStakeKeysResponseBody200OursStake = ListStakeKeysResponseBody200OursStake {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listStakeKeysResponseBody200OursStakeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListStakeKeysResponseBody200OursStake
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursStakeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listStakeKeysResponseBody200OursStakeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListStakeKeysResponseBody200OursStake
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListStakeKeysResponseBody200OursStake" (\obj -> GHC.Base.pure ListStakeKeysResponseBody200OursStake GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListStakeKeysResponseBody200OursStake' with all required fields.
mkListStakeKeysResponseBody200OursStake :: GHC.Types.Int -- ^ 'listStakeKeysResponseBody200OursStakeQuantity'
  -> ListStakeKeysResponseBody200OursStake
mkListStakeKeysResponseBody200OursStake listStakeKeysResponseBody200OursStakeQuantity = ListStakeKeysResponseBody200OursStake{listStakeKeysResponseBody200OursStakeQuantity = listStakeKeysResponseBody200OursStakeQuantity}
-- | > GET /wallets/{walletId}/stake-keys
-- 
-- The same as 'listStakeKeys' but accepts an explicit configuration.
listStakeKeysWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> m (Network.HTTP.Client.Types.Response ListStakeKeysResponse) -- ^ Monadic computation which returns the result of the operation
listStakeKeysWithConfiguration config
                               walletId = GHC.Base.fmap (\response_2 -> GHC.Base.fmap (Data.Either.either ListStakeKeysResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ListStakeKeysResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               ListStakeKeysResponseBody200)
                                                                                                                                                                                  | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_2) response_2) (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/stake-keys")) GHC.Base.mempty)
-- | > GET /wallets/{walletId}/stake-keys
-- 
-- The same as 'listStakeKeys' but returns the raw 'Data.ByteString.ByteString'.
listStakeKeysRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
listStakeKeysRaw walletId = GHC.Base.id (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/stake-keys")) GHC.Base.mempty)
-- | > GET /wallets/{walletId}/stake-keys
-- 
-- The same as 'listStakeKeys' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
listStakeKeysWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
listStakeKeysWithConfigurationRaw config
                                  walletId = GHC.Base.id (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/stake-keys")) GHC.Base.mempty)
