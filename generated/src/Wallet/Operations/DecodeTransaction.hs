-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation decodeTransaction
module Wallet.Operations.DecodeTransaction where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /wallets/{walletId}/transactions-decode
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Decode a serialized transaction, either freshly constructed,
-- partially signed or fully-signed.
decodeTransaction :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> DecodeTransactionRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response DecodeTransactionResponse) -- ^ Monadic computation which returns the result of the operation
decodeTransaction walletId
                  body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either DecodeTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> DecodeTransactionResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                      DecodeTransactionResponseBody202)
                                                                                                                                                                     | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> DecodeTransactionResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                      DecodeTransactionResponseBody400)
                                                                                                                                                                     | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> DecodeTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                      DecodeTransactionResponseBody404)
                                                                                                                                                                     | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> DecodeTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                      DecodeTransactionResponseBody406)
                                                                                                                                                                     | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> DecodeTransactionResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                      DecodeTransactionResponseBody415)
                                                                                                                                                                     | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-decode")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.requestBody.content.application\/json.schema@ in the specification.
-- 
-- An encoded transaction.
data DecodeTransactionRequestBody = DecodeTransactionRequestBody {
  -- | transaction: The CBOR-encoded transaction, represented in either hex or base64 encoding.
  -- This always includes the transaction body and the witness set, even if the
  -- latter is empty.
  decodeTransactionRequestBodyTransaction :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["transaction" Data.Aeson.Types.ToJSON..= decodeTransactionRequestBodyTransaction obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["transaction" Data.Aeson.Types.ToJSON..= decodeTransactionRequestBodyTransaction obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionRequestBody" (\obj -> GHC.Base.pure DecodeTransactionRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "transaction"))
-- | Create a new 'DecodeTransactionRequestBody' with all required fields.
mkDecodeTransactionRequestBody :: Data.Text.Internal.Text -- ^ 'decodeTransactionRequestBodyTransaction'
  -> DecodeTransactionRequestBody
mkDecodeTransactionRequestBody decodeTransactionRequestBodyTransaction = DecodeTransactionRequestBody{decodeTransactionRequestBodyTransaction = decodeTransactionRequestBodyTransaction}
-- | Represents a response of the operation 'decodeTransaction'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'DecodeTransactionResponseError' is used.
data DecodeTransactionResponse =
   DecodeTransactionResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | DecodeTransactionResponse202 DecodeTransactionResponseBody202 -- ^ Accepted
  | DecodeTransactionResponse400 DecodeTransactionResponseBody400 -- ^ Bad Request
  | DecodeTransactionResponse404 DecodeTransactionResponseBody404 -- ^ Not Found
  | DecodeTransactionResponse406 DecodeTransactionResponseBody406 -- ^ Not Acceptable
  | DecodeTransactionResponse415 DecodeTransactionResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202 = DecodeTransactionResponseBody202 {
  -- | burn
  decodeTransactionResponseBody202Burn :: DecodeTransactionResponseBody202Burn
  -- | certificates
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , decodeTransactionResponseBody202Certificates :: ([DecodeTransactionResponseBody202CertificatesVariants])
  -- | collateral: Inputs that could be external or belong to the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , decodeTransactionResponseBody202Collateral :: (GHC.Maybe.Maybe ([DecodeTransactionResponseBody202CollateralVariants]))
  -- | collateral_outputs: Outputs that could be external or belong to the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 1 items
  -- * Must have a minimum of 0 items
  , decodeTransactionResponseBody202Collateral_outputs :: (GHC.Maybe.Maybe ([DecodeTransactionResponseBody202Collateral_outputsVariants]))
  -- | deposits_returned: A list of deposits associated with a transaction.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , decodeTransactionResponseBody202Deposits_returned :: (GHC.Maybe.Maybe ([DecodeTransactionResponseBody202Deposits_returned]))
  -- | deposits_taken: A list of deposits associated with a transaction.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , decodeTransactionResponseBody202Deposits_taken :: (GHC.Maybe.Maybe ([DecodeTransactionResponseBody202Deposits_taken]))
  -- | fee: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , decodeTransactionResponseBody202Fee :: DecodeTransactionResponseBody202Fee
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , decodeTransactionResponseBody202Id :: Data.Text.Internal.Text
  -- | inputs: Inputs that could be external or belong to the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , decodeTransactionResponseBody202Inputs :: ([DecodeTransactionResponseBody202InputsVariants])
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  , decodeTransactionResponseBody202Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | mint
  , decodeTransactionResponseBody202Mint :: DecodeTransactionResponseBody202Mint
  -- | outputs: Outputs that could be external or belong to the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , decodeTransactionResponseBody202Outputs :: ([DecodeTransactionResponseBody202OutputsVariants])
  -- | script_validity: Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
  -- used in the transaction validated or not. Validity may be null if this
  -- transaction was from an era that doesn\'t support phase-2 monetary policy
  -- scripts, or is a pending transaction (we don\'t know if validation passed or
  -- failed until the transaction hits the ledger).
  , decodeTransactionResponseBody202Script_validity :: (GHC.Maybe.Maybe (Wallet.Common.Nullable DecodeTransactionResponseBody202Script_validityNonNullable))
  -- | validity_interval
  , decodeTransactionResponseBody202Validity_interval :: (GHC.Maybe.Maybe DecodeTransactionResponseBody202Validity_interval)
  -- | withdrawals: Withdrawals that could be external or belong to the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , decodeTransactionResponseBody202Withdrawals :: ([DecodeTransactionResponseBody202Withdrawals])
  -- | witness_count: Specifies the number of verification key and bootstrap wintesses.
  -- As scripts act as witnesses they are also included. Scripts can be specified
  -- and spent in a given transaction or defined to be consumed later.
  -- In the latter case they are defined in transaction outputs (feature possible from Babbage era)
  -- in one transaction and referenced in other later transaction(s). The script referencing
  -- is realized via including of reference in a reference input. If reference script
  -- is present here it included the form of the script and reference to be used later,
  -- ie. tx id and index of tx out where the script was included.
  , decodeTransactionResponseBody202Witness_count :: DecodeTransactionResponseBody202Witness_count
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["burn" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Burn obj] : ["certificates" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Certificates obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Collateral_outputs obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_returned" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Deposits_returned obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_taken" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Deposits_taken obj) : ["fee" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Fee obj] : ["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Metadata obj) : ["mint" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Mint obj] : ["outputs" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Script_validity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Withdrawals obj] : ["witness_count" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_count obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["burn" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Burn obj] : ["certificates" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Certificates obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Collateral_outputs obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_returned" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Deposits_returned obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_taken" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Deposits_taken obj) : ["fee" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Fee obj] : ["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Metadata obj) : ["mint" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Mint obj] : ["outputs" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Script_validity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Withdrawals obj] : ["witness_count" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_count obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202" (\obj -> (((((((((((((((GHC.Base.pure DecodeTransactionResponseBody202 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "burn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral_outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "deposits_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "deposits_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fee")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "mint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_validity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "validity_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "withdrawals")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "witness_count"))
-- | Create a new 'DecodeTransactionResponseBody202' with all required fields.
mkDecodeTransactionResponseBody202 :: DecodeTransactionResponseBody202Burn -- ^ 'decodeTransactionResponseBody202Burn'
  -> [DecodeTransactionResponseBody202CertificatesVariants] -- ^ 'decodeTransactionResponseBody202Certificates'
  -> DecodeTransactionResponseBody202Fee -- ^ 'decodeTransactionResponseBody202Fee'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202Id'
  -> [DecodeTransactionResponseBody202InputsVariants] -- ^ 'decodeTransactionResponseBody202Inputs'
  -> DecodeTransactionResponseBody202Mint -- ^ 'decodeTransactionResponseBody202Mint'
  -> [DecodeTransactionResponseBody202OutputsVariants] -- ^ 'decodeTransactionResponseBody202Outputs'
  -> [DecodeTransactionResponseBody202Withdrawals] -- ^ 'decodeTransactionResponseBody202Withdrawals'
  -> DecodeTransactionResponseBody202Witness_count -- ^ 'decodeTransactionResponseBody202Witness_count'
  -> DecodeTransactionResponseBody202
mkDecodeTransactionResponseBody202 decodeTransactionResponseBody202Burn decodeTransactionResponseBody202Certificates decodeTransactionResponseBody202Fee decodeTransactionResponseBody202Id decodeTransactionResponseBody202Inputs decodeTransactionResponseBody202Mint decodeTransactionResponseBody202Outputs decodeTransactionResponseBody202Withdrawals decodeTransactionResponseBody202Witness_count = DecodeTransactionResponseBody202{decodeTransactionResponseBody202Burn = decodeTransactionResponseBody202Burn,
                                                                                                                                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Certificates = decodeTransactionResponseBody202Certificates,
                                                                                                                                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Collateral = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Collateral_outputs = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Deposits_returned = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Deposits_taken = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Fee = decodeTransactionResponseBody202Fee,
                                                                                                                                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Id = decodeTransactionResponseBody202Id,
                                                                                                                                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Inputs = decodeTransactionResponseBody202Inputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Mint = decodeTransactionResponseBody202Mint,
                                                                                                                                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Outputs = decodeTransactionResponseBody202Outputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Script_validity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Validity_interval = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Withdrawals = decodeTransactionResponseBody202Withdrawals,
                                                                                                                                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Witness_count = decodeTransactionResponseBody202Witness_count}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Burn = DecodeTransactionResponseBody202Burn {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  decodeTransactionResponseBody202BurnTokens :: ([DecodeTransactionResponseBody202BurnTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , decodeTransactionResponseBody202BurnWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , decodeTransactionResponseBody202BurnWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202BurnWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202BurnWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Burn" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202Burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'DecodeTransactionResponseBody202Burn' with all required fields.
mkDecodeTransactionResponseBody202Burn :: [DecodeTransactionResponseBody202BurnTokens] -- ^ 'decodeTransactionResponseBody202BurnTokens'
  -> DecodeTransactionResponseBody202Burn
mkDecodeTransactionResponseBody202Burn decodeTransactionResponseBody202BurnTokens = DecodeTransactionResponseBody202Burn{decodeTransactionResponseBody202BurnTokens = decodeTransactionResponseBody202BurnTokens,
                                                                                                                         decodeTransactionResponseBody202BurnWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                         decodeTransactionResponseBody202BurnWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202BurnTokens = DecodeTransactionResponseBody202BurnTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  decodeTransactionResponseBody202BurnTokensAssets :: ([DecodeTransactionResponseBody202BurnTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , decodeTransactionResponseBody202BurnTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , decodeTransactionResponseBody202BurnTokensPolicy_script :: DecodeTransactionResponseBody202BurnTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202BurnTokens" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202BurnTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'DecodeTransactionResponseBody202BurnTokens' with all required fields.
mkDecodeTransactionResponseBody202BurnTokens :: [DecodeTransactionResponseBody202BurnTokensAssets] -- ^ 'decodeTransactionResponseBody202BurnTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_id'
  -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptVariants -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_script'
  -> DecodeTransactionResponseBody202BurnTokens
mkDecodeTransactionResponseBody202BurnTokens decodeTransactionResponseBody202BurnTokensAssets decodeTransactionResponseBody202BurnTokensPolicy_id decodeTransactionResponseBody202BurnTokensPolicy_script = DecodeTransactionResponseBody202BurnTokens{decodeTransactionResponseBody202BurnTokensAssets = decodeTransactionResponseBody202BurnTokensAssets,
                                                                                                                                                                                                                                                       decodeTransactionResponseBody202BurnTokensPolicy_id = decodeTransactionResponseBody202BurnTokensPolicy_id,
                                                                                                                                                                                                                                                       decodeTransactionResponseBody202BurnTokensPolicy_script = decodeTransactionResponseBody202BurnTokensPolicy_script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202BurnTokensAssets = DecodeTransactionResponseBody202BurnTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  decodeTransactionResponseBody202BurnTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , decodeTransactionResponseBody202BurnTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202BurnTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202BurnTokensAssets" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202BurnTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202BurnTokensAssets' with all required fields.
mkDecodeTransactionResponseBody202BurnTokensAssets :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202BurnTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202BurnTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202BurnTokensAssetsQuantity'
  -> DecodeTransactionResponseBody202BurnTokensAssets
mkDecodeTransactionResponseBody202BurnTokensAssets decodeTransactionResponseBody202BurnTokensAssetsAsset_name decodeTransactionResponseBody202BurnTokensAssetsFingerprint decodeTransactionResponseBody202BurnTokensAssetsQuantity = DecodeTransactionResponseBody202BurnTokensAssets{decodeTransactionResponseBody202BurnTokensAssetsAsset_name = decodeTransactionResponseBody202BurnTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                      decodeTransactionResponseBody202BurnTokensAssetsFingerprint = decodeTransactionResponseBody202BurnTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                      decodeTransactionResponseBody202BurnTokensAssetsQuantity = decodeTransactionResponseBody202BurnTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1 = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference)
  -- | script
  , decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script :: DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1' with all required fields.
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1 :: DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script'
  -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1 decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1{decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                    decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference' with all required fields.
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex'
  -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference{decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                       decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2{decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3{decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 :: DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4{decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some{decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                        decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5{decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6{decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants =
   DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
  | DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
  | DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
  | DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
  | DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2 = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info :: DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2' with all required fields.
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2 :: DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info'
  -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2 decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2{decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                         decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference' with all required fields.
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex'
  -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference{decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                       decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version :: DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info :: DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info{decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                                   decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3 = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References :: ([DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3' with all required fields.
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3 :: [DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References] -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash'
  -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3 decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3{decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                                 decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References' with all required fields.
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex'
  -> DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References
mkDecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex = DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References{decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                           decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex = decodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202BurnTokensPolicy_scriptVariants =
   DecodeTransactionResponseBody202BurnTokensPolicy_scriptVariant1 DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf1
  | DecodeTransactionResponseBody202BurnTokensPolicy_scriptVariant2 DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf2
  | DecodeTransactionResponseBody202BurnTokensPolicy_scriptVariant3 DecodeTransactionResponseBody202BurnTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptVariants
    where toJSON (DecodeTransactionResponseBody202BurnTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202BurnTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202BurnTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202BurnTokensPolicy_scriptVariants
    where parseJSON val = case (DecodeTransactionResponseBody202BurnTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202BurnTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202BurnTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data DecodeTransactionResponseBody202CertificatesOneOf1 = DecodeTransactionResponseBody202CertificatesOneOf1 {
  -- | certificate_type
  decodeTransactionResponseBody202CertificatesOneOf1Certificate_type :: DecodeTransactionResponseBody202CertificatesOneOf1Certificate_type
  -- | pool: A unique identifier for the pool.
  , decodeTransactionResponseBody202CertificatesOneOf1Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , decodeTransactionResponseBody202CertificatesOneOf1Reward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CertificatesOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CertificatesOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202CertificatesOneOf1" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202CertificatesOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'DecodeTransactionResponseBody202CertificatesOneOf1' with all required fields.
mkDecodeTransactionResponseBody202CertificatesOneOf1 :: DecodeTransactionResponseBody202CertificatesOneOf1Certificate_type -- ^ 'decodeTransactionResponseBody202CertificatesOneOf1Certificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'decodeTransactionResponseBody202CertificatesOneOf1Reward_account_path'
  -> DecodeTransactionResponseBody202CertificatesOneOf1
mkDecodeTransactionResponseBody202CertificatesOneOf1 decodeTransactionResponseBody202CertificatesOneOf1Certificate_type decodeTransactionResponseBody202CertificatesOneOf1Reward_account_path = DecodeTransactionResponseBody202CertificatesOneOf1{decodeTransactionResponseBody202CertificatesOneOf1Certificate_type = decodeTransactionResponseBody202CertificatesOneOf1Certificate_type,
                                                                                                                                                                                                                                                   decodeTransactionResponseBody202CertificatesOneOf1Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                   decodeTransactionResponseBody202CertificatesOneOf1Reward_account_path = decodeTransactionResponseBody202CertificatesOneOf1Reward_account_path}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202CertificatesOneOf1Certificate_type =
   DecodeTransactionResponseBody202CertificatesOneOf1Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | DecodeTransactionResponseBody202CertificatesOneOf1Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | DecodeTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | DecodeTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | DecodeTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CertificatesOneOf1Certificate_type
    where toJSON (DecodeTransactionResponseBody202CertificatesOneOf1Certificate_typeOther val) = val
          toJSON (DecodeTransactionResponseBody202CertificatesOneOf1Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (DecodeTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool) = "join_pool"
          toJSON (DecodeTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (DecodeTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CertificatesOneOf1Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> DecodeTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> DecodeTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> DecodeTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> DecodeTransactionResponseBody202CertificatesOneOf1Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate not belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data DecodeTransactionResponseBody202CertificatesOneOf2 = DecodeTransactionResponseBody202CertificatesOneOf2 {
  -- | certificate_type
  decodeTransactionResponseBody202CertificatesOneOf2Certificate_type :: DecodeTransactionResponseBody202CertificatesOneOf2Certificate_type
  -- | pool: A unique identifier for the pool.
  , decodeTransactionResponseBody202CertificatesOneOf2Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account
  , decodeTransactionResponseBody202CertificatesOneOf2Reward_account :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CertificatesOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf2Reward_account obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf2Reward_account obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CertificatesOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202CertificatesOneOf2" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202CertificatesOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account"))
-- | Create a new 'DecodeTransactionResponseBody202CertificatesOneOf2' with all required fields.
mkDecodeTransactionResponseBody202CertificatesOneOf2 :: DecodeTransactionResponseBody202CertificatesOneOf2Certificate_type -- ^ 'decodeTransactionResponseBody202CertificatesOneOf2Certificate_type'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202CertificatesOneOf2Reward_account'
  -> DecodeTransactionResponseBody202CertificatesOneOf2
mkDecodeTransactionResponseBody202CertificatesOneOf2 decodeTransactionResponseBody202CertificatesOneOf2Certificate_type decodeTransactionResponseBody202CertificatesOneOf2Reward_account = DecodeTransactionResponseBody202CertificatesOneOf2{decodeTransactionResponseBody202CertificatesOneOf2Certificate_type = decodeTransactionResponseBody202CertificatesOneOf2Certificate_type,
                                                                                                                                                                                                                                              decodeTransactionResponseBody202CertificatesOneOf2Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                              decodeTransactionResponseBody202CertificatesOneOf2Reward_account = decodeTransactionResponseBody202CertificatesOneOf2Reward_account}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202CertificatesOneOf2Certificate_type =
   DecodeTransactionResponseBody202CertificatesOneOf2Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | DecodeTransactionResponseBody202CertificatesOneOf2Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | DecodeTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external -- ^ Represents the JSON value @"join_pool_external"@
  | DecodeTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external -- ^ Represents the JSON value @"quit_pool_external"@
  | DecodeTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external -- ^ Represents the JSON value @"register_reward_account_external"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CertificatesOneOf2Certificate_type
    where toJSON (DecodeTransactionResponseBody202CertificatesOneOf2Certificate_typeOther val) = val
          toJSON (DecodeTransactionResponseBody202CertificatesOneOf2Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (DecodeTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external) = "join_pool_external"
          toJSON (DecodeTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external) = "quit_pool_external"
          toJSON (DecodeTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external) = "register_reward_account_external"
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CertificatesOneOf2Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool_external" -> DecodeTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external
                                            | val GHC.Classes.== "quit_pool_external" -> DecodeTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external
                                            | val GHC.Classes.== "register_reward_account_external" -> DecodeTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external
                                            | GHC.Base.otherwise -> DecodeTransactionResponseBody202CertificatesOneOf2Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202CertificatesOneOf3 = DecodeTransactionResponseBody202CertificatesOneOf3 {
  -- | pool_cost: Estimated cost set by the pool operator when registering his pool.
  -- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  decodeTransactionResponseBody202CertificatesOneOf3Pool_cost :: DecodeTransactionResponseBody202CertificatesOneOf3Pool_cost
  -- | pool_id: A unique identifier for the pool.
  , decodeTransactionResponseBody202CertificatesOneOf3Pool_id :: Data.Text.Internal.Text
  -- | pool_margin: Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , decodeTransactionResponseBody202CertificatesOneOf3Pool_margin :: DecodeTransactionResponseBody202CertificatesOneOf3Pool_margin
  -- | pool_metadata
  , decodeTransactionResponseBody202CertificatesOneOf3Pool_metadata :: (GHC.Maybe.Maybe DecodeTransactionResponseBody202CertificatesOneOf3Pool_metadata)
  -- | pool_owners
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , decodeTransactionResponseBody202CertificatesOneOf3Pool_owners :: ([Data.Text.Internal.Text])
  -- | pool_pledge: Minimal stake amount that a stake pool is willing to honor.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , decodeTransactionResponseBody202CertificatesOneOf3Pool_pledge :: DecodeTransactionResponseBody202CertificatesOneOf3Pool_pledge
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CertificatesOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CertificatesOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202CertificatesOneOf3" (\obj -> (((((GHC.Base.pure DecodeTransactionResponseBody202CertificatesOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_cost")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_margin")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool_metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_owners")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_pledge"))
-- | Create a new 'DecodeTransactionResponseBody202CertificatesOneOf3' with all required fields.
mkDecodeTransactionResponseBody202CertificatesOneOf3 :: DecodeTransactionResponseBody202CertificatesOneOf3Pool_cost -- ^ 'decodeTransactionResponseBody202CertificatesOneOf3Pool_cost'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202CertificatesOneOf3Pool_id'
  -> DecodeTransactionResponseBody202CertificatesOneOf3Pool_margin -- ^ 'decodeTransactionResponseBody202CertificatesOneOf3Pool_margin'
  -> [Data.Text.Internal.Text] -- ^ 'decodeTransactionResponseBody202CertificatesOneOf3Pool_owners'
  -> DecodeTransactionResponseBody202CertificatesOneOf3Pool_pledge -- ^ 'decodeTransactionResponseBody202CertificatesOneOf3Pool_pledge'
  -> DecodeTransactionResponseBody202CertificatesOneOf3
mkDecodeTransactionResponseBody202CertificatesOneOf3 decodeTransactionResponseBody202CertificatesOneOf3Pool_cost decodeTransactionResponseBody202CertificatesOneOf3Pool_id decodeTransactionResponseBody202CertificatesOneOf3Pool_margin decodeTransactionResponseBody202CertificatesOneOf3Pool_owners decodeTransactionResponseBody202CertificatesOneOf3Pool_pledge = DecodeTransactionResponseBody202CertificatesOneOf3{decodeTransactionResponseBody202CertificatesOneOf3Pool_cost = decodeTransactionResponseBody202CertificatesOneOf3Pool_cost,
                                                                                                                                                                                                                                                                                                                                                                                                                          decodeTransactionResponseBody202CertificatesOneOf3Pool_id = decodeTransactionResponseBody202CertificatesOneOf3Pool_id,
                                                                                                                                                                                                                                                                                                                                                                                                                          decodeTransactionResponseBody202CertificatesOneOf3Pool_margin = decodeTransactionResponseBody202CertificatesOneOf3Pool_margin,
                                                                                                                                                                                                                                                                                                                                                                                                                          decodeTransactionResponseBody202CertificatesOneOf3Pool_metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                          decodeTransactionResponseBody202CertificatesOneOf3Pool_owners = decodeTransactionResponseBody202CertificatesOneOf3Pool_owners,
                                                                                                                                                                                                                                                                                                                                                                                                                          decodeTransactionResponseBody202CertificatesOneOf3Pool_pledge = decodeTransactionResponseBody202CertificatesOneOf3Pool_pledge}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_cost@ in the specification.
-- 
-- Estimated cost set by the pool operator when registering his pool.
-- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data DecodeTransactionResponseBody202CertificatesOneOf3Pool_cost = DecodeTransactionResponseBody202CertificatesOneOf3Pool_cost {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202CertificatesOneOf3Pool_costQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CertificatesOneOf3Pool_cost
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CertificatesOneOf3Pool_cost
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202CertificatesOneOf3Pool_cost" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202CertificatesOneOf3Pool_cost GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202CertificatesOneOf3Pool_cost' with all required fields.
mkDecodeTransactionResponseBody202CertificatesOneOf3Pool_cost :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202CertificatesOneOf3Pool_costQuantity'
  -> DecodeTransactionResponseBody202CertificatesOneOf3Pool_cost
mkDecodeTransactionResponseBody202CertificatesOneOf3Pool_cost decodeTransactionResponseBody202CertificatesOneOf3Pool_costQuantity = DecodeTransactionResponseBody202CertificatesOneOf3Pool_cost{decodeTransactionResponseBody202CertificatesOneOf3Pool_costQuantity = decodeTransactionResponseBody202CertificatesOneOf3Pool_costQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_margin@ in the specification.
-- 
-- Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data DecodeTransactionResponseBody202CertificatesOneOf3Pool_margin = DecodeTransactionResponseBody202CertificatesOneOf3Pool_margin {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CertificatesOneOf3Pool_margin
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CertificatesOneOf3Pool_margin
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202CertificatesOneOf3Pool_margin" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202CertificatesOneOf3Pool_margin GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202CertificatesOneOf3Pool_margin' with all required fields.
mkDecodeTransactionResponseBody202CertificatesOneOf3Pool_margin :: GHC.Types.Double -- ^ 'decodeTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity'
  -> DecodeTransactionResponseBody202CertificatesOneOf3Pool_margin
mkDecodeTransactionResponseBody202CertificatesOneOf3Pool_margin decodeTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity = DecodeTransactionResponseBody202CertificatesOneOf3Pool_margin{decodeTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity = decodeTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_metadata@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202CertificatesOneOf3Pool_metadata = DecodeTransactionResponseBody202CertificatesOneOf3Pool_metadata {
  -- | hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  decodeTransactionResponseBody202CertificatesOneOf3Pool_metadataHash :: Data.Text.Internal.Text
  -- | url: A URL to the stake pool\'s website.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 250
  -- * Must match pattern \'^https:\/\/.+\'
  , decodeTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CertificatesOneOf3Pool_metadata
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CertificatesOneOf3Pool_metadata
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202CertificatesOneOf3Pool_metadata" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202CertificatesOneOf3Pool_metadata GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))
-- | Create a new 'DecodeTransactionResponseBody202CertificatesOneOf3Pool_metadata' with all required fields.
mkDecodeTransactionResponseBody202CertificatesOneOf3Pool_metadata :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202CertificatesOneOf3Pool_metadataHash'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl'
  -> DecodeTransactionResponseBody202CertificatesOneOf3Pool_metadata
mkDecodeTransactionResponseBody202CertificatesOneOf3Pool_metadata decodeTransactionResponseBody202CertificatesOneOf3Pool_metadataHash decodeTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl = DecodeTransactionResponseBody202CertificatesOneOf3Pool_metadata{decodeTransactionResponseBody202CertificatesOneOf3Pool_metadataHash = decodeTransactionResponseBody202CertificatesOneOf3Pool_metadataHash,
                                                                                                                                                                                                                                                                           decodeTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl = decodeTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_pledge@ in the specification.
-- 
-- Minimal stake amount that a stake pool is willing to honor.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data DecodeTransactionResponseBody202CertificatesOneOf3Pool_pledge = DecodeTransactionResponseBody202CertificatesOneOf3Pool_pledge {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CertificatesOneOf3Pool_pledge
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CertificatesOneOf3Pool_pledge
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202CertificatesOneOf3Pool_pledge" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202CertificatesOneOf3Pool_pledge GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202CertificatesOneOf3Pool_pledge' with all required fields.
mkDecodeTransactionResponseBody202CertificatesOneOf3Pool_pledge :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity'
  -> DecodeTransactionResponseBody202CertificatesOneOf3Pool_pledge
mkDecodeTransactionResponseBody202CertificatesOneOf3Pool_pledge decodeTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity = DecodeTransactionResponseBody202CertificatesOneOf3Pool_pledge{decodeTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity = decodeTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202CertificatesOneOf4 = DecodeTransactionResponseBody202CertificatesOneOf4 {
  -- | pool_id: A unique identifier for the pool.
  decodeTransactionResponseBody202CertificatesOneOf4Pool_id :: Data.Text.Internal.Text
  -- | retirement_epoch: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202CertificatesOneOf4Retirement_epoch :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CertificatesOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CertificatesOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202CertificatesOneOf4" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202CertificatesOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "retirement_epoch"))
-- | Create a new 'DecodeTransactionResponseBody202CertificatesOneOf4' with all required fields.
mkDecodeTransactionResponseBody202CertificatesOneOf4 :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202CertificatesOneOf4Pool_id'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202CertificatesOneOf4Retirement_epoch'
  -> DecodeTransactionResponseBody202CertificatesOneOf4
mkDecodeTransactionResponseBody202CertificatesOneOf4 decodeTransactionResponseBody202CertificatesOneOf4Pool_id decodeTransactionResponseBody202CertificatesOneOf4Retirement_epoch = DecodeTransactionResponseBody202CertificatesOneOf4{decodeTransactionResponseBody202CertificatesOneOf4Pool_id = decodeTransactionResponseBody202CertificatesOneOf4Pool_id,
                                                                                                                                                                                                                                       decodeTransactionResponseBody202CertificatesOneOf4Retirement_epoch = decodeTransactionResponseBody202CertificatesOneOf4Retirement_epoch}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202CertificatesOneOf5 = DecodeTransactionResponseBody202CertificatesOneOf5 {
  -- | certificate_type
  decodeTransactionResponseBody202CertificatesOneOf5Certificate_type :: DecodeTransactionResponseBody202CertificatesOneOf5Certificate_type
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CertificatesOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CertificatesOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202CertificatesOneOf5" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202CertificatesOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type"))
-- | Create a new 'DecodeTransactionResponseBody202CertificatesOneOf5' with all required fields.
mkDecodeTransactionResponseBody202CertificatesOneOf5 :: DecodeTransactionResponseBody202CertificatesOneOf5Certificate_type -- ^ 'decodeTransactionResponseBody202CertificatesOneOf5Certificate_type'
  -> DecodeTransactionResponseBody202CertificatesOneOf5
mkDecodeTransactionResponseBody202CertificatesOneOf5 decodeTransactionResponseBody202CertificatesOneOf5Certificate_type = DecodeTransactionResponseBody202CertificatesOneOf5{decodeTransactionResponseBody202CertificatesOneOf5Certificate_type = decodeTransactionResponseBody202CertificatesOneOf5Certificate_type}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202CertificatesOneOf5Certificate_type =
   DecodeTransactionResponseBody202CertificatesOneOf5Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | DecodeTransactionResponseBody202CertificatesOneOf5Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | DecodeTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumMir -- ^ Represents the JSON value @"mir"@
  | DecodeTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis -- ^ Represents the JSON value @"genesis"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CertificatesOneOf5Certificate_type
    where toJSON (DecodeTransactionResponseBody202CertificatesOneOf5Certificate_typeOther val) = val
          toJSON (DecodeTransactionResponseBody202CertificatesOneOf5Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (DecodeTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumMir) = "mir"
          toJSON (DecodeTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis) = "genesis"
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CertificatesOneOf5Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "mir" -> DecodeTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumMir
                                            | val GHC.Classes.== "genesis" -> DecodeTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis
                                            | GHC.Base.otherwise -> DecodeTransactionResponseBody202CertificatesOneOf5Certificate_typeOther val)
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- Any certificate that could occur in an arbitrary transaction:
-- might be related to delegation, pool activities, genesis or MIR.
data DecodeTransactionResponseBody202CertificatesVariants =
   DecodeTransactionResponseBody202CertificatesVariant1 DecodeTransactionResponseBody202CertificatesOneOf1
  | DecodeTransactionResponseBody202CertificatesVariant2 DecodeTransactionResponseBody202CertificatesOneOf2
  | DecodeTransactionResponseBody202CertificatesVariant3 DecodeTransactionResponseBody202CertificatesOneOf3
  | DecodeTransactionResponseBody202CertificatesVariant4 DecodeTransactionResponseBody202CertificatesOneOf4
  | DecodeTransactionResponseBody202CertificatesVariant5 DecodeTransactionResponseBody202CertificatesOneOf5
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CertificatesVariants
    where toJSON (DecodeTransactionResponseBody202CertificatesVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202CertificatesVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202CertificatesVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202CertificatesVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202CertificatesVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CertificatesVariants
    where parseJSON val = case (DecodeTransactionResponseBody202CertificatesVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202CertificatesVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202CertificatesVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202CertificatesVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202CertificatesVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.collateral.items.oneOf@ in the specification.
-- 
-- A transaction input not belonging to a given wallet.
data DecodeTransactionResponseBody202CollateralOneOf1 = DecodeTransactionResponseBody202CollateralOneOf1 {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  decodeTransactionResponseBody202CollateralOneOf1Id :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202CollateralOneOf1Index :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CollateralOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf1Id obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf1Index obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf1Id obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf1Index obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CollateralOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202CollateralOneOf1" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202CollateralOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'DecodeTransactionResponseBody202CollateralOneOf1' with all required fields.
mkDecodeTransactionResponseBody202CollateralOneOf1 :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202CollateralOneOf1Id'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202CollateralOneOf1Index'
  -> DecodeTransactionResponseBody202CollateralOneOf1
mkDecodeTransactionResponseBody202CollateralOneOf1 decodeTransactionResponseBody202CollateralOneOf1Id decodeTransactionResponseBody202CollateralOneOf1Index = DecodeTransactionResponseBody202CollateralOneOf1{decodeTransactionResponseBody202CollateralOneOf1Id = decodeTransactionResponseBody202CollateralOneOf1Id,
                                                                                                                                                                                                               decodeTransactionResponseBody202CollateralOneOf1Index = decodeTransactionResponseBody202CollateralOneOf1Index}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.collateral.items.oneOf@ in the specification.
-- 
-- A transaction input belonging to a given wallet.
data DecodeTransactionResponseBody202CollateralOneOf2 = DecodeTransactionResponseBody202CollateralOneOf2 {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  decodeTransactionResponseBody202CollateralOneOf2Address :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , decodeTransactionResponseBody202CollateralOneOf2Amount :: DecodeTransactionResponseBody202CollateralOneOf2Amount
  -- | assets: A flat list of assets (possibly empty).
  , decodeTransactionResponseBody202CollateralOneOf2Assets :: (GHC.Maybe.Maybe ([DecodeTransactionResponseBody202CollateralOneOf2Assets]))
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , decodeTransactionResponseBody202CollateralOneOf2Derivation_path :: ([Data.Text.Internal.Text])
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , decodeTransactionResponseBody202CollateralOneOf2Id :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202CollateralOneOf2Index :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CollateralOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2Address obj] : ["amount" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202CollateralOneOf2Assets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2Derivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2Id obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2Index obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2Address obj] : ["amount" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202CollateralOneOf2Assets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2Derivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2Id obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2Index obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CollateralOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202CollateralOneOf2" (\obj -> (((((GHC.Base.pure DecodeTransactionResponseBody202CollateralOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'DecodeTransactionResponseBody202CollateralOneOf2' with all required fields.
mkDecodeTransactionResponseBody202CollateralOneOf2 :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202CollateralOneOf2Address'
  -> DecodeTransactionResponseBody202CollateralOneOf2Amount -- ^ 'decodeTransactionResponseBody202CollateralOneOf2Amount'
  -> [Data.Text.Internal.Text] -- ^ 'decodeTransactionResponseBody202CollateralOneOf2Derivation_path'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202CollateralOneOf2Id'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202CollateralOneOf2Index'
  -> DecodeTransactionResponseBody202CollateralOneOf2
mkDecodeTransactionResponseBody202CollateralOneOf2 decodeTransactionResponseBody202CollateralOneOf2Address decodeTransactionResponseBody202CollateralOneOf2Amount decodeTransactionResponseBody202CollateralOneOf2Derivation_path decodeTransactionResponseBody202CollateralOneOf2Id decodeTransactionResponseBody202CollateralOneOf2Index = DecodeTransactionResponseBody202CollateralOneOf2{decodeTransactionResponseBody202CollateralOneOf2Address = decodeTransactionResponseBody202CollateralOneOf2Address,
                                                                                                                                                                                                                                                                                                                                                                                              decodeTransactionResponseBody202CollateralOneOf2Amount = decodeTransactionResponseBody202CollateralOneOf2Amount,
                                                                                                                                                                                                                                                                                                                                                                                              decodeTransactionResponseBody202CollateralOneOf2Assets = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                              decodeTransactionResponseBody202CollateralOneOf2Derivation_path = decodeTransactionResponseBody202CollateralOneOf2Derivation_path,
                                                                                                                                                                                                                                                                                                                                                                                              decodeTransactionResponseBody202CollateralOneOf2Id = decodeTransactionResponseBody202CollateralOneOf2Id,
                                                                                                                                                                                                                                                                                                                                                                                              decodeTransactionResponseBody202CollateralOneOf2Index = decodeTransactionResponseBody202CollateralOneOf2Index}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.collateral.items.oneOf.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data DecodeTransactionResponseBody202CollateralOneOf2Amount = DecodeTransactionResponseBody202CollateralOneOf2Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202CollateralOneOf2AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CollateralOneOf2Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CollateralOneOf2Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202CollateralOneOf2Amount" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202CollateralOneOf2Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202CollateralOneOf2Amount' with all required fields.
mkDecodeTransactionResponseBody202CollateralOneOf2Amount :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202CollateralOneOf2AmountQuantity'
  -> DecodeTransactionResponseBody202CollateralOneOf2Amount
mkDecodeTransactionResponseBody202CollateralOneOf2Amount decodeTransactionResponseBody202CollateralOneOf2AmountQuantity = DecodeTransactionResponseBody202CollateralOneOf2Amount{decodeTransactionResponseBody202CollateralOneOf2AmountQuantity = decodeTransactionResponseBody202CollateralOneOf2AmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.collateral.items.oneOf.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data DecodeTransactionResponseBody202CollateralOneOf2Assets = DecodeTransactionResponseBody202CollateralOneOf2Assets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  decodeTransactionResponseBody202CollateralOneOf2AssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , decodeTransactionResponseBody202CollateralOneOf2AssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202CollateralOneOf2AssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CollateralOneOf2Assets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2AssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2AssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2AssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2AssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2AssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202CollateralOneOf2AssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CollateralOneOf2Assets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202CollateralOneOf2Assets" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202CollateralOneOf2Assets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202CollateralOneOf2Assets' with all required fields.
mkDecodeTransactionResponseBody202CollateralOneOf2Assets :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202CollateralOneOf2AssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202CollateralOneOf2AssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202CollateralOneOf2AssetsQuantity'
  -> DecodeTransactionResponseBody202CollateralOneOf2Assets
mkDecodeTransactionResponseBody202CollateralOneOf2Assets decodeTransactionResponseBody202CollateralOneOf2AssetsAsset_name decodeTransactionResponseBody202CollateralOneOf2AssetsPolicy_id decodeTransactionResponseBody202CollateralOneOf2AssetsQuantity = DecodeTransactionResponseBody202CollateralOneOf2Assets{decodeTransactionResponseBody202CollateralOneOf2AssetsAsset_name = decodeTransactionResponseBody202CollateralOneOf2AssetsAsset_name,
                                                                                                                                                                                                                                                                                                                  decodeTransactionResponseBody202CollateralOneOf2AssetsPolicy_id = decodeTransactionResponseBody202CollateralOneOf2AssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                  decodeTransactionResponseBody202CollateralOneOf2AssetsQuantity = decodeTransactionResponseBody202CollateralOneOf2AssetsQuantity}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.collateral.items.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202CollateralVariants =
   DecodeTransactionResponseBody202CollateralVariant1 DecodeTransactionResponseBody202CollateralOneOf1
  | DecodeTransactionResponseBody202CollateralVariant2 DecodeTransactionResponseBody202CollateralOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202CollateralVariants
    where toJSON (DecodeTransactionResponseBody202CollateralVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202CollateralVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202CollateralVariants
    where parseJSON val = case (DecodeTransactionResponseBody202CollateralVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202CollateralVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.collateral_outputs.items.oneOf@ in the specification.
-- 
-- A transaction output not belonging to the wallet
data DecodeTransactionResponseBody202Collateral_outputsOneOf1 = DecodeTransactionResponseBody202Collateral_outputsOneOf1 {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  decodeTransactionResponseBody202Collateral_outputsOneOf1Address :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , decodeTransactionResponseBody202Collateral_outputsOneOf1Amount :: DecodeTransactionResponseBody202Collateral_outputsOneOf1Amount
  -- | assets: A flat list of assets (possibly empty).
  , decodeTransactionResponseBody202Collateral_outputsOneOf1Assets :: (GHC.Maybe.Maybe ([DecodeTransactionResponseBody202Collateral_outputsOneOf1Assets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Collateral_outputsOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf1Address obj] : ["amount" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf1Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Collateral_outputsOneOf1Assets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf1Address obj] : ["amount" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf1Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Collateral_outputsOneOf1Assets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Collateral_outputsOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Collateral_outputsOneOf1" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202Collateral_outputsOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'DecodeTransactionResponseBody202Collateral_outputsOneOf1' with all required fields.
mkDecodeTransactionResponseBody202Collateral_outputsOneOf1 :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202Collateral_outputsOneOf1Address'
  -> DecodeTransactionResponseBody202Collateral_outputsOneOf1Amount -- ^ 'decodeTransactionResponseBody202Collateral_outputsOneOf1Amount'
  -> DecodeTransactionResponseBody202Collateral_outputsOneOf1
mkDecodeTransactionResponseBody202Collateral_outputsOneOf1 decodeTransactionResponseBody202Collateral_outputsOneOf1Address decodeTransactionResponseBody202Collateral_outputsOneOf1Amount = DecodeTransactionResponseBody202Collateral_outputsOneOf1{decodeTransactionResponseBody202Collateral_outputsOneOf1Address = decodeTransactionResponseBody202Collateral_outputsOneOf1Address,
                                                                                                                                                                                                                                                     decodeTransactionResponseBody202Collateral_outputsOneOf1Amount = decodeTransactionResponseBody202Collateral_outputsOneOf1Amount,
                                                                                                                                                                                                                                                     decodeTransactionResponseBody202Collateral_outputsOneOf1Assets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.collateral_outputs.items.oneOf.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data DecodeTransactionResponseBody202Collateral_outputsOneOf1Amount = DecodeTransactionResponseBody202Collateral_outputsOneOf1Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202Collateral_outputsOneOf1AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Collateral_outputsOneOf1Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf1AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf1AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Collateral_outputsOneOf1Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Collateral_outputsOneOf1Amount" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202Collateral_outputsOneOf1Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202Collateral_outputsOneOf1Amount' with all required fields.
mkDecodeTransactionResponseBody202Collateral_outputsOneOf1Amount :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202Collateral_outputsOneOf1AmountQuantity'
  -> DecodeTransactionResponseBody202Collateral_outputsOneOf1Amount
mkDecodeTransactionResponseBody202Collateral_outputsOneOf1Amount decodeTransactionResponseBody202Collateral_outputsOneOf1AmountQuantity = DecodeTransactionResponseBody202Collateral_outputsOneOf1Amount{decodeTransactionResponseBody202Collateral_outputsOneOf1AmountQuantity = decodeTransactionResponseBody202Collateral_outputsOneOf1AmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.collateral_outputs.items.oneOf.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data DecodeTransactionResponseBody202Collateral_outputsOneOf1Assets = DecodeTransactionResponseBody202Collateral_outputsOneOf1Assets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Collateral_outputsOneOf1Assets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Collateral_outputsOneOf1Assets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Collateral_outputsOneOf1Assets" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202Collateral_outputsOneOf1Assets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202Collateral_outputsOneOf1Assets' with all required fields.
mkDecodeTransactionResponseBody202Collateral_outputsOneOf1Assets :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsQuantity'
  -> DecodeTransactionResponseBody202Collateral_outputsOneOf1Assets
mkDecodeTransactionResponseBody202Collateral_outputsOneOf1Assets decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsAsset_name decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsPolicy_id decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsQuantity = DecodeTransactionResponseBody202Collateral_outputsOneOf1Assets{decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsAsset_name = decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                                          decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsPolicy_id = decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                                          decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsQuantity = decodeTransactionResponseBody202Collateral_outputsOneOf1AssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.collateral_outputs.items.oneOf@ in the specification.
-- 
-- A transaction output not belonging to the wallet
data DecodeTransactionResponseBody202Collateral_outputsOneOf2 = DecodeTransactionResponseBody202Collateral_outputsOneOf2 {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  decodeTransactionResponseBody202Collateral_outputsOneOf2Address :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , decodeTransactionResponseBody202Collateral_outputsOneOf2Amount :: DecodeTransactionResponseBody202Collateral_outputsOneOf2Amount
  -- | assets: A flat list of assets (possibly empty).
  , decodeTransactionResponseBody202Collateral_outputsOneOf2Assets :: (GHC.Maybe.Maybe ([DecodeTransactionResponseBody202Collateral_outputsOneOf2Assets]))
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , decodeTransactionResponseBody202Collateral_outputsOneOf2Derivation_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Collateral_outputsOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf2Address obj] : ["amount" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf2Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Collateral_outputsOneOf2Assets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf2Derivation_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf2Address obj] : ["amount" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf2Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Collateral_outputsOneOf2Assets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf2Derivation_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Collateral_outputsOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Collateral_outputsOneOf2" (\obj -> (((GHC.Base.pure DecodeTransactionResponseBody202Collateral_outputsOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path"))
-- | Create a new 'DecodeTransactionResponseBody202Collateral_outputsOneOf2' with all required fields.
mkDecodeTransactionResponseBody202Collateral_outputsOneOf2 :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202Collateral_outputsOneOf2Address'
  -> DecodeTransactionResponseBody202Collateral_outputsOneOf2Amount -- ^ 'decodeTransactionResponseBody202Collateral_outputsOneOf2Amount'
  -> [Data.Text.Internal.Text] -- ^ 'decodeTransactionResponseBody202Collateral_outputsOneOf2Derivation_path'
  -> DecodeTransactionResponseBody202Collateral_outputsOneOf2
mkDecodeTransactionResponseBody202Collateral_outputsOneOf2 decodeTransactionResponseBody202Collateral_outputsOneOf2Address decodeTransactionResponseBody202Collateral_outputsOneOf2Amount decodeTransactionResponseBody202Collateral_outputsOneOf2Derivation_path = DecodeTransactionResponseBody202Collateral_outputsOneOf2{decodeTransactionResponseBody202Collateral_outputsOneOf2Address = decodeTransactionResponseBody202Collateral_outputsOneOf2Address,
                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Collateral_outputsOneOf2Amount = decodeTransactionResponseBody202Collateral_outputsOneOf2Amount,
                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Collateral_outputsOneOf2Assets = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                             decodeTransactionResponseBody202Collateral_outputsOneOf2Derivation_path = decodeTransactionResponseBody202Collateral_outputsOneOf2Derivation_path}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.collateral_outputs.items.oneOf.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data DecodeTransactionResponseBody202Collateral_outputsOneOf2Amount = DecodeTransactionResponseBody202Collateral_outputsOneOf2Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202Collateral_outputsOneOf2AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Collateral_outputsOneOf2Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf2AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf2AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Collateral_outputsOneOf2Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Collateral_outputsOneOf2Amount" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202Collateral_outputsOneOf2Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202Collateral_outputsOneOf2Amount' with all required fields.
mkDecodeTransactionResponseBody202Collateral_outputsOneOf2Amount :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202Collateral_outputsOneOf2AmountQuantity'
  -> DecodeTransactionResponseBody202Collateral_outputsOneOf2Amount
mkDecodeTransactionResponseBody202Collateral_outputsOneOf2Amount decodeTransactionResponseBody202Collateral_outputsOneOf2AmountQuantity = DecodeTransactionResponseBody202Collateral_outputsOneOf2Amount{decodeTransactionResponseBody202Collateral_outputsOneOf2AmountQuantity = decodeTransactionResponseBody202Collateral_outputsOneOf2AmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.collateral_outputs.items.oneOf.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data DecodeTransactionResponseBody202Collateral_outputsOneOf2Assets = DecodeTransactionResponseBody202Collateral_outputsOneOf2Assets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Collateral_outputsOneOf2Assets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Collateral_outputsOneOf2Assets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Collateral_outputsOneOf2Assets" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202Collateral_outputsOneOf2Assets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202Collateral_outputsOneOf2Assets' with all required fields.
mkDecodeTransactionResponseBody202Collateral_outputsOneOf2Assets :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsQuantity'
  -> DecodeTransactionResponseBody202Collateral_outputsOneOf2Assets
mkDecodeTransactionResponseBody202Collateral_outputsOneOf2Assets decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsAsset_name decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsPolicy_id decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsQuantity = DecodeTransactionResponseBody202Collateral_outputsOneOf2Assets{decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsAsset_name = decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                                          decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsPolicy_id = decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                                          decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsQuantity = decodeTransactionResponseBody202Collateral_outputsOneOf2AssetsQuantity}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.collateral_outputs.items.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Collateral_outputsVariants =
   DecodeTransactionResponseBody202Collateral_outputsVariant1 DecodeTransactionResponseBody202Collateral_outputsOneOf1
  | DecodeTransactionResponseBody202Collateral_outputsVariant2 DecodeTransactionResponseBody202Collateral_outputsOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Collateral_outputsVariants
    where toJSON (DecodeTransactionResponseBody202Collateral_outputsVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202Collateral_outputsVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Collateral_outputsVariants
    where parseJSON val = case (DecodeTransactionResponseBody202Collateral_outputsVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202Collateral_outputsVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.deposits_returned.items@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data DecodeTransactionResponseBody202Deposits_returned = DecodeTransactionResponseBody202Deposits_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202Deposits_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Deposits_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Deposits_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Deposits_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Deposits_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Deposits_returned" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202Deposits_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202Deposits_returned' with all required fields.
mkDecodeTransactionResponseBody202Deposits_returned :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202Deposits_returnedQuantity'
  -> DecodeTransactionResponseBody202Deposits_returned
mkDecodeTransactionResponseBody202Deposits_returned decodeTransactionResponseBody202Deposits_returnedQuantity = DecodeTransactionResponseBody202Deposits_returned{decodeTransactionResponseBody202Deposits_returnedQuantity = decodeTransactionResponseBody202Deposits_returnedQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.deposits_taken.items@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data DecodeTransactionResponseBody202Deposits_taken = DecodeTransactionResponseBody202Deposits_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202Deposits_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Deposits_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Deposits_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Deposits_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Deposits_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Deposits_taken" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202Deposits_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202Deposits_taken' with all required fields.
mkDecodeTransactionResponseBody202Deposits_taken :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202Deposits_takenQuantity'
  -> DecodeTransactionResponseBody202Deposits_taken
mkDecodeTransactionResponseBody202Deposits_taken decodeTransactionResponseBody202Deposits_takenQuantity = DecodeTransactionResponseBody202Deposits_taken{decodeTransactionResponseBody202Deposits_takenQuantity = decodeTransactionResponseBody202Deposits_takenQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.fee@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data DecodeTransactionResponseBody202Fee = DecodeTransactionResponseBody202Fee {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202FeeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Fee
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Fee
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Fee" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202Fee GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202Fee' with all required fields.
mkDecodeTransactionResponseBody202Fee :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202FeeQuantity'
  -> DecodeTransactionResponseBody202Fee
mkDecodeTransactionResponseBody202Fee decodeTransactionResponseBody202FeeQuantity = DecodeTransactionResponseBody202Fee{decodeTransactionResponseBody202FeeQuantity = decodeTransactionResponseBody202FeeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.inputs.items.oneOf@ in the specification.
-- 
-- A transaction input not belonging to a given wallet.
data DecodeTransactionResponseBody202InputsOneOf1 = DecodeTransactionResponseBody202InputsOneOf1 {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  decodeTransactionResponseBody202InputsOneOf1Id :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202InputsOneOf1Index :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202InputsOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf1Id obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf1Index obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf1Id obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf1Index obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202InputsOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202InputsOneOf1" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202InputsOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'DecodeTransactionResponseBody202InputsOneOf1' with all required fields.
mkDecodeTransactionResponseBody202InputsOneOf1 :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202InputsOneOf1Id'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202InputsOneOf1Index'
  -> DecodeTransactionResponseBody202InputsOneOf1
mkDecodeTransactionResponseBody202InputsOneOf1 decodeTransactionResponseBody202InputsOneOf1Id decodeTransactionResponseBody202InputsOneOf1Index = DecodeTransactionResponseBody202InputsOneOf1{decodeTransactionResponseBody202InputsOneOf1Id = decodeTransactionResponseBody202InputsOneOf1Id,
                                                                                                                                                                                               decodeTransactionResponseBody202InputsOneOf1Index = decodeTransactionResponseBody202InputsOneOf1Index}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.inputs.items.oneOf@ in the specification.
-- 
-- A transaction input belonging to a given wallet.
data DecodeTransactionResponseBody202InputsOneOf2 = DecodeTransactionResponseBody202InputsOneOf2 {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  decodeTransactionResponseBody202InputsOneOf2Address :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , decodeTransactionResponseBody202InputsOneOf2Amount :: DecodeTransactionResponseBody202InputsOneOf2Amount
  -- | assets: A flat list of assets (possibly empty).
  , decodeTransactionResponseBody202InputsOneOf2Assets :: (GHC.Maybe.Maybe ([DecodeTransactionResponseBody202InputsOneOf2Assets]))
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , decodeTransactionResponseBody202InputsOneOf2Derivation_path :: ([Data.Text.Internal.Text])
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , decodeTransactionResponseBody202InputsOneOf2Id :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202InputsOneOf2Index :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202InputsOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2Address obj] : ["amount" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202InputsOneOf2Assets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2Derivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2Id obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2Index obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2Address obj] : ["amount" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202InputsOneOf2Assets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2Derivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2Id obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2Index obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202InputsOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202InputsOneOf2" (\obj -> (((((GHC.Base.pure DecodeTransactionResponseBody202InputsOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'DecodeTransactionResponseBody202InputsOneOf2' with all required fields.
mkDecodeTransactionResponseBody202InputsOneOf2 :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202InputsOneOf2Address'
  -> DecodeTransactionResponseBody202InputsOneOf2Amount -- ^ 'decodeTransactionResponseBody202InputsOneOf2Amount'
  -> [Data.Text.Internal.Text] -- ^ 'decodeTransactionResponseBody202InputsOneOf2Derivation_path'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202InputsOneOf2Id'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202InputsOneOf2Index'
  -> DecodeTransactionResponseBody202InputsOneOf2
mkDecodeTransactionResponseBody202InputsOneOf2 decodeTransactionResponseBody202InputsOneOf2Address decodeTransactionResponseBody202InputsOneOf2Amount decodeTransactionResponseBody202InputsOneOf2Derivation_path decodeTransactionResponseBody202InputsOneOf2Id decodeTransactionResponseBody202InputsOneOf2Index = DecodeTransactionResponseBody202InputsOneOf2{decodeTransactionResponseBody202InputsOneOf2Address = decodeTransactionResponseBody202InputsOneOf2Address,
                                                                                                                                                                                                                                                                                                                                                                  decodeTransactionResponseBody202InputsOneOf2Amount = decodeTransactionResponseBody202InputsOneOf2Amount,
                                                                                                                                                                                                                                                                                                                                                                  decodeTransactionResponseBody202InputsOneOf2Assets = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                  decodeTransactionResponseBody202InputsOneOf2Derivation_path = decodeTransactionResponseBody202InputsOneOf2Derivation_path,
                                                                                                                                                                                                                                                                                                                                                                  decodeTransactionResponseBody202InputsOneOf2Id = decodeTransactionResponseBody202InputsOneOf2Id,
                                                                                                                                                                                                                                                                                                                                                                  decodeTransactionResponseBody202InputsOneOf2Index = decodeTransactionResponseBody202InputsOneOf2Index}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.inputs.items.oneOf.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data DecodeTransactionResponseBody202InputsOneOf2Amount = DecodeTransactionResponseBody202InputsOneOf2Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202InputsOneOf2AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202InputsOneOf2Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202InputsOneOf2Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202InputsOneOf2Amount" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202InputsOneOf2Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202InputsOneOf2Amount' with all required fields.
mkDecodeTransactionResponseBody202InputsOneOf2Amount :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202InputsOneOf2AmountQuantity'
  -> DecodeTransactionResponseBody202InputsOneOf2Amount
mkDecodeTransactionResponseBody202InputsOneOf2Amount decodeTransactionResponseBody202InputsOneOf2AmountQuantity = DecodeTransactionResponseBody202InputsOneOf2Amount{decodeTransactionResponseBody202InputsOneOf2AmountQuantity = decodeTransactionResponseBody202InputsOneOf2AmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.inputs.items.oneOf.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data DecodeTransactionResponseBody202InputsOneOf2Assets = DecodeTransactionResponseBody202InputsOneOf2Assets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  decodeTransactionResponseBody202InputsOneOf2AssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , decodeTransactionResponseBody202InputsOneOf2AssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202InputsOneOf2AssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202InputsOneOf2Assets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2AssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2AssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2AssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2AssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2AssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202InputsOneOf2AssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202InputsOneOf2Assets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202InputsOneOf2Assets" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202InputsOneOf2Assets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202InputsOneOf2Assets' with all required fields.
mkDecodeTransactionResponseBody202InputsOneOf2Assets :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202InputsOneOf2AssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202InputsOneOf2AssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202InputsOneOf2AssetsQuantity'
  -> DecodeTransactionResponseBody202InputsOneOf2Assets
mkDecodeTransactionResponseBody202InputsOneOf2Assets decodeTransactionResponseBody202InputsOneOf2AssetsAsset_name decodeTransactionResponseBody202InputsOneOf2AssetsPolicy_id decodeTransactionResponseBody202InputsOneOf2AssetsQuantity = DecodeTransactionResponseBody202InputsOneOf2Assets{decodeTransactionResponseBody202InputsOneOf2AssetsAsset_name = decodeTransactionResponseBody202InputsOneOf2AssetsAsset_name,
                                                                                                                                                                                                                                                                                              decodeTransactionResponseBody202InputsOneOf2AssetsPolicy_id = decodeTransactionResponseBody202InputsOneOf2AssetsPolicy_id,
                                                                                                                                                                                                                                                                                              decodeTransactionResponseBody202InputsOneOf2AssetsQuantity = decodeTransactionResponseBody202InputsOneOf2AssetsQuantity}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.inputs.items.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202InputsVariants =
   DecodeTransactionResponseBody202InputsVariant1 DecodeTransactionResponseBody202InputsOneOf1
  | DecodeTransactionResponseBody202InputsVariant2 DecodeTransactionResponseBody202InputsOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202InputsVariants
    where toJSON (DecodeTransactionResponseBody202InputsVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202InputsVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202InputsVariants
    where parseJSON val = case (DecodeTransactionResponseBody202InputsVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202InputsVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Mint = DecodeTransactionResponseBody202Mint {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  decodeTransactionResponseBody202MintTokens :: ([DecodeTransactionResponseBody202MintTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , decodeTransactionResponseBody202MintWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , decodeTransactionResponseBody202MintWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Mint
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202MintWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202MintWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Mint
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Mint" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202Mint GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'DecodeTransactionResponseBody202Mint' with all required fields.
mkDecodeTransactionResponseBody202Mint :: [DecodeTransactionResponseBody202MintTokens] -- ^ 'decodeTransactionResponseBody202MintTokens'
  -> DecodeTransactionResponseBody202Mint
mkDecodeTransactionResponseBody202Mint decodeTransactionResponseBody202MintTokens = DecodeTransactionResponseBody202Mint{decodeTransactionResponseBody202MintTokens = decodeTransactionResponseBody202MintTokens,
                                                                                                                         decodeTransactionResponseBody202MintWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                         decodeTransactionResponseBody202MintWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202MintTokens = DecodeTransactionResponseBody202MintTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  decodeTransactionResponseBody202MintTokensAssets :: ([DecodeTransactionResponseBody202MintTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , decodeTransactionResponseBody202MintTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , decodeTransactionResponseBody202MintTokensPolicy_script :: DecodeTransactionResponseBody202MintTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202MintTokens" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202MintTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'DecodeTransactionResponseBody202MintTokens' with all required fields.
mkDecodeTransactionResponseBody202MintTokens :: [DecodeTransactionResponseBody202MintTokensAssets] -- ^ 'decodeTransactionResponseBody202MintTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_id'
  -> DecodeTransactionResponseBody202MintTokensPolicy_scriptVariants -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_script'
  -> DecodeTransactionResponseBody202MintTokens
mkDecodeTransactionResponseBody202MintTokens decodeTransactionResponseBody202MintTokensAssets decodeTransactionResponseBody202MintTokensPolicy_id decodeTransactionResponseBody202MintTokensPolicy_script = DecodeTransactionResponseBody202MintTokens{decodeTransactionResponseBody202MintTokensAssets = decodeTransactionResponseBody202MintTokensAssets,
                                                                                                                                                                                                                                                       decodeTransactionResponseBody202MintTokensPolicy_id = decodeTransactionResponseBody202MintTokensPolicy_id,
                                                                                                                                                                                                                                                       decodeTransactionResponseBody202MintTokensPolicy_script = decodeTransactionResponseBody202MintTokensPolicy_script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202MintTokensAssets = DecodeTransactionResponseBody202MintTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  decodeTransactionResponseBody202MintTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , decodeTransactionResponseBody202MintTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202MintTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202MintTokensAssets" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202MintTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202MintTokensAssets' with all required fields.
mkDecodeTransactionResponseBody202MintTokensAssets :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202MintTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202MintTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202MintTokensAssetsQuantity'
  -> DecodeTransactionResponseBody202MintTokensAssets
mkDecodeTransactionResponseBody202MintTokensAssets decodeTransactionResponseBody202MintTokensAssetsAsset_name decodeTransactionResponseBody202MintTokensAssetsFingerprint decodeTransactionResponseBody202MintTokensAssetsQuantity = DecodeTransactionResponseBody202MintTokensAssets{decodeTransactionResponseBody202MintTokensAssetsAsset_name = decodeTransactionResponseBody202MintTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                      decodeTransactionResponseBody202MintTokensAssetsFingerprint = decodeTransactionResponseBody202MintTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                      decodeTransactionResponseBody202MintTokensAssetsQuantity = decodeTransactionResponseBody202MintTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1 = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference)
  -- | script
  , decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script :: DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1' with all required fields.
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1 :: DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script'
  -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1 decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1{decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                    decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference' with all required fields.
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex'
  -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference{decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                       decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2{decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3{decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 :: DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4{decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some{decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                        decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5{decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6{decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants =
   DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
  | DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
  | DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
  | DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
  | DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2 = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info :: DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2' with all required fields.
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2 :: DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info'
  -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2 decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2{decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                         decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference' with all required fields.
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex'
  -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference{decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                       decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version :: DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info :: DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info{decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                                   decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3 = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References :: ([DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3' with all required fields.
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3 :: [DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References] -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash'
  -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3 decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3{decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                                 decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References' with all required fields.
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex'
  -> DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References
mkDecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex = DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3References{decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                           decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex = decodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202MintTokensPolicy_scriptVariants =
   DecodeTransactionResponseBody202MintTokensPolicy_scriptVariant1 DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf1
  | DecodeTransactionResponseBody202MintTokensPolicy_scriptVariant2 DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf2
  | DecodeTransactionResponseBody202MintTokensPolicy_scriptVariant3 DecodeTransactionResponseBody202MintTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptVariants
    where toJSON (DecodeTransactionResponseBody202MintTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202MintTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202MintTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202MintTokensPolicy_scriptVariants
    where parseJSON val = case (DecodeTransactionResponseBody202MintTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202MintTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202MintTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.outputs.items.oneOf@ in the specification.
-- 
-- A transaction output not belonging to the wallet
data DecodeTransactionResponseBody202OutputsOneOf1 = DecodeTransactionResponseBody202OutputsOneOf1 {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  decodeTransactionResponseBody202OutputsOneOf1Address :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , decodeTransactionResponseBody202OutputsOneOf1Amount :: DecodeTransactionResponseBody202OutputsOneOf1Amount
  -- | assets: A flat list of assets (possibly empty).
  , decodeTransactionResponseBody202OutputsOneOf1Assets :: (GHC.Maybe.Maybe ([DecodeTransactionResponseBody202OutputsOneOf1Assets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202OutputsOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf1Address obj] : ["amount" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf1Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202OutputsOneOf1Assets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf1Address obj] : ["amount" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf1Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202OutputsOneOf1Assets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202OutputsOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202OutputsOneOf1" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202OutputsOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'DecodeTransactionResponseBody202OutputsOneOf1' with all required fields.
mkDecodeTransactionResponseBody202OutputsOneOf1 :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202OutputsOneOf1Address'
  -> DecodeTransactionResponseBody202OutputsOneOf1Amount -- ^ 'decodeTransactionResponseBody202OutputsOneOf1Amount'
  -> DecodeTransactionResponseBody202OutputsOneOf1
mkDecodeTransactionResponseBody202OutputsOneOf1 decodeTransactionResponseBody202OutputsOneOf1Address decodeTransactionResponseBody202OutputsOneOf1Amount = DecodeTransactionResponseBody202OutputsOneOf1{decodeTransactionResponseBody202OutputsOneOf1Address = decodeTransactionResponseBody202OutputsOneOf1Address,
                                                                                                                                                                                                         decodeTransactionResponseBody202OutputsOneOf1Amount = decodeTransactionResponseBody202OutputsOneOf1Amount,
                                                                                                                                                                                                         decodeTransactionResponseBody202OutputsOneOf1Assets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.outputs.items.oneOf.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data DecodeTransactionResponseBody202OutputsOneOf1Amount = DecodeTransactionResponseBody202OutputsOneOf1Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202OutputsOneOf1AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202OutputsOneOf1Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf1AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf1AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202OutputsOneOf1Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202OutputsOneOf1Amount" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202OutputsOneOf1Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202OutputsOneOf1Amount' with all required fields.
mkDecodeTransactionResponseBody202OutputsOneOf1Amount :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202OutputsOneOf1AmountQuantity'
  -> DecodeTransactionResponseBody202OutputsOneOf1Amount
mkDecodeTransactionResponseBody202OutputsOneOf1Amount decodeTransactionResponseBody202OutputsOneOf1AmountQuantity = DecodeTransactionResponseBody202OutputsOneOf1Amount{decodeTransactionResponseBody202OutputsOneOf1AmountQuantity = decodeTransactionResponseBody202OutputsOneOf1AmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.outputs.items.oneOf.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data DecodeTransactionResponseBody202OutputsOneOf1Assets = DecodeTransactionResponseBody202OutputsOneOf1Assets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  decodeTransactionResponseBody202OutputsOneOf1AssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , decodeTransactionResponseBody202OutputsOneOf1AssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202OutputsOneOf1AssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202OutputsOneOf1Assets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf1AssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf1AssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf1AssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf1AssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf1AssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf1AssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202OutputsOneOf1Assets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202OutputsOneOf1Assets" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202OutputsOneOf1Assets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202OutputsOneOf1Assets' with all required fields.
mkDecodeTransactionResponseBody202OutputsOneOf1Assets :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202OutputsOneOf1AssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202OutputsOneOf1AssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202OutputsOneOf1AssetsQuantity'
  -> DecodeTransactionResponseBody202OutputsOneOf1Assets
mkDecodeTransactionResponseBody202OutputsOneOf1Assets decodeTransactionResponseBody202OutputsOneOf1AssetsAsset_name decodeTransactionResponseBody202OutputsOneOf1AssetsPolicy_id decodeTransactionResponseBody202OutputsOneOf1AssetsQuantity = DecodeTransactionResponseBody202OutputsOneOf1Assets{decodeTransactionResponseBody202OutputsOneOf1AssetsAsset_name = decodeTransactionResponseBody202OutputsOneOf1AssetsAsset_name,
                                                                                                                                                                                                                                                                                                   decodeTransactionResponseBody202OutputsOneOf1AssetsPolicy_id = decodeTransactionResponseBody202OutputsOneOf1AssetsPolicy_id,
                                                                                                                                                                                                                                                                                                   decodeTransactionResponseBody202OutputsOneOf1AssetsQuantity = decodeTransactionResponseBody202OutputsOneOf1AssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.outputs.items.oneOf@ in the specification.
-- 
-- A transaction output not belonging to the wallet
data DecodeTransactionResponseBody202OutputsOneOf2 = DecodeTransactionResponseBody202OutputsOneOf2 {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  decodeTransactionResponseBody202OutputsOneOf2Address :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , decodeTransactionResponseBody202OutputsOneOf2Amount :: DecodeTransactionResponseBody202OutputsOneOf2Amount
  -- | assets: A flat list of assets (possibly empty).
  , decodeTransactionResponseBody202OutputsOneOf2Assets :: (GHC.Maybe.Maybe ([DecodeTransactionResponseBody202OutputsOneOf2Assets]))
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , decodeTransactionResponseBody202OutputsOneOf2Derivation_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202OutputsOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf2Address obj] : ["amount" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf2Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202OutputsOneOf2Assets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf2Derivation_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf2Address obj] : ["amount" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf2Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202OutputsOneOf2Assets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf2Derivation_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202OutputsOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202OutputsOneOf2" (\obj -> (((GHC.Base.pure DecodeTransactionResponseBody202OutputsOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path"))
-- | Create a new 'DecodeTransactionResponseBody202OutputsOneOf2' with all required fields.
mkDecodeTransactionResponseBody202OutputsOneOf2 :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202OutputsOneOf2Address'
  -> DecodeTransactionResponseBody202OutputsOneOf2Amount -- ^ 'decodeTransactionResponseBody202OutputsOneOf2Amount'
  -> [Data.Text.Internal.Text] -- ^ 'decodeTransactionResponseBody202OutputsOneOf2Derivation_path'
  -> DecodeTransactionResponseBody202OutputsOneOf2
mkDecodeTransactionResponseBody202OutputsOneOf2 decodeTransactionResponseBody202OutputsOneOf2Address decodeTransactionResponseBody202OutputsOneOf2Amount decodeTransactionResponseBody202OutputsOneOf2Derivation_path = DecodeTransactionResponseBody202OutputsOneOf2{decodeTransactionResponseBody202OutputsOneOf2Address = decodeTransactionResponseBody202OutputsOneOf2Address,
                                                                                                                                                                                                                                                                      decodeTransactionResponseBody202OutputsOneOf2Amount = decodeTransactionResponseBody202OutputsOneOf2Amount,
                                                                                                                                                                                                                                                                      decodeTransactionResponseBody202OutputsOneOf2Assets = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                      decodeTransactionResponseBody202OutputsOneOf2Derivation_path = decodeTransactionResponseBody202OutputsOneOf2Derivation_path}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.outputs.items.oneOf.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data DecodeTransactionResponseBody202OutputsOneOf2Amount = DecodeTransactionResponseBody202OutputsOneOf2Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202OutputsOneOf2AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202OutputsOneOf2Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf2AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf2AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202OutputsOneOf2Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202OutputsOneOf2Amount" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202OutputsOneOf2Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202OutputsOneOf2Amount' with all required fields.
mkDecodeTransactionResponseBody202OutputsOneOf2Amount :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202OutputsOneOf2AmountQuantity'
  -> DecodeTransactionResponseBody202OutputsOneOf2Amount
mkDecodeTransactionResponseBody202OutputsOneOf2Amount decodeTransactionResponseBody202OutputsOneOf2AmountQuantity = DecodeTransactionResponseBody202OutputsOneOf2Amount{decodeTransactionResponseBody202OutputsOneOf2AmountQuantity = decodeTransactionResponseBody202OutputsOneOf2AmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.outputs.items.oneOf.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data DecodeTransactionResponseBody202OutputsOneOf2Assets = DecodeTransactionResponseBody202OutputsOneOf2Assets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  decodeTransactionResponseBody202OutputsOneOf2AssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , decodeTransactionResponseBody202OutputsOneOf2AssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202OutputsOneOf2AssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202OutputsOneOf2Assets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf2AssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf2AssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf2AssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf2AssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf2AssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202OutputsOneOf2AssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202OutputsOneOf2Assets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202OutputsOneOf2Assets" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202OutputsOneOf2Assets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202OutputsOneOf2Assets' with all required fields.
mkDecodeTransactionResponseBody202OutputsOneOf2Assets :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202OutputsOneOf2AssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202OutputsOneOf2AssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202OutputsOneOf2AssetsQuantity'
  -> DecodeTransactionResponseBody202OutputsOneOf2Assets
mkDecodeTransactionResponseBody202OutputsOneOf2Assets decodeTransactionResponseBody202OutputsOneOf2AssetsAsset_name decodeTransactionResponseBody202OutputsOneOf2AssetsPolicy_id decodeTransactionResponseBody202OutputsOneOf2AssetsQuantity = DecodeTransactionResponseBody202OutputsOneOf2Assets{decodeTransactionResponseBody202OutputsOneOf2AssetsAsset_name = decodeTransactionResponseBody202OutputsOneOf2AssetsAsset_name,
                                                                                                                                                                                                                                                                                                   decodeTransactionResponseBody202OutputsOneOf2AssetsPolicy_id = decodeTransactionResponseBody202OutputsOneOf2AssetsPolicy_id,
                                                                                                                                                                                                                                                                                                   decodeTransactionResponseBody202OutputsOneOf2AssetsQuantity = decodeTransactionResponseBody202OutputsOneOf2AssetsQuantity}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.outputs.items.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202OutputsVariants =
   DecodeTransactionResponseBody202OutputsVariant1 DecodeTransactionResponseBody202OutputsOneOf1
  | DecodeTransactionResponseBody202OutputsVariant2 DecodeTransactionResponseBody202OutputsOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202OutputsVariants
    where toJSON (DecodeTransactionResponseBody202OutputsVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202OutputsVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202OutputsVariants
    where parseJSON val = case (DecodeTransactionResponseBody202OutputsVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202OutputsVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.script_validity@ in the specification.
-- 
-- Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
-- used in the transaction validated or not. Validity may be null if this
-- transaction was from an era that doesn\'t support phase-2 monetary policy
-- scripts, or is a pending transaction (we don\'t know if validation passed or
-- failed until the transaction hits the ledger).
data DecodeTransactionResponseBody202Script_validityNonNullable =
   DecodeTransactionResponseBody202Script_validityNonNullableOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | DecodeTransactionResponseBody202Script_validityNonNullableTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | DecodeTransactionResponseBody202Script_validityNonNullableEnumValid -- ^ Represents the JSON value @"valid"@
  | DecodeTransactionResponseBody202Script_validityNonNullableEnumInvalid -- ^ Represents the JSON value @"invalid"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Script_validityNonNullable
    where toJSON (DecodeTransactionResponseBody202Script_validityNonNullableOther val) = val
          toJSON (DecodeTransactionResponseBody202Script_validityNonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (DecodeTransactionResponseBody202Script_validityNonNullableEnumValid) = "valid"
          toJSON (DecodeTransactionResponseBody202Script_validityNonNullableEnumInvalid) = "invalid"
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Script_validityNonNullable
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "valid" -> DecodeTransactionResponseBody202Script_validityNonNullableEnumValid
                                            | val GHC.Classes.== "invalid" -> DecodeTransactionResponseBody202Script_validityNonNullableEnumInvalid
                                            | GHC.Base.otherwise -> DecodeTransactionResponseBody202Script_validityNonNullableOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.validity_interval@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Validity_interval = DecodeTransactionResponseBody202Validity_interval {
  -- | invalid_before
  decodeTransactionResponseBody202Validity_intervalInvalid_before :: DecodeTransactionResponseBody202Validity_intervalInvalid_before
  -- | invalid_hereafter
  , decodeTransactionResponseBody202Validity_intervalInvalid_hereafter :: DecodeTransactionResponseBody202Validity_intervalInvalid_hereafter
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Validity_interval
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Validity_interval
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Validity_interval" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202Validity_interval GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_before")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_hereafter"))
-- | Create a new 'DecodeTransactionResponseBody202Validity_interval' with all required fields.
mkDecodeTransactionResponseBody202Validity_interval :: DecodeTransactionResponseBody202Validity_intervalInvalid_before -- ^ 'decodeTransactionResponseBody202Validity_intervalInvalid_before'
  -> DecodeTransactionResponseBody202Validity_intervalInvalid_hereafter -- ^ 'decodeTransactionResponseBody202Validity_intervalInvalid_hereafter'
  -> DecodeTransactionResponseBody202Validity_interval
mkDecodeTransactionResponseBody202Validity_interval decodeTransactionResponseBody202Validity_intervalInvalid_before decodeTransactionResponseBody202Validity_intervalInvalid_hereafter = DecodeTransactionResponseBody202Validity_interval{decodeTransactionResponseBody202Validity_intervalInvalid_before = decodeTransactionResponseBody202Validity_intervalInvalid_before,
                                                                                                                                                                                                                                           decodeTransactionResponseBody202Validity_intervalInvalid_hereafter = decodeTransactionResponseBody202Validity_intervalInvalid_hereafter}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.validity_interval.properties.invalid_before@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Validity_intervalInvalid_before = DecodeTransactionResponseBody202Validity_intervalInvalid_before {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202Validity_intervalInvalid_beforeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Validity_intervalInvalid_before
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Validity_intervalInvalid_before
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Validity_intervalInvalid_before" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202Validity_intervalInvalid_before GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202Validity_intervalInvalid_before' with all required fields.
mkDecodeTransactionResponseBody202Validity_intervalInvalid_before :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202Validity_intervalInvalid_beforeQuantity'
  -> DecodeTransactionResponseBody202Validity_intervalInvalid_before
mkDecodeTransactionResponseBody202Validity_intervalInvalid_before decodeTransactionResponseBody202Validity_intervalInvalid_beforeQuantity = DecodeTransactionResponseBody202Validity_intervalInvalid_before{decodeTransactionResponseBody202Validity_intervalInvalid_beforeQuantity = decodeTransactionResponseBody202Validity_intervalInvalid_beforeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.validity_interval.properties.invalid_hereafter@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Validity_intervalInvalid_hereafter = DecodeTransactionResponseBody202Validity_intervalInvalid_hereafter {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Validity_intervalInvalid_hereafter
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Validity_intervalInvalid_hereafter
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Validity_intervalInvalid_hereafter" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202Validity_intervalInvalid_hereafter GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202Validity_intervalInvalid_hereafter' with all required fields.
mkDecodeTransactionResponseBody202Validity_intervalInvalid_hereafter :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity'
  -> DecodeTransactionResponseBody202Validity_intervalInvalid_hereafter
mkDecodeTransactionResponseBody202Validity_intervalInvalid_hereafter decodeTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity = DecodeTransactionResponseBody202Validity_intervalInvalid_hereafter{decodeTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity = decodeTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.withdrawals.items@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Withdrawals = DecodeTransactionResponseBody202Withdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  decodeTransactionResponseBody202WithdrawalsAmount :: DecodeTransactionResponseBody202WithdrawalsAmount
  -- | context: Used when withdrawal or output is ours.
  , decodeTransactionResponseBody202WithdrawalsContext :: (GHC.Maybe.Maybe DecodeTransactionResponseBody202WithdrawalsContext)
  -- | stake_address
  , decodeTransactionResponseBody202WithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Withdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202WithdrawalsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("context" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202WithdrawalsContext obj) : ["stake_address" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202WithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202WithdrawalsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("context" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202WithdrawalsContext obj) : ["stake_address" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202WithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Withdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Withdrawals" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202Withdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "context")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'DecodeTransactionResponseBody202Withdrawals' with all required fields.
mkDecodeTransactionResponseBody202Withdrawals :: DecodeTransactionResponseBody202WithdrawalsAmount -- ^ 'decodeTransactionResponseBody202WithdrawalsAmount'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202WithdrawalsStake_address'
  -> DecodeTransactionResponseBody202Withdrawals
mkDecodeTransactionResponseBody202Withdrawals decodeTransactionResponseBody202WithdrawalsAmount decodeTransactionResponseBody202WithdrawalsStake_address = DecodeTransactionResponseBody202Withdrawals{decodeTransactionResponseBody202WithdrawalsAmount = decodeTransactionResponseBody202WithdrawalsAmount,
                                                                                                                                                                                                       decodeTransactionResponseBody202WithdrawalsContext = GHC.Maybe.Nothing,
                                                                                                                                                                                                       decodeTransactionResponseBody202WithdrawalsStake_address = decodeTransactionResponseBody202WithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data DecodeTransactionResponseBody202WithdrawalsAmount = DecodeTransactionResponseBody202WithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202WithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202WithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202WithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202WithdrawalsAmount" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202WithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'DecodeTransactionResponseBody202WithdrawalsAmount' with all required fields.
mkDecodeTransactionResponseBody202WithdrawalsAmount :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202WithdrawalsAmountQuantity'
  -> DecodeTransactionResponseBody202WithdrawalsAmount
mkDecodeTransactionResponseBody202WithdrawalsAmount decodeTransactionResponseBody202WithdrawalsAmountQuantity = DecodeTransactionResponseBody202WithdrawalsAmount{decodeTransactionResponseBody202WithdrawalsAmountQuantity = decodeTransactionResponseBody202WithdrawalsAmountQuantity}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.withdrawals.items.properties.context@ in the specification.
-- 
-- Used when withdrawal or output is ours.
data DecodeTransactionResponseBody202WithdrawalsContext =
   DecodeTransactionResponseBody202WithdrawalsContextOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | DecodeTransactionResponseBody202WithdrawalsContextTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | DecodeTransactionResponseBody202WithdrawalsContextEnumOurs -- ^ Represents the JSON value @"ours"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202WithdrawalsContext
    where toJSON (DecodeTransactionResponseBody202WithdrawalsContextOther val) = val
          toJSON (DecodeTransactionResponseBody202WithdrawalsContextTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (DecodeTransactionResponseBody202WithdrawalsContextEnumOurs) = "ours"
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202WithdrawalsContext
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "ours" -> DecodeTransactionResponseBody202WithdrawalsContextEnumOurs
                                            | GHC.Base.otherwise -> DecodeTransactionResponseBody202WithdrawalsContextOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.witness_count@ in the specification.
-- 
-- Specifies the number of verification key and bootstrap wintesses.
-- As scripts act as witnesses they are also included. Scripts can be specified
-- and spent in a given transaction or defined to be consumed later.
-- In the latter case they are defined in transaction outputs (feature possible from Babbage era)
-- in one transaction and referenced in other later transaction(s). The script referencing
-- is realized via including of reference in a reference input. If reference script
-- is present here it included the form of the script and reference to be used later,
-- ie. tx id and index of tx out where the script was included.
data DecodeTransactionResponseBody202Witness_count = DecodeTransactionResponseBody202Witness_count {
  -- | bootstrap: The number of witnesses detected
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 127.0
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202Witness_countBootstrap :: GHC.Types.Int
  -- | scripts
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , decodeTransactionResponseBody202Witness_countScripts :: ([DecodeTransactionResponseBody202Witness_countScriptsVariants])
  -- | verification_key: The number of witnesses detected
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 127.0
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202Witness_countVerification_key :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Witness_count
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["bootstrap" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countBootstrap obj] : ["scripts" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScripts obj] : ["verification_key" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countVerification_key obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["bootstrap" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countBootstrap obj] : ["scripts" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScripts obj] : ["verification_key" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countVerification_key obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Witness_count
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Witness_count" (\obj -> ((GHC.Base.pure DecodeTransactionResponseBody202Witness_count GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "bootstrap")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "scripts")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "verification_key"))
-- | Create a new 'DecodeTransactionResponseBody202Witness_count' with all required fields.
mkDecodeTransactionResponseBody202Witness_count :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202Witness_countBootstrap'
  -> [DecodeTransactionResponseBody202Witness_countScriptsVariants] -- ^ 'decodeTransactionResponseBody202Witness_countScripts'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202Witness_countVerification_key'
  -> DecodeTransactionResponseBody202Witness_count
mkDecodeTransactionResponseBody202Witness_count decodeTransactionResponseBody202Witness_countBootstrap decodeTransactionResponseBody202Witness_countScripts decodeTransactionResponseBody202Witness_countVerification_key = DecodeTransactionResponseBody202Witness_count{decodeTransactionResponseBody202Witness_countBootstrap = decodeTransactionResponseBody202Witness_countBootstrap,
                                                                                                                                                                                                                                                                          decodeTransactionResponseBody202Witness_countScripts = decodeTransactionResponseBody202Witness_countScripts,
                                                                                                                                                                                                                                                                          decodeTransactionResponseBody202Witness_countVerification_key = decodeTransactionResponseBody202Witness_countVerification_key}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.witness_count.properties.scripts.items.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Witness_countScriptsOneOf1 = DecodeTransactionResponseBody202Witness_countScriptsOneOf1 {
  -- | reference: A reference input.
  decodeTransactionResponseBody202Witness_countScriptsOneOf1Reference :: (GHC.Maybe.Maybe DecodeTransactionResponseBody202Witness_countScriptsOneOf1Reference)
  -- | script
  , decodeTransactionResponseBody202Witness_countScriptsOneOf1Script :: DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Witness_countScriptsOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Witness_countScriptsOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Witness_countScriptsOneOf1" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202Witness_countScriptsOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'DecodeTransactionResponseBody202Witness_countScriptsOneOf1' with all required fields.
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1 :: DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariants -- ^ 'decodeTransactionResponseBody202Witness_countScriptsOneOf1Script'
  -> DecodeTransactionResponseBody202Witness_countScriptsOneOf1
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1 decodeTransactionResponseBody202Witness_countScriptsOneOf1Script = DecodeTransactionResponseBody202Witness_countScriptsOneOf1{decodeTransactionResponseBody202Witness_countScriptsOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                           decodeTransactionResponseBody202Witness_countScriptsOneOf1Script = decodeTransactionResponseBody202Witness_countScriptsOneOf1Script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.witness_count.properties.scripts.items.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data DecodeTransactionResponseBody202Witness_countScriptsOneOf1Reference = DecodeTransactionResponseBody202Witness_countScriptsOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  decodeTransactionResponseBody202Witness_countScriptsOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202Witness_countScriptsOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Witness_countScriptsOneOf1Reference" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202Witness_countScriptsOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'DecodeTransactionResponseBody202Witness_countScriptsOneOf1Reference' with all required fields.
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1Reference :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202Witness_countScriptsOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202Witness_countScriptsOneOf1ReferenceIndex'
  -> DecodeTransactionResponseBody202Witness_countScriptsOneOf1Reference
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1Reference decodeTransactionResponseBody202Witness_countScriptsOneOf1ReferenceId decodeTransactionResponseBody202Witness_countScriptsOneOf1ReferenceIndex = DecodeTransactionResponseBody202Witness_countScriptsOneOf1Reference{decodeTransactionResponseBody202Witness_countScriptsOneOf1ReferenceId = decodeTransactionResponseBody202Witness_countScriptsOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                           decodeTransactionResponseBody202Witness_countScriptsOneOf1ReferenceIndex = decodeTransactionResponseBody202Witness_countScriptsOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.witness_count.properties.scripts.items.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2 = DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2' with all required fields.
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2All'
  -> DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2 decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2All = DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2{decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2All = decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.witness_count.properties.scripts.items.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3 = DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3' with all required fields.
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3Any'
  -> DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3 decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3Any = DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3{decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3Any = decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.witness_count.properties.scripts.items.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4 = DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some :: DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4' with all required fields.
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4 :: DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some -- ^ 'decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some'
  -> DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4 decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some = DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4{decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some = decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.witness_count.properties.scripts.items.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some = DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some' with all required fields.
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4SomeFrom'
  -> DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4SomeAt_least decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4SomeFrom = DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4Some{decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4SomeAt_least = decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                            decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4SomeFrom = decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.witness_count.properties.scripts.items.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5 = DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5' with all required fields.
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5Active_from'
  -> DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5 decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5Active_from = DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5{decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5Active_from = decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.witness_count.properties.scripts.items.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6 = DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6' with all required fields.
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6Active_until'
  -> DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6 decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6Active_until = DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6{decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6Active_until = decodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.witness_count.properties.scripts.items.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariants =
   DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant1 Data.Text.Internal.Text
  | DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant2 DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf2
  | DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant3 DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf3
  | DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant4 DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf4
  | DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant5 DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf5
  | DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant6 DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariants
    where toJSON (DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariants
    where parseJSON val = case (DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202Witness_countScriptsOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.witness_count.properties.scripts.items.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Witness_countScriptsOneOf2 = DecodeTransactionResponseBody202Witness_countScriptsOneOf2 {
  -- | reference: A reference input.
  decodeTransactionResponseBody202Witness_countScriptsOneOf2Reference :: (GHC.Maybe.Maybe DecodeTransactionResponseBody202Witness_countScriptsOneOf2Reference)
  -- | script_info
  , decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info :: DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Witness_countScriptsOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (decodeTransactionResponseBody202Witness_countScriptsOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Witness_countScriptsOneOf2" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202Witness_countScriptsOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'DecodeTransactionResponseBody202Witness_countScriptsOneOf2' with all required fields.
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf2 :: DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info -- ^ 'decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info'
  -> DecodeTransactionResponseBody202Witness_countScriptsOneOf2
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf2 decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info = DecodeTransactionResponseBody202Witness_countScriptsOneOf2{decodeTransactionResponseBody202Witness_countScriptsOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info = decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.witness_count.properties.scripts.items.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data DecodeTransactionResponseBody202Witness_countScriptsOneOf2Reference = DecodeTransactionResponseBody202Witness_countScriptsOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  decodeTransactionResponseBody202Witness_countScriptsOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , decodeTransactionResponseBody202Witness_countScriptsOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Witness_countScriptsOneOf2Reference" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202Witness_countScriptsOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'DecodeTransactionResponseBody202Witness_countScriptsOneOf2Reference' with all required fields.
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf2Reference :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202Witness_countScriptsOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'decodeTransactionResponseBody202Witness_countScriptsOneOf2ReferenceIndex'
  -> DecodeTransactionResponseBody202Witness_countScriptsOneOf2Reference
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf2Reference decodeTransactionResponseBody202Witness_countScriptsOneOf2ReferenceId decodeTransactionResponseBody202Witness_countScriptsOneOf2ReferenceIndex = DecodeTransactionResponseBody202Witness_countScriptsOneOf2Reference{decodeTransactionResponseBody202Witness_countScriptsOneOf2ReferenceId = decodeTransactionResponseBody202Witness_countScriptsOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                           decodeTransactionResponseBody202Witness_countScriptsOneOf2ReferenceIndex = decodeTransactionResponseBody202Witness_countScriptsOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.witness_count.properties.scripts.items.oneOf.properties.script_info@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info = DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info {
  -- | language_version
  decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_version :: DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info" (\obj -> (GHC.Base.pure DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info' with all required fields.
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info :: DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_version -- ^ 'decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoScript_hash'
  -> DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info
mkDecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_version decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoScript_hash = DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_info{decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_version = decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                       decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoScript_hash = decodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.witness_count.properties.scripts.items.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_version =
   DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_version
    where toJSON (DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> DecodeTransactionResponseBody202Witness_countScriptsOneOf2Script_infoLanguage_versionOther val)
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.202.content.application\/json.schema.properties.witness_count.properties.scripts.items.oneOf@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody202Witness_countScriptsVariants =
   DecodeTransactionResponseBody202Witness_countScriptsVariant1 DecodeTransactionResponseBody202Witness_countScriptsOneOf1
  | DecodeTransactionResponseBody202Witness_countScriptsVariant2 DecodeTransactionResponseBody202Witness_countScriptsOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody202Witness_countScriptsVariants
    where toJSON (DecodeTransactionResponseBody202Witness_countScriptsVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DecodeTransactionResponseBody202Witness_countScriptsVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody202Witness_countScriptsVariants
    where parseJSON val = case (DecodeTransactionResponseBody202Witness_countScriptsVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DecodeTransactionResponseBody202Witness_countScriptsVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody400 = DecodeTransactionResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  decodeTransactionResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody400" (\obj -> GHC.Base.pure DecodeTransactionResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'DecodeTransactionResponseBody400' with all required fields.
mkDecodeTransactionResponseBody400 :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody400Message'
  -> DecodeTransactionResponseBody400
mkDecodeTransactionResponseBody400 decodeTransactionResponseBody400Message = DecodeTransactionResponseBody400{decodeTransactionResponseBody400Message = decodeTransactionResponseBody400Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody404 = DecodeTransactionResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  decodeTransactionResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody404" (\obj -> GHC.Base.pure DecodeTransactionResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'DecodeTransactionResponseBody404' with all required fields.
mkDecodeTransactionResponseBody404 :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody404Message'
  -> DecodeTransactionResponseBody404
mkDecodeTransactionResponseBody404 decodeTransactionResponseBody404Message = DecodeTransactionResponseBody404{decodeTransactionResponseBody404Message = decodeTransactionResponseBody404Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody406 = DecodeTransactionResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  decodeTransactionResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody406" (\obj -> GHC.Base.pure DecodeTransactionResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'DecodeTransactionResponseBody406' with all required fields.
mkDecodeTransactionResponseBody406 :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody406Message'
  -> DecodeTransactionResponseBody406
mkDecodeTransactionResponseBody406 decodeTransactionResponseBody406Message = DecodeTransactionResponseBody406{decodeTransactionResponseBody406Message = decodeTransactionResponseBody406Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-decode.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data DecodeTransactionResponseBody415 = DecodeTransactionResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  decodeTransactionResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DecodeTransactionResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= decodeTransactionResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DecodeTransactionResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DecodeTransactionResponseBody415" (\obj -> GHC.Base.pure DecodeTransactionResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'DecodeTransactionResponseBody415' with all required fields.
mkDecodeTransactionResponseBody415 :: Data.Text.Internal.Text -- ^ 'decodeTransactionResponseBody415Message'
  -> DecodeTransactionResponseBody415
mkDecodeTransactionResponseBody415 decodeTransactionResponseBody415Message = DecodeTransactionResponseBody415{decodeTransactionResponseBody415Message = decodeTransactionResponseBody415Message}
-- | > POST /wallets/{walletId}/transactions-decode
-- 
-- The same as 'decodeTransaction' but accepts an explicit configuration.
decodeTransactionWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> DecodeTransactionRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response DecodeTransactionResponse) -- ^ Monadic computation which returns the result of the operation
decodeTransactionWithConfiguration config
                                   walletId
                                   body = GHC.Base.fmap (\response_6 -> GHC.Base.fmap (Data.Either.either DecodeTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> DecodeTransactionResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                       DecodeTransactionResponseBody202)
                                                                                                                                                                                      | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> DecodeTransactionResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                       DecodeTransactionResponseBody400)
                                                                                                                                                                                      | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> DecodeTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                       DecodeTransactionResponseBody404)
                                                                                                                                                                                      | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> DecodeTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                         DecodeTransactionResponseBody406)
                                                                                                                                                                                      | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> DecodeTransactionResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                         DecodeTransactionResponseBody415)
                                                                                                                                                                                      | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_6) response_6) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-decode")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/transactions-decode
-- 
-- The same as 'decodeTransaction' but returns the raw 'Data.ByteString.ByteString'.
decodeTransactionRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> DecodeTransactionRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
decodeTransactionRaw walletId
                     body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-decode")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/transactions-decode
-- 
-- The same as 'decodeTransaction' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
decodeTransactionWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> DecodeTransactionRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
decodeTransactionWithConfigurationRaw config
                                      walletId
                                      body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-decode")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
