-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation joinStakePool
module Wallet.Operations.JoinStakePool where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > PUT /stake-pools/{stakePoolId}/wallets/{walletId}
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Delegate all (current and future) addresses from the given wallet to the given stake pool.
-- 
-- \<strong>Note:\<\/strong> Bech32-encoded stake pool identifiers can vary in length.
joinStakePool :: forall m . Wallet.Common.MonadHTTP m => JoinStakePoolParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> JoinStakePoolRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response JoinStakePoolResponse) -- ^ Monadic computation which returns the result of the operation
joinStakePool parameters
              body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either JoinStakePoolResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> JoinStakePoolResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                          JoinStakePoolResponseBody202)
                                                                                                                                                             | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> JoinStakePoolResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                          JoinStakePoolResponseBody400)
                                                                                                                                                             | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> JoinStakePoolResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                          JoinStakePoolResponseBody403Variants)
                                                                                                                                                             | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> JoinStakePoolResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                          JoinStakePoolResponseBody404Variants)
                                                                                                                                                             | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> JoinStakePoolResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                          JoinStakePoolResponseBody406)
                                                                                                                                                             | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> JoinStakePoolResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                          JoinStakePoolResponseBody415)
                                                                                                                                                             | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/stake-pools/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (joinStakePoolParametersPathStakePoolId parameters))) GHC.Base.<> ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (joinStakePoolParametersPathWalletId parameters))) GHC.Base.<> "")))) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.parameters@ in the specification.
-- 
-- 
data JoinStakePoolParameters = JoinStakePoolParameters {
  -- | pathStakePoolId: Represents the parameter named \'stakePoolId\'
  joinStakePoolParametersPathStakePoolId :: Data.Text.Internal.Text
  -- | pathWalletId: Represents the parameter named \'walletId\'
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  , joinStakePoolParametersPathWalletId :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolParameters
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pathStakePoolId" Data.Aeson.Types.ToJSON..= joinStakePoolParametersPathStakePoolId obj] : ["pathWalletId" Data.Aeson.Types.ToJSON..= joinStakePoolParametersPathWalletId obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pathStakePoolId" Data.Aeson.Types.ToJSON..= joinStakePoolParametersPathStakePoolId obj] : ["pathWalletId" Data.Aeson.Types.ToJSON..= joinStakePoolParametersPathWalletId obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolParameters
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolParameters" (\obj -> (GHC.Base.pure JoinStakePoolParameters GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pathStakePoolId")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pathWalletId"))
-- | Create a new 'JoinStakePoolParameters' with all required fields.
mkJoinStakePoolParameters :: Data.Text.Internal.Text -- ^ 'joinStakePoolParametersPathStakePoolId'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolParametersPathWalletId'
  -> JoinStakePoolParameters
mkJoinStakePoolParameters joinStakePoolParametersPathStakePoolId joinStakePoolParametersPathWalletId = JoinStakePoolParameters{joinStakePoolParametersPathStakePoolId = joinStakePoolParametersPathStakePoolId,
                                                                                                                               joinStakePoolParametersPathWalletId = joinStakePoolParametersPathWalletId}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.requestBody.content.application\/json.schema@ in the specification.
-- 
-- 
data JoinStakePoolRequestBody = JoinStakePoolRequestBody {
  -- | passphrase: The source wallet\'s master passphrase.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 0
  joinStakePoolRequestBodyPassphrase :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["passphrase" Data.Aeson.Types.ToJSON..= joinStakePoolRequestBodyPassphrase obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["passphrase" Data.Aeson.Types.ToJSON..= joinStakePoolRequestBodyPassphrase obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolRequestBody" (\obj -> GHC.Base.pure JoinStakePoolRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "passphrase"))
-- | Create a new 'JoinStakePoolRequestBody' with all required fields.
mkJoinStakePoolRequestBody :: Data.Text.Internal.Text -- ^ 'joinStakePoolRequestBodyPassphrase'
  -> JoinStakePoolRequestBody
mkJoinStakePoolRequestBody joinStakePoolRequestBodyPassphrase = JoinStakePoolRequestBody{joinStakePoolRequestBodyPassphrase = joinStakePoolRequestBodyPassphrase}
-- | Represents a response of the operation 'joinStakePool'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'JoinStakePoolResponseError' is used.
data JoinStakePoolResponse =
   JoinStakePoolResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | JoinStakePoolResponse202 JoinStakePoolResponseBody202 -- ^ Accepted
  | JoinStakePoolResponse400 JoinStakePoolResponseBody400 -- ^ Bad Request
  | JoinStakePoolResponse403 JoinStakePoolResponseBody403Variants -- ^ Forbidden
  | JoinStakePoolResponse404 JoinStakePoolResponseBody404Variants -- ^ Not Found
  | JoinStakePoolResponse406 JoinStakePoolResponseBody406 -- ^ Not Acceptable
  | JoinStakePoolResponse415 JoinStakePoolResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202 = JoinStakePoolResponseBody202 {
  -- | amount: An amount of Ada spent or received, from the perspective of the wallet.
  -- 
  -- That is, for outgoing transaction, it represents the amount of Ada consumed
  -- as inputs including the amount of Ada spent as fees or deposits.
  -- 
  -- For incoming transaction, it represents the total amount of Ada received to
  -- addresses that belong to the wallet.
  joinStakePoolResponseBody202Amount :: JoinStakePoolResponseBody202Amount
  -- | burn
  , joinStakePoolResponseBody202Burn :: (GHC.Maybe.Maybe JoinStakePoolResponseBody202Burn)
  -- | certificates
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , joinStakePoolResponseBody202Certificates :: (GHC.Maybe.Maybe ([JoinStakePoolResponseBody202CertificatesVariants]))
  -- | collateral: A list of transaction inputs used for collateral.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , joinStakePoolResponseBody202Collateral :: (GHC.Maybe.Maybe ([JoinStakePoolResponseBody202Collateral]))
  -- | collateral_outputs: A list of collateral return outputs with amounts specified.
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 1 items
  -- * Must have a minimum of 0 items
  , joinStakePoolResponseBody202Collateral_outputs :: (GHC.Maybe.Maybe ([JoinStakePoolResponseBody202Collateral_outputs]))
  -- | deposit_returned: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , joinStakePoolResponseBody202Deposit_returned :: JoinStakePoolResponseBody202Deposit_returned
  -- | deposit_taken: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , joinStakePoolResponseBody202Deposit_taken :: JoinStakePoolResponseBody202Deposit_taken
  -- | depth: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Current depth of the transaction in the local chain
  , joinStakePoolResponseBody202Depth :: (GHC.Maybe.Maybe JoinStakePoolResponseBody202Depth)
  -- | direction
  , joinStakePoolResponseBody202Direction :: JoinStakePoolResponseBody202Direction
  -- | expires_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending OR status == expired
  -- \<\/span>\<br\/>
  -- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
  , joinStakePoolResponseBody202Expires_at :: (GHC.Maybe.Maybe JoinStakePoolResponseBody202Expires_at)
  -- | extra_signatures
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , joinStakePoolResponseBody202Extra_signatures :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | fee: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , joinStakePoolResponseBody202Fee :: JoinStakePoolResponseBody202Fee
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , joinStakePoolResponseBody202Id :: Data.Text.Internal.Text
  -- | inputs: A list of transaction inputs.
  -- 
  -- \`assets\` and \`address\` are always present for \`outgoing\`
  -- transactions but generally absent for \`incoming\`
  -- transactions. This information is present on the Cardano explorer,
  -- but is not tracked by the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , joinStakePoolResponseBody202Inputs :: ([JoinStakePoolResponseBody202Inputs])
  -- | inserted_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Absolute time at which the transaction was inserted in a block.
  , joinStakePoolResponseBody202Inserted_at :: (GHC.Maybe.Maybe JoinStakePoolResponseBody202Inserted_at)
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  , joinStakePoolResponseBody202Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | mint
  , joinStakePoolResponseBody202Mint :: (GHC.Maybe.Maybe JoinStakePoolResponseBody202Mint)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , joinStakePoolResponseBody202Outputs :: ([JoinStakePoolResponseBody202Outputs])
  -- | pending_since: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending
  -- \<\/span>\<br\/>
  -- The point in time at which a transaction became pending.
  , joinStakePoolResponseBody202Pending_since :: (GHC.Maybe.Maybe JoinStakePoolResponseBody202Pending_since)
  -- | script_integrity: A script data integrity hash - 32 bytes
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^(script_data)1[0-9a-z]*\$\'
  , joinStakePoolResponseBody202Script_integrity :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | script_validity: Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
  -- used in the transaction validated or not. Validity may be null if this
  -- transaction was from an era that doesn\'t support phase-2 monetary policy
  -- scripts, or is a pending transaction (we don\'t know if validation passed or
  -- failed until the transaction hits the ledger).
  , joinStakePoolResponseBody202Script_validity :: (GHC.Maybe.Maybe (Wallet.Common.Nullable JoinStakePoolResponseBody202Script_validityNonNullable))
  -- | status: Current transaction status.
  -- 
  --   \`\`\`
  --        *-----------*
  --   ---> |  PENDING  |----------------*
  --        *-----------*                |
  --              |                      |
  --              V                      V
  --        *-----------*          *-----------*
  --        |           |---------->  EXPIRED  |
  --        |           |  (ttl)   *-----------*
  --        | SUBMITTED |
  --        |           \<----------------*
  --        |           |                |
  --        *-----------*           (rollback)
  --               |                     |
  --          (in ledger)          *-----------*
  --               |               |           |
  --               *---------------> IN_LEDGER |
  --                               |           |
  --                               *-----------*
  --   \`\`\`
  , joinStakePoolResponseBody202Status :: JoinStakePoolResponseBody202Status
  -- | validity_interval
  , joinStakePoolResponseBody202Validity_interval :: (GHC.Maybe.Maybe JoinStakePoolResponseBody202Validity_interval)
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , joinStakePoolResponseBody202Withdrawals :: ([JoinStakePoolResponseBody202Withdrawals])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Fee obj] : ["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Withdrawals obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Fee obj] : ["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Withdrawals obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202" (\obj -> (((((((((((((((((((((((GHC.Base.pure JoinStakePoolResponseBody202 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "burn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral_outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "depth")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "direction")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "expires_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "extra_signatures")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fee")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "inserted_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pending_since")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_integrity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_validity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "validity_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "withdrawals"))
-- | Create a new 'JoinStakePoolResponseBody202' with all required fields.
mkJoinStakePoolResponseBody202 :: JoinStakePoolResponseBody202Amount -- ^ 'joinStakePoolResponseBody202Amount'
  -> JoinStakePoolResponseBody202Deposit_returned -- ^ 'joinStakePoolResponseBody202Deposit_returned'
  -> JoinStakePoolResponseBody202Deposit_taken -- ^ 'joinStakePoolResponseBody202Deposit_taken'
  -> JoinStakePoolResponseBody202Direction -- ^ 'joinStakePoolResponseBody202Direction'
  -> JoinStakePoolResponseBody202Fee -- ^ 'joinStakePoolResponseBody202Fee'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202Id'
  -> [JoinStakePoolResponseBody202Inputs] -- ^ 'joinStakePoolResponseBody202Inputs'
  -> [JoinStakePoolResponseBody202Outputs] -- ^ 'joinStakePoolResponseBody202Outputs'
  -> JoinStakePoolResponseBody202Status -- ^ 'joinStakePoolResponseBody202Status'
  -> [JoinStakePoolResponseBody202Withdrawals] -- ^ 'joinStakePoolResponseBody202Withdrawals'
  -> JoinStakePoolResponseBody202
mkJoinStakePoolResponseBody202 joinStakePoolResponseBody202Amount joinStakePoolResponseBody202Deposit_returned joinStakePoolResponseBody202Deposit_taken joinStakePoolResponseBody202Direction joinStakePoolResponseBody202Fee joinStakePoolResponseBody202Id joinStakePoolResponseBody202Inputs joinStakePoolResponseBody202Outputs joinStakePoolResponseBody202Status joinStakePoolResponseBody202Withdrawals = JoinStakePoolResponseBody202{joinStakePoolResponseBody202Amount = joinStakePoolResponseBody202Amount,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Burn = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Certificates = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Collateral = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Collateral_outputs = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Deposit_returned = joinStakePoolResponseBody202Deposit_returned,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Deposit_taken = joinStakePoolResponseBody202Deposit_taken,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Depth = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Direction = joinStakePoolResponseBody202Direction,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Expires_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Extra_signatures = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Fee = joinStakePoolResponseBody202Fee,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Id = joinStakePoolResponseBody202Id,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Inputs = joinStakePoolResponseBody202Inputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Inserted_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Mint = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Outputs = joinStakePoolResponseBody202Outputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Pending_since = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Script_integrity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Script_validity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Status = joinStakePoolResponseBody202Status,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Validity_interval = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Withdrawals = joinStakePoolResponseBody202Withdrawals}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.amount@ in the specification.
-- 
-- An amount of Ada spent or received, from the perspective of the wallet.
-- 
-- That is, for outgoing transaction, it represents the amount of Ada consumed
-- as inputs including the amount of Ada spent as fees or deposits.
-- 
-- For incoming transaction, it represents the total amount of Ada received to
-- addresses that belong to the wallet.
data JoinStakePoolResponseBody202Amount = JoinStakePoolResponseBody202Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Amount" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202Amount' with all required fields.
mkJoinStakePoolResponseBody202Amount :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202AmountQuantity'
  -> JoinStakePoolResponseBody202Amount
mkJoinStakePoolResponseBody202Amount joinStakePoolResponseBody202AmountQuantity = JoinStakePoolResponseBody202Amount{joinStakePoolResponseBody202AmountQuantity = joinStakePoolResponseBody202AmountQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202Burn = JoinStakePoolResponseBody202Burn {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  joinStakePoolResponseBody202BurnTokens :: ([JoinStakePoolResponseBody202BurnTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , joinStakePoolResponseBody202BurnWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , joinStakePoolResponseBody202BurnWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202BurnWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202BurnWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Burn" (\obj -> ((GHC.Base.pure JoinStakePoolResponseBody202Burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'JoinStakePoolResponseBody202Burn' with all required fields.
mkJoinStakePoolResponseBody202Burn :: [JoinStakePoolResponseBody202BurnTokens] -- ^ 'joinStakePoolResponseBody202BurnTokens'
  -> JoinStakePoolResponseBody202Burn
mkJoinStakePoolResponseBody202Burn joinStakePoolResponseBody202BurnTokens = JoinStakePoolResponseBody202Burn{joinStakePoolResponseBody202BurnTokens = joinStakePoolResponseBody202BurnTokens,
                                                                                                             joinStakePoolResponseBody202BurnWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                             joinStakePoolResponseBody202BurnWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202BurnTokens = JoinStakePoolResponseBody202BurnTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  joinStakePoolResponseBody202BurnTokensAssets :: ([JoinStakePoolResponseBody202BurnTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , joinStakePoolResponseBody202BurnTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , joinStakePoolResponseBody202BurnTokensPolicy_script :: JoinStakePoolResponseBody202BurnTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202BurnTokens" (\obj -> ((GHC.Base.pure JoinStakePoolResponseBody202BurnTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'JoinStakePoolResponseBody202BurnTokens' with all required fields.
mkJoinStakePoolResponseBody202BurnTokens :: [JoinStakePoolResponseBody202BurnTokensAssets] -- ^ 'joinStakePoolResponseBody202BurnTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_id'
  -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptVariants -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_script'
  -> JoinStakePoolResponseBody202BurnTokens
mkJoinStakePoolResponseBody202BurnTokens joinStakePoolResponseBody202BurnTokensAssets joinStakePoolResponseBody202BurnTokensPolicy_id joinStakePoolResponseBody202BurnTokensPolicy_script = JoinStakePoolResponseBody202BurnTokens{joinStakePoolResponseBody202BurnTokensAssets = joinStakePoolResponseBody202BurnTokensAssets,
                                                                                                                                                                                                                                   joinStakePoolResponseBody202BurnTokensPolicy_id = joinStakePoolResponseBody202BurnTokensPolicy_id,
                                                                                                                                                                                                                                   joinStakePoolResponseBody202BurnTokensPolicy_script = joinStakePoolResponseBody202BurnTokensPolicy_script}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202BurnTokensAssets = JoinStakePoolResponseBody202BurnTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  joinStakePoolResponseBody202BurnTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , joinStakePoolResponseBody202BurnTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202BurnTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202BurnTokensAssets" (\obj -> ((GHC.Base.pure JoinStakePoolResponseBody202BurnTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202BurnTokensAssets' with all required fields.
mkJoinStakePoolResponseBody202BurnTokensAssets :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202BurnTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202BurnTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202BurnTokensAssetsQuantity'
  -> JoinStakePoolResponseBody202BurnTokensAssets
mkJoinStakePoolResponseBody202BurnTokensAssets joinStakePoolResponseBody202BurnTokensAssetsAsset_name joinStakePoolResponseBody202BurnTokensAssetsFingerprint joinStakePoolResponseBody202BurnTokensAssetsQuantity = JoinStakePoolResponseBody202BurnTokensAssets{joinStakePoolResponseBody202BurnTokensAssetsAsset_name = joinStakePoolResponseBody202BurnTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                  joinStakePoolResponseBody202BurnTokensAssetsFingerprint = joinStakePoolResponseBody202BurnTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                  joinStakePoolResponseBody202BurnTokensAssetsQuantity = joinStakePoolResponseBody202BurnTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1 = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference)
  -- | script
  , joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Script :: JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1' with all required fields.
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1 :: JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Script'
  -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1 joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Script = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1{joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                        joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Script = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference' with all required fields.
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex'
  -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1Reference{joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                       joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2{joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3{joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 :: JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4{joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some{joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                        joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5{joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6{joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants =
   JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
  | JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
  | JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
  | JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
  | JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2 = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info :: JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2' with all required fields.
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2 :: JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info'
  -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2 joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2{joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                             joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference' with all required fields.
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex'
  -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Reference{joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                       joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version :: JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info :: JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_info{joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                   joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3 = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References :: ([JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3' with all required fields.
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3 :: [JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References] -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash'
  -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3 joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3{joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                 joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References' with all required fields.
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex'
  -> JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References
mkJoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex = JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3References{joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                           joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex = joinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202BurnTokensPolicy_scriptVariants =
   JoinStakePoolResponseBody202BurnTokensPolicy_scriptVariant1 JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf1
  | JoinStakePoolResponseBody202BurnTokensPolicy_scriptVariant2 JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf2
  | JoinStakePoolResponseBody202BurnTokensPolicy_scriptVariant3 JoinStakePoolResponseBody202BurnTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptVariants
    where toJSON (JoinStakePoolResponseBody202BurnTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202BurnTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202BurnTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202BurnTokensPolicy_scriptVariants
    where parseJSON val = case (JoinStakePoolResponseBody202BurnTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202BurnTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202BurnTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data JoinStakePoolResponseBody202CertificatesOneOf1 = JoinStakePoolResponseBody202CertificatesOneOf1 {
  -- | certificate_type
  joinStakePoolResponseBody202CertificatesOneOf1Certificate_type :: JoinStakePoolResponseBody202CertificatesOneOf1Certificate_type
  -- | pool: A unique identifier for the pool.
  , joinStakePoolResponseBody202CertificatesOneOf1Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , joinStakePoolResponseBody202CertificatesOneOf1Reward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202CertificatesOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202CertificatesOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202CertificatesOneOf1" (\obj -> ((GHC.Base.pure JoinStakePoolResponseBody202CertificatesOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'JoinStakePoolResponseBody202CertificatesOneOf1' with all required fields.
mkJoinStakePoolResponseBody202CertificatesOneOf1 :: JoinStakePoolResponseBody202CertificatesOneOf1Certificate_type -- ^ 'joinStakePoolResponseBody202CertificatesOneOf1Certificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'joinStakePoolResponseBody202CertificatesOneOf1Reward_account_path'
  -> JoinStakePoolResponseBody202CertificatesOneOf1
mkJoinStakePoolResponseBody202CertificatesOneOf1 joinStakePoolResponseBody202CertificatesOneOf1Certificate_type joinStakePoolResponseBody202CertificatesOneOf1Reward_account_path = JoinStakePoolResponseBody202CertificatesOneOf1{joinStakePoolResponseBody202CertificatesOneOf1Certificate_type = joinStakePoolResponseBody202CertificatesOneOf1Certificate_type,
                                                                                                                                                                                                                                   joinStakePoolResponseBody202CertificatesOneOf1Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                   joinStakePoolResponseBody202CertificatesOneOf1Reward_account_path = joinStakePoolResponseBody202CertificatesOneOf1Reward_account_path}
-- | Defines the enum schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202CertificatesOneOf1Certificate_type =
   JoinStakePoolResponseBody202CertificatesOneOf1Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | JoinStakePoolResponseBody202CertificatesOneOf1Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | JoinStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | JoinStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | JoinStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202CertificatesOneOf1Certificate_type
    where toJSON (JoinStakePoolResponseBody202CertificatesOneOf1Certificate_typeOther val) = val
          toJSON (JoinStakePoolResponseBody202CertificatesOneOf1Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (JoinStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool) = "join_pool"
          toJSON (JoinStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (JoinStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202CertificatesOneOf1Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> JoinStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> JoinStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> JoinStakePoolResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> JoinStakePoolResponseBody202CertificatesOneOf1Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate not belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data JoinStakePoolResponseBody202CertificatesOneOf2 = JoinStakePoolResponseBody202CertificatesOneOf2 {
  -- | certificate_type
  joinStakePoolResponseBody202CertificatesOneOf2Certificate_type :: JoinStakePoolResponseBody202CertificatesOneOf2Certificate_type
  -- | pool: A unique identifier for the pool.
  , joinStakePoolResponseBody202CertificatesOneOf2Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account
  , joinStakePoolResponseBody202CertificatesOneOf2Reward_account :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202CertificatesOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf2Reward_account obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf2Reward_account obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202CertificatesOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202CertificatesOneOf2" (\obj -> ((GHC.Base.pure JoinStakePoolResponseBody202CertificatesOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account"))
-- | Create a new 'JoinStakePoolResponseBody202CertificatesOneOf2' with all required fields.
mkJoinStakePoolResponseBody202CertificatesOneOf2 :: JoinStakePoolResponseBody202CertificatesOneOf2Certificate_type -- ^ 'joinStakePoolResponseBody202CertificatesOneOf2Certificate_type'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202CertificatesOneOf2Reward_account'
  -> JoinStakePoolResponseBody202CertificatesOneOf2
mkJoinStakePoolResponseBody202CertificatesOneOf2 joinStakePoolResponseBody202CertificatesOneOf2Certificate_type joinStakePoolResponseBody202CertificatesOneOf2Reward_account = JoinStakePoolResponseBody202CertificatesOneOf2{joinStakePoolResponseBody202CertificatesOneOf2Certificate_type = joinStakePoolResponseBody202CertificatesOneOf2Certificate_type,
                                                                                                                                                                                                                              joinStakePoolResponseBody202CertificatesOneOf2Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                              joinStakePoolResponseBody202CertificatesOneOf2Reward_account = joinStakePoolResponseBody202CertificatesOneOf2Reward_account}
-- | Defines the enum schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202CertificatesOneOf2Certificate_type =
   JoinStakePoolResponseBody202CertificatesOneOf2Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | JoinStakePoolResponseBody202CertificatesOneOf2Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | JoinStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external -- ^ Represents the JSON value @"join_pool_external"@
  | JoinStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external -- ^ Represents the JSON value @"quit_pool_external"@
  | JoinStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external -- ^ Represents the JSON value @"register_reward_account_external"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202CertificatesOneOf2Certificate_type
    where toJSON (JoinStakePoolResponseBody202CertificatesOneOf2Certificate_typeOther val) = val
          toJSON (JoinStakePoolResponseBody202CertificatesOneOf2Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (JoinStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external) = "join_pool_external"
          toJSON (JoinStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external) = "quit_pool_external"
          toJSON (JoinStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external) = "register_reward_account_external"
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202CertificatesOneOf2Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool_external" -> JoinStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external
                                            | val GHC.Classes.== "quit_pool_external" -> JoinStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external
                                            | val GHC.Classes.== "register_reward_account_external" -> JoinStakePoolResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external
                                            | GHC.Base.otherwise -> JoinStakePoolResponseBody202CertificatesOneOf2Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202CertificatesOneOf3 = JoinStakePoolResponseBody202CertificatesOneOf3 {
  -- | pool_cost: Estimated cost set by the pool operator when registering his pool.
  -- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  joinStakePoolResponseBody202CertificatesOneOf3Pool_cost :: JoinStakePoolResponseBody202CertificatesOneOf3Pool_cost
  -- | pool_id: A unique identifier for the pool.
  , joinStakePoolResponseBody202CertificatesOneOf3Pool_id :: Data.Text.Internal.Text
  -- | pool_margin: Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , joinStakePoolResponseBody202CertificatesOneOf3Pool_margin :: JoinStakePoolResponseBody202CertificatesOneOf3Pool_margin
  -- | pool_metadata
  , joinStakePoolResponseBody202CertificatesOneOf3Pool_metadata :: (GHC.Maybe.Maybe JoinStakePoolResponseBody202CertificatesOneOf3Pool_metadata)
  -- | pool_owners
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , joinStakePoolResponseBody202CertificatesOneOf3Pool_owners :: ([Data.Text.Internal.Text])
  -- | pool_pledge: Minimal stake amount that a stake pool is willing to honor.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , joinStakePoolResponseBody202CertificatesOneOf3Pool_pledge :: JoinStakePoolResponseBody202CertificatesOneOf3Pool_pledge
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202CertificatesOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202CertificatesOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202CertificatesOneOf3" (\obj -> (((((GHC.Base.pure JoinStakePoolResponseBody202CertificatesOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_cost")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_margin")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool_metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_owners")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_pledge"))
-- | Create a new 'JoinStakePoolResponseBody202CertificatesOneOf3' with all required fields.
mkJoinStakePoolResponseBody202CertificatesOneOf3 :: JoinStakePoolResponseBody202CertificatesOneOf3Pool_cost -- ^ 'joinStakePoolResponseBody202CertificatesOneOf3Pool_cost'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202CertificatesOneOf3Pool_id'
  -> JoinStakePoolResponseBody202CertificatesOneOf3Pool_margin -- ^ 'joinStakePoolResponseBody202CertificatesOneOf3Pool_margin'
  -> [Data.Text.Internal.Text] -- ^ 'joinStakePoolResponseBody202CertificatesOneOf3Pool_owners'
  -> JoinStakePoolResponseBody202CertificatesOneOf3Pool_pledge -- ^ 'joinStakePoolResponseBody202CertificatesOneOf3Pool_pledge'
  -> JoinStakePoolResponseBody202CertificatesOneOf3
mkJoinStakePoolResponseBody202CertificatesOneOf3 joinStakePoolResponseBody202CertificatesOneOf3Pool_cost joinStakePoolResponseBody202CertificatesOneOf3Pool_id joinStakePoolResponseBody202CertificatesOneOf3Pool_margin joinStakePoolResponseBody202CertificatesOneOf3Pool_owners joinStakePoolResponseBody202CertificatesOneOf3Pool_pledge = JoinStakePoolResponseBody202CertificatesOneOf3{joinStakePoolResponseBody202CertificatesOneOf3Pool_cost = joinStakePoolResponseBody202CertificatesOneOf3Pool_cost,
                                                                                                                                                                                                                                                                                                                                                                                              joinStakePoolResponseBody202CertificatesOneOf3Pool_id = joinStakePoolResponseBody202CertificatesOneOf3Pool_id,
                                                                                                                                                                                                                                                                                                                                                                                              joinStakePoolResponseBody202CertificatesOneOf3Pool_margin = joinStakePoolResponseBody202CertificatesOneOf3Pool_margin,
                                                                                                                                                                                                                                                                                                                                                                                              joinStakePoolResponseBody202CertificatesOneOf3Pool_metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                              joinStakePoolResponseBody202CertificatesOneOf3Pool_owners = joinStakePoolResponseBody202CertificatesOneOf3Pool_owners,
                                                                                                                                                                                                                                                                                                                                                                                              joinStakePoolResponseBody202CertificatesOneOf3Pool_pledge = joinStakePoolResponseBody202CertificatesOneOf3Pool_pledge}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_cost@ in the specification.
-- 
-- Estimated cost set by the pool operator when registering his pool.
-- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data JoinStakePoolResponseBody202CertificatesOneOf3Pool_cost = JoinStakePoolResponseBody202CertificatesOneOf3Pool_cost {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202CertificatesOneOf3Pool_costQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202CertificatesOneOf3Pool_cost
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202CertificatesOneOf3Pool_cost
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202CertificatesOneOf3Pool_cost" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202CertificatesOneOf3Pool_cost GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202CertificatesOneOf3Pool_cost' with all required fields.
mkJoinStakePoolResponseBody202CertificatesOneOf3Pool_cost :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202CertificatesOneOf3Pool_costQuantity'
  -> JoinStakePoolResponseBody202CertificatesOneOf3Pool_cost
mkJoinStakePoolResponseBody202CertificatesOneOf3Pool_cost joinStakePoolResponseBody202CertificatesOneOf3Pool_costQuantity = JoinStakePoolResponseBody202CertificatesOneOf3Pool_cost{joinStakePoolResponseBody202CertificatesOneOf3Pool_costQuantity = joinStakePoolResponseBody202CertificatesOneOf3Pool_costQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_margin@ in the specification.
-- 
-- Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data JoinStakePoolResponseBody202CertificatesOneOf3Pool_margin = JoinStakePoolResponseBody202CertificatesOneOf3Pool_margin {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202CertificatesOneOf3Pool_marginQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202CertificatesOneOf3Pool_margin
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202CertificatesOneOf3Pool_margin
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202CertificatesOneOf3Pool_margin" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202CertificatesOneOf3Pool_margin GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202CertificatesOneOf3Pool_margin' with all required fields.
mkJoinStakePoolResponseBody202CertificatesOneOf3Pool_margin :: GHC.Types.Double -- ^ 'joinStakePoolResponseBody202CertificatesOneOf3Pool_marginQuantity'
  -> JoinStakePoolResponseBody202CertificatesOneOf3Pool_margin
mkJoinStakePoolResponseBody202CertificatesOneOf3Pool_margin joinStakePoolResponseBody202CertificatesOneOf3Pool_marginQuantity = JoinStakePoolResponseBody202CertificatesOneOf3Pool_margin{joinStakePoolResponseBody202CertificatesOneOf3Pool_marginQuantity = joinStakePoolResponseBody202CertificatesOneOf3Pool_marginQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_metadata@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202CertificatesOneOf3Pool_metadata = JoinStakePoolResponseBody202CertificatesOneOf3Pool_metadata {
  -- | hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  joinStakePoolResponseBody202CertificatesOneOf3Pool_metadataHash :: Data.Text.Internal.Text
  -- | url: A URL to the stake pool\'s website.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 250
  -- * Must match pattern \'^https:\/\/.+\'
  , joinStakePoolResponseBody202CertificatesOneOf3Pool_metadataUrl :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202CertificatesOneOf3Pool_metadata
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202CertificatesOneOf3Pool_metadata
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202CertificatesOneOf3Pool_metadata" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202CertificatesOneOf3Pool_metadata GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))
-- | Create a new 'JoinStakePoolResponseBody202CertificatesOneOf3Pool_metadata' with all required fields.
mkJoinStakePoolResponseBody202CertificatesOneOf3Pool_metadata :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202CertificatesOneOf3Pool_metadataHash'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202CertificatesOneOf3Pool_metadataUrl'
  -> JoinStakePoolResponseBody202CertificatesOneOf3Pool_metadata
mkJoinStakePoolResponseBody202CertificatesOneOf3Pool_metadata joinStakePoolResponseBody202CertificatesOneOf3Pool_metadataHash joinStakePoolResponseBody202CertificatesOneOf3Pool_metadataUrl = JoinStakePoolResponseBody202CertificatesOneOf3Pool_metadata{joinStakePoolResponseBody202CertificatesOneOf3Pool_metadataHash = joinStakePoolResponseBody202CertificatesOneOf3Pool_metadataHash,
                                                                                                                                                                                                                                                           joinStakePoolResponseBody202CertificatesOneOf3Pool_metadataUrl = joinStakePoolResponseBody202CertificatesOneOf3Pool_metadataUrl}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_pledge@ in the specification.
-- 
-- Minimal stake amount that a stake pool is willing to honor.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data JoinStakePoolResponseBody202CertificatesOneOf3Pool_pledge = JoinStakePoolResponseBody202CertificatesOneOf3Pool_pledge {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202CertificatesOneOf3Pool_pledgeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202CertificatesOneOf3Pool_pledge
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202CertificatesOneOf3Pool_pledge
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202CertificatesOneOf3Pool_pledge" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202CertificatesOneOf3Pool_pledge GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202CertificatesOneOf3Pool_pledge' with all required fields.
mkJoinStakePoolResponseBody202CertificatesOneOf3Pool_pledge :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202CertificatesOneOf3Pool_pledgeQuantity'
  -> JoinStakePoolResponseBody202CertificatesOneOf3Pool_pledge
mkJoinStakePoolResponseBody202CertificatesOneOf3Pool_pledge joinStakePoolResponseBody202CertificatesOneOf3Pool_pledgeQuantity = JoinStakePoolResponseBody202CertificatesOneOf3Pool_pledge{joinStakePoolResponseBody202CertificatesOneOf3Pool_pledgeQuantity = joinStakePoolResponseBody202CertificatesOneOf3Pool_pledgeQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202CertificatesOneOf4 = JoinStakePoolResponseBody202CertificatesOneOf4 {
  -- | pool_id: A unique identifier for the pool.
  joinStakePoolResponseBody202CertificatesOneOf4Pool_id :: Data.Text.Internal.Text
  -- | retirement_epoch: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202CertificatesOneOf4Retirement_epoch :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202CertificatesOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202CertificatesOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202CertificatesOneOf4" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202CertificatesOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "retirement_epoch"))
-- | Create a new 'JoinStakePoolResponseBody202CertificatesOneOf4' with all required fields.
mkJoinStakePoolResponseBody202CertificatesOneOf4 :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202CertificatesOneOf4Pool_id'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202CertificatesOneOf4Retirement_epoch'
  -> JoinStakePoolResponseBody202CertificatesOneOf4
mkJoinStakePoolResponseBody202CertificatesOneOf4 joinStakePoolResponseBody202CertificatesOneOf4Pool_id joinStakePoolResponseBody202CertificatesOneOf4Retirement_epoch = JoinStakePoolResponseBody202CertificatesOneOf4{joinStakePoolResponseBody202CertificatesOneOf4Pool_id = joinStakePoolResponseBody202CertificatesOneOf4Pool_id,
                                                                                                                                                                                                                       joinStakePoolResponseBody202CertificatesOneOf4Retirement_epoch = joinStakePoolResponseBody202CertificatesOneOf4Retirement_epoch}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202CertificatesOneOf5 = JoinStakePoolResponseBody202CertificatesOneOf5 {
  -- | certificate_type
  joinStakePoolResponseBody202CertificatesOneOf5Certificate_type :: JoinStakePoolResponseBody202CertificatesOneOf5Certificate_type
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202CertificatesOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202CertificatesOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202CertificatesOneOf5" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202CertificatesOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type"))
-- | Create a new 'JoinStakePoolResponseBody202CertificatesOneOf5' with all required fields.
mkJoinStakePoolResponseBody202CertificatesOneOf5 :: JoinStakePoolResponseBody202CertificatesOneOf5Certificate_type -- ^ 'joinStakePoolResponseBody202CertificatesOneOf5Certificate_type'
  -> JoinStakePoolResponseBody202CertificatesOneOf5
mkJoinStakePoolResponseBody202CertificatesOneOf5 joinStakePoolResponseBody202CertificatesOneOf5Certificate_type = JoinStakePoolResponseBody202CertificatesOneOf5{joinStakePoolResponseBody202CertificatesOneOf5Certificate_type = joinStakePoolResponseBody202CertificatesOneOf5Certificate_type}
-- | Defines the enum schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202CertificatesOneOf5Certificate_type =
   JoinStakePoolResponseBody202CertificatesOneOf5Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | JoinStakePoolResponseBody202CertificatesOneOf5Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | JoinStakePoolResponseBody202CertificatesOneOf5Certificate_typeEnumMir -- ^ Represents the JSON value @"mir"@
  | JoinStakePoolResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis -- ^ Represents the JSON value @"genesis"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202CertificatesOneOf5Certificate_type
    where toJSON (JoinStakePoolResponseBody202CertificatesOneOf5Certificate_typeOther val) = val
          toJSON (JoinStakePoolResponseBody202CertificatesOneOf5Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (JoinStakePoolResponseBody202CertificatesOneOf5Certificate_typeEnumMir) = "mir"
          toJSON (JoinStakePoolResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis) = "genesis"
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202CertificatesOneOf5Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "mir" -> JoinStakePoolResponseBody202CertificatesOneOf5Certificate_typeEnumMir
                                            | val GHC.Classes.== "genesis" -> JoinStakePoolResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis
                                            | GHC.Base.otherwise -> JoinStakePoolResponseBody202CertificatesOneOf5Certificate_typeOther val)
-- | Defines the oneOf schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- Any certificate that could occur in an arbitrary transaction:
-- might be related to delegation, pool activities, genesis or MIR.
data JoinStakePoolResponseBody202CertificatesVariants =
   JoinStakePoolResponseBody202CertificatesVariant1 JoinStakePoolResponseBody202CertificatesOneOf1
  | JoinStakePoolResponseBody202CertificatesVariant2 JoinStakePoolResponseBody202CertificatesOneOf2
  | JoinStakePoolResponseBody202CertificatesVariant3 JoinStakePoolResponseBody202CertificatesOneOf3
  | JoinStakePoolResponseBody202CertificatesVariant4 JoinStakePoolResponseBody202CertificatesOneOf4
  | JoinStakePoolResponseBody202CertificatesVariant5 JoinStakePoolResponseBody202CertificatesOneOf5
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202CertificatesVariants
    where toJSON (JoinStakePoolResponseBody202CertificatesVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202CertificatesVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202CertificatesVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202CertificatesVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202CertificatesVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202CertificatesVariants
    where parseJSON val = case (JoinStakePoolResponseBody202CertificatesVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202CertificatesVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202CertificatesVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202CertificatesVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202CertificatesVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.collateral.items@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202Collateral = JoinStakePoolResponseBody202Collateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  joinStakePoolResponseBody202CollateralAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , joinStakePoolResponseBody202CollateralAmount :: (GHC.Maybe.Maybe JoinStakePoolResponseBody202CollateralAmount)
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , joinStakePoolResponseBody202CollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202CollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Collateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Collateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Collateral" (\obj -> (((GHC.Base.pure JoinStakePoolResponseBody202Collateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'JoinStakePoolResponseBody202Collateral' with all required fields.
mkJoinStakePoolResponseBody202Collateral :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202CollateralId'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202CollateralIndex'
  -> JoinStakePoolResponseBody202Collateral
mkJoinStakePoolResponseBody202Collateral joinStakePoolResponseBody202CollateralId joinStakePoolResponseBody202CollateralIndex = JoinStakePoolResponseBody202Collateral{joinStakePoolResponseBody202CollateralAddress = GHC.Maybe.Nothing,
                                                                                                                                                                       joinStakePoolResponseBody202CollateralAmount = GHC.Maybe.Nothing,
                                                                                                                                                                       joinStakePoolResponseBody202CollateralId = joinStakePoolResponseBody202CollateralId,
                                                                                                                                                                       joinStakePoolResponseBody202CollateralIndex = joinStakePoolResponseBody202CollateralIndex}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data JoinStakePoolResponseBody202CollateralAmount = JoinStakePoolResponseBody202CollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202CollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202CollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202CollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202CollateralAmount" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202CollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202CollateralAmount' with all required fields.
mkJoinStakePoolResponseBody202CollateralAmount :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202CollateralAmountQuantity'
  -> JoinStakePoolResponseBody202CollateralAmount
mkJoinStakePoolResponseBody202CollateralAmount joinStakePoolResponseBody202CollateralAmountQuantity = JoinStakePoolResponseBody202CollateralAmount{joinStakePoolResponseBody202CollateralAmountQuantity = joinStakePoolResponseBody202CollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.collateral_outputs.items@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202Collateral_outputs = JoinStakePoolResponseBody202Collateral_outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  joinStakePoolResponseBody202Collateral_outputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , joinStakePoolResponseBody202Collateral_outputsAmount :: JoinStakePoolResponseBody202Collateral_outputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , joinStakePoolResponseBody202Collateral_outputsAssets :: (GHC.Maybe.Maybe ([JoinStakePoolResponseBody202Collateral_outputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Collateral_outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Collateral_outputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202Collateral_outputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Collateral_outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Collateral_outputs" (\obj -> ((GHC.Base.pure JoinStakePoolResponseBody202Collateral_outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'JoinStakePoolResponseBody202Collateral_outputs' with all required fields.
mkJoinStakePoolResponseBody202Collateral_outputs :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202Collateral_outputsAddress'
  -> JoinStakePoolResponseBody202Collateral_outputsAmount -- ^ 'joinStakePoolResponseBody202Collateral_outputsAmount'
  -> JoinStakePoolResponseBody202Collateral_outputs
mkJoinStakePoolResponseBody202Collateral_outputs joinStakePoolResponseBody202Collateral_outputsAddress joinStakePoolResponseBody202Collateral_outputsAmount = JoinStakePoolResponseBody202Collateral_outputs{joinStakePoolResponseBody202Collateral_outputsAddress = joinStakePoolResponseBody202Collateral_outputsAddress,
                                                                                                                                                                                                             joinStakePoolResponseBody202Collateral_outputsAmount = joinStakePoolResponseBody202Collateral_outputsAmount,
                                                                                                                                                                                                             joinStakePoolResponseBody202Collateral_outputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.collateral_outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data JoinStakePoolResponseBody202Collateral_outputsAmount = JoinStakePoolResponseBody202Collateral_outputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202Collateral_outputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Collateral_outputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Collateral_outputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Collateral_outputsAmount" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202Collateral_outputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202Collateral_outputsAmount' with all required fields.
mkJoinStakePoolResponseBody202Collateral_outputsAmount :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Collateral_outputsAmountQuantity'
  -> JoinStakePoolResponseBody202Collateral_outputsAmount
mkJoinStakePoolResponseBody202Collateral_outputsAmount joinStakePoolResponseBody202Collateral_outputsAmountQuantity = JoinStakePoolResponseBody202Collateral_outputsAmount{joinStakePoolResponseBody202Collateral_outputsAmountQuantity = joinStakePoolResponseBody202Collateral_outputsAmountQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.collateral_outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data JoinStakePoolResponseBody202Collateral_outputsAssets = JoinStakePoolResponseBody202Collateral_outputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  joinStakePoolResponseBody202Collateral_outputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , joinStakePoolResponseBody202Collateral_outputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202Collateral_outputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Collateral_outputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Collateral_outputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Collateral_outputsAssets" (\obj -> ((GHC.Base.pure JoinStakePoolResponseBody202Collateral_outputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202Collateral_outputsAssets' with all required fields.
mkJoinStakePoolResponseBody202Collateral_outputsAssets :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202Collateral_outputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202Collateral_outputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Collateral_outputsAssetsQuantity'
  -> JoinStakePoolResponseBody202Collateral_outputsAssets
mkJoinStakePoolResponseBody202Collateral_outputsAssets joinStakePoolResponseBody202Collateral_outputsAssetsAsset_name joinStakePoolResponseBody202Collateral_outputsAssetsPolicy_id joinStakePoolResponseBody202Collateral_outputsAssetsQuantity = JoinStakePoolResponseBody202Collateral_outputsAssets{joinStakePoolResponseBody202Collateral_outputsAssetsAsset_name = joinStakePoolResponseBody202Collateral_outputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                        joinStakePoolResponseBody202Collateral_outputsAssetsPolicy_id = joinStakePoolResponseBody202Collateral_outputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                        joinStakePoolResponseBody202Collateral_outputsAssetsQuantity = joinStakePoolResponseBody202Collateral_outputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.deposit_returned@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data JoinStakePoolResponseBody202Deposit_returned = JoinStakePoolResponseBody202Deposit_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202Deposit_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Deposit_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Deposit_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Deposit_returned" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202Deposit_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202Deposit_returned' with all required fields.
mkJoinStakePoolResponseBody202Deposit_returned :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Deposit_returnedQuantity'
  -> JoinStakePoolResponseBody202Deposit_returned
mkJoinStakePoolResponseBody202Deposit_returned joinStakePoolResponseBody202Deposit_returnedQuantity = JoinStakePoolResponseBody202Deposit_returned{joinStakePoolResponseBody202Deposit_returnedQuantity = joinStakePoolResponseBody202Deposit_returnedQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.deposit_taken@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data JoinStakePoolResponseBody202Deposit_taken = JoinStakePoolResponseBody202Deposit_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202Deposit_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Deposit_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Deposit_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Deposit_taken" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202Deposit_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202Deposit_taken' with all required fields.
mkJoinStakePoolResponseBody202Deposit_taken :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Deposit_takenQuantity'
  -> JoinStakePoolResponseBody202Deposit_taken
mkJoinStakePoolResponseBody202Deposit_taken joinStakePoolResponseBody202Deposit_takenQuantity = JoinStakePoolResponseBody202Deposit_taken{joinStakePoolResponseBody202Deposit_takenQuantity = joinStakePoolResponseBody202Deposit_takenQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.depth@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Current depth of the transaction in the local chain
data JoinStakePoolResponseBody202Depth = JoinStakePoolResponseBody202Depth {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202DepthQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Depth
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Depth
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Depth" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202Depth GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202Depth' with all required fields.
mkJoinStakePoolResponseBody202Depth :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202DepthQuantity'
  -> JoinStakePoolResponseBody202Depth
mkJoinStakePoolResponseBody202Depth joinStakePoolResponseBody202DepthQuantity = JoinStakePoolResponseBody202Depth{joinStakePoolResponseBody202DepthQuantity = joinStakePoolResponseBody202DepthQuantity}
-- | Defines the enum schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.direction@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202Direction =
   JoinStakePoolResponseBody202DirectionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | JoinStakePoolResponseBody202DirectionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | JoinStakePoolResponseBody202DirectionEnumOutgoing -- ^ Represents the JSON value @"outgoing"@
  | JoinStakePoolResponseBody202DirectionEnumIncoming -- ^ Represents the JSON value @"incoming"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Direction
    where toJSON (JoinStakePoolResponseBody202DirectionOther val) = val
          toJSON (JoinStakePoolResponseBody202DirectionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (JoinStakePoolResponseBody202DirectionEnumOutgoing) = "outgoing"
          toJSON (JoinStakePoolResponseBody202DirectionEnumIncoming) = "incoming"
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Direction
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "outgoing" -> JoinStakePoolResponseBody202DirectionEnumOutgoing
                                            | val GHC.Classes.== "incoming" -> JoinStakePoolResponseBody202DirectionEnumIncoming
                                            | GHC.Base.otherwise -> JoinStakePoolResponseBody202DirectionOther val)
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.expires_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending OR status == expired
-- \<\/span>\<br\/>
-- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
data JoinStakePoolResponseBody202Expires_at = JoinStakePoolResponseBody202Expires_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202Expires_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202Expires_atEpoch_number :: GHC.Types.Int
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202Expires_atSlot_number :: GHC.Types.Int
  -- | time
  , joinStakePoolResponseBody202Expires_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Expires_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Expires_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Expires_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Expires_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Expires_at" (\obj -> (((GHC.Base.pure JoinStakePoolResponseBody202Expires_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'JoinStakePoolResponseBody202Expires_at' with all required fields.
mkJoinStakePoolResponseBody202Expires_at :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Expires_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Expires_atEpoch_number'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Expires_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202Expires_atTime'
  -> JoinStakePoolResponseBody202Expires_at
mkJoinStakePoolResponseBody202Expires_at joinStakePoolResponseBody202Expires_atAbsolute_slot_number joinStakePoolResponseBody202Expires_atEpoch_number joinStakePoolResponseBody202Expires_atSlot_number joinStakePoolResponseBody202Expires_atTime = JoinStakePoolResponseBody202Expires_at{joinStakePoolResponseBody202Expires_atAbsolute_slot_number = joinStakePoolResponseBody202Expires_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                             joinStakePoolResponseBody202Expires_atEpoch_number = joinStakePoolResponseBody202Expires_atEpoch_number,
                                                                                                                                                                                                                                                                                             joinStakePoolResponseBody202Expires_atSlot_number = joinStakePoolResponseBody202Expires_atSlot_number,
                                                                                                                                                                                                                                                                                             joinStakePoolResponseBody202Expires_atTime = joinStakePoolResponseBody202Expires_atTime}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.fee@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data JoinStakePoolResponseBody202Fee = JoinStakePoolResponseBody202Fee {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202FeeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Fee
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Fee
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Fee" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202Fee GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202Fee' with all required fields.
mkJoinStakePoolResponseBody202Fee :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202FeeQuantity'
  -> JoinStakePoolResponseBody202Fee
mkJoinStakePoolResponseBody202Fee joinStakePoolResponseBody202FeeQuantity = JoinStakePoolResponseBody202Fee{joinStakePoolResponseBody202FeeQuantity = joinStakePoolResponseBody202FeeQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.inputs.items@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202Inputs = JoinStakePoolResponseBody202Inputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  joinStakePoolResponseBody202InputsAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , joinStakePoolResponseBody202InputsAmount :: (GHC.Maybe.Maybe JoinStakePoolResponseBody202InputsAmount)
  -- | assets: A flat list of assets (possibly empty).
  , joinStakePoolResponseBody202InputsAssets :: (GHC.Maybe.Maybe ([JoinStakePoolResponseBody202InputsAssets]))
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , joinStakePoolResponseBody202InputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202InputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Inputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202InputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202InputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Inputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Inputs" (\obj -> ((((GHC.Base.pure JoinStakePoolResponseBody202Inputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'JoinStakePoolResponseBody202Inputs' with all required fields.
mkJoinStakePoolResponseBody202Inputs :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202InputsId'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202InputsIndex'
  -> JoinStakePoolResponseBody202Inputs
mkJoinStakePoolResponseBody202Inputs joinStakePoolResponseBody202InputsId joinStakePoolResponseBody202InputsIndex = JoinStakePoolResponseBody202Inputs{joinStakePoolResponseBody202InputsAddress = GHC.Maybe.Nothing,
                                                                                                                                                       joinStakePoolResponseBody202InputsAmount = GHC.Maybe.Nothing,
                                                                                                                                                       joinStakePoolResponseBody202InputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                       joinStakePoolResponseBody202InputsId = joinStakePoolResponseBody202InputsId,
                                                                                                                                                       joinStakePoolResponseBody202InputsIndex = joinStakePoolResponseBody202InputsIndex}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data JoinStakePoolResponseBody202InputsAmount = JoinStakePoolResponseBody202InputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202InputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202InputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202InputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202InputsAmount" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202InputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202InputsAmount' with all required fields.
mkJoinStakePoolResponseBody202InputsAmount :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202InputsAmountQuantity'
  -> JoinStakePoolResponseBody202InputsAmount
mkJoinStakePoolResponseBody202InputsAmount joinStakePoolResponseBody202InputsAmountQuantity = JoinStakePoolResponseBody202InputsAmount{joinStakePoolResponseBody202InputsAmountQuantity = joinStakePoolResponseBody202InputsAmountQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data JoinStakePoolResponseBody202InputsAssets = JoinStakePoolResponseBody202InputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  joinStakePoolResponseBody202InputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , joinStakePoolResponseBody202InputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202InputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202InputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202InputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202InputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202InputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202InputsAssets" (\obj -> ((GHC.Base.pure JoinStakePoolResponseBody202InputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202InputsAssets' with all required fields.
mkJoinStakePoolResponseBody202InputsAssets :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202InputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202InputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202InputsAssetsQuantity'
  -> JoinStakePoolResponseBody202InputsAssets
mkJoinStakePoolResponseBody202InputsAssets joinStakePoolResponseBody202InputsAssetsAsset_name joinStakePoolResponseBody202InputsAssetsPolicy_id joinStakePoolResponseBody202InputsAssetsQuantity = JoinStakePoolResponseBody202InputsAssets{joinStakePoolResponseBody202InputsAssetsAsset_name = joinStakePoolResponseBody202InputsAssetsAsset_name,
                                                                                                                                                                                                                                            joinStakePoolResponseBody202InputsAssetsPolicy_id = joinStakePoolResponseBody202InputsAssetsPolicy_id,
                                                                                                                                                                                                                                            joinStakePoolResponseBody202InputsAssetsQuantity = joinStakePoolResponseBody202InputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.inserted_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Absolute time at which the transaction was inserted in a block.
data JoinStakePoolResponseBody202Inserted_at = JoinStakePoolResponseBody202Inserted_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202Inserted_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202Inserted_atEpoch_number :: GHC.Types.Int
  -- | height
  , joinStakePoolResponseBody202Inserted_atHeight :: JoinStakePoolResponseBody202Inserted_atHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202Inserted_atSlot_number :: GHC.Types.Int
  -- | time
  , joinStakePoolResponseBody202Inserted_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Inserted_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Inserted_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Inserted_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Inserted_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Inserted_at" (\obj -> ((((GHC.Base.pure JoinStakePoolResponseBody202Inserted_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'JoinStakePoolResponseBody202Inserted_at' with all required fields.
mkJoinStakePoolResponseBody202Inserted_at :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Inserted_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Inserted_atEpoch_number'
  -> JoinStakePoolResponseBody202Inserted_atHeight -- ^ 'joinStakePoolResponseBody202Inserted_atHeight'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Inserted_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202Inserted_atTime'
  -> JoinStakePoolResponseBody202Inserted_at
mkJoinStakePoolResponseBody202Inserted_at joinStakePoolResponseBody202Inserted_atAbsolute_slot_number joinStakePoolResponseBody202Inserted_atEpoch_number joinStakePoolResponseBody202Inserted_atHeight joinStakePoolResponseBody202Inserted_atSlot_number joinStakePoolResponseBody202Inserted_atTime = JoinStakePoolResponseBody202Inserted_at{joinStakePoolResponseBody202Inserted_atAbsolute_slot_number = joinStakePoolResponseBody202Inserted_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                 joinStakePoolResponseBody202Inserted_atEpoch_number = joinStakePoolResponseBody202Inserted_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                                 joinStakePoolResponseBody202Inserted_atHeight = joinStakePoolResponseBody202Inserted_atHeight,
                                                                                                                                                                                                                                                                                                                                                 joinStakePoolResponseBody202Inserted_atSlot_number = joinStakePoolResponseBody202Inserted_atSlot_number,
                                                                                                                                                                                                                                                                                                                                                 joinStakePoolResponseBody202Inserted_atTime = joinStakePoolResponseBody202Inserted_atTime}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.inserted_at.properties.height@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202Inserted_atHeight = JoinStakePoolResponseBody202Inserted_atHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202Inserted_atHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Inserted_atHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Inserted_atHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Inserted_atHeight" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202Inserted_atHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202Inserted_atHeight' with all required fields.
mkJoinStakePoolResponseBody202Inserted_atHeight :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Inserted_atHeightQuantity'
  -> JoinStakePoolResponseBody202Inserted_atHeight
mkJoinStakePoolResponseBody202Inserted_atHeight joinStakePoolResponseBody202Inserted_atHeightQuantity = JoinStakePoolResponseBody202Inserted_atHeight{joinStakePoolResponseBody202Inserted_atHeightQuantity = joinStakePoolResponseBody202Inserted_atHeightQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202Mint = JoinStakePoolResponseBody202Mint {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  joinStakePoolResponseBody202MintTokens :: ([JoinStakePoolResponseBody202MintTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , joinStakePoolResponseBody202MintWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , joinStakePoolResponseBody202MintWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Mint
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202MintWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202MintWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Mint
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Mint" (\obj -> ((GHC.Base.pure JoinStakePoolResponseBody202Mint GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'JoinStakePoolResponseBody202Mint' with all required fields.
mkJoinStakePoolResponseBody202Mint :: [JoinStakePoolResponseBody202MintTokens] -- ^ 'joinStakePoolResponseBody202MintTokens'
  -> JoinStakePoolResponseBody202Mint
mkJoinStakePoolResponseBody202Mint joinStakePoolResponseBody202MintTokens = JoinStakePoolResponseBody202Mint{joinStakePoolResponseBody202MintTokens = joinStakePoolResponseBody202MintTokens,
                                                                                                             joinStakePoolResponseBody202MintWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                             joinStakePoolResponseBody202MintWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202MintTokens = JoinStakePoolResponseBody202MintTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  joinStakePoolResponseBody202MintTokensAssets :: ([JoinStakePoolResponseBody202MintTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , joinStakePoolResponseBody202MintTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , joinStakePoolResponseBody202MintTokensPolicy_script :: JoinStakePoolResponseBody202MintTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202MintTokens" (\obj -> ((GHC.Base.pure JoinStakePoolResponseBody202MintTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'JoinStakePoolResponseBody202MintTokens' with all required fields.
mkJoinStakePoolResponseBody202MintTokens :: [JoinStakePoolResponseBody202MintTokensAssets] -- ^ 'joinStakePoolResponseBody202MintTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_id'
  -> JoinStakePoolResponseBody202MintTokensPolicy_scriptVariants -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_script'
  -> JoinStakePoolResponseBody202MintTokens
mkJoinStakePoolResponseBody202MintTokens joinStakePoolResponseBody202MintTokensAssets joinStakePoolResponseBody202MintTokensPolicy_id joinStakePoolResponseBody202MintTokensPolicy_script = JoinStakePoolResponseBody202MintTokens{joinStakePoolResponseBody202MintTokensAssets = joinStakePoolResponseBody202MintTokensAssets,
                                                                                                                                                                                                                                   joinStakePoolResponseBody202MintTokensPolicy_id = joinStakePoolResponseBody202MintTokensPolicy_id,
                                                                                                                                                                                                                                   joinStakePoolResponseBody202MintTokensPolicy_script = joinStakePoolResponseBody202MintTokensPolicy_script}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202MintTokensAssets = JoinStakePoolResponseBody202MintTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  joinStakePoolResponseBody202MintTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , joinStakePoolResponseBody202MintTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202MintTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202MintTokensAssets" (\obj -> ((GHC.Base.pure JoinStakePoolResponseBody202MintTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202MintTokensAssets' with all required fields.
mkJoinStakePoolResponseBody202MintTokensAssets :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202MintTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202MintTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202MintTokensAssetsQuantity'
  -> JoinStakePoolResponseBody202MintTokensAssets
mkJoinStakePoolResponseBody202MintTokensAssets joinStakePoolResponseBody202MintTokensAssetsAsset_name joinStakePoolResponseBody202MintTokensAssetsFingerprint joinStakePoolResponseBody202MintTokensAssetsQuantity = JoinStakePoolResponseBody202MintTokensAssets{joinStakePoolResponseBody202MintTokensAssetsAsset_name = joinStakePoolResponseBody202MintTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                  joinStakePoolResponseBody202MintTokensAssetsFingerprint = joinStakePoolResponseBody202MintTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                  joinStakePoolResponseBody202MintTokensAssetsQuantity = joinStakePoolResponseBody202MintTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1 = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference)
  -- | script
  , joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Script :: JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1' with all required fields.
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1 :: JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Script'
  -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1 joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Script = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1{joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                        joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Script = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference' with all required fields.
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex'
  -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1Reference{joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                       joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2{joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3{joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 :: JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4{joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some{joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                        joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5{joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6{joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants =
   JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
  | JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
  | JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
  | JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
  | JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2 = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info :: JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2' with all required fields.
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2 :: JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info'
  -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2 joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2{joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                             joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference' with all required fields.
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex'
  -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Reference{joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                       joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version :: JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info :: JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_info{joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                   joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3 = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References :: ([JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3' with all required fields.
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3 :: [JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References] -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3Script_hash'
  -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3 joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3Script_hash = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3{joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                 joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3Script_hash = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References' with all required fields.
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex'
  -> JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References
mkJoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex = JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3References{joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                           joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex = joinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202MintTokensPolicy_scriptVariants =
   JoinStakePoolResponseBody202MintTokensPolicy_scriptVariant1 JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf1
  | JoinStakePoolResponseBody202MintTokensPolicy_scriptVariant2 JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf2
  | JoinStakePoolResponseBody202MintTokensPolicy_scriptVariant3 JoinStakePoolResponseBody202MintTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptVariants
    where toJSON (JoinStakePoolResponseBody202MintTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202MintTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody202MintTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202MintTokensPolicy_scriptVariants
    where parseJSON val = case (JoinStakePoolResponseBody202MintTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202MintTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody202MintTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.outputs.items@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202Outputs = JoinStakePoolResponseBody202Outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  joinStakePoolResponseBody202OutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , joinStakePoolResponseBody202OutputsAmount :: JoinStakePoolResponseBody202OutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , joinStakePoolResponseBody202OutputsAssets :: (GHC.Maybe.Maybe ([JoinStakePoolResponseBody202OutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202OutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (joinStakePoolResponseBody202OutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Outputs" (\obj -> ((GHC.Base.pure JoinStakePoolResponseBody202Outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'JoinStakePoolResponseBody202Outputs' with all required fields.
mkJoinStakePoolResponseBody202Outputs :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202OutputsAddress'
  -> JoinStakePoolResponseBody202OutputsAmount -- ^ 'joinStakePoolResponseBody202OutputsAmount'
  -> JoinStakePoolResponseBody202Outputs
mkJoinStakePoolResponseBody202Outputs joinStakePoolResponseBody202OutputsAddress joinStakePoolResponseBody202OutputsAmount = JoinStakePoolResponseBody202Outputs{joinStakePoolResponseBody202OutputsAddress = joinStakePoolResponseBody202OutputsAddress,
                                                                                                                                                                 joinStakePoolResponseBody202OutputsAmount = joinStakePoolResponseBody202OutputsAmount,
                                                                                                                                                                 joinStakePoolResponseBody202OutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data JoinStakePoolResponseBody202OutputsAmount = JoinStakePoolResponseBody202OutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202OutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202OutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202OutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202OutputsAmount" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202OutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202OutputsAmount' with all required fields.
mkJoinStakePoolResponseBody202OutputsAmount :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202OutputsAmountQuantity'
  -> JoinStakePoolResponseBody202OutputsAmount
mkJoinStakePoolResponseBody202OutputsAmount joinStakePoolResponseBody202OutputsAmountQuantity = JoinStakePoolResponseBody202OutputsAmount{joinStakePoolResponseBody202OutputsAmountQuantity = joinStakePoolResponseBody202OutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data JoinStakePoolResponseBody202OutputsAssets = JoinStakePoolResponseBody202OutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  joinStakePoolResponseBody202OutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , joinStakePoolResponseBody202OutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202OutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202OutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202OutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202OutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202OutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202OutputsAssets" (\obj -> ((GHC.Base.pure JoinStakePoolResponseBody202OutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202OutputsAssets' with all required fields.
mkJoinStakePoolResponseBody202OutputsAssets :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202OutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202OutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202OutputsAssetsQuantity'
  -> JoinStakePoolResponseBody202OutputsAssets
mkJoinStakePoolResponseBody202OutputsAssets joinStakePoolResponseBody202OutputsAssetsAsset_name joinStakePoolResponseBody202OutputsAssetsPolicy_id joinStakePoolResponseBody202OutputsAssetsQuantity = JoinStakePoolResponseBody202OutputsAssets{joinStakePoolResponseBody202OutputsAssetsAsset_name = joinStakePoolResponseBody202OutputsAssetsAsset_name,
                                                                                                                                                                                                                                                 joinStakePoolResponseBody202OutputsAssetsPolicy_id = joinStakePoolResponseBody202OutputsAssetsPolicy_id,
                                                                                                                                                                                                                                                 joinStakePoolResponseBody202OutputsAssetsQuantity = joinStakePoolResponseBody202OutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.pending_since@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending
-- \<\/span>\<br\/>
-- The point in time at which a transaction became pending.
data JoinStakePoolResponseBody202Pending_since = JoinStakePoolResponseBody202Pending_since {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202Pending_sinceAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202Pending_sinceEpoch_number :: GHC.Types.Int
  -- | height
  , joinStakePoolResponseBody202Pending_sinceHeight :: JoinStakePoolResponseBody202Pending_sinceHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , joinStakePoolResponseBody202Pending_sinceSlot_number :: GHC.Types.Int
  -- | time
  , joinStakePoolResponseBody202Pending_sinceTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Pending_since
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Pending_sinceTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Pending_sinceTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Pending_since
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Pending_since" (\obj -> ((((GHC.Base.pure JoinStakePoolResponseBody202Pending_since GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'JoinStakePoolResponseBody202Pending_since' with all required fields.
mkJoinStakePoolResponseBody202Pending_since :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Pending_sinceAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Pending_sinceEpoch_number'
  -> JoinStakePoolResponseBody202Pending_sinceHeight -- ^ 'joinStakePoolResponseBody202Pending_sinceHeight'
  -> GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Pending_sinceSlot_number'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202Pending_sinceTime'
  -> JoinStakePoolResponseBody202Pending_since
mkJoinStakePoolResponseBody202Pending_since joinStakePoolResponseBody202Pending_sinceAbsolute_slot_number joinStakePoolResponseBody202Pending_sinceEpoch_number joinStakePoolResponseBody202Pending_sinceHeight joinStakePoolResponseBody202Pending_sinceSlot_number joinStakePoolResponseBody202Pending_sinceTime = JoinStakePoolResponseBody202Pending_since{joinStakePoolResponseBody202Pending_sinceAbsolute_slot_number = joinStakePoolResponseBody202Pending_sinceAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Pending_sinceEpoch_number = joinStakePoolResponseBody202Pending_sinceEpoch_number,
                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Pending_sinceHeight = joinStakePoolResponseBody202Pending_sinceHeight,
                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Pending_sinceSlot_number = joinStakePoolResponseBody202Pending_sinceSlot_number,
                                                                                                                                                                                                                                                                                                                                                               joinStakePoolResponseBody202Pending_sinceTime = joinStakePoolResponseBody202Pending_sinceTime}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.pending_since.properties.height@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202Pending_sinceHeight = JoinStakePoolResponseBody202Pending_sinceHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202Pending_sinceHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Pending_sinceHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Pending_sinceHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Pending_sinceHeight" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202Pending_sinceHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202Pending_sinceHeight' with all required fields.
mkJoinStakePoolResponseBody202Pending_sinceHeight :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Pending_sinceHeightQuantity'
  -> JoinStakePoolResponseBody202Pending_sinceHeight
mkJoinStakePoolResponseBody202Pending_sinceHeight joinStakePoolResponseBody202Pending_sinceHeightQuantity = JoinStakePoolResponseBody202Pending_sinceHeight{joinStakePoolResponseBody202Pending_sinceHeightQuantity = joinStakePoolResponseBody202Pending_sinceHeightQuantity}
-- | Defines the enum schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.script_validity@ in the specification.
-- 
-- Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
-- used in the transaction validated or not. Validity may be null if this
-- transaction was from an era that doesn\'t support phase-2 monetary policy
-- scripts, or is a pending transaction (we don\'t know if validation passed or
-- failed until the transaction hits the ledger).
data JoinStakePoolResponseBody202Script_validityNonNullable =
   JoinStakePoolResponseBody202Script_validityNonNullableOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | JoinStakePoolResponseBody202Script_validityNonNullableTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | JoinStakePoolResponseBody202Script_validityNonNullableEnumValid -- ^ Represents the JSON value @"valid"@
  | JoinStakePoolResponseBody202Script_validityNonNullableEnumInvalid -- ^ Represents the JSON value @"invalid"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Script_validityNonNullable
    where toJSON (JoinStakePoolResponseBody202Script_validityNonNullableOther val) = val
          toJSON (JoinStakePoolResponseBody202Script_validityNonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (JoinStakePoolResponseBody202Script_validityNonNullableEnumValid) = "valid"
          toJSON (JoinStakePoolResponseBody202Script_validityNonNullableEnumInvalid) = "invalid"
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Script_validityNonNullable
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "valid" -> JoinStakePoolResponseBody202Script_validityNonNullableEnumValid
                                            | val GHC.Classes.== "invalid" -> JoinStakePoolResponseBody202Script_validityNonNullableEnumInvalid
                                            | GHC.Base.otherwise -> JoinStakePoolResponseBody202Script_validityNonNullableOther val)
-- | Defines the enum schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.status@ in the specification.
-- 
-- Current transaction status.
-- 
--   \`\`\`
--        *-----------*
--   ---> |  PENDING  |----------------*
--        *-----------*                |
--              |                      |
--              V                      V
--        *-----------*          *-----------*
--        |           |---------->  EXPIRED  |
--        |           |  (ttl)   *-----------*
--        | SUBMITTED |
--        |           \<----------------*
--        |           |                |
--        *-----------*           (rollback)
--               |                     |
--          (in ledger)          *-----------*
--               |               |           |
--               *---------------> IN_LEDGER |
--                               |           |
--                               *-----------*
--   \`\`\`
data JoinStakePoolResponseBody202Status =
   JoinStakePoolResponseBody202StatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | JoinStakePoolResponseBody202StatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | JoinStakePoolResponseBody202StatusEnumPending -- ^ Represents the JSON value @"pending"@
  | JoinStakePoolResponseBody202StatusEnumSubmitted -- ^ Represents the JSON value @"submitted"@
  | JoinStakePoolResponseBody202StatusEnumIn_ledger -- ^ Represents the JSON value @"in_ledger"@
  | JoinStakePoolResponseBody202StatusEnumExpired -- ^ Represents the JSON value @"expired"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Status
    where toJSON (JoinStakePoolResponseBody202StatusOther val) = val
          toJSON (JoinStakePoolResponseBody202StatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (JoinStakePoolResponseBody202StatusEnumPending) = "pending"
          toJSON (JoinStakePoolResponseBody202StatusEnumSubmitted) = "submitted"
          toJSON (JoinStakePoolResponseBody202StatusEnumIn_ledger) = "in_ledger"
          toJSON (JoinStakePoolResponseBody202StatusEnumExpired) = "expired"
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Status
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "pending" -> JoinStakePoolResponseBody202StatusEnumPending
                                            | val GHC.Classes.== "submitted" -> JoinStakePoolResponseBody202StatusEnumSubmitted
                                            | val GHC.Classes.== "in_ledger" -> JoinStakePoolResponseBody202StatusEnumIn_ledger
                                            | val GHC.Classes.== "expired" -> JoinStakePoolResponseBody202StatusEnumExpired
                                            | GHC.Base.otherwise -> JoinStakePoolResponseBody202StatusOther val)
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.validity_interval@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202Validity_interval = JoinStakePoolResponseBody202Validity_interval {
  -- | invalid_before
  joinStakePoolResponseBody202Validity_intervalInvalid_before :: JoinStakePoolResponseBody202Validity_intervalInvalid_before
  -- | invalid_hereafter
  , joinStakePoolResponseBody202Validity_intervalInvalid_hereafter :: JoinStakePoolResponseBody202Validity_intervalInvalid_hereafter
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Validity_interval
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Validity_interval
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Validity_interval" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202Validity_interval GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_before")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_hereafter"))
-- | Create a new 'JoinStakePoolResponseBody202Validity_interval' with all required fields.
mkJoinStakePoolResponseBody202Validity_interval :: JoinStakePoolResponseBody202Validity_intervalInvalid_before -- ^ 'joinStakePoolResponseBody202Validity_intervalInvalid_before'
  -> JoinStakePoolResponseBody202Validity_intervalInvalid_hereafter -- ^ 'joinStakePoolResponseBody202Validity_intervalInvalid_hereafter'
  -> JoinStakePoolResponseBody202Validity_interval
mkJoinStakePoolResponseBody202Validity_interval joinStakePoolResponseBody202Validity_intervalInvalid_before joinStakePoolResponseBody202Validity_intervalInvalid_hereafter = JoinStakePoolResponseBody202Validity_interval{joinStakePoolResponseBody202Validity_intervalInvalid_before = joinStakePoolResponseBody202Validity_intervalInvalid_before,
                                                                                                                                                                                                                           joinStakePoolResponseBody202Validity_intervalInvalid_hereafter = joinStakePoolResponseBody202Validity_intervalInvalid_hereafter}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.validity_interval.properties.invalid_before@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202Validity_intervalInvalid_before = JoinStakePoolResponseBody202Validity_intervalInvalid_before {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202Validity_intervalInvalid_beforeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Validity_intervalInvalid_before
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Validity_intervalInvalid_before
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Validity_intervalInvalid_before" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202Validity_intervalInvalid_before GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202Validity_intervalInvalid_before' with all required fields.
mkJoinStakePoolResponseBody202Validity_intervalInvalid_before :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Validity_intervalInvalid_beforeQuantity'
  -> JoinStakePoolResponseBody202Validity_intervalInvalid_before
mkJoinStakePoolResponseBody202Validity_intervalInvalid_before joinStakePoolResponseBody202Validity_intervalInvalid_beforeQuantity = JoinStakePoolResponseBody202Validity_intervalInvalid_before{joinStakePoolResponseBody202Validity_intervalInvalid_beforeQuantity = joinStakePoolResponseBody202Validity_intervalInvalid_beforeQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.validity_interval.properties.invalid_hereafter@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202Validity_intervalInvalid_hereafter = JoinStakePoolResponseBody202Validity_intervalInvalid_hereafter {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202Validity_intervalInvalid_hereafterQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Validity_intervalInvalid_hereafter
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Validity_intervalInvalid_hereafter
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Validity_intervalInvalid_hereafter" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202Validity_intervalInvalid_hereafter GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202Validity_intervalInvalid_hereafter' with all required fields.
mkJoinStakePoolResponseBody202Validity_intervalInvalid_hereafter :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202Validity_intervalInvalid_hereafterQuantity'
  -> JoinStakePoolResponseBody202Validity_intervalInvalid_hereafter
mkJoinStakePoolResponseBody202Validity_intervalInvalid_hereafter joinStakePoolResponseBody202Validity_intervalInvalid_hereafterQuantity = JoinStakePoolResponseBody202Validity_intervalInvalid_hereafter{joinStakePoolResponseBody202Validity_intervalInvalid_hereafterQuantity = joinStakePoolResponseBody202Validity_intervalInvalid_hereafterQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.withdrawals.items@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody202Withdrawals = JoinStakePoolResponseBody202Withdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  joinStakePoolResponseBody202WithdrawalsAmount :: JoinStakePoolResponseBody202WithdrawalsAmount
  -- | stake_address
  , joinStakePoolResponseBody202WithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202Withdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202WithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202WithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202Withdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202Withdrawals" (\obj -> (GHC.Base.pure JoinStakePoolResponseBody202Withdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'JoinStakePoolResponseBody202Withdrawals' with all required fields.
mkJoinStakePoolResponseBody202Withdrawals :: JoinStakePoolResponseBody202WithdrawalsAmount -- ^ 'joinStakePoolResponseBody202WithdrawalsAmount'
  -> Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody202WithdrawalsStake_address'
  -> JoinStakePoolResponseBody202Withdrawals
mkJoinStakePoolResponseBody202Withdrawals joinStakePoolResponseBody202WithdrawalsAmount joinStakePoolResponseBody202WithdrawalsStake_address = JoinStakePoolResponseBody202Withdrawals{joinStakePoolResponseBody202WithdrawalsAmount = joinStakePoolResponseBody202WithdrawalsAmount,
                                                                                                                                                                                       joinStakePoolResponseBody202WithdrawalsStake_address = joinStakePoolResponseBody202WithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.202.content.application\/json.schema.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data JoinStakePoolResponseBody202WithdrawalsAmount = JoinStakePoolResponseBody202WithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  joinStakePoolResponseBody202WithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody202WithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody202WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody202WithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody202WithdrawalsAmount" (\obj -> GHC.Base.pure JoinStakePoolResponseBody202WithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'JoinStakePoolResponseBody202WithdrawalsAmount' with all required fields.
mkJoinStakePoolResponseBody202WithdrawalsAmount :: GHC.Types.Int -- ^ 'joinStakePoolResponseBody202WithdrawalsAmountQuantity'
  -> JoinStakePoolResponseBody202WithdrawalsAmount
mkJoinStakePoolResponseBody202WithdrawalsAmount joinStakePoolResponseBody202WithdrawalsAmountQuantity = JoinStakePoolResponseBody202WithdrawalsAmount{joinStakePoolResponseBody202WithdrawalsAmountQuantity = joinStakePoolResponseBody202WithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody400 = JoinStakePoolResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  joinStakePoolResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody400" (\obj -> GHC.Base.pure JoinStakePoolResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'JoinStakePoolResponseBody400' with all required fields.
mkJoinStakePoolResponseBody400 :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody400Message'
  -> JoinStakePoolResponseBody400
mkJoinStakePoolResponseBody400 joinStakePoolResponseBody400Message = JoinStakePoolResponseBody400{joinStakePoolResponseBody400Message = joinStakePoolResponseBody400Message}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody403OneOf1 = JoinStakePoolResponseBody403OneOf1 {
  -- | message: May occur when a transaction can\'t be balanced for fees.
  joinStakePoolResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody403OneOf1" (\obj -> GHC.Base.pure JoinStakePoolResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'JoinStakePoolResponseBody403OneOf1' with all required fields.
mkJoinStakePoolResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody403OneOf1Message'
  -> JoinStakePoolResponseBody403OneOf1
mkJoinStakePoolResponseBody403OneOf1 joinStakePoolResponseBody403OneOf1Message = JoinStakePoolResponseBody403OneOf1{joinStakePoolResponseBody403OneOf1Message = joinStakePoolResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody403OneOf2 = JoinStakePoolResponseBody403OneOf2 {
  -- | message: May occur when an action require a signing key but the wallet has only access to verification keys.
  joinStakePoolResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody403OneOf2" (\obj -> GHC.Base.pure JoinStakePoolResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'JoinStakePoolResponseBody403OneOf2' with all required fields.
mkJoinStakePoolResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody403OneOf2Message'
  -> JoinStakePoolResponseBody403OneOf2
mkJoinStakePoolResponseBody403OneOf2 joinStakePoolResponseBody403OneOf2Message = JoinStakePoolResponseBody403OneOf2{joinStakePoolResponseBody403OneOf2Message = joinStakePoolResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody403OneOf3 = JoinStakePoolResponseBody403OneOf3 {
  -- | message: May occur when the given spending passphrase is wrong.
  joinStakePoolResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody403OneOf3" (\obj -> GHC.Base.pure JoinStakePoolResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'JoinStakePoolResponseBody403OneOf3' with all required fields.
mkJoinStakePoolResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody403OneOf3Message'
  -> JoinStakePoolResponseBody403OneOf3
mkJoinStakePoolResponseBody403OneOf3 joinStakePoolResponseBody403OneOf3Message = JoinStakePoolResponseBody403OneOf3{joinStakePoolResponseBody403OneOf3Message = joinStakePoolResponseBody403OneOf3Message}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody403OneOf4 = JoinStakePoolResponseBody403OneOf4 {
  -- | message: May occur when a given poolId matches the current delegation preferences of the wallet\'s account.
  joinStakePoolResponseBody403OneOf4Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody403OneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "pool_already_joined"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "pool_already_joined"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody403OneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody403OneOf4" (\obj -> GHC.Base.pure JoinStakePoolResponseBody403OneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'JoinStakePoolResponseBody403OneOf4' with all required fields.
mkJoinStakePoolResponseBody403OneOf4 :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody403OneOf4Message'
  -> JoinStakePoolResponseBody403OneOf4
mkJoinStakePoolResponseBody403OneOf4 joinStakePoolResponseBody403OneOf4Message = JoinStakePoolResponseBody403OneOf4{joinStakePoolResponseBody403OneOf4Message = joinStakePoolResponseBody403OneOf4Message}
-- | Defines the oneOf schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody403Variants =
   JoinStakePoolResponseBody403Variant1 JoinStakePoolResponseBody403OneOf1
  | JoinStakePoolResponseBody403Variant2 JoinStakePoolResponseBody403OneOf2
  | JoinStakePoolResponseBody403Variant3 JoinStakePoolResponseBody403OneOf3
  | JoinStakePoolResponseBody403Variant4 JoinStakePoolResponseBody403OneOf4
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody403Variants
    where toJSON (JoinStakePoolResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody403Variant4 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody403Variants
    where parseJSON val = case (JoinStakePoolResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody403Variant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.404.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody404OneOf1 = JoinStakePoolResponseBody404OneOf1 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  joinStakePoolResponseBody404OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody404OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody404OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody404OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody404OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody404OneOf1" (\obj -> GHC.Base.pure JoinStakePoolResponseBody404OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'JoinStakePoolResponseBody404OneOf1' with all required fields.
mkJoinStakePoolResponseBody404OneOf1 :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody404OneOf1Message'
  -> JoinStakePoolResponseBody404OneOf1
mkJoinStakePoolResponseBody404OneOf1 joinStakePoolResponseBody404OneOf1Message = JoinStakePoolResponseBody404OneOf1{joinStakePoolResponseBody404OneOf1Message = joinStakePoolResponseBody404OneOf1Message}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.404.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody404OneOf2 = JoinStakePoolResponseBody404OneOf2 {
  -- | message: May occur when a given poolId does not match any known pool.
  joinStakePoolResponseBody404OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody404OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody404OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody404OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody404OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody404OneOf2" (\obj -> GHC.Base.pure JoinStakePoolResponseBody404OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'JoinStakePoolResponseBody404OneOf2' with all required fields.
mkJoinStakePoolResponseBody404OneOf2 :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody404OneOf2Message'
  -> JoinStakePoolResponseBody404OneOf2
mkJoinStakePoolResponseBody404OneOf2 joinStakePoolResponseBody404OneOf2Message = JoinStakePoolResponseBody404OneOf2{joinStakePoolResponseBody404OneOf2Message = joinStakePoolResponseBody404OneOf2Message}
-- | Defines the oneOf schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.404.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody404Variants =
   JoinStakePoolResponseBody404Variant1 JoinStakePoolResponseBody404OneOf1
  | JoinStakePoolResponseBody404Variant2 JoinStakePoolResponseBody404OneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody404Variants
    where toJSON (JoinStakePoolResponseBody404Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (JoinStakePoolResponseBody404Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody404Variants
    where parseJSON val = case (JoinStakePoolResponseBody404Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((JoinStakePoolResponseBody404Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody406 = JoinStakePoolResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  joinStakePoolResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody406" (\obj -> GHC.Base.pure JoinStakePoolResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'JoinStakePoolResponseBody406' with all required fields.
mkJoinStakePoolResponseBody406 :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody406Message'
  -> JoinStakePoolResponseBody406
mkJoinStakePoolResponseBody406 joinStakePoolResponseBody406Message = JoinStakePoolResponseBody406{joinStakePoolResponseBody406Message = joinStakePoolResponseBody406Message}
-- | Defines the object schema located at @paths.\/stake-pools\/{stakePoolId}\/wallets\/{walletId}.PUT.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data JoinStakePoolResponseBody415 = JoinStakePoolResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  joinStakePoolResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON JoinStakePoolResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= joinStakePoolResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON JoinStakePoolResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "JoinStakePoolResponseBody415" (\obj -> GHC.Base.pure JoinStakePoolResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'JoinStakePoolResponseBody415' with all required fields.
mkJoinStakePoolResponseBody415 :: Data.Text.Internal.Text -- ^ 'joinStakePoolResponseBody415Message'
  -> JoinStakePoolResponseBody415
mkJoinStakePoolResponseBody415 joinStakePoolResponseBody415Message = JoinStakePoolResponseBody415{joinStakePoolResponseBody415Message = joinStakePoolResponseBody415Message}
-- | > PUT /stake-pools/{stakePoolId}/wallets/{walletId}
-- 
-- The same as 'joinStakePool' but accepts an explicit configuration.
joinStakePoolWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> JoinStakePoolParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> JoinStakePoolRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response JoinStakePoolResponse) -- ^ Monadic computation which returns the result of the operation
joinStakePoolWithConfiguration config
                               parameters
                               body = GHC.Base.fmap (\response_7 -> GHC.Base.fmap (Data.Either.either JoinStakePoolResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> JoinStakePoolResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                           JoinStakePoolResponseBody202)
                                                                                                                                                                              | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> JoinStakePoolResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                           JoinStakePoolResponseBody400)
                                                                                                                                                                              | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> JoinStakePoolResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                             JoinStakePoolResponseBody403Variants)
                                                                                                                                                                              | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> JoinStakePoolResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                             JoinStakePoolResponseBody404Variants)
                                                                                                                                                                              | (\status_12 -> Network.HTTP.Types.Status.statusCode status_12 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> JoinStakePoolResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                             JoinStakePoolResponseBody406)
                                                                                                                                                                              | (\status_13 -> Network.HTTP.Types.Status.statusCode status_13 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> JoinStakePoolResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                             JoinStakePoolResponseBody415)
                                                                                                                                                                              | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_7) response_7) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/stake-pools/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (joinStakePoolParametersPathStakePoolId parameters))) GHC.Base.<> ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (joinStakePoolParametersPathWalletId parameters))) GHC.Base.<> "")))) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > PUT /stake-pools/{stakePoolId}/wallets/{walletId}
-- 
-- The same as 'joinStakePool' but returns the raw 'Data.ByteString.ByteString'.
joinStakePoolRaw :: forall m . Wallet.Common.MonadHTTP m => JoinStakePoolParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> JoinStakePoolRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
joinStakePoolRaw parameters
                 body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/stake-pools/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (joinStakePoolParametersPathStakePoolId parameters))) GHC.Base.<> ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (joinStakePoolParametersPathWalletId parameters))) GHC.Base.<> "")))) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > PUT /stake-pools/{stakePoolId}/wallets/{walletId}
-- 
-- The same as 'joinStakePool' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
joinStakePoolWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> JoinStakePoolParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> JoinStakePoolRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
joinStakePoolWithConfigurationRaw config
                                  parameters
                                  body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/stake-pools/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (joinStakePoolParametersPathStakePoolId parameters))) GHC.Base.<> ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (joinStakePoolParametersPathWalletId parameters))) GHC.Base.<> "")))) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
