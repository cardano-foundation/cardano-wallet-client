-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation listSharedTransactions
module Wallet.Operations.ListSharedTransactions where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > GET /shared-wallets/{walletId}/transactions
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Lists all incoming and outgoing wallet\'s transactions.
listSharedTransactions :: forall m . Wallet.Common.MonadHTTP m => ListSharedTransactionsParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response ListSharedTransactionsResponse) -- ^ Monadic computation which returns the result of the operation
listSharedTransactions parameters = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either ListSharedTransactionsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ListSharedTransactionsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                           ([ListSharedTransactionsResponseBody200]))
                                                                                                                                                                                     | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> ListSharedTransactionsResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                           ListSharedTransactionsResponseBody400Variants)
                                                                                                                                                                                     | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> ListSharedTransactionsResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                           ListSharedTransactionsResponseBody404)
                                                                                                                                                                                     | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ListSharedTransactionsResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                           ListSharedTransactionsResponseBody406)
                                                                                                                                                                                     | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/shared-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listSharedTransactionsParametersPathWalletId parameters))) GHC.Base.<> "/transactions")) [Wallet.Common.QueryParameter (Data.Text.pack "start") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryStart parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Wallet.Common.QueryParameter (Data.Text.pack "end") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryEnd parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Wallet.Common.QueryParameter (Data.Text.pack "order") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryOrder parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Wallet.Common.QueryParameter (Data.Text.pack "max_count") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryMax_count parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Wallet.Common.QueryParameter (Data.Text.pack "minWithdrawal") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryMinWithdrawal parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          Wallet.Common.QueryParameter (Data.Text.pack "simple-metadata") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQuerySimple_metadata parameters) (Data.Text.pack "form") GHC.Types.False])
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.parameters@ in the specification.
-- 
-- 
data ListSharedTransactionsParameters = ListSharedTransactionsParameters {
  -- | pathWalletId: Represents the parameter named \'walletId\'
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  listSharedTransactionsParametersPathWalletId :: Data.Text.Internal.Text
  -- | queryEnd: Represents the parameter named \'end\'
  -- 
  -- An optional end time in ISO 8601 date-and-time format. Basic and
  -- extended formats are both accepted. Times can be local (with a
  -- timezone offset) or UTC.
  -- 
  -- If both a start time and an end time are specified, then the start
  -- time must not be later than the end time.
  -- 
  -- Example: \`2008-08-08T08:08:08Z\`
  , listSharedTransactionsParametersQueryEnd :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | queryMax_count: Represents the parameter named \'max_count\'
  -- 
  -- An optional maximum count.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 1.0
  , listSharedTransactionsParametersQueryMax_count :: (GHC.Maybe.Maybe GHC.Types.Int)
  -- | queryMinWithdrawal: Represents the parameter named \'minWithdrawal\'
  -- 
  -- Returns only transactions that have at least one withdrawal above the given amount.
  -- This is particularly useful when set to \`1\` in order to list the withdrawal history of a wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 1.0
  , listSharedTransactionsParametersQueryMinWithdrawal :: (GHC.Maybe.Maybe GHC.Types.Int)
  -- | queryOrder: Represents the parameter named \'order\'
  -- 
  -- An optional sort order.
  , listSharedTransactionsParametersQueryOrder :: (GHC.Maybe.Maybe ListSharedTransactionsParametersQueryOrder)
  -- | querySimple-metadata: Represents the parameter named \'simple-metadata\'
  -- 
  -- When present (or equal to true) in the query, the metadata format for the
  -- transaction(s) in the output will be untyped plain json as specified in
  -- [CIP 25](https:\/\/cips.cardano.org\/cips\/cip25\/)
  , listSharedTransactionsParametersQuerySimple_metadata :: (GHC.Maybe.Maybe GHC.Types.Bool)
  -- | queryStart: Represents the parameter named \'start\'
  -- 
  -- An optional start time in ISO 8601 date-and-time format. Basic and
  -- extended formats are both accepted. Times can be local (with a
  -- timezone offset) or UTC.
  -- 
  -- If both a start time and an end time are specified, then the start
  -- time must not be later than the end time.
  -- 
  -- Example: \`2008-08-08T08:08:08Z\`
  , listSharedTransactionsParametersQueryStart :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsParameters
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pathWalletId" Data.Aeson.Types.ToJSON..= listSharedTransactionsParametersPathWalletId obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryEnd" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsParametersQueryEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryMax_count" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsParametersQueryMax_count obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryMinWithdrawal" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsParametersQueryMinWithdrawal obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryOrder" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsParametersQueryOrder obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("querySimple-metadata" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsParametersQuerySimple_metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryStart" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsParametersQueryStart obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pathWalletId" Data.Aeson.Types.ToJSON..= listSharedTransactionsParametersPathWalletId obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryEnd" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsParametersQueryEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryMax_count" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsParametersQueryMax_count obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryMinWithdrawal" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsParametersQueryMinWithdrawal obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryOrder" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsParametersQueryOrder obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("querySimple-metadata" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsParametersQuerySimple_metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryStart" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsParametersQueryStart obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsParameters
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsParameters" (\obj -> ((((((GHC.Base.pure ListSharedTransactionsParameters GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pathWalletId")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "queryEnd")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "queryMax_count")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "queryMinWithdrawal")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "queryOrder")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "querySimple-metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "queryStart"))
-- | Create a new 'ListSharedTransactionsParameters' with all required fields.
mkListSharedTransactionsParameters :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsParametersPathWalletId'
  -> ListSharedTransactionsParameters
mkListSharedTransactionsParameters listSharedTransactionsParametersPathWalletId = ListSharedTransactionsParameters{listSharedTransactionsParametersPathWalletId = listSharedTransactionsParametersPathWalletId,
                                                                                                                   listSharedTransactionsParametersQueryEnd = GHC.Maybe.Nothing,
                                                                                                                   listSharedTransactionsParametersQueryMax_count = GHC.Maybe.Nothing,
                                                                                                                   listSharedTransactionsParametersQueryMinWithdrawal = GHC.Maybe.Nothing,
                                                                                                                   listSharedTransactionsParametersQueryOrder = GHC.Maybe.Nothing,
                                                                                                                   listSharedTransactionsParametersQuerySimple_metadata = GHC.Maybe.Nothing,
                                                                                                                   listSharedTransactionsParametersQueryStart = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.parameters.properties.queryOrder@ in the specification.
-- 
-- Represents the parameter named \'order\'
-- 
-- An optional sort order.
data ListSharedTransactionsParametersQueryOrder =
   ListSharedTransactionsParametersQueryOrderOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListSharedTransactionsParametersQueryOrderTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListSharedTransactionsParametersQueryOrderEnumAscending -- ^ Represents the JSON value @"ascending"@
  | ListSharedTransactionsParametersQueryOrderEnumDescending -- ^ Represents the JSON value @"descending"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsParametersQueryOrder
    where toJSON (ListSharedTransactionsParametersQueryOrderOther val) = val
          toJSON (ListSharedTransactionsParametersQueryOrderTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListSharedTransactionsParametersQueryOrderEnumAscending) = "ascending"
          toJSON (ListSharedTransactionsParametersQueryOrderEnumDescending) = "descending"
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsParametersQueryOrder
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "ascending" -> ListSharedTransactionsParametersQueryOrderEnumAscending
                                            | val GHC.Classes.== "descending" -> ListSharedTransactionsParametersQueryOrderEnumDescending
                                            | GHC.Base.otherwise -> ListSharedTransactionsParametersQueryOrderOther val)
-- | Represents a response of the operation 'listSharedTransactions'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'ListSharedTransactionsResponseError' is used.
data ListSharedTransactionsResponse =
   ListSharedTransactionsResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | ListSharedTransactionsResponse200 ([ListSharedTransactionsResponseBody200]) -- ^ Ok
  | ListSharedTransactionsResponse400 ListSharedTransactionsResponseBody400Variants -- ^ Bad Request
  | ListSharedTransactionsResponse404 ListSharedTransactionsResponseBody404 -- ^ Not Found
  | ListSharedTransactionsResponse406 ListSharedTransactionsResponseBody406 -- ^ Not Acceptable
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200 = ListSharedTransactionsResponseBody200 {
  -- | amount: An amount of Ada spent or received, from the perspective of the wallet.
  -- 
  -- That is, for outgoing transaction, it represents the amount of Ada consumed
  -- as inputs including the amount of Ada spent as fees or deposits.
  -- 
  -- For incoming transaction, it represents the total amount of Ada received to
  -- addresses that belong to the wallet.
  listSharedTransactionsResponseBody200Amount :: ListSharedTransactionsResponseBody200Amount
  -- | burn
  , listSharedTransactionsResponseBody200Burn :: (GHC.Maybe.Maybe ListSharedTransactionsResponseBody200Burn)
  -- | certificates
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listSharedTransactionsResponseBody200Certificates :: (GHC.Maybe.Maybe ([ListSharedTransactionsResponseBody200CertificatesVariants]))
  -- | collateral: A list of transaction inputs used for collateral.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listSharedTransactionsResponseBody200Collateral :: (GHC.Maybe.Maybe ([ListSharedTransactionsResponseBody200Collateral]))
  -- | collateral_outputs: A list of collateral return outputs with amounts specified.
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 1 items
  -- * Must have a minimum of 0 items
  , listSharedTransactionsResponseBody200Collateral_outputs :: (GHC.Maybe.Maybe ([ListSharedTransactionsResponseBody200Collateral_outputs]))
  -- | deposit_returned: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listSharedTransactionsResponseBody200Deposit_returned :: ListSharedTransactionsResponseBody200Deposit_returned
  -- | deposit_taken: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listSharedTransactionsResponseBody200Deposit_taken :: ListSharedTransactionsResponseBody200Deposit_taken
  -- | depth: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Current depth of the transaction in the local chain
  , listSharedTransactionsResponseBody200Depth :: (GHC.Maybe.Maybe ListSharedTransactionsResponseBody200Depth)
  -- | direction
  , listSharedTransactionsResponseBody200Direction :: ListSharedTransactionsResponseBody200Direction
  -- | expires_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending OR status == expired
  -- \<\/span>\<br\/>
  -- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
  , listSharedTransactionsResponseBody200Expires_at :: (GHC.Maybe.Maybe ListSharedTransactionsResponseBody200Expires_at)
  -- | extra_signatures
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listSharedTransactionsResponseBody200Extra_signatures :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | fee: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listSharedTransactionsResponseBody200Fee :: ListSharedTransactionsResponseBody200Fee
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , listSharedTransactionsResponseBody200Id :: Data.Text.Internal.Text
  -- | inputs: A list of transaction inputs.
  -- 
  -- \`assets\` and \`address\` are always present for \`outgoing\`
  -- transactions but generally absent for \`incoming\`
  -- transactions. This information is present on the Cardano explorer,
  -- but is not tracked by the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listSharedTransactionsResponseBody200Inputs :: ([ListSharedTransactionsResponseBody200Inputs])
  -- | inserted_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Absolute time at which the transaction was inserted in a block.
  , listSharedTransactionsResponseBody200Inserted_at :: (GHC.Maybe.Maybe ListSharedTransactionsResponseBody200Inserted_at)
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  , listSharedTransactionsResponseBody200Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | mint
  , listSharedTransactionsResponseBody200Mint :: (GHC.Maybe.Maybe ListSharedTransactionsResponseBody200Mint)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listSharedTransactionsResponseBody200Outputs :: ([ListSharedTransactionsResponseBody200Outputs])
  -- | pending_since: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending
  -- \<\/span>\<br\/>
  -- The point in time at which a transaction became pending.
  , listSharedTransactionsResponseBody200Pending_since :: (GHC.Maybe.Maybe ListSharedTransactionsResponseBody200Pending_since)
  -- | script_integrity: A script data integrity hash - 32 bytes
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^(script_data)1[0-9a-z]*\$\'
  , listSharedTransactionsResponseBody200Script_integrity :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | script_validity: Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
  -- used in the transaction validated or not. Validity may be null if this
  -- transaction was from an era that doesn\'t support phase-2 monetary policy
  -- scripts, or is a pending transaction (we don\'t know if validation passed or
  -- failed until the transaction hits the ledger).
  , listSharedTransactionsResponseBody200Script_validity :: (GHC.Maybe.Maybe (Wallet.Common.Nullable ListSharedTransactionsResponseBody200Script_validityNonNullable))
  -- | status: Current transaction status.
  -- 
  --   \`\`\`
  --        *-----------*
  --   ---> |  PENDING  |----------------*
  --        *-----------*                |
  --              |                      |
  --              V                      V
  --        *-----------*          *-----------*
  --        |           |---------->  EXPIRED  |
  --        |           |  (ttl)   *-----------*
  --        | SUBMITTED |
  --        |           \<----------------*
  --        |           |                |
  --        *-----------*           (rollback)
  --               |                     |
  --          (in ledger)          *-----------*
  --               |               |           |
  --               *---------------> IN_LEDGER |
  --                               |           |
  --                               *-----------*
  --   \`\`\`
  , listSharedTransactionsResponseBody200Status :: ListSharedTransactionsResponseBody200Status
  -- | validity_interval
  , listSharedTransactionsResponseBody200Validity_interval :: (GHC.Maybe.Maybe ListSharedTransactionsResponseBody200Validity_interval)
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listSharedTransactionsResponseBody200Withdrawals :: ([ListSharedTransactionsResponseBody200Withdrawals])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Fee obj] : ["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Withdrawals obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Fee obj] : ["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Withdrawals obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200" (\obj -> (((((((((((((((((((((((GHC.Base.pure ListSharedTransactionsResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "burn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral_outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "depth")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "direction")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "expires_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "extra_signatures")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fee")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "inserted_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pending_since")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_integrity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_validity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "validity_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "withdrawals"))
-- | Create a new 'ListSharedTransactionsResponseBody200' with all required fields.
mkListSharedTransactionsResponseBody200 :: ListSharedTransactionsResponseBody200Amount -- ^ 'listSharedTransactionsResponseBody200Amount'
  -> ListSharedTransactionsResponseBody200Deposit_returned -- ^ 'listSharedTransactionsResponseBody200Deposit_returned'
  -> ListSharedTransactionsResponseBody200Deposit_taken -- ^ 'listSharedTransactionsResponseBody200Deposit_taken'
  -> ListSharedTransactionsResponseBody200Direction -- ^ 'listSharedTransactionsResponseBody200Direction'
  -> ListSharedTransactionsResponseBody200Fee -- ^ 'listSharedTransactionsResponseBody200Fee'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200Id'
  -> [ListSharedTransactionsResponseBody200Inputs] -- ^ 'listSharedTransactionsResponseBody200Inputs'
  -> [ListSharedTransactionsResponseBody200Outputs] -- ^ 'listSharedTransactionsResponseBody200Outputs'
  -> ListSharedTransactionsResponseBody200Status -- ^ 'listSharedTransactionsResponseBody200Status'
  -> [ListSharedTransactionsResponseBody200Withdrawals] -- ^ 'listSharedTransactionsResponseBody200Withdrawals'
  -> ListSharedTransactionsResponseBody200
mkListSharedTransactionsResponseBody200 listSharedTransactionsResponseBody200Amount listSharedTransactionsResponseBody200Deposit_returned listSharedTransactionsResponseBody200Deposit_taken listSharedTransactionsResponseBody200Direction listSharedTransactionsResponseBody200Fee listSharedTransactionsResponseBody200Id listSharedTransactionsResponseBody200Inputs listSharedTransactionsResponseBody200Outputs listSharedTransactionsResponseBody200Status listSharedTransactionsResponseBody200Withdrawals = ListSharedTransactionsResponseBody200{listSharedTransactionsResponseBody200Amount = listSharedTransactionsResponseBody200Amount,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Burn = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Certificates = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Collateral = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Collateral_outputs = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Deposit_returned = listSharedTransactionsResponseBody200Deposit_returned,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Deposit_taken = listSharedTransactionsResponseBody200Deposit_taken,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Depth = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Direction = listSharedTransactionsResponseBody200Direction,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Expires_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Extra_signatures = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Fee = listSharedTransactionsResponseBody200Fee,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Id = listSharedTransactionsResponseBody200Id,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Inputs = listSharedTransactionsResponseBody200Inputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Inserted_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Mint = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Outputs = listSharedTransactionsResponseBody200Outputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Pending_since = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Script_integrity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Script_validity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Status = listSharedTransactionsResponseBody200Status,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Validity_interval = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200Withdrawals = listSharedTransactionsResponseBody200Withdrawals}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.amount@ in the specification.
-- 
-- An amount of Ada spent or received, from the perspective of the wallet.
-- 
-- That is, for outgoing transaction, it represents the amount of Ada consumed
-- as inputs including the amount of Ada spent as fees or deposits.
-- 
-- For incoming transaction, it represents the total amount of Ada received to
-- addresses that belong to the wallet.
data ListSharedTransactionsResponseBody200Amount = ListSharedTransactionsResponseBody200Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Amount" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200Amount' with all required fields.
mkListSharedTransactionsResponseBody200Amount :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200AmountQuantity'
  -> ListSharedTransactionsResponseBody200Amount
mkListSharedTransactionsResponseBody200Amount listSharedTransactionsResponseBody200AmountQuantity = ListSharedTransactionsResponseBody200Amount{listSharedTransactionsResponseBody200AmountQuantity = listSharedTransactionsResponseBody200AmountQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200Burn = ListSharedTransactionsResponseBody200Burn {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  listSharedTransactionsResponseBody200BurnTokens :: ([ListSharedTransactionsResponseBody200BurnTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , listSharedTransactionsResponseBody200BurnWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , listSharedTransactionsResponseBody200BurnWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200BurnWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200BurnWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Burn" (\obj -> ((GHC.Base.pure ListSharedTransactionsResponseBody200Burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'ListSharedTransactionsResponseBody200Burn' with all required fields.
mkListSharedTransactionsResponseBody200Burn :: [ListSharedTransactionsResponseBody200BurnTokens] -- ^ 'listSharedTransactionsResponseBody200BurnTokens'
  -> ListSharedTransactionsResponseBody200Burn
mkListSharedTransactionsResponseBody200Burn listSharedTransactionsResponseBody200BurnTokens = ListSharedTransactionsResponseBody200Burn{listSharedTransactionsResponseBody200BurnTokens = listSharedTransactionsResponseBody200BurnTokens,
                                                                                                                                        listSharedTransactionsResponseBody200BurnWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                                        listSharedTransactionsResponseBody200BurnWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200BurnTokens = ListSharedTransactionsResponseBody200BurnTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listSharedTransactionsResponseBody200BurnTokensAssets :: ([ListSharedTransactionsResponseBody200BurnTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listSharedTransactionsResponseBody200BurnTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , listSharedTransactionsResponseBody200BurnTokensPolicy_script :: ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200BurnTokens" (\obj -> ((GHC.Base.pure ListSharedTransactionsResponseBody200BurnTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'ListSharedTransactionsResponseBody200BurnTokens' with all required fields.
mkListSharedTransactionsResponseBody200BurnTokens :: [ListSharedTransactionsResponseBody200BurnTokensAssets] -- ^ 'listSharedTransactionsResponseBody200BurnTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_id'
  -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptVariants -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_script'
  -> ListSharedTransactionsResponseBody200BurnTokens
mkListSharedTransactionsResponseBody200BurnTokens listSharedTransactionsResponseBody200BurnTokensAssets listSharedTransactionsResponseBody200BurnTokensPolicy_id listSharedTransactionsResponseBody200BurnTokensPolicy_script = ListSharedTransactionsResponseBody200BurnTokens{listSharedTransactionsResponseBody200BurnTokensAssets = listSharedTransactionsResponseBody200BurnTokensAssets,
                                                                                                                                                                                                                                                                                listSharedTransactionsResponseBody200BurnTokensPolicy_id = listSharedTransactionsResponseBody200BurnTokensPolicy_id,
                                                                                                                                                                                                                                                                                listSharedTransactionsResponseBody200BurnTokensPolicy_script = listSharedTransactionsResponseBody200BurnTokensPolicy_script}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200BurnTokensAssets = ListSharedTransactionsResponseBody200BurnTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listSharedTransactionsResponseBody200BurnTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , listSharedTransactionsResponseBody200BurnTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200BurnTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200BurnTokensAssets" (\obj -> ((GHC.Base.pure ListSharedTransactionsResponseBody200BurnTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200BurnTokensAssets' with all required fields.
mkListSharedTransactionsResponseBody200BurnTokensAssets :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200BurnTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200BurnTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200BurnTokensAssetsQuantity'
  -> ListSharedTransactionsResponseBody200BurnTokensAssets
mkListSharedTransactionsResponseBody200BurnTokensAssets listSharedTransactionsResponseBody200BurnTokensAssetsAsset_name listSharedTransactionsResponseBody200BurnTokensAssetsFingerprint listSharedTransactionsResponseBody200BurnTokensAssetsQuantity = ListSharedTransactionsResponseBody200BurnTokensAssets{listSharedTransactionsResponseBody200BurnTokensAssetsAsset_name = listSharedTransactionsResponseBody200BurnTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                                               listSharedTransactionsResponseBody200BurnTokensAssetsFingerprint = listSharedTransactionsResponseBody200BurnTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                                               listSharedTransactionsResponseBody200BurnTokensAssetsQuantity = listSharedTransactionsResponseBody200BurnTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1 = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference)
  -- | script
  , listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script :: ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1' with all required fields.
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1 :: ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script'
  -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1 listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1{listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                                   listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference' with all required fields.
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex'
  -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference{listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2{listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3{listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 :: ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4{listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some{listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                                            listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5{listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6{listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants =
   ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant2 ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
  | ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant3 ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
  | ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant4 ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
  | ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant5 ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
  | ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant6 ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2 = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info :: ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2' with all required fields.
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2 :: ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info'
  -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2 listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2{listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                                        listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference' with all required fields.
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex'
  -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference{listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version :: ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info :: ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info{listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                                                       listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3 = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References :: ([ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3' with all required fields.
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3 :: [ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References] -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash'
  -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3 listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3{listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                                                     listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References' with all required fields.
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex'
  -> ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References
mkListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex = ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References{listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                                               listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex = listSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptVariants =
   ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptVariant1 ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1
  | ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptVariant2 ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2
  | ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptVariant3 ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptVariants
    where toJSON (ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptVariants
    where parseJSON val = case (ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200BurnTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data ListSharedTransactionsResponseBody200CertificatesOneOf1 = ListSharedTransactionsResponseBody200CertificatesOneOf1 {
  -- | certificate_type
  listSharedTransactionsResponseBody200CertificatesOneOf1Certificate_type :: ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_type
  -- | pool: A unique identifier for the pool.
  , listSharedTransactionsResponseBody200CertificatesOneOf1Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , listSharedTransactionsResponseBody200CertificatesOneOf1Reward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200CertificatesOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200CertificatesOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200CertificatesOneOf1" (\obj -> ((GHC.Base.pure ListSharedTransactionsResponseBody200CertificatesOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'ListSharedTransactionsResponseBody200CertificatesOneOf1' with all required fields.
mkListSharedTransactionsResponseBody200CertificatesOneOf1 :: ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_type -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf1Certificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf1Reward_account_path'
  -> ListSharedTransactionsResponseBody200CertificatesOneOf1
mkListSharedTransactionsResponseBody200CertificatesOneOf1 listSharedTransactionsResponseBody200CertificatesOneOf1Certificate_type listSharedTransactionsResponseBody200CertificatesOneOf1Reward_account_path = ListSharedTransactionsResponseBody200CertificatesOneOf1{listSharedTransactionsResponseBody200CertificatesOneOf1Certificate_type = listSharedTransactionsResponseBody200CertificatesOneOf1Certificate_type,
                                                                                                                                                                                                                                                                       listSharedTransactionsResponseBody200CertificatesOneOf1Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                       listSharedTransactionsResponseBody200CertificatesOneOf1Reward_account_path = listSharedTransactionsResponseBody200CertificatesOneOf1Reward_account_path}
-- | Defines the enum schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_type =
   ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_type
    where toJSON (ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_typeOther val) = val
          toJSON (ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumJoin_pool) = "join_pool"
          toJSON (ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> ListSharedTransactionsResponseBody200CertificatesOneOf1Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate not belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data ListSharedTransactionsResponseBody200CertificatesOneOf2 = ListSharedTransactionsResponseBody200CertificatesOneOf2 {
  -- | certificate_type
  listSharedTransactionsResponseBody200CertificatesOneOf2Certificate_type :: ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_type
  -- | pool: A unique identifier for the pool.
  , listSharedTransactionsResponseBody200CertificatesOneOf2Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account
  , listSharedTransactionsResponseBody200CertificatesOneOf2Reward_account :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200CertificatesOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf2Reward_account obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf2Reward_account obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200CertificatesOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200CertificatesOneOf2" (\obj -> ((GHC.Base.pure ListSharedTransactionsResponseBody200CertificatesOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account"))
-- | Create a new 'ListSharedTransactionsResponseBody200CertificatesOneOf2' with all required fields.
mkListSharedTransactionsResponseBody200CertificatesOneOf2 :: ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_type -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf2Certificate_type'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf2Reward_account'
  -> ListSharedTransactionsResponseBody200CertificatesOneOf2
mkListSharedTransactionsResponseBody200CertificatesOneOf2 listSharedTransactionsResponseBody200CertificatesOneOf2Certificate_type listSharedTransactionsResponseBody200CertificatesOneOf2Reward_account = ListSharedTransactionsResponseBody200CertificatesOneOf2{listSharedTransactionsResponseBody200CertificatesOneOf2Certificate_type = listSharedTransactionsResponseBody200CertificatesOneOf2Certificate_type,
                                                                                                                                                                                                                                                                  listSharedTransactionsResponseBody200CertificatesOneOf2Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                  listSharedTransactionsResponseBody200CertificatesOneOf2Reward_account = listSharedTransactionsResponseBody200CertificatesOneOf2Reward_account}
-- | Defines the enum schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_type =
   ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumJoin_pool_external -- ^ Represents the JSON value @"join_pool_external"@
  | ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumQuit_pool_external -- ^ Represents the JSON value @"quit_pool_external"@
  | ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external -- ^ Represents the JSON value @"register_reward_account_external"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_type
    where toJSON (ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_typeOther val) = val
          toJSON (ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumJoin_pool_external) = "join_pool_external"
          toJSON (ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumQuit_pool_external) = "quit_pool_external"
          toJSON (ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external) = "register_reward_account_external"
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool_external" -> ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumJoin_pool_external
                                            | val GHC.Classes.== "quit_pool_external" -> ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumQuit_pool_external
                                            | val GHC.Classes.== "register_reward_account_external" -> ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external
                                            | GHC.Base.otherwise -> ListSharedTransactionsResponseBody200CertificatesOneOf2Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200CertificatesOneOf3 = ListSharedTransactionsResponseBody200CertificatesOneOf3 {
  -- | pool_cost: Estimated cost set by the pool operator when registering his pool.
  -- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  listSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost :: ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost
  -- | pool_id: A unique identifier for the pool.
  , listSharedTransactionsResponseBody200CertificatesOneOf3Pool_id :: Data.Text.Internal.Text
  -- | pool_margin: Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , listSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin :: ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin
  -- | pool_metadata
  , listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata :: (GHC.Maybe.Maybe ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata)
  -- | pool_owners
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listSharedTransactionsResponseBody200CertificatesOneOf3Pool_owners :: ([Data.Text.Internal.Text])
  -- | pool_pledge: Minimal stake amount that a stake pool is willing to honor.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , listSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge :: ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200CertificatesOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200CertificatesOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200CertificatesOneOf3" (\obj -> (((((GHC.Base.pure ListSharedTransactionsResponseBody200CertificatesOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_cost")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_margin")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool_metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_owners")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_pledge"))
-- | Create a new 'ListSharedTransactionsResponseBody200CertificatesOneOf3' with all required fields.
mkListSharedTransactionsResponseBody200CertificatesOneOf3 :: ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf3Pool_id'
  -> ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin'
  -> [Data.Text.Internal.Text] -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf3Pool_owners'
  -> ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge'
  -> ListSharedTransactionsResponseBody200CertificatesOneOf3
mkListSharedTransactionsResponseBody200CertificatesOneOf3 listSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost listSharedTransactionsResponseBody200CertificatesOneOf3Pool_id listSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin listSharedTransactionsResponseBody200CertificatesOneOf3Pool_owners listSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge = ListSharedTransactionsResponseBody200CertificatesOneOf3{listSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost = listSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost,
                                                                                                                                                                                                                                                                                                                                                                                                                                                             listSharedTransactionsResponseBody200CertificatesOneOf3Pool_id = listSharedTransactionsResponseBody200CertificatesOneOf3Pool_id,
                                                                                                                                                                                                                                                                                                                                                                                                                                                             listSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin = listSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin,
                                                                                                                                                                                                                                                                                                                                                                                                                                                             listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                             listSharedTransactionsResponseBody200CertificatesOneOf3Pool_owners = listSharedTransactionsResponseBody200CertificatesOneOf3Pool_owners,
                                                                                                                                                                                                                                                                                                                                                                                                                                                             listSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge = listSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_cost@ in the specification.
-- 
-- Estimated cost set by the pool operator when registering his pool.
-- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost = ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost' with all required fields.
mkListSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity'
  -> ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost
mkListSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost listSharedTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity = ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_cost{listSharedTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity = listSharedTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_margin@ in the specification.
-- 
-- Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin = ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin' with all required fields.
mkListSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin :: GHC.Types.Double -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity'
  -> ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin
mkListSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin listSharedTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity = ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_margin{listSharedTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity = listSharedTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_metadata@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata = ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata {
  -- | hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash :: Data.Text.Internal.Text
  -- | url: A URL to the stake pool\'s website.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 250
  -- * Must match pattern \'^https:\/\/.+\'
  , listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))
-- | Create a new 'ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata' with all required fields.
mkListSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl'
  -> ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata
mkListSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl = ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadata{listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash = listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash,
                                                                                                                                                                                                                                                                                               listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl = listSharedTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_pledge@ in the specification.
-- 
-- Minimal stake amount that a stake pool is willing to honor.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge = ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge' with all required fields.
mkListSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity'
  -> ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge
mkListSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge listSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity = ListSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledge{listSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity = listSharedTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200CertificatesOneOf4 = ListSharedTransactionsResponseBody200CertificatesOneOf4 {
  -- | pool_id: A unique identifier for the pool.
  listSharedTransactionsResponseBody200CertificatesOneOf4Pool_id :: Data.Text.Internal.Text
  -- | retirement_epoch: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200CertificatesOneOf4Retirement_epoch :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200CertificatesOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200CertificatesOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200CertificatesOneOf4" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200CertificatesOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "retirement_epoch"))
-- | Create a new 'ListSharedTransactionsResponseBody200CertificatesOneOf4' with all required fields.
mkListSharedTransactionsResponseBody200CertificatesOneOf4 :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf4Pool_id'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf4Retirement_epoch'
  -> ListSharedTransactionsResponseBody200CertificatesOneOf4
mkListSharedTransactionsResponseBody200CertificatesOneOf4 listSharedTransactionsResponseBody200CertificatesOneOf4Pool_id listSharedTransactionsResponseBody200CertificatesOneOf4Retirement_epoch = ListSharedTransactionsResponseBody200CertificatesOneOf4{listSharedTransactionsResponseBody200CertificatesOneOf4Pool_id = listSharedTransactionsResponseBody200CertificatesOneOf4Pool_id,
                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200CertificatesOneOf4Retirement_epoch = listSharedTransactionsResponseBody200CertificatesOneOf4Retirement_epoch}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200CertificatesOneOf5 = ListSharedTransactionsResponseBody200CertificatesOneOf5 {
  -- | certificate_type
  listSharedTransactionsResponseBody200CertificatesOneOf5Certificate_type :: ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_type
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200CertificatesOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200CertificatesOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200CertificatesOneOf5" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200CertificatesOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type"))
-- | Create a new 'ListSharedTransactionsResponseBody200CertificatesOneOf5' with all required fields.
mkListSharedTransactionsResponseBody200CertificatesOneOf5 :: ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_type -- ^ 'listSharedTransactionsResponseBody200CertificatesOneOf5Certificate_type'
  -> ListSharedTransactionsResponseBody200CertificatesOneOf5
mkListSharedTransactionsResponseBody200CertificatesOneOf5 listSharedTransactionsResponseBody200CertificatesOneOf5Certificate_type = ListSharedTransactionsResponseBody200CertificatesOneOf5{listSharedTransactionsResponseBody200CertificatesOneOf5Certificate_type = listSharedTransactionsResponseBody200CertificatesOneOf5Certificate_type}
-- | Defines the enum schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_type =
   ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumMir -- ^ Represents the JSON value @"mir"@
  | ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumGenesis -- ^ Represents the JSON value @"genesis"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_type
    where toJSON (ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_typeOther val) = val
          toJSON (ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumMir) = "mir"
          toJSON (ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumGenesis) = "genesis"
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "mir" -> ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumMir
                                            | val GHC.Classes.== "genesis" -> ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumGenesis
                                            | GHC.Base.otherwise -> ListSharedTransactionsResponseBody200CertificatesOneOf5Certificate_typeOther val)
-- | Defines the oneOf schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- Any certificate that could occur in an arbitrary transaction:
-- might be related to delegation, pool activities, genesis or MIR.
data ListSharedTransactionsResponseBody200CertificatesVariants =
   ListSharedTransactionsResponseBody200CertificatesVariant1 ListSharedTransactionsResponseBody200CertificatesOneOf1
  | ListSharedTransactionsResponseBody200CertificatesVariant2 ListSharedTransactionsResponseBody200CertificatesOneOf2
  | ListSharedTransactionsResponseBody200CertificatesVariant3 ListSharedTransactionsResponseBody200CertificatesOneOf3
  | ListSharedTransactionsResponseBody200CertificatesVariant4 ListSharedTransactionsResponseBody200CertificatesOneOf4
  | ListSharedTransactionsResponseBody200CertificatesVariant5 ListSharedTransactionsResponseBody200CertificatesOneOf5
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200CertificatesVariants
    where toJSON (ListSharedTransactionsResponseBody200CertificatesVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200CertificatesVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200CertificatesVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200CertificatesVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200CertificatesVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200CertificatesVariants
    where parseJSON val = case (ListSharedTransactionsResponseBody200CertificatesVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200CertificatesVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200CertificatesVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200CertificatesVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200CertificatesVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.collateral.items@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200Collateral = ListSharedTransactionsResponseBody200Collateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  listSharedTransactionsResponseBody200CollateralAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listSharedTransactionsResponseBody200CollateralAmount :: (GHC.Maybe.Maybe ListSharedTransactionsResponseBody200CollateralAmount)
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , listSharedTransactionsResponseBody200CollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200CollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Collateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Collateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Collateral" (\obj -> (((GHC.Base.pure ListSharedTransactionsResponseBody200Collateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListSharedTransactionsResponseBody200Collateral' with all required fields.
mkListSharedTransactionsResponseBody200Collateral :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200CollateralId'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200CollateralIndex'
  -> ListSharedTransactionsResponseBody200Collateral
mkListSharedTransactionsResponseBody200Collateral listSharedTransactionsResponseBody200CollateralId listSharedTransactionsResponseBody200CollateralIndex = ListSharedTransactionsResponseBody200Collateral{listSharedTransactionsResponseBody200CollateralAddress = GHC.Maybe.Nothing,
                                                                                                                                                                                                           listSharedTransactionsResponseBody200CollateralAmount = GHC.Maybe.Nothing,
                                                                                                                                                                                                           listSharedTransactionsResponseBody200CollateralId = listSharedTransactionsResponseBody200CollateralId,
                                                                                                                                                                                                           listSharedTransactionsResponseBody200CollateralIndex = listSharedTransactionsResponseBody200CollateralIndex}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListSharedTransactionsResponseBody200CollateralAmount = ListSharedTransactionsResponseBody200CollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200CollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200CollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200CollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200CollateralAmount" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200CollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200CollateralAmount' with all required fields.
mkListSharedTransactionsResponseBody200CollateralAmount :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200CollateralAmountQuantity'
  -> ListSharedTransactionsResponseBody200CollateralAmount
mkListSharedTransactionsResponseBody200CollateralAmount listSharedTransactionsResponseBody200CollateralAmountQuantity = ListSharedTransactionsResponseBody200CollateralAmount{listSharedTransactionsResponseBody200CollateralAmountQuantity = listSharedTransactionsResponseBody200CollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.collateral_outputs.items@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200Collateral_outputs = ListSharedTransactionsResponseBody200Collateral_outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  listSharedTransactionsResponseBody200Collateral_outputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listSharedTransactionsResponseBody200Collateral_outputsAmount :: ListSharedTransactionsResponseBody200Collateral_outputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , listSharedTransactionsResponseBody200Collateral_outputsAssets :: (GHC.Maybe.Maybe ([ListSharedTransactionsResponseBody200Collateral_outputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Collateral_outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Collateral_outputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200Collateral_outputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Collateral_outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Collateral_outputs" (\obj -> ((GHC.Base.pure ListSharedTransactionsResponseBody200Collateral_outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'ListSharedTransactionsResponseBody200Collateral_outputs' with all required fields.
mkListSharedTransactionsResponseBody200Collateral_outputs :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200Collateral_outputsAddress'
  -> ListSharedTransactionsResponseBody200Collateral_outputsAmount -- ^ 'listSharedTransactionsResponseBody200Collateral_outputsAmount'
  -> ListSharedTransactionsResponseBody200Collateral_outputs
mkListSharedTransactionsResponseBody200Collateral_outputs listSharedTransactionsResponseBody200Collateral_outputsAddress listSharedTransactionsResponseBody200Collateral_outputsAmount = ListSharedTransactionsResponseBody200Collateral_outputs{listSharedTransactionsResponseBody200Collateral_outputsAddress = listSharedTransactionsResponseBody200Collateral_outputsAddress,
                                                                                                                                                                                                                                                 listSharedTransactionsResponseBody200Collateral_outputsAmount = listSharedTransactionsResponseBody200Collateral_outputsAmount,
                                                                                                                                                                                                                                                 listSharedTransactionsResponseBody200Collateral_outputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.collateral_outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListSharedTransactionsResponseBody200Collateral_outputsAmount = ListSharedTransactionsResponseBody200Collateral_outputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200Collateral_outputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Collateral_outputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Collateral_outputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Collateral_outputsAmount" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200Collateral_outputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200Collateral_outputsAmount' with all required fields.
mkListSharedTransactionsResponseBody200Collateral_outputsAmount :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Collateral_outputsAmountQuantity'
  -> ListSharedTransactionsResponseBody200Collateral_outputsAmount
mkListSharedTransactionsResponseBody200Collateral_outputsAmount listSharedTransactionsResponseBody200Collateral_outputsAmountQuantity = ListSharedTransactionsResponseBody200Collateral_outputsAmount{listSharedTransactionsResponseBody200Collateral_outputsAmountQuantity = listSharedTransactionsResponseBody200Collateral_outputsAmountQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.collateral_outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ListSharedTransactionsResponseBody200Collateral_outputsAssets = ListSharedTransactionsResponseBody200Collateral_outputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listSharedTransactionsResponseBody200Collateral_outputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listSharedTransactionsResponseBody200Collateral_outputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200Collateral_outputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Collateral_outputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Collateral_outputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Collateral_outputsAssets" (\obj -> ((GHC.Base.pure ListSharedTransactionsResponseBody200Collateral_outputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200Collateral_outputsAssets' with all required fields.
mkListSharedTransactionsResponseBody200Collateral_outputsAssets :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200Collateral_outputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200Collateral_outputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Collateral_outputsAssetsQuantity'
  -> ListSharedTransactionsResponseBody200Collateral_outputsAssets
mkListSharedTransactionsResponseBody200Collateral_outputsAssets listSharedTransactionsResponseBody200Collateral_outputsAssetsAsset_name listSharedTransactionsResponseBody200Collateral_outputsAssetsPolicy_id listSharedTransactionsResponseBody200Collateral_outputsAssetsQuantity = ListSharedTransactionsResponseBody200Collateral_outputsAssets{listSharedTransactionsResponseBody200Collateral_outputsAssetsAsset_name = listSharedTransactionsResponseBody200Collateral_outputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                                     listSharedTransactionsResponseBody200Collateral_outputsAssetsPolicy_id = listSharedTransactionsResponseBody200Collateral_outputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                                     listSharedTransactionsResponseBody200Collateral_outputsAssetsQuantity = listSharedTransactionsResponseBody200Collateral_outputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.deposit_returned@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListSharedTransactionsResponseBody200Deposit_returned = ListSharedTransactionsResponseBody200Deposit_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200Deposit_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Deposit_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Deposit_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Deposit_returned" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200Deposit_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200Deposit_returned' with all required fields.
mkListSharedTransactionsResponseBody200Deposit_returned :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Deposit_returnedQuantity'
  -> ListSharedTransactionsResponseBody200Deposit_returned
mkListSharedTransactionsResponseBody200Deposit_returned listSharedTransactionsResponseBody200Deposit_returnedQuantity = ListSharedTransactionsResponseBody200Deposit_returned{listSharedTransactionsResponseBody200Deposit_returnedQuantity = listSharedTransactionsResponseBody200Deposit_returnedQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.deposit_taken@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListSharedTransactionsResponseBody200Deposit_taken = ListSharedTransactionsResponseBody200Deposit_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200Deposit_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Deposit_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Deposit_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Deposit_taken" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200Deposit_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200Deposit_taken' with all required fields.
mkListSharedTransactionsResponseBody200Deposit_taken :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Deposit_takenQuantity'
  -> ListSharedTransactionsResponseBody200Deposit_taken
mkListSharedTransactionsResponseBody200Deposit_taken listSharedTransactionsResponseBody200Deposit_takenQuantity = ListSharedTransactionsResponseBody200Deposit_taken{listSharedTransactionsResponseBody200Deposit_takenQuantity = listSharedTransactionsResponseBody200Deposit_takenQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.depth@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Current depth of the transaction in the local chain
data ListSharedTransactionsResponseBody200Depth = ListSharedTransactionsResponseBody200Depth {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200DepthQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Depth
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Depth
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Depth" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200Depth GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200Depth' with all required fields.
mkListSharedTransactionsResponseBody200Depth :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200DepthQuantity'
  -> ListSharedTransactionsResponseBody200Depth
mkListSharedTransactionsResponseBody200Depth listSharedTransactionsResponseBody200DepthQuantity = ListSharedTransactionsResponseBody200Depth{listSharedTransactionsResponseBody200DepthQuantity = listSharedTransactionsResponseBody200DepthQuantity}
-- | Defines the enum schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.direction@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200Direction =
   ListSharedTransactionsResponseBody200DirectionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListSharedTransactionsResponseBody200DirectionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListSharedTransactionsResponseBody200DirectionEnumOutgoing -- ^ Represents the JSON value @"outgoing"@
  | ListSharedTransactionsResponseBody200DirectionEnumIncoming -- ^ Represents the JSON value @"incoming"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Direction
    where toJSON (ListSharedTransactionsResponseBody200DirectionOther val) = val
          toJSON (ListSharedTransactionsResponseBody200DirectionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListSharedTransactionsResponseBody200DirectionEnumOutgoing) = "outgoing"
          toJSON (ListSharedTransactionsResponseBody200DirectionEnumIncoming) = "incoming"
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Direction
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "outgoing" -> ListSharedTransactionsResponseBody200DirectionEnumOutgoing
                                            | val GHC.Classes.== "incoming" -> ListSharedTransactionsResponseBody200DirectionEnumIncoming
                                            | GHC.Base.otherwise -> ListSharedTransactionsResponseBody200DirectionOther val)
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.expires_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending OR status == expired
-- \<\/span>\<br\/>
-- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
data ListSharedTransactionsResponseBody200Expires_at = ListSharedTransactionsResponseBody200Expires_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200Expires_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200Expires_atEpoch_number :: GHC.Types.Int
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200Expires_atSlot_number :: GHC.Types.Int
  -- | time
  , listSharedTransactionsResponseBody200Expires_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Expires_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Expires_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Expires_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Expires_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Expires_at" (\obj -> (((GHC.Base.pure ListSharedTransactionsResponseBody200Expires_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'ListSharedTransactionsResponseBody200Expires_at' with all required fields.
mkListSharedTransactionsResponseBody200Expires_at :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Expires_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Expires_atEpoch_number'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Expires_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200Expires_atTime'
  -> ListSharedTransactionsResponseBody200Expires_at
mkListSharedTransactionsResponseBody200Expires_at listSharedTransactionsResponseBody200Expires_atAbsolute_slot_number listSharedTransactionsResponseBody200Expires_atEpoch_number listSharedTransactionsResponseBody200Expires_atSlot_number listSharedTransactionsResponseBody200Expires_atTime = ListSharedTransactionsResponseBody200Expires_at{listSharedTransactionsResponseBody200Expires_atAbsolute_slot_number = listSharedTransactionsResponseBody200Expires_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                   listSharedTransactionsResponseBody200Expires_atEpoch_number = listSharedTransactionsResponseBody200Expires_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                                   listSharedTransactionsResponseBody200Expires_atSlot_number = listSharedTransactionsResponseBody200Expires_atSlot_number,
                                                                                                                                                                                                                                                                                                                                                   listSharedTransactionsResponseBody200Expires_atTime = listSharedTransactionsResponseBody200Expires_atTime}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.fee@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListSharedTransactionsResponseBody200Fee = ListSharedTransactionsResponseBody200Fee {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200FeeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Fee
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Fee
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Fee" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200Fee GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200Fee' with all required fields.
mkListSharedTransactionsResponseBody200Fee :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200FeeQuantity'
  -> ListSharedTransactionsResponseBody200Fee
mkListSharedTransactionsResponseBody200Fee listSharedTransactionsResponseBody200FeeQuantity = ListSharedTransactionsResponseBody200Fee{listSharedTransactionsResponseBody200FeeQuantity = listSharedTransactionsResponseBody200FeeQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.inputs.items@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200Inputs = ListSharedTransactionsResponseBody200Inputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  listSharedTransactionsResponseBody200InputsAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listSharedTransactionsResponseBody200InputsAmount :: (GHC.Maybe.Maybe ListSharedTransactionsResponseBody200InputsAmount)
  -- | assets: A flat list of assets (possibly empty).
  , listSharedTransactionsResponseBody200InputsAssets :: (GHC.Maybe.Maybe ([ListSharedTransactionsResponseBody200InputsAssets]))
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , listSharedTransactionsResponseBody200InputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200InputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Inputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200InputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200InputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Inputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Inputs" (\obj -> ((((GHC.Base.pure ListSharedTransactionsResponseBody200Inputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListSharedTransactionsResponseBody200Inputs' with all required fields.
mkListSharedTransactionsResponseBody200Inputs :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200InputsId'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200InputsIndex'
  -> ListSharedTransactionsResponseBody200Inputs
mkListSharedTransactionsResponseBody200Inputs listSharedTransactionsResponseBody200InputsId listSharedTransactionsResponseBody200InputsIndex = ListSharedTransactionsResponseBody200Inputs{listSharedTransactionsResponseBody200InputsAddress = GHC.Maybe.Nothing,
                                                                                                                                                                                           listSharedTransactionsResponseBody200InputsAmount = GHC.Maybe.Nothing,
                                                                                                                                                                                           listSharedTransactionsResponseBody200InputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                                                           listSharedTransactionsResponseBody200InputsId = listSharedTransactionsResponseBody200InputsId,
                                                                                                                                                                                           listSharedTransactionsResponseBody200InputsIndex = listSharedTransactionsResponseBody200InputsIndex}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListSharedTransactionsResponseBody200InputsAmount = ListSharedTransactionsResponseBody200InputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200InputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200InputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200InputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200InputsAmount" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200InputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200InputsAmount' with all required fields.
mkListSharedTransactionsResponseBody200InputsAmount :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200InputsAmountQuantity'
  -> ListSharedTransactionsResponseBody200InputsAmount
mkListSharedTransactionsResponseBody200InputsAmount listSharedTransactionsResponseBody200InputsAmountQuantity = ListSharedTransactionsResponseBody200InputsAmount{listSharedTransactionsResponseBody200InputsAmountQuantity = listSharedTransactionsResponseBody200InputsAmountQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ListSharedTransactionsResponseBody200InputsAssets = ListSharedTransactionsResponseBody200InputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listSharedTransactionsResponseBody200InputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listSharedTransactionsResponseBody200InputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200InputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200InputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200InputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200InputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200InputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200InputsAssets" (\obj -> ((GHC.Base.pure ListSharedTransactionsResponseBody200InputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200InputsAssets' with all required fields.
mkListSharedTransactionsResponseBody200InputsAssets :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200InputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200InputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200InputsAssetsQuantity'
  -> ListSharedTransactionsResponseBody200InputsAssets
mkListSharedTransactionsResponseBody200InputsAssets listSharedTransactionsResponseBody200InputsAssetsAsset_name listSharedTransactionsResponseBody200InputsAssetsPolicy_id listSharedTransactionsResponseBody200InputsAssetsQuantity = ListSharedTransactionsResponseBody200InputsAssets{listSharedTransactionsResponseBody200InputsAssetsAsset_name = listSharedTransactionsResponseBody200InputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                         listSharedTransactionsResponseBody200InputsAssetsPolicy_id = listSharedTransactionsResponseBody200InputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                         listSharedTransactionsResponseBody200InputsAssetsQuantity = listSharedTransactionsResponseBody200InputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.inserted_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Absolute time at which the transaction was inserted in a block.
data ListSharedTransactionsResponseBody200Inserted_at = ListSharedTransactionsResponseBody200Inserted_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200Inserted_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200Inserted_atEpoch_number :: GHC.Types.Int
  -- | height
  , listSharedTransactionsResponseBody200Inserted_atHeight :: ListSharedTransactionsResponseBody200Inserted_atHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200Inserted_atSlot_number :: GHC.Types.Int
  -- | time
  , listSharedTransactionsResponseBody200Inserted_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Inserted_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Inserted_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Inserted_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Inserted_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Inserted_at" (\obj -> ((((GHC.Base.pure ListSharedTransactionsResponseBody200Inserted_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'ListSharedTransactionsResponseBody200Inserted_at' with all required fields.
mkListSharedTransactionsResponseBody200Inserted_at :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Inserted_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Inserted_atEpoch_number'
  -> ListSharedTransactionsResponseBody200Inserted_atHeight -- ^ 'listSharedTransactionsResponseBody200Inserted_atHeight'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Inserted_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200Inserted_atTime'
  -> ListSharedTransactionsResponseBody200Inserted_at
mkListSharedTransactionsResponseBody200Inserted_at listSharedTransactionsResponseBody200Inserted_atAbsolute_slot_number listSharedTransactionsResponseBody200Inserted_atEpoch_number listSharedTransactionsResponseBody200Inserted_atHeight listSharedTransactionsResponseBody200Inserted_atSlot_number listSharedTransactionsResponseBody200Inserted_atTime = ListSharedTransactionsResponseBody200Inserted_at{listSharedTransactionsResponseBody200Inserted_atAbsolute_slot_number = listSharedTransactionsResponseBody200Inserted_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                                                                listSharedTransactionsResponseBody200Inserted_atEpoch_number = listSharedTransactionsResponseBody200Inserted_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                                                                listSharedTransactionsResponseBody200Inserted_atHeight = listSharedTransactionsResponseBody200Inserted_atHeight,
                                                                                                                                                                                                                                                                                                                                                                                                                listSharedTransactionsResponseBody200Inserted_atSlot_number = listSharedTransactionsResponseBody200Inserted_atSlot_number,
                                                                                                                                                                                                                                                                                                                                                                                                                listSharedTransactionsResponseBody200Inserted_atTime = listSharedTransactionsResponseBody200Inserted_atTime}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.inserted_at.properties.height@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200Inserted_atHeight = ListSharedTransactionsResponseBody200Inserted_atHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200Inserted_atHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Inserted_atHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Inserted_atHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Inserted_atHeight" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200Inserted_atHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200Inserted_atHeight' with all required fields.
mkListSharedTransactionsResponseBody200Inserted_atHeight :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Inserted_atHeightQuantity'
  -> ListSharedTransactionsResponseBody200Inserted_atHeight
mkListSharedTransactionsResponseBody200Inserted_atHeight listSharedTransactionsResponseBody200Inserted_atHeightQuantity = ListSharedTransactionsResponseBody200Inserted_atHeight{listSharedTransactionsResponseBody200Inserted_atHeightQuantity = listSharedTransactionsResponseBody200Inserted_atHeightQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200Mint = ListSharedTransactionsResponseBody200Mint {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  listSharedTransactionsResponseBody200MintTokens :: ([ListSharedTransactionsResponseBody200MintTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , listSharedTransactionsResponseBody200MintWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , listSharedTransactionsResponseBody200MintWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Mint
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200MintWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200MintWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Mint
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Mint" (\obj -> ((GHC.Base.pure ListSharedTransactionsResponseBody200Mint GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'ListSharedTransactionsResponseBody200Mint' with all required fields.
mkListSharedTransactionsResponseBody200Mint :: [ListSharedTransactionsResponseBody200MintTokens] -- ^ 'listSharedTransactionsResponseBody200MintTokens'
  -> ListSharedTransactionsResponseBody200Mint
mkListSharedTransactionsResponseBody200Mint listSharedTransactionsResponseBody200MintTokens = ListSharedTransactionsResponseBody200Mint{listSharedTransactionsResponseBody200MintTokens = listSharedTransactionsResponseBody200MintTokens,
                                                                                                                                        listSharedTransactionsResponseBody200MintWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                                        listSharedTransactionsResponseBody200MintWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200MintTokens = ListSharedTransactionsResponseBody200MintTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listSharedTransactionsResponseBody200MintTokensAssets :: ([ListSharedTransactionsResponseBody200MintTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listSharedTransactionsResponseBody200MintTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , listSharedTransactionsResponseBody200MintTokensPolicy_script :: ListSharedTransactionsResponseBody200MintTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200MintTokens" (\obj -> ((GHC.Base.pure ListSharedTransactionsResponseBody200MintTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'ListSharedTransactionsResponseBody200MintTokens' with all required fields.
mkListSharedTransactionsResponseBody200MintTokens :: [ListSharedTransactionsResponseBody200MintTokensAssets] -- ^ 'listSharedTransactionsResponseBody200MintTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_id'
  -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptVariants -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_script'
  -> ListSharedTransactionsResponseBody200MintTokens
mkListSharedTransactionsResponseBody200MintTokens listSharedTransactionsResponseBody200MintTokensAssets listSharedTransactionsResponseBody200MintTokensPolicy_id listSharedTransactionsResponseBody200MintTokensPolicy_script = ListSharedTransactionsResponseBody200MintTokens{listSharedTransactionsResponseBody200MintTokensAssets = listSharedTransactionsResponseBody200MintTokensAssets,
                                                                                                                                                                                                                                                                                listSharedTransactionsResponseBody200MintTokensPolicy_id = listSharedTransactionsResponseBody200MintTokensPolicy_id,
                                                                                                                                                                                                                                                                                listSharedTransactionsResponseBody200MintTokensPolicy_script = listSharedTransactionsResponseBody200MintTokensPolicy_script}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200MintTokensAssets = ListSharedTransactionsResponseBody200MintTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listSharedTransactionsResponseBody200MintTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , listSharedTransactionsResponseBody200MintTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200MintTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200MintTokensAssets" (\obj -> ((GHC.Base.pure ListSharedTransactionsResponseBody200MintTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200MintTokensAssets' with all required fields.
mkListSharedTransactionsResponseBody200MintTokensAssets :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200MintTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200MintTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200MintTokensAssetsQuantity'
  -> ListSharedTransactionsResponseBody200MintTokensAssets
mkListSharedTransactionsResponseBody200MintTokensAssets listSharedTransactionsResponseBody200MintTokensAssetsAsset_name listSharedTransactionsResponseBody200MintTokensAssetsFingerprint listSharedTransactionsResponseBody200MintTokensAssetsQuantity = ListSharedTransactionsResponseBody200MintTokensAssets{listSharedTransactionsResponseBody200MintTokensAssetsAsset_name = listSharedTransactionsResponseBody200MintTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                                               listSharedTransactionsResponseBody200MintTokensAssetsFingerprint = listSharedTransactionsResponseBody200MintTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                                               listSharedTransactionsResponseBody200MintTokensAssetsQuantity = listSharedTransactionsResponseBody200MintTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1 = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference)
  -- | script
  , listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script :: ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1' with all required fields.
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1 :: ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script'
  -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1 listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1{listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                                   listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference' with all required fields.
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex'
  -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference{listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2{listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3{listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 :: ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4{listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some{listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                                            listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5{listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6{listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants =
   ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant2 ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
  | ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant3 ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
  | ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant4 ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
  | ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant5 ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
  | ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant6 ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2 = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info :: ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2' with all required fields.
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2 :: ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info'
  -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2 listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2{listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                                        listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference' with all required fields.
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex'
  -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference{listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                                           listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version :: ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info :: ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info{listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                                                       listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3 = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References :: ([ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3' with all required fields.
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3 :: [ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References] -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash'
  -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3 listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3{listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                                                     listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References' with all required fields.
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex'
  -> ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References
mkListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex = ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References{listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                                               listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex = listSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200MintTokensPolicy_scriptVariants =
   ListSharedTransactionsResponseBody200MintTokensPolicy_scriptVariant1 ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf1
  | ListSharedTransactionsResponseBody200MintTokensPolicy_scriptVariant2 ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf2
  | ListSharedTransactionsResponseBody200MintTokensPolicy_scriptVariant3 ListSharedTransactionsResponseBody200MintTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptVariants
    where toJSON (ListSharedTransactionsResponseBody200MintTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200MintTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody200MintTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200MintTokensPolicy_scriptVariants
    where parseJSON val = case (ListSharedTransactionsResponseBody200MintTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200MintTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody200MintTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.outputs.items@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200Outputs = ListSharedTransactionsResponseBody200Outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  listSharedTransactionsResponseBody200OutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listSharedTransactionsResponseBody200OutputsAmount :: ListSharedTransactionsResponseBody200OutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , listSharedTransactionsResponseBody200OutputsAssets :: (GHC.Maybe.Maybe ([ListSharedTransactionsResponseBody200OutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200OutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listSharedTransactionsResponseBody200OutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Outputs" (\obj -> ((GHC.Base.pure ListSharedTransactionsResponseBody200Outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'ListSharedTransactionsResponseBody200Outputs' with all required fields.
mkListSharedTransactionsResponseBody200Outputs :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200OutputsAddress'
  -> ListSharedTransactionsResponseBody200OutputsAmount -- ^ 'listSharedTransactionsResponseBody200OutputsAmount'
  -> ListSharedTransactionsResponseBody200Outputs
mkListSharedTransactionsResponseBody200Outputs listSharedTransactionsResponseBody200OutputsAddress listSharedTransactionsResponseBody200OutputsAmount = ListSharedTransactionsResponseBody200Outputs{listSharedTransactionsResponseBody200OutputsAddress = listSharedTransactionsResponseBody200OutputsAddress,
                                                                                                                                                                                                     listSharedTransactionsResponseBody200OutputsAmount = listSharedTransactionsResponseBody200OutputsAmount,
                                                                                                                                                                                                     listSharedTransactionsResponseBody200OutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListSharedTransactionsResponseBody200OutputsAmount = ListSharedTransactionsResponseBody200OutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200OutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200OutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200OutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200OutputsAmount" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200OutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200OutputsAmount' with all required fields.
mkListSharedTransactionsResponseBody200OutputsAmount :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200OutputsAmountQuantity'
  -> ListSharedTransactionsResponseBody200OutputsAmount
mkListSharedTransactionsResponseBody200OutputsAmount listSharedTransactionsResponseBody200OutputsAmountQuantity = ListSharedTransactionsResponseBody200OutputsAmount{listSharedTransactionsResponseBody200OutputsAmountQuantity = listSharedTransactionsResponseBody200OutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ListSharedTransactionsResponseBody200OutputsAssets = ListSharedTransactionsResponseBody200OutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listSharedTransactionsResponseBody200OutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listSharedTransactionsResponseBody200OutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200OutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200OutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200OutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200OutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200OutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200OutputsAssets" (\obj -> ((GHC.Base.pure ListSharedTransactionsResponseBody200OutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200OutputsAssets' with all required fields.
mkListSharedTransactionsResponseBody200OutputsAssets :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200OutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200OutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200OutputsAssetsQuantity'
  -> ListSharedTransactionsResponseBody200OutputsAssets
mkListSharedTransactionsResponseBody200OutputsAssets listSharedTransactionsResponseBody200OutputsAssetsAsset_name listSharedTransactionsResponseBody200OutputsAssetsPolicy_id listSharedTransactionsResponseBody200OutputsAssetsQuantity = ListSharedTransactionsResponseBody200OutputsAssets{listSharedTransactionsResponseBody200OutputsAssetsAsset_name = listSharedTransactionsResponseBody200OutputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                              listSharedTransactionsResponseBody200OutputsAssetsPolicy_id = listSharedTransactionsResponseBody200OutputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                              listSharedTransactionsResponseBody200OutputsAssetsQuantity = listSharedTransactionsResponseBody200OutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.pending_since@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending
-- \<\/span>\<br\/>
-- The point in time at which a transaction became pending.
data ListSharedTransactionsResponseBody200Pending_since = ListSharedTransactionsResponseBody200Pending_since {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200Pending_sinceAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200Pending_sinceEpoch_number :: GHC.Types.Int
  -- | height
  , listSharedTransactionsResponseBody200Pending_sinceHeight :: ListSharedTransactionsResponseBody200Pending_sinceHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listSharedTransactionsResponseBody200Pending_sinceSlot_number :: GHC.Types.Int
  -- | time
  , listSharedTransactionsResponseBody200Pending_sinceTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Pending_since
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Pending_sinceTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Pending_sinceTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Pending_since
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Pending_since" (\obj -> ((((GHC.Base.pure ListSharedTransactionsResponseBody200Pending_since GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'ListSharedTransactionsResponseBody200Pending_since' with all required fields.
mkListSharedTransactionsResponseBody200Pending_since :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Pending_sinceAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Pending_sinceEpoch_number'
  -> ListSharedTransactionsResponseBody200Pending_sinceHeight -- ^ 'listSharedTransactionsResponseBody200Pending_sinceHeight'
  -> GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Pending_sinceSlot_number'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200Pending_sinceTime'
  -> ListSharedTransactionsResponseBody200Pending_since
mkListSharedTransactionsResponseBody200Pending_since listSharedTransactionsResponseBody200Pending_sinceAbsolute_slot_number listSharedTransactionsResponseBody200Pending_sinceEpoch_number listSharedTransactionsResponseBody200Pending_sinceHeight listSharedTransactionsResponseBody200Pending_sinceSlot_number listSharedTransactionsResponseBody200Pending_sinceTime = ListSharedTransactionsResponseBody200Pending_since{listSharedTransactionsResponseBody200Pending_sinceAbsolute_slot_number = listSharedTransactionsResponseBody200Pending_sinceAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                                                                              listSharedTransactionsResponseBody200Pending_sinceEpoch_number = listSharedTransactionsResponseBody200Pending_sinceEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                                                                              listSharedTransactionsResponseBody200Pending_sinceHeight = listSharedTransactionsResponseBody200Pending_sinceHeight,
                                                                                                                                                                                                                                                                                                                                                                                                                              listSharedTransactionsResponseBody200Pending_sinceSlot_number = listSharedTransactionsResponseBody200Pending_sinceSlot_number,
                                                                                                                                                                                                                                                                                                                                                                                                                              listSharedTransactionsResponseBody200Pending_sinceTime = listSharedTransactionsResponseBody200Pending_sinceTime}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.pending_since.properties.height@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200Pending_sinceHeight = ListSharedTransactionsResponseBody200Pending_sinceHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200Pending_sinceHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Pending_sinceHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Pending_sinceHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Pending_sinceHeight" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200Pending_sinceHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200Pending_sinceHeight' with all required fields.
mkListSharedTransactionsResponseBody200Pending_sinceHeight :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Pending_sinceHeightQuantity'
  -> ListSharedTransactionsResponseBody200Pending_sinceHeight
mkListSharedTransactionsResponseBody200Pending_sinceHeight listSharedTransactionsResponseBody200Pending_sinceHeightQuantity = ListSharedTransactionsResponseBody200Pending_sinceHeight{listSharedTransactionsResponseBody200Pending_sinceHeightQuantity = listSharedTransactionsResponseBody200Pending_sinceHeightQuantity}
-- | Defines the enum schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.script_validity@ in the specification.
-- 
-- Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
-- used in the transaction validated or not. Validity may be null if this
-- transaction was from an era that doesn\'t support phase-2 monetary policy
-- scripts, or is a pending transaction (we don\'t know if validation passed or
-- failed until the transaction hits the ledger).
data ListSharedTransactionsResponseBody200Script_validityNonNullable =
   ListSharedTransactionsResponseBody200Script_validityNonNullableOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListSharedTransactionsResponseBody200Script_validityNonNullableTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListSharedTransactionsResponseBody200Script_validityNonNullableEnumValid -- ^ Represents the JSON value @"valid"@
  | ListSharedTransactionsResponseBody200Script_validityNonNullableEnumInvalid -- ^ Represents the JSON value @"invalid"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Script_validityNonNullable
    where toJSON (ListSharedTransactionsResponseBody200Script_validityNonNullableOther val) = val
          toJSON (ListSharedTransactionsResponseBody200Script_validityNonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListSharedTransactionsResponseBody200Script_validityNonNullableEnumValid) = "valid"
          toJSON (ListSharedTransactionsResponseBody200Script_validityNonNullableEnumInvalid) = "invalid"
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Script_validityNonNullable
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "valid" -> ListSharedTransactionsResponseBody200Script_validityNonNullableEnumValid
                                            | val GHC.Classes.== "invalid" -> ListSharedTransactionsResponseBody200Script_validityNonNullableEnumInvalid
                                            | GHC.Base.otherwise -> ListSharedTransactionsResponseBody200Script_validityNonNullableOther val)
-- | Defines the enum schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.status@ in the specification.
-- 
-- Current transaction status.
-- 
--   \`\`\`
--        *-----------*
--   ---> |  PENDING  |----------------*
--        *-----------*                |
--              |                      |
--              V                      V
--        *-----------*          *-----------*
--        |           |---------->  EXPIRED  |
--        |           |  (ttl)   *-----------*
--        | SUBMITTED |
--        |           \<----------------*
--        |           |                |
--        *-----------*           (rollback)
--               |                     |
--          (in ledger)          *-----------*
--               |               |           |
--               *---------------> IN_LEDGER |
--                               |           |
--                               *-----------*
--   \`\`\`
data ListSharedTransactionsResponseBody200Status =
   ListSharedTransactionsResponseBody200StatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListSharedTransactionsResponseBody200StatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListSharedTransactionsResponseBody200StatusEnumPending -- ^ Represents the JSON value @"pending"@
  | ListSharedTransactionsResponseBody200StatusEnumSubmitted -- ^ Represents the JSON value @"submitted"@
  | ListSharedTransactionsResponseBody200StatusEnumIn_ledger -- ^ Represents the JSON value @"in_ledger"@
  | ListSharedTransactionsResponseBody200StatusEnumExpired -- ^ Represents the JSON value @"expired"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Status
    where toJSON (ListSharedTransactionsResponseBody200StatusOther val) = val
          toJSON (ListSharedTransactionsResponseBody200StatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListSharedTransactionsResponseBody200StatusEnumPending) = "pending"
          toJSON (ListSharedTransactionsResponseBody200StatusEnumSubmitted) = "submitted"
          toJSON (ListSharedTransactionsResponseBody200StatusEnumIn_ledger) = "in_ledger"
          toJSON (ListSharedTransactionsResponseBody200StatusEnumExpired) = "expired"
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Status
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "pending" -> ListSharedTransactionsResponseBody200StatusEnumPending
                                            | val GHC.Classes.== "submitted" -> ListSharedTransactionsResponseBody200StatusEnumSubmitted
                                            | val GHC.Classes.== "in_ledger" -> ListSharedTransactionsResponseBody200StatusEnumIn_ledger
                                            | val GHC.Classes.== "expired" -> ListSharedTransactionsResponseBody200StatusEnumExpired
                                            | GHC.Base.otherwise -> ListSharedTransactionsResponseBody200StatusOther val)
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.validity_interval@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200Validity_interval = ListSharedTransactionsResponseBody200Validity_interval {
  -- | invalid_before
  listSharedTransactionsResponseBody200Validity_intervalInvalid_before :: ListSharedTransactionsResponseBody200Validity_intervalInvalid_before
  -- | invalid_hereafter
  , listSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter :: ListSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Validity_interval
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Validity_interval
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Validity_interval" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200Validity_interval GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_before")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_hereafter"))
-- | Create a new 'ListSharedTransactionsResponseBody200Validity_interval' with all required fields.
mkListSharedTransactionsResponseBody200Validity_interval :: ListSharedTransactionsResponseBody200Validity_intervalInvalid_before -- ^ 'listSharedTransactionsResponseBody200Validity_intervalInvalid_before'
  -> ListSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter -- ^ 'listSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter'
  -> ListSharedTransactionsResponseBody200Validity_interval
mkListSharedTransactionsResponseBody200Validity_interval listSharedTransactionsResponseBody200Validity_intervalInvalid_before listSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter = ListSharedTransactionsResponseBody200Validity_interval{listSharedTransactionsResponseBody200Validity_intervalInvalid_before = listSharedTransactionsResponseBody200Validity_intervalInvalid_before,
                                                                                                                                                                                                                                                               listSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter = listSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.validity_interval.properties.invalid_before@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200Validity_intervalInvalid_before = ListSharedTransactionsResponseBody200Validity_intervalInvalid_before {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Validity_intervalInvalid_before
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Validity_intervalInvalid_before
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Validity_intervalInvalid_before" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200Validity_intervalInvalid_before GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200Validity_intervalInvalid_before' with all required fields.
mkListSharedTransactionsResponseBody200Validity_intervalInvalid_before :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity'
  -> ListSharedTransactionsResponseBody200Validity_intervalInvalid_before
mkListSharedTransactionsResponseBody200Validity_intervalInvalid_before listSharedTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity = ListSharedTransactionsResponseBody200Validity_intervalInvalid_before{listSharedTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity = listSharedTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.validity_interval.properties.invalid_hereafter@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter = ListSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter' with all required fields.
mkListSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity'
  -> ListSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter
mkListSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter listSharedTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity = ListSharedTransactionsResponseBody200Validity_intervalInvalid_hereafter{listSharedTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity = listSharedTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.withdrawals.items@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody200Withdrawals = ListSharedTransactionsResponseBody200Withdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  listSharedTransactionsResponseBody200WithdrawalsAmount :: ListSharedTransactionsResponseBody200WithdrawalsAmount
  -- | stake_address
  , listSharedTransactionsResponseBody200WithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200Withdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200WithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200WithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200Withdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200Withdrawals" (\obj -> (GHC.Base.pure ListSharedTransactionsResponseBody200Withdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'ListSharedTransactionsResponseBody200Withdrawals' with all required fields.
mkListSharedTransactionsResponseBody200Withdrawals :: ListSharedTransactionsResponseBody200WithdrawalsAmount -- ^ 'listSharedTransactionsResponseBody200WithdrawalsAmount'
  -> Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody200WithdrawalsStake_address'
  -> ListSharedTransactionsResponseBody200Withdrawals
mkListSharedTransactionsResponseBody200Withdrawals listSharedTransactionsResponseBody200WithdrawalsAmount listSharedTransactionsResponseBody200WithdrawalsStake_address = ListSharedTransactionsResponseBody200Withdrawals{listSharedTransactionsResponseBody200WithdrawalsAmount = listSharedTransactionsResponseBody200WithdrawalsAmount,
                                                                                                                                                                                                                           listSharedTransactionsResponseBody200WithdrawalsStake_address = listSharedTransactionsResponseBody200WithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListSharedTransactionsResponseBody200WithdrawalsAmount = ListSharedTransactionsResponseBody200WithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listSharedTransactionsResponseBody200WithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody200WithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody200WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody200WithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody200WithdrawalsAmount" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody200WithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListSharedTransactionsResponseBody200WithdrawalsAmount' with all required fields.
mkListSharedTransactionsResponseBody200WithdrawalsAmount :: GHC.Types.Int -- ^ 'listSharedTransactionsResponseBody200WithdrawalsAmountQuantity'
  -> ListSharedTransactionsResponseBody200WithdrawalsAmount
mkListSharedTransactionsResponseBody200WithdrawalsAmount listSharedTransactionsResponseBody200WithdrawalsAmountQuantity = ListSharedTransactionsResponseBody200WithdrawalsAmount{listSharedTransactionsResponseBody200WithdrawalsAmountQuantity = listSharedTransactionsResponseBody200WithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody400OneOf1 = ListSharedTransactionsResponseBody400OneOf1 {
  -- | message: May occur when trying to withdraw less than the minimal UTxO value.
  listSharedTransactionsResponseBody400OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody400OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "min_withdrawal_wrong"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "min_withdrawal_wrong"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody400OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody400OneOf1" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody400OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListSharedTransactionsResponseBody400OneOf1' with all required fields.
mkListSharedTransactionsResponseBody400OneOf1 :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody400OneOf1Message'
  -> ListSharedTransactionsResponseBody400OneOf1
mkListSharedTransactionsResponseBody400OneOf1 listSharedTransactionsResponseBody400OneOf1Message = ListSharedTransactionsResponseBody400OneOf1{listSharedTransactionsResponseBody400OneOf1Message = listSharedTransactionsResponseBody400OneOf1Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody400OneOf2 = ListSharedTransactionsResponseBody400OneOf2 {
  -- | message: May occur when a provided time-range is unsound.
  listSharedTransactionsResponseBody400OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody400OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody400OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "start_time_later_than_end_time"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody400OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "start_time_later_than_end_time"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody400OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody400OneOf2" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody400OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListSharedTransactionsResponseBody400OneOf2' with all required fields.
mkListSharedTransactionsResponseBody400OneOf2 :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody400OneOf2Message'
  -> ListSharedTransactionsResponseBody400OneOf2
mkListSharedTransactionsResponseBody400OneOf2 listSharedTransactionsResponseBody400OneOf2Message = ListSharedTransactionsResponseBody400OneOf2{listSharedTransactionsResponseBody400OneOf2Message = listSharedTransactionsResponseBody400OneOf2Message}
-- | Defines the oneOf schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody400Variants =
   ListSharedTransactionsResponseBody400Variant1 ListSharedTransactionsResponseBody400OneOf1
  | ListSharedTransactionsResponseBody400Variant2 ListSharedTransactionsResponseBody400OneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody400Variants
    where toJSON (ListSharedTransactionsResponseBody400Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListSharedTransactionsResponseBody400Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody400Variants
    where parseJSON val = case (ListSharedTransactionsResponseBody400Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListSharedTransactionsResponseBody400Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody404 = ListSharedTransactionsResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  listSharedTransactionsResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody404" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListSharedTransactionsResponseBody404' with all required fields.
mkListSharedTransactionsResponseBody404 :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody404Message'
  -> ListSharedTransactionsResponseBody404
mkListSharedTransactionsResponseBody404 listSharedTransactionsResponseBody404Message = ListSharedTransactionsResponseBody404{listSharedTransactionsResponseBody404Message = listSharedTransactionsResponseBody404Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions.GET.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data ListSharedTransactionsResponseBody406 = ListSharedTransactionsResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  listSharedTransactionsResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListSharedTransactionsResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listSharedTransactionsResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListSharedTransactionsResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListSharedTransactionsResponseBody406" (\obj -> GHC.Base.pure ListSharedTransactionsResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListSharedTransactionsResponseBody406' with all required fields.
mkListSharedTransactionsResponseBody406 :: Data.Text.Internal.Text -- ^ 'listSharedTransactionsResponseBody406Message'
  -> ListSharedTransactionsResponseBody406
mkListSharedTransactionsResponseBody406 listSharedTransactionsResponseBody406Message = ListSharedTransactionsResponseBody406{listSharedTransactionsResponseBody406Message = listSharedTransactionsResponseBody406Message}
-- | > GET /shared-wallets/{walletId}/transactions
-- 
-- The same as 'listSharedTransactions' but accepts an explicit configuration.
listSharedTransactionsWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> ListSharedTransactionsParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response ListSharedTransactionsResponse) -- ^ Monadic computation which returns the result of the operation
listSharedTransactionsWithConfiguration config
                                        parameters = GHC.Base.fmap (\response_5 -> GHC.Base.fmap (Data.Either.either ListSharedTransactionsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ListSharedTransactionsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                            ([ListSharedTransactionsResponseBody200]))
                                                                                                                                                                                                      | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> ListSharedTransactionsResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                            ListSharedTransactionsResponseBody400Variants)
                                                                                                                                                                                                      | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> ListSharedTransactionsResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                            ListSharedTransactionsResponseBody404)
                                                                                                                                                                                                      | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ListSharedTransactionsResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                            ListSharedTransactionsResponseBody406)
                                                                                                                                                                                                      | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_5) response_5) (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/shared-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listSharedTransactionsParametersPathWalletId parameters))) GHC.Base.<> "/transactions")) [Wallet.Common.QueryParameter (Data.Text.pack "start") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryStart parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Wallet.Common.QueryParameter (Data.Text.pack "end") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryEnd parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Wallet.Common.QueryParameter (Data.Text.pack "order") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryOrder parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Wallet.Common.QueryParameter (Data.Text.pack "max_count") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryMax_count parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Wallet.Common.QueryParameter (Data.Text.pack "minWithdrawal") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryMinWithdrawal parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Wallet.Common.QueryParameter (Data.Text.pack "simple-metadata") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQuerySimple_metadata parameters) (Data.Text.pack "form") GHC.Types.False])
-- | > GET /shared-wallets/{walletId}/transactions
-- 
-- The same as 'listSharedTransactions' but returns the raw 'Data.ByteString.ByteString'.
listSharedTransactionsRaw :: forall m . Wallet.Common.MonadHTTP m => ListSharedTransactionsParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
listSharedTransactionsRaw parameters = GHC.Base.id (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/shared-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listSharedTransactionsParametersPathWalletId parameters))) GHC.Base.<> "/transactions")) [Wallet.Common.QueryParameter (Data.Text.pack "start") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryStart parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                      Wallet.Common.QueryParameter (Data.Text.pack "end") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryEnd parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                      Wallet.Common.QueryParameter (Data.Text.pack "order") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryOrder parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                      Wallet.Common.QueryParameter (Data.Text.pack "max_count") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryMax_count parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                      Wallet.Common.QueryParameter (Data.Text.pack "minWithdrawal") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryMinWithdrawal parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                      Wallet.Common.QueryParameter (Data.Text.pack "simple-metadata") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQuerySimple_metadata parameters) (Data.Text.pack "form") GHC.Types.False])
-- | > GET /shared-wallets/{walletId}/transactions
-- 
-- The same as 'listSharedTransactions' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
listSharedTransactionsWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> ListSharedTransactionsParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
listSharedTransactionsWithConfigurationRaw config
                                           parameters = GHC.Base.id (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/shared-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listSharedTransactionsParametersPathWalletId parameters))) GHC.Base.<> "/transactions")) [Wallet.Common.QueryParameter (Data.Text.pack "start") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryStart parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                             Wallet.Common.QueryParameter (Data.Text.pack "end") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryEnd parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                             Wallet.Common.QueryParameter (Data.Text.pack "order") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryOrder parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                             Wallet.Common.QueryParameter (Data.Text.pack "max_count") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryMax_count parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                             Wallet.Common.QueryParameter (Data.Text.pack "minWithdrawal") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQueryMinWithdrawal parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                             Wallet.Common.QueryParameter (Data.Text.pack "simple-metadata") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listSharedTransactionsParametersQuerySimple_metadata parameters) (Data.Text.pack "form") GHC.Types.False])
