-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation putWallet
module Wallet.Operations.PutWallet where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > PUT /wallets/{walletId}
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
putWallet :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutWalletRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response PutWalletResponse) -- ^ Monadic computation which returns the result of the operation
putWallet walletId
          body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PutWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                              PutWalletResponseBody200)
                                                                                                                                                     | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                              PutWalletResponseBody400)
                                                                                                                                                     | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                              PutWalletResponseBody404)
                                                                                                                                                     | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                              PutWalletResponseBody406)
                                                                                                                                                     | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                              PutWalletResponseBody415)
                                                                                                                                                     | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.requestBody.content.application\/json.schema@ in the specification.
-- 
-- 
data PutWalletRequestBody = PutWalletRequestBody {
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  putWalletRequestBodyName :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("name" Data.Aeson.Types.ToJSON..=)) (putWalletRequestBodyName obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("name" Data.Aeson.Types.ToJSON..=)) (putWalletRequestBodyName obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletRequestBody" (\obj -> GHC.Base.pure PutWalletRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "name"))
-- | Create a new 'PutWalletRequestBody' with all required fields.
mkPutWalletRequestBody :: PutWalletRequestBody
mkPutWalletRequestBody = PutWalletRequestBody{putWalletRequestBodyName = GHC.Maybe.Nothing}
-- | Represents a response of the operation 'putWallet'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PutWalletResponseError' is used.
data PutWalletResponse =
   PutWalletResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | PutWalletResponse200 PutWalletResponseBody200 -- ^ Ok
  | PutWalletResponse400 PutWalletResponseBody400 -- ^ Bad Request
  | PutWalletResponse404 PutWalletResponseBody404 -- ^ Not Found
  | PutWalletResponse406 PutWalletResponseBody406 -- ^ Not Acceptable
  | PutWalletResponse415 PutWalletResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema@ in the specification.
-- 
-- 
data PutWalletResponseBody200 = PutWalletResponseBody200 {
  -- | address_pool_gap: Number of consecutive unused addresses allowed.
  -- 
  -- **IMPORTANT DISCLAIMER:** Using values other than \`20\` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
  -- your wallet in a different software which is strictly following BIP-44.
  -- 
  -- Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
  -- 
  -- **IMPORTANT DISCLAIMER 2:** There is no way to \`import\` addresses generated outside (e.g. using cardano-addresses) into the wallet.
  -- Wallet only discovers transactions on its used and unused addresses that are within its currently seen \`address_pool_gap\`.
  -- Transactions on addresses that \"belong\" to the wallet but happen to be beyond its \`address_pool_gap\` will not be visible to the wallet.
  -- This is a technical limitation of the industry standard [BIP-44](https:\/\/github.com\/bitcoin\/bips\/blob\/master\/bip-0044.mediawiki). See also [CIP-1852](https:\/\/github.com\/cardano-foundation\/CIPs\/blob\/master\/CIP-1852\/CIP-1852.md).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100000.0
  -- * Minimum  of 10.0
  putWalletResponseBody200Address_pool_gap :: GHC.Types.Int
  -- | assets: Current non-Ada asset holdings of the wallet.
  -- 
  -- The amount of assets available to spend may be less than the total
  -- unspent assets due to transaction change amounts which are yet to
  -- be fully confirmed (pending).
  , putWalletResponseBody200Assets :: PutWalletResponseBody200Assets
  -- | balance: Wallet current Ada balance(s).
  , putWalletResponseBody200Balance :: PutWalletResponseBody200Balance
  -- | delegation: Delegation settings
  , putWalletResponseBody200Delegation :: PutWalletResponseBody200Delegation
  -- | id: A unique identifier for the wallet
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  , putWalletResponseBody200Id :: Data.Text.Internal.Text
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , putWalletResponseBody200Name :: Data.Text.Internal.Text
  -- | passphrase: Information about the wallet\'s passphrase
  , putWalletResponseBody200Passphrase :: (GHC.Maybe.Maybe PutWalletResponseBody200Passphrase)
  -- | state: Whether a wallet is ready to use or still syncing
  , putWalletResponseBody200State :: PutWalletResponseBody200State
  -- | tip: A reference to a particular time slot, and the block height at that point.
  , putWalletResponseBody200Tip :: PutWalletResponseBody200Tip
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address_pool_gap" Data.Aeson.Types.ToJSON..= putWalletResponseBody200Address_pool_gap obj] : ["assets" Data.Aeson.Types.ToJSON..= putWalletResponseBody200Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= putWalletResponseBody200Balance obj] : ["delegation" Data.Aeson.Types.ToJSON..= putWalletResponseBody200Delegation obj] : ["id" Data.Aeson.Types.ToJSON..= putWalletResponseBody200Id obj] : ["name" Data.Aeson.Types.ToJSON..= putWalletResponseBody200Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (putWalletResponseBody200Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= putWalletResponseBody200State obj] : ["tip" Data.Aeson.Types.ToJSON..= putWalletResponseBody200Tip obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address_pool_gap" Data.Aeson.Types.ToJSON..= putWalletResponseBody200Address_pool_gap obj] : ["assets" Data.Aeson.Types.ToJSON..= putWalletResponseBody200Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= putWalletResponseBody200Balance obj] : ["delegation" Data.Aeson.Types.ToJSON..= putWalletResponseBody200Delegation obj] : ["id" Data.Aeson.Types.ToJSON..= putWalletResponseBody200Id obj] : ["name" Data.Aeson.Types.ToJSON..= putWalletResponseBody200Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (putWalletResponseBody200Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= putWalletResponseBody200State obj] : ["tip" Data.Aeson.Types.ToJSON..= putWalletResponseBody200Tip obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200" (\obj -> ((((((((GHC.Base.pure PutWalletResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address_pool_gap")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "balance")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delegation")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "state")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tip"))
-- | Create a new 'PutWalletResponseBody200' with all required fields.
mkPutWalletResponseBody200 :: GHC.Types.Int -- ^ 'putWalletResponseBody200Address_pool_gap'
  -> PutWalletResponseBody200Assets -- ^ 'putWalletResponseBody200Assets'
  -> PutWalletResponseBody200Balance -- ^ 'putWalletResponseBody200Balance'
  -> PutWalletResponseBody200Delegation -- ^ 'putWalletResponseBody200Delegation'
  -> Data.Text.Internal.Text -- ^ 'putWalletResponseBody200Id'
  -> Data.Text.Internal.Text -- ^ 'putWalletResponseBody200Name'
  -> PutWalletResponseBody200State -- ^ 'putWalletResponseBody200State'
  -> PutWalletResponseBody200Tip -- ^ 'putWalletResponseBody200Tip'
  -> PutWalletResponseBody200
mkPutWalletResponseBody200 putWalletResponseBody200Address_pool_gap putWalletResponseBody200Assets putWalletResponseBody200Balance putWalletResponseBody200Delegation putWalletResponseBody200Id putWalletResponseBody200Name putWalletResponseBody200State putWalletResponseBody200Tip = PutWalletResponseBody200{putWalletResponseBody200Address_pool_gap = putWalletResponseBody200Address_pool_gap,
                                                                                                                                                                                                                                                                                                                   putWalletResponseBody200Assets = putWalletResponseBody200Assets,
                                                                                                                                                                                                                                                                                                                   putWalletResponseBody200Balance = putWalletResponseBody200Balance,
                                                                                                                                                                                                                                                                                                                   putWalletResponseBody200Delegation = putWalletResponseBody200Delegation,
                                                                                                                                                                                                                                                                                                                   putWalletResponseBody200Id = putWalletResponseBody200Id,
                                                                                                                                                                                                                                                                                                                   putWalletResponseBody200Name = putWalletResponseBody200Name,
                                                                                                                                                                                                                                                                                                                   putWalletResponseBody200Passphrase = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                   putWalletResponseBody200State = putWalletResponseBody200State,
                                                                                                                                                                                                                                                                                                                   putWalletResponseBody200Tip = putWalletResponseBody200Tip}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.assets@ in the specification.
-- 
-- Current non-Ada asset holdings of the wallet.
-- 
-- The amount of assets available to spend may be less than the total
-- unspent assets due to transaction change amounts which are yet to
-- be fully confirmed (pending).
data PutWalletResponseBody200Assets = PutWalletResponseBody200Assets {
  -- | available: Available UTxO asset balances (funds that can be spent without
  -- condition).
  putWalletResponseBody200AssetsAvailable :: ([PutWalletResponseBody200AssetsAvailable])
  -- | total: Total asset balances (available balances plus pending change balances).
  , putWalletResponseBody200AssetsTotal :: ([PutWalletResponseBody200AssetsTotal])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200Assets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200Assets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200Assets" (\obj -> (GHC.Base.pure PutWalletResponseBody200Assets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'PutWalletResponseBody200Assets' with all required fields.
mkPutWalletResponseBody200Assets :: [PutWalletResponseBody200AssetsAvailable] -- ^ 'putWalletResponseBody200AssetsAvailable'
  -> [PutWalletResponseBody200AssetsTotal] -- ^ 'putWalletResponseBody200AssetsTotal'
  -> PutWalletResponseBody200Assets
mkPutWalletResponseBody200Assets putWalletResponseBody200AssetsAvailable putWalletResponseBody200AssetsTotal = PutWalletResponseBody200Assets{putWalletResponseBody200AssetsAvailable = putWalletResponseBody200AssetsAvailable,
                                                                                                                                              putWalletResponseBody200AssetsTotal = putWalletResponseBody200AssetsTotal}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.assets.properties.available.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PutWalletResponseBody200AssetsAvailable = PutWalletResponseBody200AssetsAvailable {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  putWalletResponseBody200AssetsAvailableAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , putWalletResponseBody200AssetsAvailablePolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , putWalletResponseBody200AssetsAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200AssetsAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsAvailableQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsAvailableQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200AssetsAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200AssetsAvailable" (\obj -> ((GHC.Base.pure PutWalletResponseBody200AssetsAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PutWalletResponseBody200AssetsAvailable' with all required fields.
mkPutWalletResponseBody200AssetsAvailable :: Data.Text.Internal.Text -- ^ 'putWalletResponseBody200AssetsAvailableAsset_name'
  -> Data.Text.Internal.Text -- ^ 'putWalletResponseBody200AssetsAvailablePolicy_id'
  -> GHC.Types.Int -- ^ 'putWalletResponseBody200AssetsAvailableQuantity'
  -> PutWalletResponseBody200AssetsAvailable
mkPutWalletResponseBody200AssetsAvailable putWalletResponseBody200AssetsAvailableAsset_name putWalletResponseBody200AssetsAvailablePolicy_id putWalletResponseBody200AssetsAvailableQuantity = PutWalletResponseBody200AssetsAvailable{putWalletResponseBody200AssetsAvailableAsset_name = putWalletResponseBody200AssetsAvailableAsset_name,
                                                                                                                                                                                                                                       putWalletResponseBody200AssetsAvailablePolicy_id = putWalletResponseBody200AssetsAvailablePolicy_id,
                                                                                                                                                                                                                                       putWalletResponseBody200AssetsAvailableQuantity = putWalletResponseBody200AssetsAvailableQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.assets.properties.total.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PutWalletResponseBody200AssetsTotal = PutWalletResponseBody200AssetsTotal {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  putWalletResponseBody200AssetsTotalAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , putWalletResponseBody200AssetsTotalPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , putWalletResponseBody200AssetsTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200AssetsTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsTotalQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= putWalletResponseBody200AssetsTotalQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200AssetsTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200AssetsTotal" (\obj -> ((GHC.Base.pure PutWalletResponseBody200AssetsTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PutWalletResponseBody200AssetsTotal' with all required fields.
mkPutWalletResponseBody200AssetsTotal :: Data.Text.Internal.Text -- ^ 'putWalletResponseBody200AssetsTotalAsset_name'
  -> Data.Text.Internal.Text -- ^ 'putWalletResponseBody200AssetsTotalPolicy_id'
  -> GHC.Types.Int -- ^ 'putWalletResponseBody200AssetsTotalQuantity'
  -> PutWalletResponseBody200AssetsTotal
mkPutWalletResponseBody200AssetsTotal putWalletResponseBody200AssetsTotalAsset_name putWalletResponseBody200AssetsTotalPolicy_id putWalletResponseBody200AssetsTotalQuantity = PutWalletResponseBody200AssetsTotal{putWalletResponseBody200AssetsTotalAsset_name = putWalletResponseBody200AssetsTotalAsset_name,
                                                                                                                                                                                                                   putWalletResponseBody200AssetsTotalPolicy_id = putWalletResponseBody200AssetsTotalPolicy_id,
                                                                                                                                                                                                                   putWalletResponseBody200AssetsTotalQuantity = putWalletResponseBody200AssetsTotalQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.balance@ in the specification.
-- 
-- Wallet current Ada balance(s).
data PutWalletResponseBody200Balance = PutWalletResponseBody200Balance {
  -- | available: Available Ada UTxO balance (funds that can be spent without condition).
  putWalletResponseBody200BalanceAvailable :: PutWalletResponseBody200BalanceAvailable
  -- | reward: The Ada balance of the reward account for this wallet.
  , putWalletResponseBody200BalanceReward :: PutWalletResponseBody200BalanceReward
  -- | total: Total Ada balance (available balance plus pending change and reward balance).
  , putWalletResponseBody200BalanceTotal :: PutWalletResponseBody200BalanceTotal
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200Balance
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= putWalletResponseBody200BalanceAvailable obj] : ["reward" Data.Aeson.Types.ToJSON..= putWalletResponseBody200BalanceReward obj] : ["total" Data.Aeson.Types.ToJSON..= putWalletResponseBody200BalanceTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= putWalletResponseBody200BalanceAvailable obj] : ["reward" Data.Aeson.Types.ToJSON..= putWalletResponseBody200BalanceReward obj] : ["total" Data.Aeson.Types.ToJSON..= putWalletResponseBody200BalanceTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200Balance
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200Balance" (\obj -> ((GHC.Base.pure PutWalletResponseBody200Balance GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'PutWalletResponseBody200Balance' with all required fields.
mkPutWalletResponseBody200Balance :: PutWalletResponseBody200BalanceAvailable -- ^ 'putWalletResponseBody200BalanceAvailable'
  -> PutWalletResponseBody200BalanceReward -- ^ 'putWalletResponseBody200BalanceReward'
  -> PutWalletResponseBody200BalanceTotal -- ^ 'putWalletResponseBody200BalanceTotal'
  -> PutWalletResponseBody200Balance
mkPutWalletResponseBody200Balance putWalletResponseBody200BalanceAvailable putWalletResponseBody200BalanceReward putWalletResponseBody200BalanceTotal = PutWalletResponseBody200Balance{putWalletResponseBody200BalanceAvailable = putWalletResponseBody200BalanceAvailable,
                                                                                                                                                                                        putWalletResponseBody200BalanceReward = putWalletResponseBody200BalanceReward,
                                                                                                                                                                                        putWalletResponseBody200BalanceTotal = putWalletResponseBody200BalanceTotal}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.balance.properties.available@ in the specification.
-- 
-- Available Ada UTxO balance (funds that can be spent without condition).
data PutWalletResponseBody200BalanceAvailable = PutWalletResponseBody200BalanceAvailable {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  putWalletResponseBody200BalanceAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200BalanceAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putWalletResponseBody200BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putWalletResponseBody200BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200BalanceAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200BalanceAvailable" (\obj -> GHC.Base.pure PutWalletResponseBody200BalanceAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PutWalletResponseBody200BalanceAvailable' with all required fields.
mkPutWalletResponseBody200BalanceAvailable :: GHC.Types.Int -- ^ 'putWalletResponseBody200BalanceAvailableQuantity'
  -> PutWalletResponseBody200BalanceAvailable
mkPutWalletResponseBody200BalanceAvailable putWalletResponseBody200BalanceAvailableQuantity = PutWalletResponseBody200BalanceAvailable{putWalletResponseBody200BalanceAvailableQuantity = putWalletResponseBody200BalanceAvailableQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.balance.properties.reward@ in the specification.
-- 
-- The Ada balance of the reward account for this wallet.
data PutWalletResponseBody200BalanceReward = PutWalletResponseBody200BalanceReward {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  putWalletResponseBody200BalanceRewardQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200BalanceReward
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putWalletResponseBody200BalanceRewardQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putWalletResponseBody200BalanceRewardQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200BalanceReward
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200BalanceReward" (\obj -> GHC.Base.pure PutWalletResponseBody200BalanceReward GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PutWalletResponseBody200BalanceReward' with all required fields.
mkPutWalletResponseBody200BalanceReward :: GHC.Types.Int -- ^ 'putWalletResponseBody200BalanceRewardQuantity'
  -> PutWalletResponseBody200BalanceReward
mkPutWalletResponseBody200BalanceReward putWalletResponseBody200BalanceRewardQuantity = PutWalletResponseBody200BalanceReward{putWalletResponseBody200BalanceRewardQuantity = putWalletResponseBody200BalanceRewardQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.balance.properties.total@ in the specification.
-- 
-- Total Ada balance (available balance plus pending change and reward balance).
data PutWalletResponseBody200BalanceTotal = PutWalletResponseBody200BalanceTotal {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  putWalletResponseBody200BalanceTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200BalanceTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putWalletResponseBody200BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putWalletResponseBody200BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200BalanceTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200BalanceTotal" (\obj -> GHC.Base.pure PutWalletResponseBody200BalanceTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PutWalletResponseBody200BalanceTotal' with all required fields.
mkPutWalletResponseBody200BalanceTotal :: GHC.Types.Int -- ^ 'putWalletResponseBody200BalanceTotalQuantity'
  -> PutWalletResponseBody200BalanceTotal
mkPutWalletResponseBody200BalanceTotal putWalletResponseBody200BalanceTotalQuantity = PutWalletResponseBody200BalanceTotal{putWalletResponseBody200BalanceTotalQuantity = putWalletResponseBody200BalanceTotalQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.delegation@ in the specification.
-- 
-- Delegation settings
data PutWalletResponseBody200Delegation = PutWalletResponseBody200Delegation {
  -- | active: Currently active delegation status.
  putWalletResponseBody200DelegationActive :: PutWalletResponseBody200DelegationActive
  -- | next
  , putWalletResponseBody200DelegationNext :: ([PutWalletResponseBody200DelegationNext])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200Delegation
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= putWalletResponseBody200DelegationActive obj] : ["next" Data.Aeson.Types.ToJSON..= putWalletResponseBody200DelegationNext obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= putWalletResponseBody200DelegationActive obj] : ["next" Data.Aeson.Types.ToJSON..= putWalletResponseBody200DelegationNext obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200Delegation
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200Delegation" (\obj -> (GHC.Base.pure PutWalletResponseBody200Delegation GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "next"))
-- | Create a new 'PutWalletResponseBody200Delegation' with all required fields.
mkPutWalletResponseBody200Delegation :: PutWalletResponseBody200DelegationActive -- ^ 'putWalletResponseBody200DelegationActive'
  -> [PutWalletResponseBody200DelegationNext] -- ^ 'putWalletResponseBody200DelegationNext'
  -> PutWalletResponseBody200Delegation
mkPutWalletResponseBody200Delegation putWalletResponseBody200DelegationActive putWalletResponseBody200DelegationNext = PutWalletResponseBody200Delegation{putWalletResponseBody200DelegationActive = putWalletResponseBody200DelegationActive,
                                                                                                                                                          putWalletResponseBody200DelegationNext = putWalletResponseBody200DelegationNext}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.delegation.properties.active@ in the specification.
-- 
-- Currently active delegation status.
data PutWalletResponseBody200DelegationActive = PutWalletResponseBody200DelegationActive {
  -- | status
  putWalletResponseBody200DelegationActiveStatus :: PutWalletResponseBody200DelegationActiveStatus
  -- | target: A unique Stake-Pool identifier (present only if status = \`delegating\`)
  , putWalletResponseBody200DelegationActiveTarget :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200DelegationActive
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["status" Data.Aeson.Types.ToJSON..= putWalletResponseBody200DelegationActiveStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (putWalletResponseBody200DelegationActiveTarget obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["status" Data.Aeson.Types.ToJSON..= putWalletResponseBody200DelegationActiveStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (putWalletResponseBody200DelegationActiveTarget obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200DelegationActive
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200DelegationActive" (\obj -> (GHC.Base.pure PutWalletResponseBody200DelegationActive GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "target"))
-- | Create a new 'PutWalletResponseBody200DelegationActive' with all required fields.
mkPutWalletResponseBody200DelegationActive :: PutWalletResponseBody200DelegationActiveStatus -- ^ 'putWalletResponseBody200DelegationActiveStatus'
  -> PutWalletResponseBody200DelegationActive
mkPutWalletResponseBody200DelegationActive putWalletResponseBody200DelegationActiveStatus = PutWalletResponseBody200DelegationActive{putWalletResponseBody200DelegationActiveStatus = putWalletResponseBody200DelegationActiveStatus,
                                                                                                                                     putWalletResponseBody200DelegationActiveTarget = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.delegation.properties.active.properties.status@ in the specification.
-- 
-- 
data PutWalletResponseBody200DelegationActiveStatus =
   PutWalletResponseBody200DelegationActiveStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PutWalletResponseBody200DelegationActiveStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PutWalletResponseBody200DelegationActiveStatusEnumNot_delegating -- ^ Represents the JSON value @"not_delegating"@
  | PutWalletResponseBody200DelegationActiveStatusEnumDelegating -- ^ Represents the JSON value @"delegating"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200DelegationActiveStatus
    where toJSON (PutWalletResponseBody200DelegationActiveStatusOther val) = val
          toJSON (PutWalletResponseBody200DelegationActiveStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PutWalletResponseBody200DelegationActiveStatusEnumNot_delegating) = "not_delegating"
          toJSON (PutWalletResponseBody200DelegationActiveStatusEnumDelegating) = "delegating"
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200DelegationActiveStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "not_delegating" -> PutWalletResponseBody200DelegationActiveStatusEnumNot_delegating
                                            | val GHC.Classes.== "delegating" -> PutWalletResponseBody200DelegationActiveStatusEnumDelegating
                                            | GHC.Base.otherwise -> PutWalletResponseBody200DelegationActiveStatusOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.delegation.properties.next.items@ in the specification.
-- 
-- Next delegation status becomes active at the start of the second epoch after the corresponding delegation certificate was discovered. The exact moment is specified by changes_at
data PutWalletResponseBody200DelegationNext = PutWalletResponseBody200DelegationNext {
  -- | changes_at
  putWalletResponseBody200DelegationNextChanges_at :: PutWalletResponseBody200DelegationNextChanges_at
  -- | status
  , putWalletResponseBody200DelegationNextStatus :: PutWalletResponseBody200DelegationNextStatus
  -- | target: A unique Stake-Pool identifier (present only if status = \`delegating\`)
  , putWalletResponseBody200DelegationNextTarget :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200DelegationNext
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["changes_at" Data.Aeson.Types.ToJSON..= putWalletResponseBody200DelegationNextChanges_at obj] : ["status" Data.Aeson.Types.ToJSON..= putWalletResponseBody200DelegationNextStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (putWalletResponseBody200DelegationNextTarget obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["changes_at" Data.Aeson.Types.ToJSON..= putWalletResponseBody200DelegationNextChanges_at obj] : ["status" Data.Aeson.Types.ToJSON..= putWalletResponseBody200DelegationNextStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (putWalletResponseBody200DelegationNextTarget obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200DelegationNext
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200DelegationNext" (\obj -> ((GHC.Base.pure PutWalletResponseBody200DelegationNext GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "changes_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "target"))
-- | Create a new 'PutWalletResponseBody200DelegationNext' with all required fields.
mkPutWalletResponseBody200DelegationNext :: PutWalletResponseBody200DelegationNextChanges_at -- ^ 'putWalletResponseBody200DelegationNextChanges_at'
  -> PutWalletResponseBody200DelegationNextStatus -- ^ 'putWalletResponseBody200DelegationNextStatus'
  -> PutWalletResponseBody200DelegationNext
mkPutWalletResponseBody200DelegationNext putWalletResponseBody200DelegationNextChanges_at putWalletResponseBody200DelegationNextStatus = PutWalletResponseBody200DelegationNext{putWalletResponseBody200DelegationNextChanges_at = putWalletResponseBody200DelegationNextChanges_at,
                                                                                                                                                                                putWalletResponseBody200DelegationNextStatus = putWalletResponseBody200DelegationNextStatus,
                                                                                                                                                                                putWalletResponseBody200DelegationNextTarget = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.delegation.properties.next.items.properties.changes_at@ in the specification.
-- 
-- 
data PutWalletResponseBody200DelegationNextChanges_at = PutWalletResponseBody200DelegationNextChanges_at {
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  putWalletResponseBody200DelegationNextChanges_atEpoch_number :: GHC.Types.Int
  -- | epoch_start_time
  , putWalletResponseBody200DelegationNextChanges_atEpoch_start_time :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200DelegationNextChanges_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["epoch_number" Data.Aeson.Types.ToJSON..= putWalletResponseBody200DelegationNextChanges_atEpoch_number obj] : ["epoch_start_time" Data.Aeson.Types.ToJSON..= putWalletResponseBody200DelegationNextChanges_atEpoch_start_time obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["epoch_number" Data.Aeson.Types.ToJSON..= putWalletResponseBody200DelegationNextChanges_atEpoch_number obj] : ["epoch_start_time" Data.Aeson.Types.ToJSON..= putWalletResponseBody200DelegationNextChanges_atEpoch_start_time obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200DelegationNextChanges_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200DelegationNextChanges_at" (\obj -> (GHC.Base.pure PutWalletResponseBody200DelegationNextChanges_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_start_time"))
-- | Create a new 'PutWalletResponseBody200DelegationNextChanges_at' with all required fields.
mkPutWalletResponseBody200DelegationNextChanges_at :: GHC.Types.Int -- ^ 'putWalletResponseBody200DelegationNextChanges_atEpoch_number'
  -> Data.Text.Internal.Text -- ^ 'putWalletResponseBody200DelegationNextChanges_atEpoch_start_time'
  -> PutWalletResponseBody200DelegationNextChanges_at
mkPutWalletResponseBody200DelegationNextChanges_at putWalletResponseBody200DelegationNextChanges_atEpoch_number putWalletResponseBody200DelegationNextChanges_atEpoch_start_time = PutWalletResponseBody200DelegationNextChanges_at{putWalletResponseBody200DelegationNextChanges_atEpoch_number = putWalletResponseBody200DelegationNextChanges_atEpoch_number,
                                                                                                                                                                                                                                    putWalletResponseBody200DelegationNextChanges_atEpoch_start_time = putWalletResponseBody200DelegationNextChanges_atEpoch_start_time}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.delegation.properties.next.items.properties.status@ in the specification.
-- 
-- 
data PutWalletResponseBody200DelegationNextStatus =
   PutWalletResponseBody200DelegationNextStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PutWalletResponseBody200DelegationNextStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PutWalletResponseBody200DelegationNextStatusEnumNot_delegating -- ^ Represents the JSON value @"not_delegating"@
  | PutWalletResponseBody200DelegationNextStatusEnumDelegating -- ^ Represents the JSON value @"delegating"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200DelegationNextStatus
    where toJSON (PutWalletResponseBody200DelegationNextStatusOther val) = val
          toJSON (PutWalletResponseBody200DelegationNextStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PutWalletResponseBody200DelegationNextStatusEnumNot_delegating) = "not_delegating"
          toJSON (PutWalletResponseBody200DelegationNextStatusEnumDelegating) = "delegating"
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200DelegationNextStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "not_delegating" -> PutWalletResponseBody200DelegationNextStatusEnumNot_delegating
                                            | val GHC.Classes.== "delegating" -> PutWalletResponseBody200DelegationNextStatusEnumDelegating
                                            | GHC.Base.otherwise -> PutWalletResponseBody200DelegationNextStatusOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.passphrase@ in the specification.
-- 
-- Information about the wallet\'s passphrase
data PutWalletResponseBody200Passphrase = PutWalletResponseBody200Passphrase {
  -- | last_updated_at
  putWalletResponseBody200PassphraseLast_updated_at :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200Passphrase
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= putWalletResponseBody200PassphraseLast_updated_at obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= putWalletResponseBody200PassphraseLast_updated_at obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200Passphrase
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200Passphrase" (\obj -> GHC.Base.pure PutWalletResponseBody200Passphrase GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "last_updated_at"))
-- | Create a new 'PutWalletResponseBody200Passphrase' with all required fields.
mkPutWalletResponseBody200Passphrase :: Data.Text.Internal.Text -- ^ 'putWalletResponseBody200PassphraseLast_updated_at'
  -> PutWalletResponseBody200Passphrase
mkPutWalletResponseBody200Passphrase putWalletResponseBody200PassphraseLast_updated_at = PutWalletResponseBody200Passphrase{putWalletResponseBody200PassphraseLast_updated_at = putWalletResponseBody200PassphraseLast_updated_at}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.state@ in the specification.
-- 
-- Whether a wallet is ready to use or still syncing
data PutWalletResponseBody200State = PutWalletResponseBody200State {
  -- | progress: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == syncing
  -- \<\/span>\<br\/>
  putWalletResponseBody200StateProgress :: (GHC.Maybe.Maybe PutWalletResponseBody200StateProgress)
  -- | status
  , putWalletResponseBody200StateStatus :: PutWalletResponseBody200StateStatus
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200State
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (putWalletResponseBody200StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= putWalletResponseBody200StateStatus obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (putWalletResponseBody200StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= putWalletResponseBody200StateStatus obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200State
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200State" (\obj -> (GHC.Base.pure PutWalletResponseBody200State GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "progress")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status"))
-- | Create a new 'PutWalletResponseBody200State' with all required fields.
mkPutWalletResponseBody200State :: PutWalletResponseBody200StateStatus -- ^ 'putWalletResponseBody200StateStatus'
  -> PutWalletResponseBody200State
mkPutWalletResponseBody200State putWalletResponseBody200StateStatus = PutWalletResponseBody200State{putWalletResponseBody200StateProgress = GHC.Maybe.Nothing,
                                                                                                    putWalletResponseBody200StateStatus = putWalletResponseBody200StateStatus}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.state.properties.progress@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == syncing
-- \<\/span>\<br\/>
data PutWalletResponseBody200StateProgress = PutWalletResponseBody200StateProgress {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  putWalletResponseBody200StateProgressQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200StateProgress
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putWalletResponseBody200StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putWalletResponseBody200StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200StateProgress
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200StateProgress" (\obj -> GHC.Base.pure PutWalletResponseBody200StateProgress GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PutWalletResponseBody200StateProgress' with all required fields.
mkPutWalletResponseBody200StateProgress :: GHC.Types.Double -- ^ 'putWalletResponseBody200StateProgressQuantity'
  -> PutWalletResponseBody200StateProgress
mkPutWalletResponseBody200StateProgress putWalletResponseBody200StateProgressQuantity = PutWalletResponseBody200StateProgress{putWalletResponseBody200StateProgressQuantity = putWalletResponseBody200StateProgressQuantity}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.state.properties.status@ in the specification.
-- 
-- 
data PutWalletResponseBody200StateStatus =
   PutWalletResponseBody200StateStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PutWalletResponseBody200StateStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PutWalletResponseBody200StateStatusEnumReady -- ^ Represents the JSON value @"ready"@
  | PutWalletResponseBody200StateStatusEnumSyncing -- ^ Represents the JSON value @"syncing"@
  | PutWalletResponseBody200StateStatusEnumNot_responding -- ^ Represents the JSON value @"not_responding"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200StateStatus
    where toJSON (PutWalletResponseBody200StateStatusOther val) = val
          toJSON (PutWalletResponseBody200StateStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PutWalletResponseBody200StateStatusEnumReady) = "ready"
          toJSON (PutWalletResponseBody200StateStatusEnumSyncing) = "syncing"
          toJSON (PutWalletResponseBody200StateStatusEnumNot_responding) = "not_responding"
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200StateStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "ready" -> PutWalletResponseBody200StateStatusEnumReady
                                            | val GHC.Classes.== "syncing" -> PutWalletResponseBody200StateStatusEnumSyncing
                                            | val GHC.Classes.== "not_responding" -> PutWalletResponseBody200StateStatusEnumNot_responding
                                            | GHC.Base.otherwise -> PutWalletResponseBody200StateStatusOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.tip@ in the specification.
-- 
-- A reference to a particular time slot, and the block height at that point.
data PutWalletResponseBody200Tip = PutWalletResponseBody200Tip {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  putWalletResponseBody200TipAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , putWalletResponseBody200TipEpoch_number :: GHC.Types.Int
  -- | height
  , putWalletResponseBody200TipHeight :: PutWalletResponseBody200TipHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , putWalletResponseBody200TipSlot_number :: GHC.Types.Int
  -- | time
  , putWalletResponseBody200TipTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200Tip
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= putWalletResponseBody200TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= putWalletResponseBody200TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= putWalletResponseBody200TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= putWalletResponseBody200TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= putWalletResponseBody200TipTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= putWalletResponseBody200TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= putWalletResponseBody200TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= putWalletResponseBody200TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= putWalletResponseBody200TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= putWalletResponseBody200TipTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200Tip
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200Tip" (\obj -> ((((GHC.Base.pure PutWalletResponseBody200Tip GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'PutWalletResponseBody200Tip' with all required fields.
mkPutWalletResponseBody200Tip :: GHC.Types.Int -- ^ 'putWalletResponseBody200TipAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'putWalletResponseBody200TipEpoch_number'
  -> PutWalletResponseBody200TipHeight -- ^ 'putWalletResponseBody200TipHeight'
  -> GHC.Types.Int -- ^ 'putWalletResponseBody200TipSlot_number'
  -> Data.Text.Internal.Text -- ^ 'putWalletResponseBody200TipTime'
  -> PutWalletResponseBody200Tip
mkPutWalletResponseBody200Tip putWalletResponseBody200TipAbsolute_slot_number putWalletResponseBody200TipEpoch_number putWalletResponseBody200TipHeight putWalletResponseBody200TipSlot_number putWalletResponseBody200TipTime = PutWalletResponseBody200Tip{putWalletResponseBody200TipAbsolute_slot_number = putWalletResponseBody200TipAbsolute_slot_number,
                                                                                                                                                                                                                                                             putWalletResponseBody200TipEpoch_number = putWalletResponseBody200TipEpoch_number,
                                                                                                                                                                                                                                                             putWalletResponseBody200TipHeight = putWalletResponseBody200TipHeight,
                                                                                                                                                                                                                                                             putWalletResponseBody200TipSlot_number = putWalletResponseBody200TipSlot_number,
                                                                                                                                                                                                                                                             putWalletResponseBody200TipTime = putWalletResponseBody200TipTime}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.tip.properties.height@ in the specification.
-- 
-- 
data PutWalletResponseBody200TipHeight = PutWalletResponseBody200TipHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  putWalletResponseBody200TipHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody200TipHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putWalletResponseBody200TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putWalletResponseBody200TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody200TipHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody200TipHeight" (\obj -> GHC.Base.pure PutWalletResponseBody200TipHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PutWalletResponseBody200TipHeight' with all required fields.
mkPutWalletResponseBody200TipHeight :: GHC.Types.Int -- ^ 'putWalletResponseBody200TipHeightQuantity'
  -> PutWalletResponseBody200TipHeight
mkPutWalletResponseBody200TipHeight putWalletResponseBody200TipHeightQuantity = PutWalletResponseBody200TipHeight{putWalletResponseBody200TipHeightQuantity = putWalletResponseBody200TipHeightQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data PutWalletResponseBody400 = PutWalletResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  putWalletResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody400" (\obj -> GHC.Base.pure PutWalletResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutWalletResponseBody400' with all required fields.
mkPutWalletResponseBody400 :: Data.Text.Internal.Text -- ^ 'putWalletResponseBody400Message'
  -> PutWalletResponseBody400
mkPutWalletResponseBody400 putWalletResponseBody400Message = PutWalletResponseBody400{putWalletResponseBody400Message = putWalletResponseBody400Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data PutWalletResponseBody404 = PutWalletResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  putWalletResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody404" (\obj -> GHC.Base.pure PutWalletResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutWalletResponseBody404' with all required fields.
mkPutWalletResponseBody404 :: Data.Text.Internal.Text -- ^ 'putWalletResponseBody404Message'
  -> PutWalletResponseBody404
mkPutWalletResponseBody404 putWalletResponseBody404Message = PutWalletResponseBody404{putWalletResponseBody404Message = putWalletResponseBody404Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data PutWalletResponseBody406 = PutWalletResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  putWalletResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody406" (\obj -> GHC.Base.pure PutWalletResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutWalletResponseBody406' with all required fields.
mkPutWalletResponseBody406 :: Data.Text.Internal.Text -- ^ 'putWalletResponseBody406Message'
  -> PutWalletResponseBody406
mkPutWalletResponseBody406 putWalletResponseBody406Message = PutWalletResponseBody406{putWalletResponseBody406Message = putWalletResponseBody406Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}.PUT.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data PutWalletResponseBody415 = PutWalletResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  putWalletResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletResponseBody415" (\obj -> GHC.Base.pure PutWalletResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutWalletResponseBody415' with all required fields.
mkPutWalletResponseBody415 :: Data.Text.Internal.Text -- ^ 'putWalletResponseBody415Message'
  -> PutWalletResponseBody415
mkPutWalletResponseBody415 putWalletResponseBody415Message = PutWalletResponseBody415{putWalletResponseBody415Message = putWalletResponseBody415Message}
-- | > PUT /wallets/{walletId}
-- 
-- The same as 'putWallet' but accepts an explicit configuration.
putWalletWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutWalletRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response PutWalletResponse) -- ^ Monadic computation which returns the result of the operation
putWalletWithConfiguration config
                           walletId
                           body = GHC.Base.fmap (\response_6 -> GHC.Base.fmap (Data.Either.either PutWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                               PutWalletResponseBody200)
                                                                                                                                                                      | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                               PutWalletResponseBody400)
                                                                                                                                                                      | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                               PutWalletResponseBody404)
                                                                                                                                                                      | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                 PutWalletResponseBody406)
                                                                                                                                                                      | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                 PutWalletResponseBody415)
                                                                                                                                                                      | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_6) response_6) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > PUT /wallets/{walletId}
-- 
-- The same as 'putWallet' but returns the raw 'Data.ByteString.ByteString'.
putWalletRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutWalletRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
putWalletRaw walletId
             body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > PUT /wallets/{walletId}
-- 
-- The same as 'putWallet' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
putWalletWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutWalletRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
putWalletWithConfigurationRaw config
                              walletId
                              body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
