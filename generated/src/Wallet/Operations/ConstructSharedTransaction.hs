-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation constructSharedTransaction
module Wallet.Operations.ConstructSharedTransaction where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /shared-wallets/{walletId}/transactions-construct
-- 
-- \<p align=\"right\">status: \<strong>under development\<\/strong>\<\/p>
-- 
-- Create a transaction to be signed from the shared wallet.
-- 
-- Works for the following fields:
--   - payments
--   - metadata
--   - validity_interval
constructSharedTransaction :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> ConstructSharedTransactionRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response ConstructSharedTransactionResponse) -- ^ Monadic computation which returns the result of the operation
constructSharedTransaction walletId
                           body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either ConstructSharedTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> ConstructSharedTransactionResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                 ConstructSharedTransactionResponseBody202)
                                                                                                                                                                                       | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> ConstructSharedTransactionResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                 ConstructSharedTransactionResponseBody400Variants)
                                                                                                                                                                                       | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> ConstructSharedTransactionResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                 ConstructSharedTransactionResponseBody403Variants)
                                                                                                                                                                                       | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> ConstructSharedTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                 ConstructSharedTransactionResponseBody404)
                                                                                                                                                                                       | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ConstructSharedTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                 ConstructSharedTransactionResponseBody406)
                                                                                                                                                                                       | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> ConstructSharedTransactionResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                 ConstructSharedTransactionResponseBody415)
                                                                                                                                                                                       | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/shared-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-construct")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema@ in the specification.
-- 
-- At least one field needs to be chosen
data ConstructSharedTransactionRequestBody = ConstructSharedTransactionRequestBody {
  -- | delegations: \<p>status: \<strong>stable\<\/strong>\<\/p>
  -- 
  -- A list of staking actions (joining, rejoining or leaving from stake pools).
  -- Using \'0H\' stake key index is supported at this moment. This will change with
  -- multi-account support.
  -- Only one delegation action can be used.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  constructSharedTransactionRequestBodyDelegations :: (GHC.Maybe.Maybe ([ConstructSharedTransactionRequestBodyDelegationsVariants]))
  -- | encoding: Encoding of transaction CBOR returned in response (base64 by default).
  , constructSharedTransactionRequestBodyEncoding :: (GHC.Maybe.Maybe ConstructSharedTransactionRequestBodyEncoding)
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  , constructSharedTransactionRequestBodyMetadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | mint_burn: An entry for each unique asset to be minted and\/or burned,
  -- containing helpful information.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , constructSharedTransactionRequestBodyMint_burn :: (GHC.Maybe.Maybe ([ConstructSharedTransactionRequestBodyMint_burn]))
  -- | payments: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , constructSharedTransactionRequestBodyPayments :: (GHC.Maybe.Maybe ([ConstructSharedTransactionRequestBodyPayments]))
  -- | validity_interval: Specify only invalid_before or invalid_hereafter or both.
  -- 
  -- Please note that, if not set, the default values are:
  --   - \`\"invalid_before\": {\"quantity\":0, \"unit\":\"slot\"}\`
  --   - \`\"invalid_hereafter\":{\"quantity\":7200, \"unit\":\"second\"}\`
  -- 
  -- Which translates to 2h transaction TTL.
  , constructSharedTransactionRequestBodyValidity_interval :: (GHC.Maybe.Maybe ConstructSharedTransactionRequestBodyValidity_interval)
  -- | withdrawal: When provided, instruments the server to automatically withdraw rewards from the source wallet when they are deemed
  -- sufficient (i.e. they contribute to the balance for at least as much as they cost).
  -- 
  -- As a consequence, the resulting transaction may or may not have a withdrawal object. Summarizing:
  -- 
  -- withdrawal field | reward balance | result
  -- ---              | ---            | ---
  -- \`null\`           | too small      | ✓ no withdrawals generated
  -- \`null\`           | big enough     | ✓ no withdrawals generated
  -- \`\"self\"\`         | too small      | ✓ no withdrawals generated
  -- \`\"self\"\`         | big enough     | ✓ withdrawal generated
  , constructSharedTransactionRequestBodyWithdrawal :: (GHC.Maybe.Maybe ConstructSharedTransactionRequestBodyWithdrawal)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("delegations" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyDelegations obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("encoding" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyEncoding obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyMetadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint_burn" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyMint_burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("payments" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyPayments obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyValidity_interval obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawal" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyWithdrawal obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("delegations" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyDelegations obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("encoding" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyEncoding obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyMetadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint_burn" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyMint_burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("payments" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyPayments obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyValidity_interval obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawal" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyWithdrawal obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBody" (\obj -> ((((((GHC.Base.pure ConstructSharedTransactionRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "delegations")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "encoding")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mint_burn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "payments")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "validity_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "withdrawal"))
-- | Create a new 'ConstructSharedTransactionRequestBody' with all required fields.
mkConstructSharedTransactionRequestBody :: ConstructSharedTransactionRequestBody
mkConstructSharedTransactionRequestBody = ConstructSharedTransactionRequestBody{constructSharedTransactionRequestBodyDelegations = GHC.Maybe.Nothing,
                                                                                constructSharedTransactionRequestBodyEncoding = GHC.Maybe.Nothing,
                                                                                constructSharedTransactionRequestBodyMetadata = GHC.Maybe.Nothing,
                                                                                constructSharedTransactionRequestBodyMint_burn = GHC.Maybe.Nothing,
                                                                                constructSharedTransactionRequestBodyPayments = GHC.Maybe.Nothing,
                                                                                constructSharedTransactionRequestBodyValidity_interval = GHC.Maybe.Nothing,
                                                                                constructSharedTransactionRequestBodyWithdrawal = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.delegations.items.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyDelegationsOneOf1 = ConstructSharedTransactionRequestBodyDelegationsOneOf1 {
  -- | join
  constructSharedTransactionRequestBodyDelegationsOneOf1Join :: ConstructSharedTransactionRequestBodyDelegationsOneOf1Join
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyDelegationsOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["join" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyDelegationsOneOf1Join obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["join" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyDelegationsOneOf1Join obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyDelegationsOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyDelegationsOneOf1" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyDelegationsOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "join"))
-- | Create a new 'ConstructSharedTransactionRequestBodyDelegationsOneOf1' with all required fields.
mkConstructSharedTransactionRequestBodyDelegationsOneOf1 :: ConstructSharedTransactionRequestBodyDelegationsOneOf1Join -- ^ 'constructSharedTransactionRequestBodyDelegationsOneOf1Join'
  -> ConstructSharedTransactionRequestBodyDelegationsOneOf1
mkConstructSharedTransactionRequestBodyDelegationsOneOf1 constructSharedTransactionRequestBodyDelegationsOneOf1Join = ConstructSharedTransactionRequestBodyDelegationsOneOf1{constructSharedTransactionRequestBodyDelegationsOneOf1Join = constructSharedTransactionRequestBodyDelegationsOneOf1Join}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.delegations.items.oneOf.properties.join@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyDelegationsOneOf1Join = ConstructSharedTransactionRequestBodyDelegationsOneOf1Join {
  -- | pool: A unique identifier for the pool.
  constructSharedTransactionRequestBodyDelegationsOneOf1JoinPool :: Data.Text.Internal.Text
  -- | stake_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , constructSharedTransactionRequestBodyDelegationsOneOf1JoinStake_key_index :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyDelegationsOneOf1Join
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyDelegationsOneOf1JoinPool obj] : ["stake_key_index" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyDelegationsOneOf1JoinStake_key_index obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyDelegationsOneOf1JoinPool obj] : ["stake_key_index" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyDelegationsOneOf1JoinStake_key_index obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyDelegationsOneOf1Join
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyDelegationsOneOf1Join" (\obj -> (GHC.Base.pure ConstructSharedTransactionRequestBodyDelegationsOneOf1Join GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_key_index"))
-- | Create a new 'ConstructSharedTransactionRequestBodyDelegationsOneOf1Join' with all required fields.
mkConstructSharedTransactionRequestBodyDelegationsOneOf1Join :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionRequestBodyDelegationsOneOf1JoinPool'
  -> Data.Text.Internal.Text -- ^ 'constructSharedTransactionRequestBodyDelegationsOneOf1JoinStake_key_index'
  -> ConstructSharedTransactionRequestBodyDelegationsOneOf1Join
mkConstructSharedTransactionRequestBodyDelegationsOneOf1Join constructSharedTransactionRequestBodyDelegationsOneOf1JoinPool constructSharedTransactionRequestBodyDelegationsOneOf1JoinStake_key_index = ConstructSharedTransactionRequestBodyDelegationsOneOf1Join{constructSharedTransactionRequestBodyDelegationsOneOf1JoinPool = constructSharedTransactionRequestBodyDelegationsOneOf1JoinPool,
                                                                                                                                                                                                                                                                   constructSharedTransactionRequestBodyDelegationsOneOf1JoinStake_key_index = constructSharedTransactionRequestBodyDelegationsOneOf1JoinStake_key_index}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.delegations.items.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyDelegationsOneOf2 = ConstructSharedTransactionRequestBodyDelegationsOneOf2 {
  -- | quit
  constructSharedTransactionRequestBodyDelegationsOneOf2Quit :: ConstructSharedTransactionRequestBodyDelegationsOneOf2Quit
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyDelegationsOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quit" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyDelegationsOneOf2Quit obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quit" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyDelegationsOneOf2Quit obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyDelegationsOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyDelegationsOneOf2" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyDelegationsOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quit"))
-- | Create a new 'ConstructSharedTransactionRequestBodyDelegationsOneOf2' with all required fields.
mkConstructSharedTransactionRequestBodyDelegationsOneOf2 :: ConstructSharedTransactionRequestBodyDelegationsOneOf2Quit -- ^ 'constructSharedTransactionRequestBodyDelegationsOneOf2Quit'
  -> ConstructSharedTransactionRequestBodyDelegationsOneOf2
mkConstructSharedTransactionRequestBodyDelegationsOneOf2 constructSharedTransactionRequestBodyDelegationsOneOf2Quit = ConstructSharedTransactionRequestBodyDelegationsOneOf2{constructSharedTransactionRequestBodyDelegationsOneOf2Quit = constructSharedTransactionRequestBodyDelegationsOneOf2Quit}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.delegations.items.oneOf.properties.quit@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyDelegationsOneOf2Quit = ConstructSharedTransactionRequestBodyDelegationsOneOf2Quit {
  -- | stake_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  constructSharedTransactionRequestBodyDelegationsOneOf2QuitStake_key_index :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyDelegationsOneOf2Quit
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["stake_key_index" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyDelegationsOneOf2QuitStake_key_index obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["stake_key_index" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyDelegationsOneOf2QuitStake_key_index obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyDelegationsOneOf2Quit
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyDelegationsOneOf2Quit" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyDelegationsOneOf2Quit GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_key_index"))
-- | Create a new 'ConstructSharedTransactionRequestBodyDelegationsOneOf2Quit' with all required fields.
mkConstructSharedTransactionRequestBodyDelegationsOneOf2Quit :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionRequestBodyDelegationsOneOf2QuitStake_key_index'
  -> ConstructSharedTransactionRequestBodyDelegationsOneOf2Quit
mkConstructSharedTransactionRequestBodyDelegationsOneOf2Quit constructSharedTransactionRequestBodyDelegationsOneOf2QuitStake_key_index = ConstructSharedTransactionRequestBodyDelegationsOneOf2Quit{constructSharedTransactionRequestBodyDelegationsOneOf2QuitStake_key_index = constructSharedTransactionRequestBodyDelegationsOneOf2QuitStake_key_index}
-- | Defines the oneOf schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.delegations.items.oneOf@ in the specification.
-- 
-- A delegation action for a given stake key denoted by its soft index.
-- Pool id is only required for \"join\".
-- Stake key index are required for both actions.
data ConstructSharedTransactionRequestBodyDelegationsVariants =
   ConstructSharedTransactionRequestBodyDelegationsVariant1 ConstructSharedTransactionRequestBodyDelegationsOneOf1
  | ConstructSharedTransactionRequestBodyDelegationsVariant2 ConstructSharedTransactionRequestBodyDelegationsOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyDelegationsVariants
    where toJSON (ConstructSharedTransactionRequestBodyDelegationsVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionRequestBodyDelegationsVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyDelegationsVariants
    where parseJSON val = case (ConstructSharedTransactionRequestBodyDelegationsVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionRequestBodyDelegationsVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the enum schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.encoding@ in the specification.
-- 
-- Encoding of transaction CBOR returned in response (base64 by default).
data ConstructSharedTransactionRequestBodyEncoding =
   ConstructSharedTransactionRequestBodyEncodingOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ConstructSharedTransactionRequestBodyEncodingTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ConstructSharedTransactionRequestBodyEncodingEnumBase16 -- ^ Represents the JSON value @"base16"@
  | ConstructSharedTransactionRequestBodyEncodingEnumBase64 -- ^ Represents the JSON value @"base64"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyEncoding
    where toJSON (ConstructSharedTransactionRequestBodyEncodingOther val) = val
          toJSON (ConstructSharedTransactionRequestBodyEncodingTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ConstructSharedTransactionRequestBodyEncodingEnumBase16) = "base16"
          toJSON (ConstructSharedTransactionRequestBodyEncodingEnumBase64) = "base64"
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyEncoding
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "base16" -> ConstructSharedTransactionRequestBodyEncodingEnumBase16
                                            | val GHC.Classes.== "base64" -> ConstructSharedTransactionRequestBodyEncodingEnumBase64
                                            | GHC.Base.otherwise -> ConstructSharedTransactionRequestBodyEncodingOther val)
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyMint_burn = ConstructSharedTransactionRequestBodyMint_burn {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  constructSharedTransactionRequestBodyMint_burnAsset_name :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | operation
  , constructSharedTransactionRequestBodyMint_burnOperation :: ConstructSharedTransactionRequestBodyMint_burnOperationVariants
  -- | policy_script_template
  , constructSharedTransactionRequestBodyMint_burnPolicy_script_template :: ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyMint_burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("asset_name" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyMint_burnAsset_name obj) : ["operation" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnOperation obj] : ["policy_script_template" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_template obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("asset_name" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyMint_burnAsset_name obj) : ["operation" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnOperation obj] : ["policy_script_template" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_template obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyMint_burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyMint_burn" (\obj -> ((GHC.Base.pure ConstructSharedTransactionRequestBodyMint_burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "operation")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script_template"))
-- | Create a new 'ConstructSharedTransactionRequestBodyMint_burn' with all required fields.
mkConstructSharedTransactionRequestBodyMint_burn :: ConstructSharedTransactionRequestBodyMint_burnOperationVariants -- ^ 'constructSharedTransactionRequestBodyMint_burnOperation'
  -> ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariants -- ^ 'constructSharedTransactionRequestBodyMint_burnPolicy_script_template'
  -> ConstructSharedTransactionRequestBodyMint_burn
mkConstructSharedTransactionRequestBodyMint_burn constructSharedTransactionRequestBodyMint_burnOperation constructSharedTransactionRequestBodyMint_burnPolicy_script_template = ConstructSharedTransactionRequestBodyMint_burn{constructSharedTransactionRequestBodyMint_burnAsset_name = GHC.Maybe.Nothing,
                                                                                                                                                                                                                               constructSharedTransactionRequestBodyMint_burnOperation = constructSharedTransactionRequestBodyMint_burnOperation,
                                                                                                                                                                                                                               constructSharedTransactionRequestBodyMint_burnPolicy_script_template = constructSharedTransactionRequestBodyMint_burnPolicy_script_template}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.operation.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1 = ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1 {
  -- | mint
  constructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint :: (GHC.Maybe.Maybe ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mint"))
-- | Create a new 'ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1' with all required fields.
mkConstructSharedTransactionRequestBodyMint_burnOperationOneOf1 :: ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1
mkConstructSharedTransactionRequestBodyMint_burnOperationOneOf1 = ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1{constructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.operation.oneOf.properties.mint@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint = ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint {
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionRequestBodyMint_burnOperationOneOf1MintQuantity :: GHC.Types.Int
  -- | receiving_address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  , constructSharedTransactionRequestBodyMint_burnOperationOneOf1MintReceiving_address :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnOperationOneOf1MintQuantity obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("receiving_address" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyMint_burnOperationOneOf1MintReceiving_address obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnOperationOneOf1MintQuantity obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("receiving_address" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyMint_burnOperationOneOf1MintReceiving_address obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint" (\obj -> (GHC.Base.pure ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "receiving_address"))
-- | Create a new 'ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint' with all required fields.
mkConstructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint :: GHC.Types.Int -- ^ 'constructSharedTransactionRequestBodyMint_burnOperationOneOf1MintQuantity'
  -> ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint
mkConstructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint constructSharedTransactionRequestBodyMint_burnOperationOneOf1MintQuantity = ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1Mint{constructSharedTransactionRequestBodyMint_burnOperationOneOf1MintQuantity = constructSharedTransactionRequestBodyMint_burnOperationOneOf1MintQuantity,
                                                                                                                                                                                                                  constructSharedTransactionRequestBodyMint_burnOperationOneOf1MintReceiving_address = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.operation.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2 = ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2 {
  -- | burn
  constructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn :: (GHC.Maybe.Maybe ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "burn"))
-- | Create a new 'ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2' with all required fields.
mkConstructSharedTransactionRequestBodyMint_burnOperationOneOf2 :: ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2
mkConstructSharedTransactionRequestBodyMint_burnOperationOneOf2 = ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2{constructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.operation.oneOf.properties.burn@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn = ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn {
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionRequestBodyMint_burnOperationOneOf2BurnQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnOperationOneOf2BurnQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnOperationOneOf2BurnQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn' with all required fields.
mkConstructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn :: GHC.Types.Int -- ^ 'constructSharedTransactionRequestBodyMint_burnOperationOneOf2BurnQuantity'
  -> ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn
mkConstructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn constructSharedTransactionRequestBodyMint_burnOperationOneOf2BurnQuantity = ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2Burn{constructSharedTransactionRequestBodyMint_burnOperationOneOf2BurnQuantity = constructSharedTransactionRequestBodyMint_burnOperationOneOf2BurnQuantity}
-- | Defines the oneOf schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.operation.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyMint_burnOperationVariants =
   ConstructSharedTransactionRequestBodyMint_burnOperationVariant1 ConstructSharedTransactionRequestBodyMint_burnOperationOneOf1
  | ConstructSharedTransactionRequestBodyMint_burnOperationVariant2 ConstructSharedTransactionRequestBodyMint_burnOperationOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyMint_burnOperationVariants
    where toJSON (ConstructSharedTransactionRequestBodyMint_burnOperationVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionRequestBodyMint_burnOperationVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyMint_burnOperationVariants
    where parseJSON val = case (ConstructSharedTransactionRequestBodyMint_burnOperationVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionRequestBodyMint_burnOperationVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2 = ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list cosigners\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2All :: ([ScriptTemplateValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2' with all required fields.
mkConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2 :: [ScriptTemplateValue] -- ^ 'constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2All'
  -> ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2
mkConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2 constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2All = ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2{constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2All = constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2All}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3 = ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list cosigners\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3Any :: ([ScriptTemplateValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3' with all required fields.
mkConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3 :: [ScriptTemplateValue] -- ^ 'constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3Any'
  -> ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3
mkConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3 constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3Any = ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3{constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3Any = constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3Any}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4 = ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list cosigners\' verification keys are expected to make the script valid.
  constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some :: ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4' with all required fields.
mkConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4 :: ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some -- ^ 'constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some'
  -> ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4
mkConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4 constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some = ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4{constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some = constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.policy_script_template.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list cosigners\' verification keys are expected to make the script valid.
data ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some = ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeFrom :: ([ScriptTemplateValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some" (\obj -> (GHC.Base.pure ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some' with all required fields.
mkConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some :: GHC.Types.Int -- ^ 'constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeAt_least'
  -> [ScriptTemplateValue] -- ^ 'constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeFrom'
  -> ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some
mkConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeAt_least constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeFrom = ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some{constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeAt_least = constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                            constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeFrom = constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5 = ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5' with all required fields.
mkConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5 :: GHC.Types.Int -- ^ 'constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5Active_from'
  -> ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5
mkConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5 constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5Active_from = ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5{constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5Active_from = constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5Active_from}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6 = ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6' with all required fields.
mkConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6 :: GHC.Types.Int -- ^ 'constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6Active_until'
  -> ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6
mkConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6 constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6Active_until = ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6{constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6Active_until = constructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariants =
   ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant1 Data.Text.Internal.Text
  | ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant2 ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf2
  | ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant3 ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf3
  | ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant4 ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf4
  | ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant5 ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf5
  | ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant6 ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariants
    where toJSON (ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariants
    where parseJSON val = case (ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionRequestBodyMint_burnPolicy_script_templateVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.payments.items@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyPayments = ConstructSharedTransactionRequestBodyPayments {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  constructSharedTransactionRequestBodyPaymentsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructSharedTransactionRequestBodyPaymentsAmount :: ConstructSharedTransactionRequestBodyPaymentsAmount
  -- | assets: A flat list of assets (possibly empty).
  , constructSharedTransactionRequestBodyPaymentsAssets :: (GHC.Maybe.Maybe ([ConstructSharedTransactionRequestBodyPaymentsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyPayments
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyPaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyPaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyPaymentsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyPaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyPaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyPaymentsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyPayments
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyPayments" (\obj -> ((GHC.Base.pure ConstructSharedTransactionRequestBodyPayments GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'ConstructSharedTransactionRequestBodyPayments' with all required fields.
mkConstructSharedTransactionRequestBodyPayments :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionRequestBodyPaymentsAddress'
  -> ConstructSharedTransactionRequestBodyPaymentsAmount -- ^ 'constructSharedTransactionRequestBodyPaymentsAmount'
  -> ConstructSharedTransactionRequestBodyPayments
mkConstructSharedTransactionRequestBodyPayments constructSharedTransactionRequestBodyPaymentsAddress constructSharedTransactionRequestBodyPaymentsAmount = ConstructSharedTransactionRequestBodyPayments{constructSharedTransactionRequestBodyPaymentsAddress = constructSharedTransactionRequestBodyPaymentsAddress,
                                                                                                                                                                                                         constructSharedTransactionRequestBodyPaymentsAmount = constructSharedTransactionRequestBodyPaymentsAmount,
                                                                                                                                                                                                         constructSharedTransactionRequestBodyPaymentsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.payments.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructSharedTransactionRequestBodyPaymentsAmount = ConstructSharedTransactionRequestBodyPaymentsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionRequestBodyPaymentsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyPaymentsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyPaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyPaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyPaymentsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyPaymentsAmount" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyPaymentsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionRequestBodyPaymentsAmount' with all required fields.
mkConstructSharedTransactionRequestBodyPaymentsAmount :: GHC.Types.Int -- ^ 'constructSharedTransactionRequestBodyPaymentsAmountQuantity'
  -> ConstructSharedTransactionRequestBodyPaymentsAmount
mkConstructSharedTransactionRequestBodyPaymentsAmount constructSharedTransactionRequestBodyPaymentsAmountQuantity = ConstructSharedTransactionRequestBodyPaymentsAmount{constructSharedTransactionRequestBodyPaymentsAmountQuantity = constructSharedTransactionRequestBodyPaymentsAmountQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.payments.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ConstructSharedTransactionRequestBodyPaymentsAssets = ConstructSharedTransactionRequestBodyPaymentsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  constructSharedTransactionRequestBodyPaymentsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , constructSharedTransactionRequestBodyPaymentsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , constructSharedTransactionRequestBodyPaymentsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyPaymentsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyPaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyPaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyPaymentsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyPaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyPaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyPaymentsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyPaymentsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyPaymentsAssets" (\obj -> ((GHC.Base.pure ConstructSharedTransactionRequestBodyPaymentsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionRequestBodyPaymentsAssets' with all required fields.
mkConstructSharedTransactionRequestBodyPaymentsAssets :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionRequestBodyPaymentsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'constructSharedTransactionRequestBodyPaymentsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'constructSharedTransactionRequestBodyPaymentsAssetsQuantity'
  -> ConstructSharedTransactionRequestBodyPaymentsAssets
mkConstructSharedTransactionRequestBodyPaymentsAssets constructSharedTransactionRequestBodyPaymentsAssetsAsset_name constructSharedTransactionRequestBodyPaymentsAssetsPolicy_id constructSharedTransactionRequestBodyPaymentsAssetsQuantity = ConstructSharedTransactionRequestBodyPaymentsAssets{constructSharedTransactionRequestBodyPaymentsAssetsAsset_name = constructSharedTransactionRequestBodyPaymentsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                   constructSharedTransactionRequestBodyPaymentsAssetsPolicy_id = constructSharedTransactionRequestBodyPaymentsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                   constructSharedTransactionRequestBodyPaymentsAssetsQuantity = constructSharedTransactionRequestBodyPaymentsAssetsQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.validity_interval@ in the specification.
-- 
-- Specify only invalid_before or invalid_hereafter or both.
-- 
-- Please note that, if not set, the default values are:
--   - \`\"invalid_before\": {\"quantity\":0, \"unit\":\"slot\"}\`
--   - \`\"invalid_hereafter\":{\"quantity\":7200, \"unit\":\"second\"}\`
-- 
-- Which translates to 2h transaction TTL.
data ConstructSharedTransactionRequestBodyValidity_interval = ConstructSharedTransactionRequestBodyValidity_interval {
  -- | invalid_before
  constructSharedTransactionRequestBodyValidity_intervalInvalid_before :: (GHC.Maybe.Maybe ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeVariants)
  -- | invalid_hereafter
  , constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafter :: (GHC.Maybe.Maybe ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterVariants)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyValidity_interval
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invalid_before" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyValidity_intervalInvalid_before obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invalid_hereafter" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafter obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invalid_before" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyValidity_intervalInvalid_before obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invalid_hereafter" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafter obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyValidity_interval
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyValidity_interval" (\obj -> (GHC.Base.pure ConstructSharedTransactionRequestBodyValidity_interval GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "invalid_before")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "invalid_hereafter"))
-- | Create a new 'ConstructSharedTransactionRequestBodyValidity_interval' with all required fields.
mkConstructSharedTransactionRequestBodyValidity_interval :: ConstructSharedTransactionRequestBodyValidity_interval
mkConstructSharedTransactionRequestBodyValidity_interval = ConstructSharedTransactionRequestBodyValidity_interval{constructSharedTransactionRequestBodyValidity_intervalInvalid_before = GHC.Maybe.Nothing,
                                                                                                                  constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafter = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.validity_interval.properties.invalid_before.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1 = ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1 {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1Quantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "second"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "second"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1' with all required fields.
mkConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1 :: GHC.Types.Double -- ^ 'constructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1Quantity'
  -> ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1
mkConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1 constructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1Quantity = ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1{constructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1Quantity = constructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1Quantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.validity_interval.properties.invalid_before.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2 = ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2 {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2Quantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2' with all required fields.
mkConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2 :: GHC.Types.Int -- ^ 'constructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2Quantity'
  -> ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2
mkConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2 constructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2Quantity = ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2{constructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2Quantity = constructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2Quantity}
-- | Defines the oneOf schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.validity_interval.properties.invalid_before.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeVariants =
   ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeVariant1 ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1
  | ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeVariant2 ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeVariants
    where toJSON (ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeVariants
    where parseJSON val = case (ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionRequestBodyValidity_intervalInvalid_beforeVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.validity_interval.properties.invalid_hereafter.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1 = ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1 {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1Quantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "second"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "second"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1' with all required fields.
mkConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1 :: GHC.Types.Double -- ^ 'constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1Quantity'
  -> ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1
mkConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1 constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1Quantity = ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1{constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1Quantity = constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1Quantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.validity_interval.properties.invalid_hereafter.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2 = ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2 {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2Quantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2" (\obj -> GHC.Base.pure ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2' with all required fields.
mkConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2 :: GHC.Types.Int -- ^ 'constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2Quantity'
  -> ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2
mkConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2 constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2Quantity = ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2{constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2Quantity = constructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2Quantity}
-- | Defines the oneOf schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.validity_interval.properties.invalid_hereafter.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterVariants =
   ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterVariant1 ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1
  | ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterVariant2 ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterVariants
    where toJSON (ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterVariants
    where parseJSON val = case (ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionRequestBodyValidity_intervalInvalid_hereafterVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the enum schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.withdrawal@ in the specification.
-- 
-- When provided, instruments the server to automatically withdraw rewards from the source wallet when they are deemed
-- sufficient (i.e. they contribute to the balance for at least as much as they cost).
-- 
-- As a consequence, the resulting transaction may or may not have a withdrawal object. Summarizing:
-- 
-- withdrawal field | reward balance | result
-- ---              | ---            | ---
-- \`null\`           | too small      | ✓ no withdrawals generated
-- \`null\`           | big enough     | ✓ no withdrawals generated
-- \`\"self\"\`         | too small      | ✓ no withdrawals generated
-- \`\"self\"\`         | big enough     | ✓ withdrawal generated
data ConstructSharedTransactionRequestBodyWithdrawal =
   ConstructSharedTransactionRequestBodyWithdrawalOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ConstructSharedTransactionRequestBodyWithdrawalTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ConstructSharedTransactionRequestBodyWithdrawalEnumSelf -- ^ Represents the JSON value @"self"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionRequestBodyWithdrawal
    where toJSON (ConstructSharedTransactionRequestBodyWithdrawalOther val) = val
          toJSON (ConstructSharedTransactionRequestBodyWithdrawalTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ConstructSharedTransactionRequestBodyWithdrawalEnumSelf) = "self"
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionRequestBodyWithdrawal
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "self" -> ConstructSharedTransactionRequestBodyWithdrawalEnumSelf
                                            | GHC.Base.otherwise -> ConstructSharedTransactionRequestBodyWithdrawalOther val)
-- | Represents a response of the operation 'constructSharedTransaction'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'ConstructSharedTransactionResponseError' is used.
data ConstructSharedTransactionResponse =
   ConstructSharedTransactionResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | ConstructSharedTransactionResponse202 ConstructSharedTransactionResponseBody202 -- ^ Accepted
  | ConstructSharedTransactionResponse400 ConstructSharedTransactionResponseBody400Variants -- ^ Bad Request
  | ConstructSharedTransactionResponse403 ConstructSharedTransactionResponseBody403Variants -- ^ Forbidden
  | ConstructSharedTransactionResponse404 ConstructSharedTransactionResponseBody404 -- ^ Not Found
  | ConstructSharedTransactionResponse406 ConstructSharedTransactionResponseBody406 -- ^ Not Acceptable
  | ConstructSharedTransactionResponse415 ConstructSharedTransactionResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody202 = ConstructSharedTransactionResponseBody202 {
  -- | coin_selection
  constructSharedTransactionResponseBody202Coin_selection :: ConstructSharedTransactionResponseBody202Coin_selection
  -- | fee: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructSharedTransactionResponseBody202Fee :: ConstructSharedTransactionResponseBody202Fee
  -- | transaction: The CBOR-encoded transaction, represented in either hex or base64 encoding.
  -- This always includes the transaction body and the witness set, even if the
  -- latter is empty.
  , constructSharedTransactionResponseBody202Transaction :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["coin_selection" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selection obj] : ["fee" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Fee obj] : ["transaction" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Transaction obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["coin_selection" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selection obj] : ["fee" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Fee obj] : ["transaction" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Transaction obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202" (\obj -> ((GHC.Base.pure ConstructSharedTransactionResponseBody202 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "coin_selection")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fee")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "transaction"))
-- | Create a new 'ConstructSharedTransactionResponseBody202' with all required fields.
mkConstructSharedTransactionResponseBody202 :: ConstructSharedTransactionResponseBody202Coin_selection -- ^ 'constructSharedTransactionResponseBody202Coin_selection'
  -> ConstructSharedTransactionResponseBody202Fee -- ^ 'constructSharedTransactionResponseBody202Fee'
  -> Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody202Transaction'
  -> ConstructSharedTransactionResponseBody202
mkConstructSharedTransactionResponseBody202 constructSharedTransactionResponseBody202Coin_selection constructSharedTransactionResponseBody202Fee constructSharedTransactionResponseBody202Transaction = ConstructSharedTransactionResponseBody202{constructSharedTransactionResponseBody202Coin_selection = constructSharedTransactionResponseBody202Coin_selection,
                                                                                                                                                                                                                                                  constructSharedTransactionResponseBody202Fee = constructSharedTransactionResponseBody202Fee,
                                                                                                                                                                                                                                                  constructSharedTransactionResponseBody202Transaction = constructSharedTransactionResponseBody202Transaction}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody202Coin_selection = ConstructSharedTransactionResponseBody202Coin_selection {
  -- | certificates
  constructSharedTransactionResponseBody202Coin_selectionCertificates :: (GHC.Maybe.Maybe ([ConstructSharedTransactionResponseBody202Coin_selectionCertificates]))
  -- | change: A list of transaction change outputs.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , constructSharedTransactionResponseBody202Coin_selectionChange :: ([ConstructSharedTransactionResponseBody202Coin_selectionChange])
  -- | collateral: A list of transaction inputs used for collateral
  , constructSharedTransactionResponseBody202Coin_selectionCollateral :: (GHC.Maybe.Maybe ([ConstructSharedTransactionResponseBody202Coin_selectionCollateral]))
  -- | deposits_returned: A list of deposits associated with a transaction.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , constructSharedTransactionResponseBody202Coin_selectionDeposits_returned :: (GHC.Maybe.Maybe ([ConstructSharedTransactionResponseBody202Coin_selectionDeposits_returned]))
  -- | deposits_taken: A list of deposits associated with a transaction.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , constructSharedTransactionResponseBody202Coin_selectionDeposits_taken :: (GHC.Maybe.Maybe ([ConstructSharedTransactionResponseBody202Coin_selectionDeposits_taken]))
  -- | inputs: A list of transaction inputs
  , constructSharedTransactionResponseBody202Coin_selectionInputs :: ([ConstructSharedTransactionResponseBody202Coin_selectionInputs])
  -- | metadata: Transaction metadata, serialized according to the expected on-chain binary format, base64-encoded.
  , constructSharedTransactionResponseBody202Coin_selectionMetadata :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , constructSharedTransactionResponseBody202Coin_selectionOutputs :: ([ConstructSharedTransactionResponseBody202Coin_selectionOutputs])
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , constructSharedTransactionResponseBody202Coin_selectionWithdrawals :: (GHC.Maybe.Maybe ([ConstructSharedTransactionResponseBody202Coin_selectionWithdrawals]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selection
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionCertificates obj) : ["change" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChange obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionCollateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_returned" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionDeposits_returned obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_taken" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionDeposits_taken obj) : ["inputs" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionMetadata obj) : ["outputs" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionOutputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawals" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionWithdrawals obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionCertificates obj) : ["change" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChange obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionCollateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_returned" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionDeposits_returned obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_taken" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionDeposits_taken obj) : ["inputs" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionMetadata obj) : ["outputs" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionOutputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawals" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionWithdrawals obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selection
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selection" (\obj -> ((((((((GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selection GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "change")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "deposits_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "deposits_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "withdrawals"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selection' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selection :: [ConstructSharedTransactionResponseBody202Coin_selectionChange] -- ^ 'constructSharedTransactionResponseBody202Coin_selectionChange'
  -> [ConstructSharedTransactionResponseBody202Coin_selectionInputs] -- ^ 'constructSharedTransactionResponseBody202Coin_selectionInputs'
  -> [ConstructSharedTransactionResponseBody202Coin_selectionOutputs] -- ^ 'constructSharedTransactionResponseBody202Coin_selectionOutputs'
  -> ConstructSharedTransactionResponseBody202Coin_selection
mkConstructSharedTransactionResponseBody202Coin_selection constructSharedTransactionResponseBody202Coin_selectionChange constructSharedTransactionResponseBody202Coin_selectionInputs constructSharedTransactionResponseBody202Coin_selectionOutputs = ConstructSharedTransactionResponseBody202Coin_selection{constructSharedTransactionResponseBody202Coin_selectionCertificates = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                               constructSharedTransactionResponseBody202Coin_selectionChange = constructSharedTransactionResponseBody202Coin_selectionChange,
                                                                                                                                                                                                                                                                                                               constructSharedTransactionResponseBody202Coin_selectionCollateral = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                               constructSharedTransactionResponseBody202Coin_selectionDeposits_returned = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                               constructSharedTransactionResponseBody202Coin_selectionDeposits_taken = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                               constructSharedTransactionResponseBody202Coin_selectionInputs = constructSharedTransactionResponseBody202Coin_selectionInputs,
                                                                                                                                                                                                                                                                                                               constructSharedTransactionResponseBody202Coin_selectionMetadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                               constructSharedTransactionResponseBody202Coin_selectionOutputs = constructSharedTransactionResponseBody202Coin_selectionOutputs,
                                                                                                                                                                                                                                                                                                               constructSharedTransactionResponseBody202Coin_selectionWithdrawals = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.certificates.items@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data ConstructSharedTransactionResponseBody202Coin_selectionCertificates = ConstructSharedTransactionResponseBody202Coin_selectionCertificates {
  -- | certificate_type
  constructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_type :: ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_type
  -- | pool: A unique identifier for the pool.
  , constructSharedTransactionResponseBody202Coin_selectionCertificatesPool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , constructSharedTransactionResponseBody202Coin_selectionCertificatesReward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionCertificates
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionCertificatesPool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCertificatesReward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionCertificatesPool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCertificatesReward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionCertificates
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionCertificates" (\obj -> ((GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionCertificates GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionCertificates' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionCertificates :: ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_type -- ^ 'constructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'constructSharedTransactionResponseBody202Coin_selectionCertificatesReward_account_path'
  -> ConstructSharedTransactionResponseBody202Coin_selectionCertificates
mkConstructSharedTransactionResponseBody202Coin_selectionCertificates constructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_type constructSharedTransactionResponseBody202Coin_selectionCertificatesReward_account_path = ConstructSharedTransactionResponseBody202Coin_selectionCertificates{constructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_type = constructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_type,
                                                                                                                                                                                                                                                                                                                       constructSharedTransactionResponseBody202Coin_selectionCertificatesPool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                       constructSharedTransactionResponseBody202Coin_selectionCertificatesReward_account_path = constructSharedTransactionResponseBody202Coin_selectionCertificatesReward_account_path}
-- | Defines the enum schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.certificates.items.properties.certificate_type@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_type =
   ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_type
    where toJSON (ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_typeOther val) = val
          toJSON (ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumJoin_pool) = "join_pool"
          toJSON (ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> ConstructSharedTransactionResponseBody202Coin_selectionCertificatesCertificate_typeOther val)
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.change.items@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody202Coin_selectionChange = ConstructSharedTransactionResponseBody202Coin_selectionChange {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  constructSharedTransactionResponseBody202Coin_selectionChangeAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructSharedTransactionResponseBody202Coin_selectionChangeAmount :: ConstructSharedTransactionResponseBody202Coin_selectionChangeAmount
  -- | assets: A flat list of assets (possibly empty).
  , constructSharedTransactionResponseBody202Coin_selectionChangeAssets :: (GHC.Maybe.Maybe ([ConstructSharedTransactionResponseBody202Coin_selectionChangeAssets]))
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , constructSharedTransactionResponseBody202Coin_selectionChangeDerivation_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionChange
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChangeAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChangeAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionChangeAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChangeDerivation_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChangeAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChangeAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionChangeAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChangeDerivation_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionChange
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionChange" (\obj -> (((GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionChange GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionChange' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionChange :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody202Coin_selectionChangeAddress'
  -> ConstructSharedTransactionResponseBody202Coin_selectionChangeAmount -- ^ 'constructSharedTransactionResponseBody202Coin_selectionChangeAmount'
  -> [Data.Text.Internal.Text] -- ^ 'constructSharedTransactionResponseBody202Coin_selectionChangeDerivation_path'
  -> ConstructSharedTransactionResponseBody202Coin_selectionChange
mkConstructSharedTransactionResponseBody202Coin_selectionChange constructSharedTransactionResponseBody202Coin_selectionChangeAddress constructSharedTransactionResponseBody202Coin_selectionChangeAmount constructSharedTransactionResponseBody202Coin_selectionChangeDerivation_path = ConstructSharedTransactionResponseBody202Coin_selectionChange{constructSharedTransactionResponseBody202Coin_selectionChangeAddress = constructSharedTransactionResponseBody202Coin_selectionChangeAddress,
                                                                                                                                                                                                                                                                                                                                                      constructSharedTransactionResponseBody202Coin_selectionChangeAmount = constructSharedTransactionResponseBody202Coin_selectionChangeAmount,
                                                                                                                                                                                                                                                                                                                                                      constructSharedTransactionResponseBody202Coin_selectionChangeAssets = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                      constructSharedTransactionResponseBody202Coin_selectionChangeDerivation_path = constructSharedTransactionResponseBody202Coin_selectionChangeDerivation_path}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.change.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructSharedTransactionResponseBody202Coin_selectionChangeAmount = ConstructSharedTransactionResponseBody202Coin_selectionChangeAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionResponseBody202Coin_selectionChangeAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionChangeAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChangeAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChangeAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionChangeAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionChangeAmount" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionChangeAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionChangeAmount' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionChangeAmount :: GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody202Coin_selectionChangeAmountQuantity'
  -> ConstructSharedTransactionResponseBody202Coin_selectionChangeAmount
mkConstructSharedTransactionResponseBody202Coin_selectionChangeAmount constructSharedTransactionResponseBody202Coin_selectionChangeAmountQuantity = ConstructSharedTransactionResponseBody202Coin_selectionChangeAmount{constructSharedTransactionResponseBody202Coin_selectionChangeAmountQuantity = constructSharedTransactionResponseBody202Coin_selectionChangeAmountQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.change.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ConstructSharedTransactionResponseBody202Coin_selectionChangeAssets = ConstructSharedTransactionResponseBody202Coin_selectionChangeAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  constructSharedTransactionResponseBody202Coin_selectionChangeAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , constructSharedTransactionResponseBody202Coin_selectionChangeAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , constructSharedTransactionResponseBody202Coin_selectionChangeAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionChangeAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChangeAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChangeAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChangeAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChangeAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChangeAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionChangeAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionChangeAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionChangeAssets" (\obj -> ((GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionChangeAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionChangeAssets' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionChangeAssets :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody202Coin_selectionChangeAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody202Coin_selectionChangeAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody202Coin_selectionChangeAssetsQuantity'
  -> ConstructSharedTransactionResponseBody202Coin_selectionChangeAssets
mkConstructSharedTransactionResponseBody202Coin_selectionChangeAssets constructSharedTransactionResponseBody202Coin_selectionChangeAssetsAsset_name constructSharedTransactionResponseBody202Coin_selectionChangeAssetsPolicy_id constructSharedTransactionResponseBody202Coin_selectionChangeAssetsQuantity = ConstructSharedTransactionResponseBody202Coin_selectionChangeAssets{constructSharedTransactionResponseBody202Coin_selectionChangeAssetsAsset_name = constructSharedTransactionResponseBody202Coin_selectionChangeAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                                                                   constructSharedTransactionResponseBody202Coin_selectionChangeAssetsPolicy_id = constructSharedTransactionResponseBody202Coin_selectionChangeAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                                                                   constructSharedTransactionResponseBody202Coin_selectionChangeAssetsQuantity = constructSharedTransactionResponseBody202Coin_selectionChangeAssetsQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.collateral.items@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody202Coin_selectionCollateral = ConstructSharedTransactionResponseBody202Coin_selectionCollateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  constructSharedTransactionResponseBody202Coin_selectionCollateralAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructSharedTransactionResponseBody202Coin_selectionCollateralAmount :: ConstructSharedTransactionResponseBody202Coin_selectionCollateralAmount
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , constructSharedTransactionResponseBody202Coin_selectionCollateralDerivation_path :: ([Data.Text.Internal.Text])
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , constructSharedTransactionResponseBody202Coin_selectionCollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , constructSharedTransactionResponseBody202Coin_selectionCollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionCollateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCollateralAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCollateralAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCollateralDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCollateralAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCollateralAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCollateralDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionCollateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionCollateral" (\obj -> ((((GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionCollateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionCollateral' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionCollateral :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody202Coin_selectionCollateralAddress'
  -> ConstructSharedTransactionResponseBody202Coin_selectionCollateralAmount -- ^ 'constructSharedTransactionResponseBody202Coin_selectionCollateralAmount'
  -> [Data.Text.Internal.Text] -- ^ 'constructSharedTransactionResponseBody202Coin_selectionCollateralDerivation_path'
  -> Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody202Coin_selectionCollateralId'
  -> GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody202Coin_selectionCollateralIndex'
  -> ConstructSharedTransactionResponseBody202Coin_selectionCollateral
mkConstructSharedTransactionResponseBody202Coin_selectionCollateral constructSharedTransactionResponseBody202Coin_selectionCollateralAddress constructSharedTransactionResponseBody202Coin_selectionCollateralAmount constructSharedTransactionResponseBody202Coin_selectionCollateralDerivation_path constructSharedTransactionResponseBody202Coin_selectionCollateralId constructSharedTransactionResponseBody202Coin_selectionCollateralIndex = ConstructSharedTransactionResponseBody202Coin_selectionCollateral{constructSharedTransactionResponseBody202Coin_selectionCollateralAddress = constructSharedTransactionResponseBody202Coin_selectionCollateralAddress,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     constructSharedTransactionResponseBody202Coin_selectionCollateralAmount = constructSharedTransactionResponseBody202Coin_selectionCollateralAmount,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     constructSharedTransactionResponseBody202Coin_selectionCollateralDerivation_path = constructSharedTransactionResponseBody202Coin_selectionCollateralDerivation_path,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     constructSharedTransactionResponseBody202Coin_selectionCollateralId = constructSharedTransactionResponseBody202Coin_selectionCollateralId,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     constructSharedTransactionResponseBody202Coin_selectionCollateralIndex = constructSharedTransactionResponseBody202Coin_selectionCollateralIndex}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructSharedTransactionResponseBody202Coin_selectionCollateralAmount = ConstructSharedTransactionResponseBody202Coin_selectionCollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionResponseBody202Coin_selectionCollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionCollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionCollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionCollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionCollateralAmount" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionCollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionCollateralAmount' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionCollateralAmount :: GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody202Coin_selectionCollateralAmountQuantity'
  -> ConstructSharedTransactionResponseBody202Coin_selectionCollateralAmount
mkConstructSharedTransactionResponseBody202Coin_selectionCollateralAmount constructSharedTransactionResponseBody202Coin_selectionCollateralAmountQuantity = ConstructSharedTransactionResponseBody202Coin_selectionCollateralAmount{constructSharedTransactionResponseBody202Coin_selectionCollateralAmountQuantity = constructSharedTransactionResponseBody202Coin_selectionCollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.deposits_returned.items@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructSharedTransactionResponseBody202Coin_selectionDeposits_returned = ConstructSharedTransactionResponseBody202Coin_selectionDeposits_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionResponseBody202Coin_selectionDeposits_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionDeposits_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionDeposits_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionDeposits_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionDeposits_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionDeposits_returned" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionDeposits_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionDeposits_returned' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionDeposits_returned :: GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody202Coin_selectionDeposits_returnedQuantity'
  -> ConstructSharedTransactionResponseBody202Coin_selectionDeposits_returned
mkConstructSharedTransactionResponseBody202Coin_selectionDeposits_returned constructSharedTransactionResponseBody202Coin_selectionDeposits_returnedQuantity = ConstructSharedTransactionResponseBody202Coin_selectionDeposits_returned{constructSharedTransactionResponseBody202Coin_selectionDeposits_returnedQuantity = constructSharedTransactionResponseBody202Coin_selectionDeposits_returnedQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.deposits_taken.items@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructSharedTransactionResponseBody202Coin_selectionDeposits_taken = ConstructSharedTransactionResponseBody202Coin_selectionDeposits_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionResponseBody202Coin_selectionDeposits_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionDeposits_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionDeposits_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionDeposits_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionDeposits_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionDeposits_taken" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionDeposits_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionDeposits_taken' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionDeposits_taken :: GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody202Coin_selectionDeposits_takenQuantity'
  -> ConstructSharedTransactionResponseBody202Coin_selectionDeposits_taken
mkConstructSharedTransactionResponseBody202Coin_selectionDeposits_taken constructSharedTransactionResponseBody202Coin_selectionDeposits_takenQuantity = ConstructSharedTransactionResponseBody202Coin_selectionDeposits_taken{constructSharedTransactionResponseBody202Coin_selectionDeposits_takenQuantity = constructSharedTransactionResponseBody202Coin_selectionDeposits_takenQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.inputs.items@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody202Coin_selectionInputs = ConstructSharedTransactionResponseBody202Coin_selectionInputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  constructSharedTransactionResponseBody202Coin_selectionInputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructSharedTransactionResponseBody202Coin_selectionInputsAmount :: ConstructSharedTransactionResponseBody202Coin_selectionInputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , constructSharedTransactionResponseBody202Coin_selectionInputsAssets :: (GHC.Maybe.Maybe ([ConstructSharedTransactionResponseBody202Coin_selectionInputsAssets]))
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , constructSharedTransactionResponseBody202Coin_selectionInputsDerivation_path :: ([Data.Text.Internal.Text])
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , constructSharedTransactionResponseBody202Coin_selectionInputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , constructSharedTransactionResponseBody202Coin_selectionInputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionInputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionInputsAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsId obj] : ["index" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionInputsAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsId obj] : ["index" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionInputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionInputs" (\obj -> (((((GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionInputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionInputs' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionInputs :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody202Coin_selectionInputsAddress'
  -> ConstructSharedTransactionResponseBody202Coin_selectionInputsAmount -- ^ 'constructSharedTransactionResponseBody202Coin_selectionInputsAmount'
  -> [Data.Text.Internal.Text] -- ^ 'constructSharedTransactionResponseBody202Coin_selectionInputsDerivation_path'
  -> Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody202Coin_selectionInputsId'
  -> GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody202Coin_selectionInputsIndex'
  -> ConstructSharedTransactionResponseBody202Coin_selectionInputs
mkConstructSharedTransactionResponseBody202Coin_selectionInputs constructSharedTransactionResponseBody202Coin_selectionInputsAddress constructSharedTransactionResponseBody202Coin_selectionInputsAmount constructSharedTransactionResponseBody202Coin_selectionInputsDerivation_path constructSharedTransactionResponseBody202Coin_selectionInputsId constructSharedTransactionResponseBody202Coin_selectionInputsIndex = ConstructSharedTransactionResponseBody202Coin_selectionInputs{constructSharedTransactionResponseBody202Coin_selectionInputsAddress = constructSharedTransactionResponseBody202Coin_selectionInputsAddress,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         constructSharedTransactionResponseBody202Coin_selectionInputsAmount = constructSharedTransactionResponseBody202Coin_selectionInputsAmount,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         constructSharedTransactionResponseBody202Coin_selectionInputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         constructSharedTransactionResponseBody202Coin_selectionInputsDerivation_path = constructSharedTransactionResponseBody202Coin_selectionInputsDerivation_path,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         constructSharedTransactionResponseBody202Coin_selectionInputsId = constructSharedTransactionResponseBody202Coin_selectionInputsId,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         constructSharedTransactionResponseBody202Coin_selectionInputsIndex = constructSharedTransactionResponseBody202Coin_selectionInputsIndex}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructSharedTransactionResponseBody202Coin_selectionInputsAmount = ConstructSharedTransactionResponseBody202Coin_selectionInputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionResponseBody202Coin_selectionInputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionInputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionInputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionInputsAmount" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionInputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionInputsAmount' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionInputsAmount :: GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody202Coin_selectionInputsAmountQuantity'
  -> ConstructSharedTransactionResponseBody202Coin_selectionInputsAmount
mkConstructSharedTransactionResponseBody202Coin_selectionInputsAmount constructSharedTransactionResponseBody202Coin_selectionInputsAmountQuantity = ConstructSharedTransactionResponseBody202Coin_selectionInputsAmount{constructSharedTransactionResponseBody202Coin_selectionInputsAmountQuantity = constructSharedTransactionResponseBody202Coin_selectionInputsAmountQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ConstructSharedTransactionResponseBody202Coin_selectionInputsAssets = ConstructSharedTransactionResponseBody202Coin_selectionInputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  constructSharedTransactionResponseBody202Coin_selectionInputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , constructSharedTransactionResponseBody202Coin_selectionInputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , constructSharedTransactionResponseBody202Coin_selectionInputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionInputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionInputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionInputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionInputsAssets" (\obj -> ((GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionInputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionInputsAssets' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionInputsAssets :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody202Coin_selectionInputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody202Coin_selectionInputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody202Coin_selectionInputsAssetsQuantity'
  -> ConstructSharedTransactionResponseBody202Coin_selectionInputsAssets
mkConstructSharedTransactionResponseBody202Coin_selectionInputsAssets constructSharedTransactionResponseBody202Coin_selectionInputsAssetsAsset_name constructSharedTransactionResponseBody202Coin_selectionInputsAssetsPolicy_id constructSharedTransactionResponseBody202Coin_selectionInputsAssetsQuantity = ConstructSharedTransactionResponseBody202Coin_selectionInputsAssets{constructSharedTransactionResponseBody202Coin_selectionInputsAssetsAsset_name = constructSharedTransactionResponseBody202Coin_selectionInputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                                                                   constructSharedTransactionResponseBody202Coin_selectionInputsAssetsPolicy_id = constructSharedTransactionResponseBody202Coin_selectionInputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                                                                   constructSharedTransactionResponseBody202Coin_selectionInputsAssetsQuantity = constructSharedTransactionResponseBody202Coin_selectionInputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.outputs.items@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody202Coin_selectionOutputs = ConstructSharedTransactionResponseBody202Coin_selectionOutputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  constructSharedTransactionResponseBody202Coin_selectionOutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructSharedTransactionResponseBody202Coin_selectionOutputsAmount :: ConstructSharedTransactionResponseBody202Coin_selectionOutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , constructSharedTransactionResponseBody202Coin_selectionOutputsAssets :: (GHC.Maybe.Maybe ([ConstructSharedTransactionResponseBody202Coin_selectionOutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionOutputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionOutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionOutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionOutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionOutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionOutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody202Coin_selectionOutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionOutputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionOutputs" (\obj -> ((GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionOutputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionOutputs' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionOutputs :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody202Coin_selectionOutputsAddress'
  -> ConstructSharedTransactionResponseBody202Coin_selectionOutputsAmount -- ^ 'constructSharedTransactionResponseBody202Coin_selectionOutputsAmount'
  -> ConstructSharedTransactionResponseBody202Coin_selectionOutputs
mkConstructSharedTransactionResponseBody202Coin_selectionOutputs constructSharedTransactionResponseBody202Coin_selectionOutputsAddress constructSharedTransactionResponseBody202Coin_selectionOutputsAmount = ConstructSharedTransactionResponseBody202Coin_selectionOutputs{constructSharedTransactionResponseBody202Coin_selectionOutputsAddress = constructSharedTransactionResponseBody202Coin_selectionOutputsAddress,
                                                                                                                                                                                                                                                                             constructSharedTransactionResponseBody202Coin_selectionOutputsAmount = constructSharedTransactionResponseBody202Coin_selectionOutputsAmount,
                                                                                                                                                                                                                                                                             constructSharedTransactionResponseBody202Coin_selectionOutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructSharedTransactionResponseBody202Coin_selectionOutputsAmount = ConstructSharedTransactionResponseBody202Coin_selectionOutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionResponseBody202Coin_selectionOutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionOutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionOutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionOutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionOutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionOutputsAmount" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionOutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionOutputsAmount' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionOutputsAmount :: GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody202Coin_selectionOutputsAmountQuantity'
  -> ConstructSharedTransactionResponseBody202Coin_selectionOutputsAmount
mkConstructSharedTransactionResponseBody202Coin_selectionOutputsAmount constructSharedTransactionResponseBody202Coin_selectionOutputsAmountQuantity = ConstructSharedTransactionResponseBody202Coin_selectionOutputsAmount{constructSharedTransactionResponseBody202Coin_selectionOutputsAmountQuantity = constructSharedTransactionResponseBody202Coin_selectionOutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ConstructSharedTransactionResponseBody202Coin_selectionOutputsAssets = ConstructSharedTransactionResponseBody202Coin_selectionOutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionOutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionOutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionOutputsAssets" (\obj -> ((GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionOutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionOutputsAssets' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionOutputsAssets :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsQuantity'
  -> ConstructSharedTransactionResponseBody202Coin_selectionOutputsAssets
mkConstructSharedTransactionResponseBody202Coin_selectionOutputsAssets constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsAsset_name constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsPolicy_id constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsQuantity = ConstructSharedTransactionResponseBody202Coin_selectionOutputsAssets{constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsAsset_name = constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                                                                        constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsPolicy_id = constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                                                                        constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsQuantity = constructSharedTransactionResponseBody202Coin_selectionOutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.withdrawals.items@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody202Coin_selectionWithdrawals = ConstructSharedTransactionResponseBody202Coin_selectionWithdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  constructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount :: ConstructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , constructSharedTransactionResponseBody202Coin_selectionWithdrawalsDerivation_path :: ([Data.Text.Internal.Text])
  -- | stake_address
  , constructSharedTransactionResponseBody202Coin_selectionWithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionWithdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionWithdrawalsDerivation_path obj] : ["stake_address" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionWithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionWithdrawalsDerivation_path obj] : ["stake_address" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionWithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionWithdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionWithdrawals" (\obj -> ((GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionWithdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionWithdrawals' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionWithdrawals :: ConstructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount -- ^ 'constructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount'
  -> [Data.Text.Internal.Text] -- ^ 'constructSharedTransactionResponseBody202Coin_selectionWithdrawalsDerivation_path'
  -> Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody202Coin_selectionWithdrawalsStake_address'
  -> ConstructSharedTransactionResponseBody202Coin_selectionWithdrawals
mkConstructSharedTransactionResponseBody202Coin_selectionWithdrawals constructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount constructSharedTransactionResponseBody202Coin_selectionWithdrawalsDerivation_path constructSharedTransactionResponseBody202Coin_selectionWithdrawalsStake_address = ConstructSharedTransactionResponseBody202Coin_selectionWithdrawals{constructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount = constructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount,
                                                                                                                                                                                                                                                                                                                                                                                     constructSharedTransactionResponseBody202Coin_selectionWithdrawalsDerivation_path = constructSharedTransactionResponseBody202Coin_selectionWithdrawalsDerivation_path,
                                                                                                                                                                                                                                                                                                                                                                                     constructSharedTransactionResponseBody202Coin_selectionWithdrawalsStake_address = constructSharedTransactionResponseBody202Coin_selectionWithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount = ConstructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount' with all required fields.
mkConstructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount :: GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmountQuantity'
  -> ConstructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount
mkConstructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount constructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmountQuantity = ConstructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmount{constructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmountQuantity = constructSharedTransactionResponseBody202Coin_selectionWithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.fee@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructSharedTransactionResponseBody202Fee = ConstructSharedTransactionResponseBody202Fee {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionResponseBody202FeeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody202Fee
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody202Fee
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody202Fee" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody202Fee GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionResponseBody202Fee' with all required fields.
mkConstructSharedTransactionResponseBody202Fee :: GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody202FeeQuantity'
  -> ConstructSharedTransactionResponseBody202Fee
mkConstructSharedTransactionResponseBody202Fee constructSharedTransactionResponseBody202FeeQuantity = ConstructSharedTransactionResponseBody202Fee{constructSharedTransactionResponseBody202FeeQuantity = constructSharedTransactionResponseBody202FeeQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody400OneOf1 = ConstructSharedTransactionResponseBody400OneOf1 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  constructSharedTransactionResponseBody400OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody400OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody400OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody400OneOf1" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody400OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody400OneOf1' with all required fields.
mkConstructSharedTransactionResponseBody400OneOf1 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody400OneOf1Message'
  -> ConstructSharedTransactionResponseBody400OneOf1
mkConstructSharedTransactionResponseBody400OneOf1 constructSharedTransactionResponseBody400OneOf1Message = ConstructSharedTransactionResponseBody400OneOf1{constructSharedTransactionResponseBody400OneOf1Message = constructSharedTransactionResponseBody400OneOf1Message}
-- | Defines the oneOf schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody400Variants =
   ConstructSharedTransactionResponseBody400Variant1 ConstructSharedTransactionResponseBody400OneOf1
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody400Variants
    where toJSON (ConstructSharedTransactionResponseBody400Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody400Variants
    where parseJSON val = case (ConstructSharedTransactionResponseBody400Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched" of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf1 = ConstructSharedTransactionResponseBody403OneOf1 {
  -- | message: May occur when trying to perform an operation not supported by this type of wallet.
  constructSharedTransactionResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf1" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf1' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf1Message'
  -> ConstructSharedTransactionResponseBody403OneOf1
mkConstructSharedTransactionResponseBody403OneOf1 constructSharedTransactionResponseBody403OneOf1Message = ConstructSharedTransactionResponseBody403OneOf1{constructSharedTransactionResponseBody403OneOf1Message = constructSharedTransactionResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf2 = ConstructSharedTransactionResponseBody403OneOf2 {
  -- | message: May occur when submitting a withdrawal while another withdrawal is pending.
  constructSharedTransactionResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf2" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf2' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf2Message'
  -> ConstructSharedTransactionResponseBody403OneOf2
mkConstructSharedTransactionResponseBody403OneOf2 constructSharedTransactionResponseBody403OneOf2Message = ConstructSharedTransactionResponseBody403OneOf2{constructSharedTransactionResponseBody403OneOf2Message = constructSharedTransactionResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf3 = ConstructSharedTransactionResponseBody403OneOf3 {
  -- | info
  constructSharedTransactionResponseBody403OneOf3Info :: (GHC.Maybe.Maybe ConstructSharedTransactionResponseBody403OneOf3Info)
  -- | message: Occurs when a requested output has a quantity of lovelace that is below the minimum required by the ledger.
  , constructSharedTransactionResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody403OneOf3Info obj) : ["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (constructSharedTransactionResponseBody403OneOf3Info obj) : ["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf3" (\obj -> (GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "info")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf3' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf3Message'
  -> ConstructSharedTransactionResponseBody403OneOf3
mkConstructSharedTransactionResponseBody403OneOf3 constructSharedTransactionResponseBody403OneOf3Message = ConstructSharedTransactionResponseBody403OneOf3{constructSharedTransactionResponseBody403OneOf3Info = GHC.Maybe.Nothing,
                                                                                                                                                           constructSharedTransactionResponseBody403OneOf3Message = constructSharedTransactionResponseBody403OneOf3Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf.properties.info@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf3Info = ConstructSharedTransactionResponseBody403OneOf3Info {
  -- | tx_output_index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionResponseBody403OneOf3InfoTx_output_index :: GHC.Types.Int
  -- | tx_output_lovelace_required_minimum: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum :: ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
  -- | tx_output_lovelace_specified: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified :: ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf3Info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf3InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf3InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf3Info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf3Info" (\obj -> ((GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf3Info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_index")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_required_minimum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_specified"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf3Info' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf3Info :: GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody403OneOf3InfoTx_output_index'
  -> ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum -- ^ 'constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum'
  -> ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified -- ^ 'constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified'
  -> ConstructSharedTransactionResponseBody403OneOf3Info
mkConstructSharedTransactionResponseBody403OneOf3Info constructSharedTransactionResponseBody403OneOf3InfoTx_output_index constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified = ConstructSharedTransactionResponseBody403OneOf3Info{constructSharedTransactionResponseBody403OneOf3InfoTx_output_index = constructSharedTransactionResponseBody403OneOf3InfoTx_output_index,
                                                                                                                                                                                                                                                                                                                                                      constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum = constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum,
                                                                                                                                                                                                                                                                                                                                                      constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified = constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_required_minimum@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum = ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum :: GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity'
  -> ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
mkConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity = ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum{constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity = constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_specified@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified = ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified :: GHC.Types.Int -- ^ 'constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity'
  -> ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
mkConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity = ConstructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified{constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity = constructSharedTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf4 = ConstructSharedTransactionResponseBody403OneOf4 {
  -- | message: May occur when a transaction can\'t be balanced for fees.
  constructSharedTransactionResponseBody403OneOf4Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf4" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf4' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf4 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf4Message'
  -> ConstructSharedTransactionResponseBody403OneOf4
mkConstructSharedTransactionResponseBody403OneOf4 constructSharedTransactionResponseBody403OneOf4Message = ConstructSharedTransactionResponseBody403OneOf4{constructSharedTransactionResponseBody403OneOf4Message = constructSharedTransactionResponseBody403OneOf4Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf5 = ConstructSharedTransactionResponseBody403OneOf5 {
  -- | message: May occur when there\'s not enough money in the wallet to cover a requested payment.
  constructSharedTransactionResponseBody403OneOf5Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf5" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf5' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf5 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf5Message'
  -> ConstructSharedTransactionResponseBody403OneOf5
mkConstructSharedTransactionResponseBody403OneOf5 constructSharedTransactionResponseBody403OneOf5Message = ConstructSharedTransactionResponseBody403OneOf5{constructSharedTransactionResponseBody403OneOf5Message = constructSharedTransactionResponseBody403OneOf5Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf6 = ConstructSharedTransactionResponseBody403OneOf6 {
  -- | message: May occur when the total balance of pure ada UTxOs in the wallet is
  -- insufficient to cover the minimum collateral amount required for a
  -- transaction requiring collateral.
  constructSharedTransactionResponseBody403OneOf6Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf6" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf6' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf6 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf6Message'
  -> ConstructSharedTransactionResponseBody403OneOf6
mkConstructSharedTransactionResponseBody403OneOf6 constructSharedTransactionResponseBody403OneOf6Message = ConstructSharedTransactionResponseBody403OneOf6{constructSharedTransactionResponseBody403OneOf6Message = constructSharedTransactionResponseBody403OneOf6Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf7 = ConstructSharedTransactionResponseBody403OneOf7 {
  -- | message: May occur when the wallet can\'t cover for all requested outputs without making the transaction too large.
  constructSharedTransactionResponseBody403OneOf7Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf7
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_is_too_big"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_is_too_big"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf7
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf7" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf7 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf7' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf7 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf7Message'
  -> ConstructSharedTransactionResponseBody403OneOf7
mkConstructSharedTransactionResponseBody403OneOf7 constructSharedTransactionResponseBody403OneOf7Message = ConstructSharedTransactionResponseBody403OneOf7{constructSharedTransactionResponseBody403OneOf7Message = constructSharedTransactionResponseBody403OneOf7Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf8 = ConstructSharedTransactionResponseBody403OneOf8 {
  -- | message: Occurs when more than 1 delegation action is included in a transaction.
  constructSharedTransactionResponseBody403OneOf8Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf8
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "created_multidelegation_transaction"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "created_multidelegation_transaction"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf8
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf8" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf8 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf8' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf8 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf8Message'
  -> ConstructSharedTransactionResponseBody403OneOf8
mkConstructSharedTransactionResponseBody403OneOf8 constructSharedTransactionResponseBody403OneOf8Message = ConstructSharedTransactionResponseBody403OneOf8{constructSharedTransactionResponseBody403OneOf8Message = constructSharedTransactionResponseBody403OneOf8Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf9 = ConstructSharedTransactionResponseBody403OneOf9 {
  -- | message: Occurs when a delegation action does not use \'0H\' account.
  constructSharedTransactionResponseBody403OneOf9Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf9
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "created_multiaccount_transaction"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "created_multiaccount_transaction"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf9
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf9" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf9 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf9' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf9 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf9Message'
  -> ConstructSharedTransactionResponseBody403OneOf9
mkConstructSharedTransactionResponseBody403OneOf9 constructSharedTransactionResponseBody403OneOf9Message = ConstructSharedTransactionResponseBody403OneOf9{constructSharedTransactionResponseBody403OneOf9Message = constructSharedTransactionResponseBody403OneOf9Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf10 = ConstructSharedTransactionResponseBody403OneOf10 {
  -- | message: Occurs when a policy script template either does not pass validation
  -- or has more than one cosigner.
  constructSharedTransactionResponseBody403OneOf10Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf10
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf10Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "created_wrong_policy_script_template"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf10Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "created_wrong_policy_script_template"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf10
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf10" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf10 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf10' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf10 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf10Message'
  -> ConstructSharedTransactionResponseBody403OneOf10
mkConstructSharedTransactionResponseBody403OneOf10 constructSharedTransactionResponseBody403OneOf10Message = ConstructSharedTransactionResponseBody403OneOf10{constructSharedTransactionResponseBody403OneOf10Message = constructSharedTransactionResponseBody403OneOf10Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf11 = ConstructSharedTransactionResponseBody403OneOf11 {
  -- | message: Occurs when an asset name exceeds 32 bytes in length.
  constructSharedTransactionResponseBody403OneOf11Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf11
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf11Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "asset_name_too_long"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf11Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "asset_name_too_long"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf11
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf11" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf11 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf11' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf11 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf11Message'
  -> ConstructSharedTransactionResponseBody403OneOf11
mkConstructSharedTransactionResponseBody403OneOf11 constructSharedTransactionResponseBody403OneOf11Message = ConstructSharedTransactionResponseBody403OneOf11{constructSharedTransactionResponseBody403OneOf11Message = constructSharedTransactionResponseBody403OneOf11Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf12 = ConstructSharedTransactionResponseBody403OneOf12 {
  -- | message: Occurs when attempting to mint or burn an asset quantity that is not
  -- greater than zero or exceeds 9223372036854775807 (2^63 - 1).
  constructSharedTransactionResponseBody403OneOf12Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf12
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf12Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "mint_or_burn_asset_quantity_out_of_bounds"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf12Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "mint_or_burn_asset_quantity_out_of_bounds"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf12
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf12" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf12 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf12' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf12 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf12Message'
  -> ConstructSharedTransactionResponseBody403OneOf12
mkConstructSharedTransactionResponseBody403OneOf12 constructSharedTransactionResponseBody403OneOf12Message = ConstructSharedTransactionResponseBody403OneOf12{constructSharedTransactionResponseBody403OneOf12Message = constructSharedTransactionResponseBody403OneOf12Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf13 = ConstructSharedTransactionResponseBody403OneOf13 {
  -- | message: Occurs when attempting to create a transaction with invalid validity
  -- bounds. The \'invalid_before\' bound must precede the \'invalid_hereafter\'
  -- bound, and the given time values must not be negative.
  constructSharedTransactionResponseBody403OneOf13Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf13
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf13Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_validity_bounds"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf13Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_validity_bounds"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf13
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf13" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf13 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf13' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf13 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf13Message'
  -> ConstructSharedTransactionResponseBody403OneOf13
mkConstructSharedTransactionResponseBody403OneOf13 constructSharedTransactionResponseBody403OneOf13Message = ConstructSharedTransactionResponseBody403OneOf13{constructSharedTransactionResponseBody403OneOf13Message = constructSharedTransactionResponseBody403OneOf13Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf14 = ConstructSharedTransactionResponseBody403OneOf14 {
  -- | message: Occurs when attempting to create a transaction with a validity interval
  -- that is not a subinterval of an associated script\'s timelock interval.
  constructSharedTransactionResponseBody403OneOf14Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf14
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf14Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "validity_interval_not_inside_script_timelock"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf14Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "validity_interval_not_inside_script_timelock"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf14
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf14" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf14 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf14' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf14 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf14Message'
  -> ConstructSharedTransactionResponseBody403OneOf14
mkConstructSharedTransactionResponseBody403OneOf14 constructSharedTransactionResponseBody403OneOf14Message = ConstructSharedTransactionResponseBody403OneOf14{constructSharedTransactionResponseBody403OneOf14Message = constructSharedTransactionResponseBody403OneOf14Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf15 = ConstructSharedTransactionResponseBody403OneOf15 {
  -- | message: Occurs when attempting to create a transaction for an incomplete shared wallet.
  constructSharedTransactionResponseBody403OneOf15Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf15
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf15Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "shared_wallet_incomplete"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf15Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "shared_wallet_incomplete"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf15
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf15" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf15 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf15' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf15 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf15Message'
  -> ConstructSharedTransactionResponseBody403OneOf15
mkConstructSharedTransactionResponseBody403OneOf15 constructSharedTransactionResponseBody403OneOf15Message = ConstructSharedTransactionResponseBody403OneOf15{constructSharedTransactionResponseBody403OneOf15Message = constructSharedTransactionResponseBody403OneOf15Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403OneOf16 = ConstructSharedTransactionResponseBody403OneOf16 {
  -- | message: Occurs when attempting to create a delegation transaction for a shared wallet
  -- without a delegation script template.
  constructSharedTransactionResponseBody403OneOf16Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403OneOf16
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf16Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "staking_invalid"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody403OneOf16Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "staking_invalid"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403OneOf16
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody403OneOf16" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody403OneOf16 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody403OneOf16' with all required fields.
mkConstructSharedTransactionResponseBody403OneOf16 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody403OneOf16Message'
  -> ConstructSharedTransactionResponseBody403OneOf16
mkConstructSharedTransactionResponseBody403OneOf16 constructSharedTransactionResponseBody403OneOf16Message = ConstructSharedTransactionResponseBody403OneOf16{constructSharedTransactionResponseBody403OneOf16Message = constructSharedTransactionResponseBody403OneOf16Message}
-- | Defines the oneOf schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody403Variants =
   ConstructSharedTransactionResponseBody403Variant1 ConstructSharedTransactionResponseBody403OneOf1
  | ConstructSharedTransactionResponseBody403Variant2 ConstructSharedTransactionResponseBody403OneOf2
  | ConstructSharedTransactionResponseBody403Variant3 ConstructSharedTransactionResponseBody403OneOf3
  | ConstructSharedTransactionResponseBody403Variant4 ConstructSharedTransactionResponseBody403OneOf4
  | ConstructSharedTransactionResponseBody403Variant5 ConstructSharedTransactionResponseBody403OneOf5
  | ConstructSharedTransactionResponseBody403Variant6 ConstructSharedTransactionResponseBody403OneOf6
  | ConstructSharedTransactionResponseBody403Variant7 ConstructSharedTransactionResponseBody403OneOf7
  | ConstructSharedTransactionResponseBody403Variant8 ConstructSharedTransactionResponseBody403OneOf8
  | ConstructSharedTransactionResponseBody403Variant9 ConstructSharedTransactionResponseBody403OneOf9
  | ConstructSharedTransactionResponseBody403Variant10 ConstructSharedTransactionResponseBody403OneOf10
  | ConstructSharedTransactionResponseBody403Variant11 ConstructSharedTransactionResponseBody403OneOf11
  | ConstructSharedTransactionResponseBody403Variant12 ConstructSharedTransactionResponseBody403OneOf12
  | ConstructSharedTransactionResponseBody403Variant13 ConstructSharedTransactionResponseBody403OneOf13
  | ConstructSharedTransactionResponseBody403Variant14 ConstructSharedTransactionResponseBody403OneOf14
  | ConstructSharedTransactionResponseBody403Variant15 ConstructSharedTransactionResponseBody403OneOf15
  | ConstructSharedTransactionResponseBody403Variant16 ConstructSharedTransactionResponseBody403OneOf16
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody403Variants
    where toJSON (ConstructSharedTransactionResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionResponseBody403Variant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionResponseBody403Variant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionResponseBody403Variant6 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionResponseBody403Variant7 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionResponseBody403Variant8 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionResponseBody403Variant9 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionResponseBody403Variant10 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionResponseBody403Variant11 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionResponseBody403Variant12 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionResponseBody403Variant13 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionResponseBody403Variant14 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionResponseBody403Variant15 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructSharedTransactionResponseBody403Variant16 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody403Variants
    where parseJSON val = case (ConstructSharedTransactionResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionResponseBody403Variant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionResponseBody403Variant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionResponseBody403Variant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionResponseBody403Variant7 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionResponseBody403Variant8 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionResponseBody403Variant9 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionResponseBody403Variant10 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionResponseBody403Variant11 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionResponseBody403Variant12 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionResponseBody403Variant13 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionResponseBody403Variant14 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionResponseBody403Variant15 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructSharedTransactionResponseBody403Variant16 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))))))))))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody404 = ConstructSharedTransactionResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  constructSharedTransactionResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody404" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody404' with all required fields.
mkConstructSharedTransactionResponseBody404 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody404Message'
  -> ConstructSharedTransactionResponseBody404
mkConstructSharedTransactionResponseBody404 constructSharedTransactionResponseBody404Message = ConstructSharedTransactionResponseBody404{constructSharedTransactionResponseBody404Message = constructSharedTransactionResponseBody404Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody406 = ConstructSharedTransactionResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  constructSharedTransactionResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody406" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody406' with all required fields.
mkConstructSharedTransactionResponseBody406 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody406Message'
  -> ConstructSharedTransactionResponseBody406
mkConstructSharedTransactionResponseBody406 constructSharedTransactionResponseBody406Message = ConstructSharedTransactionResponseBody406{constructSharedTransactionResponseBody406Message = constructSharedTransactionResponseBody406Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/transactions-construct.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data ConstructSharedTransactionResponseBody415 = ConstructSharedTransactionResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  constructSharedTransactionResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructSharedTransactionResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructSharedTransactionResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructSharedTransactionResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructSharedTransactionResponseBody415" (\obj -> GHC.Base.pure ConstructSharedTransactionResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructSharedTransactionResponseBody415' with all required fields.
mkConstructSharedTransactionResponseBody415 :: Data.Text.Internal.Text -- ^ 'constructSharedTransactionResponseBody415Message'
  -> ConstructSharedTransactionResponseBody415
mkConstructSharedTransactionResponseBody415 constructSharedTransactionResponseBody415Message = ConstructSharedTransactionResponseBody415{constructSharedTransactionResponseBody415Message = constructSharedTransactionResponseBody415Message}
-- | > POST /shared-wallets/{walletId}/transactions-construct
-- 
-- The same as 'constructSharedTransaction' but accepts an explicit configuration.
constructSharedTransactionWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> ConstructSharedTransactionRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response ConstructSharedTransactionResponse) -- ^ Monadic computation which returns the result of the operation
constructSharedTransactionWithConfiguration config
                                            walletId
                                            body = GHC.Base.fmap (\response_7 -> GHC.Base.fmap (Data.Either.either ConstructSharedTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> ConstructSharedTransactionResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ConstructSharedTransactionResponseBody202)
                                                                                                                                                                                                        | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> ConstructSharedTransactionResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                  ConstructSharedTransactionResponseBody400Variants)
                                                                                                                                                                                                        | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> ConstructSharedTransactionResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ConstructSharedTransactionResponseBody403Variants)
                                                                                                                                                                                                        | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> ConstructSharedTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ConstructSharedTransactionResponseBody404)
                                                                                                                                                                                                        | (\status_12 -> Network.HTTP.Types.Status.statusCode status_12 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ConstructSharedTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ConstructSharedTransactionResponseBody406)
                                                                                                                                                                                                        | (\status_13 -> Network.HTTP.Types.Status.statusCode status_13 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> ConstructSharedTransactionResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                    ConstructSharedTransactionResponseBody415)
                                                                                                                                                                                                        | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_7) response_7) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/shared-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-construct")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /shared-wallets/{walletId}/transactions-construct
-- 
-- The same as 'constructSharedTransaction' but returns the raw 'Data.ByteString.ByteString'.
constructSharedTransactionRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> ConstructSharedTransactionRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
constructSharedTransactionRaw walletId
                              body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/shared-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-construct")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /shared-wallets/{walletId}/transactions-construct
-- 
-- The same as 'constructSharedTransaction' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
constructSharedTransactionWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> ConstructSharedTransactionRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
constructSharedTransactionWithConfigurationRaw config
                                               walletId
                                               body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/shared-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-construct")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
