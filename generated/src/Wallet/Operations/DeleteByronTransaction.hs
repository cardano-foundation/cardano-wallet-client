-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation deleteByronTransaction
module Wallet.Operations.DeleteByronTransaction where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > DELETE /byron-wallets/{walletId}/transactions/{transactionId}
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Forget pending Byron transaction. Importantly, a transaction, when sent,
-- cannot be cancelled. One can only request forgetting about it
-- in order to try spending (concurrently) the same UTxO in another
-- transaction. But, the transaction may still show up later in a block
-- and therefore, appear in the wallet.
deleteByronTransaction :: forall m . Wallet.Common.MonadHTTP m => DeleteByronTransactionParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response DeleteByronTransactionResponse) -- ^ Monadic computation which returns the result of the operation
deleteByronTransaction parameters = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either DeleteByronTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 204) (Network.HTTP.Client.Types.responseStatus response) -> Data.Either.Right DeleteByronTransactionResponse204
                                                                                                                                                                                     | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> DeleteByronTransactionResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                           DeleteByronTransactionResponseBody403)
                                                                                                                                                                                     | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> DeleteByronTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                           DeleteByronTransactionResponseBody404Variants)
                                                                                                                                                                                     | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> DeleteByronTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                           DeleteByronTransactionResponseBody406)
                                                                                                                                                                                     | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "DELETE") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (deleteByronTransactionParametersPathWalletId parameters))) GHC.Base.<> ("/transactions/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (deleteByronTransactionParametersPathTransactionId parameters))) GHC.Base.<> "")))) GHC.Base.mempty)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.DELETE.parameters@ in the specification.
-- 
-- 
data DeleteByronTransactionParameters = DeleteByronTransactionParameters {
  -- | pathTransactionId: Represents the parameter named \'transactionId\'
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  deleteByronTransactionParametersPathTransactionId :: Data.Text.Internal.Text
  -- | pathWalletId: Represents the parameter named \'walletId\'
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  , deleteByronTransactionParametersPathWalletId :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DeleteByronTransactionParameters
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pathTransactionId" Data.Aeson.Types.ToJSON..= deleteByronTransactionParametersPathTransactionId obj] : ["pathWalletId" Data.Aeson.Types.ToJSON..= deleteByronTransactionParametersPathWalletId obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pathTransactionId" Data.Aeson.Types.ToJSON..= deleteByronTransactionParametersPathTransactionId obj] : ["pathWalletId" Data.Aeson.Types.ToJSON..= deleteByronTransactionParametersPathWalletId obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DeleteByronTransactionParameters
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DeleteByronTransactionParameters" (\obj -> (GHC.Base.pure DeleteByronTransactionParameters GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pathTransactionId")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pathWalletId"))
-- | Create a new 'DeleteByronTransactionParameters' with all required fields.
mkDeleteByronTransactionParameters :: Data.Text.Internal.Text -- ^ 'deleteByronTransactionParametersPathTransactionId'
  -> Data.Text.Internal.Text -- ^ 'deleteByronTransactionParametersPathWalletId'
  -> DeleteByronTransactionParameters
mkDeleteByronTransactionParameters deleteByronTransactionParametersPathTransactionId deleteByronTransactionParametersPathWalletId = DeleteByronTransactionParameters{deleteByronTransactionParametersPathTransactionId = deleteByronTransactionParametersPathTransactionId,
                                                                                                                                                                     deleteByronTransactionParametersPathWalletId = deleteByronTransactionParametersPathWalletId}
-- | Represents a response of the operation 'deleteByronTransaction'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'DeleteByronTransactionResponseError' is used.
data DeleteByronTransactionResponse =
   DeleteByronTransactionResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | DeleteByronTransactionResponse204 -- ^ No Content
  | DeleteByronTransactionResponse403 DeleteByronTransactionResponseBody403 -- ^ Forbidden
  | DeleteByronTransactionResponse404 DeleteByronTransactionResponseBody404Variants -- ^ Not Found
  | DeleteByronTransactionResponse406 DeleteByronTransactionResponseBody406 -- ^ Not Acceptable
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.DELETE.responses.403.content.application\/json.schema@ in the specification.
-- 
-- 
data DeleteByronTransactionResponseBody403 = DeleteByronTransactionResponseBody403 {
  -- | message: Occurs when attempting to delete a transaction which is neither pending nor expired.
  deleteByronTransactionResponseBody403Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DeleteByronTransactionResponseBody403
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= deleteByronTransactionResponseBody403Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_already_in_ledger"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= deleteByronTransactionResponseBody403Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_already_in_ledger"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DeleteByronTransactionResponseBody403
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DeleteByronTransactionResponseBody403" (\obj -> GHC.Base.pure DeleteByronTransactionResponseBody403 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'DeleteByronTransactionResponseBody403' with all required fields.
mkDeleteByronTransactionResponseBody403 :: Data.Text.Internal.Text -- ^ 'deleteByronTransactionResponseBody403Message'
  -> DeleteByronTransactionResponseBody403
mkDeleteByronTransactionResponseBody403 deleteByronTransactionResponseBody403Message = DeleteByronTransactionResponseBody403{deleteByronTransactionResponseBody403Message = deleteByronTransactionResponseBody403Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.DELETE.responses.404.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data DeleteByronTransactionResponseBody404OneOf1 = DeleteByronTransactionResponseBody404OneOf1 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  deleteByronTransactionResponseBody404OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DeleteByronTransactionResponseBody404OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= deleteByronTransactionResponseBody404OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= deleteByronTransactionResponseBody404OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DeleteByronTransactionResponseBody404OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DeleteByronTransactionResponseBody404OneOf1" (\obj -> GHC.Base.pure DeleteByronTransactionResponseBody404OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'DeleteByronTransactionResponseBody404OneOf1' with all required fields.
mkDeleteByronTransactionResponseBody404OneOf1 :: Data.Text.Internal.Text -- ^ 'deleteByronTransactionResponseBody404OneOf1Message'
  -> DeleteByronTransactionResponseBody404OneOf1
mkDeleteByronTransactionResponseBody404OneOf1 deleteByronTransactionResponseBody404OneOf1Message = DeleteByronTransactionResponseBody404OneOf1{deleteByronTransactionResponseBody404OneOf1Message = deleteByronTransactionResponseBody404OneOf1Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.DELETE.responses.404.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data DeleteByronTransactionResponseBody404OneOf2 = DeleteByronTransactionResponseBody404OneOf2 {
  -- | message: May occur when a given transactionId does not match with any known transactions.
  deleteByronTransactionResponseBody404OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DeleteByronTransactionResponseBody404OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= deleteByronTransactionResponseBody404OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_transaction"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= deleteByronTransactionResponseBody404OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_transaction"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DeleteByronTransactionResponseBody404OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DeleteByronTransactionResponseBody404OneOf2" (\obj -> GHC.Base.pure DeleteByronTransactionResponseBody404OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'DeleteByronTransactionResponseBody404OneOf2' with all required fields.
mkDeleteByronTransactionResponseBody404OneOf2 :: Data.Text.Internal.Text -- ^ 'deleteByronTransactionResponseBody404OneOf2Message'
  -> DeleteByronTransactionResponseBody404OneOf2
mkDeleteByronTransactionResponseBody404OneOf2 deleteByronTransactionResponseBody404OneOf2Message = DeleteByronTransactionResponseBody404OneOf2{deleteByronTransactionResponseBody404OneOf2Message = deleteByronTransactionResponseBody404OneOf2Message}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.DELETE.responses.404.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data DeleteByronTransactionResponseBody404Variants =
   DeleteByronTransactionResponseBody404Variant1 DeleteByronTransactionResponseBody404OneOf1
  | DeleteByronTransactionResponseBody404Variant2 DeleteByronTransactionResponseBody404OneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DeleteByronTransactionResponseBody404Variants
    where toJSON (DeleteByronTransactionResponseBody404Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (DeleteByronTransactionResponseBody404Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON DeleteByronTransactionResponseBody404Variants
    where parseJSON val = case (DeleteByronTransactionResponseBody404Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((DeleteByronTransactionResponseBody404Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.DELETE.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data DeleteByronTransactionResponseBody406 = DeleteByronTransactionResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  deleteByronTransactionResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON DeleteByronTransactionResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= deleteByronTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= deleteByronTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON DeleteByronTransactionResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "DeleteByronTransactionResponseBody406" (\obj -> GHC.Base.pure DeleteByronTransactionResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'DeleteByronTransactionResponseBody406' with all required fields.
mkDeleteByronTransactionResponseBody406 :: Data.Text.Internal.Text -- ^ 'deleteByronTransactionResponseBody406Message'
  -> DeleteByronTransactionResponseBody406
mkDeleteByronTransactionResponseBody406 deleteByronTransactionResponseBody406Message = DeleteByronTransactionResponseBody406{deleteByronTransactionResponseBody406Message = deleteByronTransactionResponseBody406Message}
-- | > DELETE /byron-wallets/{walletId}/transactions/{transactionId}
-- 
-- The same as 'deleteByronTransaction' but accepts an explicit configuration.
deleteByronTransactionWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> DeleteByronTransactionParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response DeleteByronTransactionResponse) -- ^ Monadic computation which returns the result of the operation
deleteByronTransactionWithConfiguration config
                                        parameters = GHC.Base.fmap (\response_5 -> GHC.Base.fmap (Data.Either.either DeleteByronTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 204) (Network.HTTP.Client.Types.responseStatus response) -> Data.Either.Right DeleteByronTransactionResponse204
                                                                                                                                                                                                      | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> DeleteByronTransactionResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                            DeleteByronTransactionResponseBody403)
                                                                                                                                                                                                      | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> DeleteByronTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                            DeleteByronTransactionResponseBody404Variants)
                                                                                                                                                                                                      | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> DeleteByronTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                            DeleteByronTransactionResponseBody406)
                                                                                                                                                                                                      | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_5) response_5) (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "DELETE") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (deleteByronTransactionParametersPathWalletId parameters))) GHC.Base.<> ("/transactions/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (deleteByronTransactionParametersPathTransactionId parameters))) GHC.Base.<> "")))) GHC.Base.mempty)
-- | > DELETE /byron-wallets/{walletId}/transactions/{transactionId}
-- 
-- The same as 'deleteByronTransaction' but returns the raw 'Data.ByteString.ByteString'.
deleteByronTransactionRaw :: forall m . Wallet.Common.MonadHTTP m => DeleteByronTransactionParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
deleteByronTransactionRaw parameters = GHC.Base.id (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "DELETE") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (deleteByronTransactionParametersPathWalletId parameters))) GHC.Base.<> ("/transactions/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (deleteByronTransactionParametersPathTransactionId parameters))) GHC.Base.<> "")))) GHC.Base.mempty)
-- | > DELETE /byron-wallets/{walletId}/transactions/{transactionId}
-- 
-- The same as 'deleteByronTransaction' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
deleteByronTransactionWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> DeleteByronTransactionParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
deleteByronTransactionWithConfigurationRaw config
                                           parameters = GHC.Base.id (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "DELETE") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (deleteByronTransactionParametersPathWalletId parameters))) GHC.Base.<> ("/transactions/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (deleteByronTransactionParametersPathTransactionId parameters))) GHC.Base.<> "")))) GHC.Base.mempty)
