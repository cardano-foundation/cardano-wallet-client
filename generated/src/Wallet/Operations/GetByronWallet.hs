-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation getByronWallet
module Wallet.Operations.GetByronWallet where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > GET /byron-wallets/{walletId}
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Return information about a Byron wallet.
getByronWallet :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response GetByronWalletResponse) -- ^ Monadic computation which returns the result of the operation
getByronWallet walletId = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either GetByronWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetByronWalletResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                 GetByronWalletResponseBody200)
                                                                                                                                                                   | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> GetByronWalletResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                 GetByronWalletResponseBody404)
                                                                                                                                                                   | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> GetByronWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                 GetByronWalletResponseBody406)
                                                                                                                                                                   | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty)
-- | Represents a response of the operation 'getByronWallet'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'GetByronWalletResponseError' is used.
data GetByronWalletResponse =
   GetByronWalletResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | GetByronWalletResponse200 GetByronWalletResponseBody200 -- ^ Ok
  | GetByronWalletResponse404 GetByronWalletResponseBody404 -- ^ Not Found
  | GetByronWalletResponse406 GetByronWalletResponseBody406 -- ^ Not Acceptable
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.200.content.application\/json.schema@ in the specification.
-- 
-- 
data GetByronWalletResponseBody200 = GetByronWalletResponseBody200 {
  -- | assets: Current non-Ada asset holdings of the wallet.
  -- 
  -- The amount of assets available to spend may be less than the total
  -- unspent assets due to transaction change amounts which are yet to
  -- be fully confirmed (pending).
  getByronWalletResponseBody200Assets :: GetByronWalletResponseBody200Assets
  -- | balance: Byron wallet\'s current balance(s)
  , getByronWalletResponseBody200Balance :: GetByronWalletResponseBody200Balance
  -- | discovery: Mechanism used for discovering addresses.
  , getByronWalletResponseBody200Discovery :: GetByronWalletResponseBody200Discovery
  -- | id: A unique identifier for the wallet
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  , getByronWalletResponseBody200Id :: Data.Text.Internal.Text
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , getByronWalletResponseBody200Name :: Data.Text.Internal.Text
  -- | passphrase: Information about the wallet\'s passphrase
  , getByronWalletResponseBody200Passphrase :: (GHC.Maybe.Maybe GetByronWalletResponseBody200Passphrase)
  -- | state: Whether a wallet is ready to use or still syncing
  , getByronWalletResponseBody200State :: GetByronWalletResponseBody200State
  -- | tip: A reference to a particular time slot, and the block height at that point.
  , getByronWalletResponseBody200Tip :: GetByronWalletResponseBody200Tip
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200Balance obj] : ["discovery" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200Discovery obj] : ["id" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200Id obj] : ["name" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (getByronWalletResponseBody200Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200State obj] : ["tip" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200Tip obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200Balance obj] : ["discovery" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200Discovery obj] : ["id" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200Id obj] : ["name" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (getByronWalletResponseBody200Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200State obj] : ["tip" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200Tip obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletResponseBody200" (\obj -> (((((((GHC.Base.pure GetByronWalletResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "balance")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "discovery")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "state")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tip"))
-- | Create a new 'GetByronWalletResponseBody200' with all required fields.
mkGetByronWalletResponseBody200 :: GetByronWalletResponseBody200Assets -- ^ 'getByronWalletResponseBody200Assets'
  -> GetByronWalletResponseBody200Balance -- ^ 'getByronWalletResponseBody200Balance'
  -> GetByronWalletResponseBody200Discovery -- ^ 'getByronWalletResponseBody200Discovery'
  -> Data.Text.Internal.Text -- ^ 'getByronWalletResponseBody200Id'
  -> Data.Text.Internal.Text -- ^ 'getByronWalletResponseBody200Name'
  -> GetByronWalletResponseBody200State -- ^ 'getByronWalletResponseBody200State'
  -> GetByronWalletResponseBody200Tip -- ^ 'getByronWalletResponseBody200Tip'
  -> GetByronWalletResponseBody200
mkGetByronWalletResponseBody200 getByronWalletResponseBody200Assets getByronWalletResponseBody200Balance getByronWalletResponseBody200Discovery getByronWalletResponseBody200Id getByronWalletResponseBody200Name getByronWalletResponseBody200State getByronWalletResponseBody200Tip = GetByronWalletResponseBody200{getByronWalletResponseBody200Assets = getByronWalletResponseBody200Assets,
                                                                                                                                                                                                                                                                                                                      getByronWalletResponseBody200Balance = getByronWalletResponseBody200Balance,
                                                                                                                                                                                                                                                                                                                      getByronWalletResponseBody200Discovery = getByronWalletResponseBody200Discovery,
                                                                                                                                                                                                                                                                                                                      getByronWalletResponseBody200Id = getByronWalletResponseBody200Id,
                                                                                                                                                                                                                                                                                                                      getByronWalletResponseBody200Name = getByronWalletResponseBody200Name,
                                                                                                                                                                                                                                                                                                                      getByronWalletResponseBody200Passphrase = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                      getByronWalletResponseBody200State = getByronWalletResponseBody200State,
                                                                                                                                                                                                                                                                                                                      getByronWalletResponseBody200Tip = getByronWalletResponseBody200Tip}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.assets@ in the specification.
-- 
-- Current non-Ada asset holdings of the wallet.
-- 
-- The amount of assets available to spend may be less than the total
-- unspent assets due to transaction change amounts which are yet to
-- be fully confirmed (pending).
data GetByronWalletResponseBody200Assets = GetByronWalletResponseBody200Assets {
  -- | available: Available UTxO asset balances (funds that can be spent without
  -- condition).
  getByronWalletResponseBody200AssetsAvailable :: ([GetByronWalletResponseBody200AssetsAvailable])
  -- | total: Total asset balances (available balances plus pending change balances).
  , getByronWalletResponseBody200AssetsTotal :: ([GetByronWalletResponseBody200AssetsTotal])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody200Assets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody200Assets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletResponseBody200Assets" (\obj -> (GHC.Base.pure GetByronWalletResponseBody200Assets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'GetByronWalletResponseBody200Assets' with all required fields.
mkGetByronWalletResponseBody200Assets :: [GetByronWalletResponseBody200AssetsAvailable] -- ^ 'getByronWalletResponseBody200AssetsAvailable'
  -> [GetByronWalletResponseBody200AssetsTotal] -- ^ 'getByronWalletResponseBody200AssetsTotal'
  -> GetByronWalletResponseBody200Assets
mkGetByronWalletResponseBody200Assets getByronWalletResponseBody200AssetsAvailable getByronWalletResponseBody200AssetsTotal = GetByronWalletResponseBody200Assets{getByronWalletResponseBody200AssetsAvailable = getByronWalletResponseBody200AssetsAvailable,
                                                                                                                                                                  getByronWalletResponseBody200AssetsTotal = getByronWalletResponseBody200AssetsTotal}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.assets.properties.available.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data GetByronWalletResponseBody200AssetsAvailable = GetByronWalletResponseBody200AssetsAvailable {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getByronWalletResponseBody200AssetsAvailableAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getByronWalletResponseBody200AssetsAvailablePolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronWalletResponseBody200AssetsAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody200AssetsAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsAvailableQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsAvailableQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody200AssetsAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletResponseBody200AssetsAvailable" (\obj -> ((GHC.Base.pure GetByronWalletResponseBody200AssetsAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronWalletResponseBody200AssetsAvailable' with all required fields.
mkGetByronWalletResponseBody200AssetsAvailable :: Data.Text.Internal.Text -- ^ 'getByronWalletResponseBody200AssetsAvailableAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getByronWalletResponseBody200AssetsAvailablePolicy_id'
  -> GHC.Types.Int -- ^ 'getByronWalletResponseBody200AssetsAvailableQuantity'
  -> GetByronWalletResponseBody200AssetsAvailable
mkGetByronWalletResponseBody200AssetsAvailable getByronWalletResponseBody200AssetsAvailableAsset_name getByronWalletResponseBody200AssetsAvailablePolicy_id getByronWalletResponseBody200AssetsAvailableQuantity = GetByronWalletResponseBody200AssetsAvailable{getByronWalletResponseBody200AssetsAvailableAsset_name = getByronWalletResponseBody200AssetsAvailableAsset_name,
                                                                                                                                                                                                                                                                getByronWalletResponseBody200AssetsAvailablePolicy_id = getByronWalletResponseBody200AssetsAvailablePolicy_id,
                                                                                                                                                                                                                                                                getByronWalletResponseBody200AssetsAvailableQuantity = getByronWalletResponseBody200AssetsAvailableQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.assets.properties.total.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data GetByronWalletResponseBody200AssetsTotal = GetByronWalletResponseBody200AssetsTotal {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getByronWalletResponseBody200AssetsTotalAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getByronWalletResponseBody200AssetsTotalPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronWalletResponseBody200AssetsTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody200AssetsTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsTotalQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200AssetsTotalQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody200AssetsTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletResponseBody200AssetsTotal" (\obj -> ((GHC.Base.pure GetByronWalletResponseBody200AssetsTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronWalletResponseBody200AssetsTotal' with all required fields.
mkGetByronWalletResponseBody200AssetsTotal :: Data.Text.Internal.Text -- ^ 'getByronWalletResponseBody200AssetsTotalAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getByronWalletResponseBody200AssetsTotalPolicy_id'
  -> GHC.Types.Int -- ^ 'getByronWalletResponseBody200AssetsTotalQuantity'
  -> GetByronWalletResponseBody200AssetsTotal
mkGetByronWalletResponseBody200AssetsTotal getByronWalletResponseBody200AssetsTotalAsset_name getByronWalletResponseBody200AssetsTotalPolicy_id getByronWalletResponseBody200AssetsTotalQuantity = GetByronWalletResponseBody200AssetsTotal{getByronWalletResponseBody200AssetsTotalAsset_name = getByronWalletResponseBody200AssetsTotalAsset_name,
                                                                                                                                                                                                                                            getByronWalletResponseBody200AssetsTotalPolicy_id = getByronWalletResponseBody200AssetsTotalPolicy_id,
                                                                                                                                                                                                                                            getByronWalletResponseBody200AssetsTotalQuantity = getByronWalletResponseBody200AssetsTotalQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.balance@ in the specification.
-- 
-- Byron wallet\'s current balance(s)
data GetByronWalletResponseBody200Balance = GetByronWalletResponseBody200Balance {
  -- | available: Available balance (funds that can be spent)
  getByronWalletResponseBody200BalanceAvailable :: GetByronWalletResponseBody200BalanceAvailable
  -- | total: Total balance (available balance plus pending change)
  , getByronWalletResponseBody200BalanceTotal :: GetByronWalletResponseBody200BalanceTotal
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody200Balance
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200BalanceAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200BalanceTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200BalanceAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200BalanceTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody200Balance
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletResponseBody200Balance" (\obj -> (GHC.Base.pure GetByronWalletResponseBody200Balance GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'GetByronWalletResponseBody200Balance' with all required fields.
mkGetByronWalletResponseBody200Balance :: GetByronWalletResponseBody200BalanceAvailable -- ^ 'getByronWalletResponseBody200BalanceAvailable'
  -> GetByronWalletResponseBody200BalanceTotal -- ^ 'getByronWalletResponseBody200BalanceTotal'
  -> GetByronWalletResponseBody200Balance
mkGetByronWalletResponseBody200Balance getByronWalletResponseBody200BalanceAvailable getByronWalletResponseBody200BalanceTotal = GetByronWalletResponseBody200Balance{getByronWalletResponseBody200BalanceAvailable = getByronWalletResponseBody200BalanceAvailable,
                                                                                                                                                                      getByronWalletResponseBody200BalanceTotal = getByronWalletResponseBody200BalanceTotal}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.balance.properties.available@ in the specification.
-- 
-- Available balance (funds that can be spent)
data GetByronWalletResponseBody200BalanceAvailable = GetByronWalletResponseBody200BalanceAvailable {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronWalletResponseBody200BalanceAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody200BalanceAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody200BalanceAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletResponseBody200BalanceAvailable" (\obj -> GHC.Base.pure GetByronWalletResponseBody200BalanceAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronWalletResponseBody200BalanceAvailable' with all required fields.
mkGetByronWalletResponseBody200BalanceAvailable :: GHC.Types.Int -- ^ 'getByronWalletResponseBody200BalanceAvailableQuantity'
  -> GetByronWalletResponseBody200BalanceAvailable
mkGetByronWalletResponseBody200BalanceAvailable getByronWalletResponseBody200BalanceAvailableQuantity = GetByronWalletResponseBody200BalanceAvailable{getByronWalletResponseBody200BalanceAvailableQuantity = getByronWalletResponseBody200BalanceAvailableQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.balance.properties.total@ in the specification.
-- 
-- Total balance (available balance plus pending change)
data GetByronWalletResponseBody200BalanceTotal = GetByronWalletResponseBody200BalanceTotal {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronWalletResponseBody200BalanceTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody200BalanceTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody200BalanceTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletResponseBody200BalanceTotal" (\obj -> GHC.Base.pure GetByronWalletResponseBody200BalanceTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronWalletResponseBody200BalanceTotal' with all required fields.
mkGetByronWalletResponseBody200BalanceTotal :: GHC.Types.Int -- ^ 'getByronWalletResponseBody200BalanceTotalQuantity'
  -> GetByronWalletResponseBody200BalanceTotal
mkGetByronWalletResponseBody200BalanceTotal getByronWalletResponseBody200BalanceTotalQuantity = GetByronWalletResponseBody200BalanceTotal{getByronWalletResponseBody200BalanceTotalQuantity = getByronWalletResponseBody200BalanceTotalQuantity}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.discovery@ in the specification.
-- 
-- Mechanism used for discovering addresses.
data GetByronWalletResponseBody200Discovery =
   GetByronWalletResponseBody200DiscoveryOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetByronWalletResponseBody200DiscoveryTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetByronWalletResponseBody200DiscoveryEnumRandom -- ^ Represents the JSON value @"random"@
  | GetByronWalletResponseBody200DiscoveryEnumSequential -- ^ Represents the JSON value @"sequential"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody200Discovery
    where toJSON (GetByronWalletResponseBody200DiscoveryOther val) = val
          toJSON (GetByronWalletResponseBody200DiscoveryTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetByronWalletResponseBody200DiscoveryEnumRandom) = "random"
          toJSON (GetByronWalletResponseBody200DiscoveryEnumSequential) = "sequential"
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody200Discovery
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "random" -> GetByronWalletResponseBody200DiscoveryEnumRandom
                                            | val GHC.Classes.== "sequential" -> GetByronWalletResponseBody200DiscoveryEnumSequential
                                            | GHC.Base.otherwise -> GetByronWalletResponseBody200DiscoveryOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.passphrase@ in the specification.
-- 
-- Information about the wallet\'s passphrase
data GetByronWalletResponseBody200Passphrase = GetByronWalletResponseBody200Passphrase {
  -- | last_updated_at
  getByronWalletResponseBody200PassphraseLast_updated_at :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody200Passphrase
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200PassphraseLast_updated_at obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200PassphraseLast_updated_at obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody200Passphrase
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletResponseBody200Passphrase" (\obj -> GHC.Base.pure GetByronWalletResponseBody200Passphrase GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "last_updated_at"))
-- | Create a new 'GetByronWalletResponseBody200Passphrase' with all required fields.
mkGetByronWalletResponseBody200Passphrase :: Data.Text.Internal.Text -- ^ 'getByronWalletResponseBody200PassphraseLast_updated_at'
  -> GetByronWalletResponseBody200Passphrase
mkGetByronWalletResponseBody200Passphrase getByronWalletResponseBody200PassphraseLast_updated_at = GetByronWalletResponseBody200Passphrase{getByronWalletResponseBody200PassphraseLast_updated_at = getByronWalletResponseBody200PassphraseLast_updated_at}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.state@ in the specification.
-- 
-- Whether a wallet is ready to use or still syncing
data GetByronWalletResponseBody200State = GetByronWalletResponseBody200State {
  -- | progress: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == syncing
  -- \<\/span>\<br\/>
  getByronWalletResponseBody200StateProgress :: (GHC.Maybe.Maybe GetByronWalletResponseBody200StateProgress)
  -- | status
  , getByronWalletResponseBody200StateStatus :: GetByronWalletResponseBody200StateStatus
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody200State
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (getByronWalletResponseBody200StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200StateStatus obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (getByronWalletResponseBody200StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200StateStatus obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody200State
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletResponseBody200State" (\obj -> (GHC.Base.pure GetByronWalletResponseBody200State GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "progress")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status"))
-- | Create a new 'GetByronWalletResponseBody200State' with all required fields.
mkGetByronWalletResponseBody200State :: GetByronWalletResponseBody200StateStatus -- ^ 'getByronWalletResponseBody200StateStatus'
  -> GetByronWalletResponseBody200State
mkGetByronWalletResponseBody200State getByronWalletResponseBody200StateStatus = GetByronWalletResponseBody200State{getByronWalletResponseBody200StateProgress = GHC.Maybe.Nothing,
                                                                                                                   getByronWalletResponseBody200StateStatus = getByronWalletResponseBody200StateStatus}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.state.properties.progress@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == syncing
-- \<\/span>\<br\/>
data GetByronWalletResponseBody200StateProgress = GetByronWalletResponseBody200StateProgress {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  getByronWalletResponseBody200StateProgressQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody200StateProgress
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody200StateProgress
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletResponseBody200StateProgress" (\obj -> GHC.Base.pure GetByronWalletResponseBody200StateProgress GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronWalletResponseBody200StateProgress' with all required fields.
mkGetByronWalletResponseBody200StateProgress :: GHC.Types.Double -- ^ 'getByronWalletResponseBody200StateProgressQuantity'
  -> GetByronWalletResponseBody200StateProgress
mkGetByronWalletResponseBody200StateProgress getByronWalletResponseBody200StateProgressQuantity = GetByronWalletResponseBody200StateProgress{getByronWalletResponseBody200StateProgressQuantity = getByronWalletResponseBody200StateProgressQuantity}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.state.properties.status@ in the specification.
-- 
-- 
data GetByronWalletResponseBody200StateStatus =
   GetByronWalletResponseBody200StateStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetByronWalletResponseBody200StateStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetByronWalletResponseBody200StateStatusEnumReady -- ^ Represents the JSON value @"ready"@
  | GetByronWalletResponseBody200StateStatusEnumSyncing -- ^ Represents the JSON value @"syncing"@
  | GetByronWalletResponseBody200StateStatusEnumNot_responding -- ^ Represents the JSON value @"not_responding"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody200StateStatus
    where toJSON (GetByronWalletResponseBody200StateStatusOther val) = val
          toJSON (GetByronWalletResponseBody200StateStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetByronWalletResponseBody200StateStatusEnumReady) = "ready"
          toJSON (GetByronWalletResponseBody200StateStatusEnumSyncing) = "syncing"
          toJSON (GetByronWalletResponseBody200StateStatusEnumNot_responding) = "not_responding"
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody200StateStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "ready" -> GetByronWalletResponseBody200StateStatusEnumReady
                                            | val GHC.Classes.== "syncing" -> GetByronWalletResponseBody200StateStatusEnumSyncing
                                            | val GHC.Classes.== "not_responding" -> GetByronWalletResponseBody200StateStatusEnumNot_responding
                                            | GHC.Base.otherwise -> GetByronWalletResponseBody200StateStatusOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.tip@ in the specification.
-- 
-- A reference to a particular time slot, and the block height at that point.
data GetByronWalletResponseBody200Tip = GetByronWalletResponseBody200Tip {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronWalletResponseBody200TipAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronWalletResponseBody200TipEpoch_number :: GHC.Types.Int
  -- | height
  , getByronWalletResponseBody200TipHeight :: GetByronWalletResponseBody200TipHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronWalletResponseBody200TipSlot_number :: GHC.Types.Int
  -- | time
  , getByronWalletResponseBody200TipTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody200Tip
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200TipTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200TipTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody200Tip
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletResponseBody200Tip" (\obj -> ((((GHC.Base.pure GetByronWalletResponseBody200Tip GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'GetByronWalletResponseBody200Tip' with all required fields.
mkGetByronWalletResponseBody200Tip :: GHC.Types.Int -- ^ 'getByronWalletResponseBody200TipAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'getByronWalletResponseBody200TipEpoch_number'
  -> GetByronWalletResponseBody200TipHeight -- ^ 'getByronWalletResponseBody200TipHeight'
  -> GHC.Types.Int -- ^ 'getByronWalletResponseBody200TipSlot_number'
  -> Data.Text.Internal.Text -- ^ 'getByronWalletResponseBody200TipTime'
  -> GetByronWalletResponseBody200Tip
mkGetByronWalletResponseBody200Tip getByronWalletResponseBody200TipAbsolute_slot_number getByronWalletResponseBody200TipEpoch_number getByronWalletResponseBody200TipHeight getByronWalletResponseBody200TipSlot_number getByronWalletResponseBody200TipTime = GetByronWalletResponseBody200Tip{getByronWalletResponseBody200TipAbsolute_slot_number = getByronWalletResponseBody200TipAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                getByronWalletResponseBody200TipEpoch_number = getByronWalletResponseBody200TipEpoch_number,
                                                                                                                                                                                                                                                                                                getByronWalletResponseBody200TipHeight = getByronWalletResponseBody200TipHeight,
                                                                                                                                                                                                                                                                                                getByronWalletResponseBody200TipSlot_number = getByronWalletResponseBody200TipSlot_number,
                                                                                                                                                                                                                                                                                                getByronWalletResponseBody200TipTime = getByronWalletResponseBody200TipTime}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.200.content.application\/json.schema.properties.tip.properties.height@ in the specification.
-- 
-- 
data GetByronWalletResponseBody200TipHeight = GetByronWalletResponseBody200TipHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronWalletResponseBody200TipHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody200TipHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody200TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody200TipHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletResponseBody200TipHeight" (\obj -> GHC.Base.pure GetByronWalletResponseBody200TipHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronWalletResponseBody200TipHeight' with all required fields.
mkGetByronWalletResponseBody200TipHeight :: GHC.Types.Int -- ^ 'getByronWalletResponseBody200TipHeightQuantity'
  -> GetByronWalletResponseBody200TipHeight
mkGetByronWalletResponseBody200TipHeight getByronWalletResponseBody200TipHeightQuantity = GetByronWalletResponseBody200TipHeight{getByronWalletResponseBody200TipHeightQuantity = getByronWalletResponseBody200TipHeightQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data GetByronWalletResponseBody404 = GetByronWalletResponseBody404 {
  -- | code: A specific error code for this error, more precise than HTTP ones.
  getByronWalletResponseBody404Code :: Data.Text.Internal.Text
  -- | message: A descriptive error message.
  , getByronWalletResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["code" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody404Code obj] : ["message" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody404Message obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["code" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody404Code obj] : ["message" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody404Message obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletResponseBody404" (\obj -> (GHC.Base.pure GetByronWalletResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "code")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetByronWalletResponseBody404' with all required fields.
mkGetByronWalletResponseBody404 :: Data.Text.Internal.Text -- ^ 'getByronWalletResponseBody404Code'
  -> Data.Text.Internal.Text -- ^ 'getByronWalletResponseBody404Message'
  -> GetByronWalletResponseBody404
mkGetByronWalletResponseBody404 getByronWalletResponseBody404Code getByronWalletResponseBody404Message = GetByronWalletResponseBody404{getByronWalletResponseBody404Code = getByronWalletResponseBody404Code,
                                                                                                                                       getByronWalletResponseBody404Message = getByronWalletResponseBody404Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.GET.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data GetByronWalletResponseBody406 = GetByronWalletResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  getByronWalletResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletResponseBody406" (\obj -> GHC.Base.pure GetByronWalletResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetByronWalletResponseBody406' with all required fields.
mkGetByronWalletResponseBody406 :: Data.Text.Internal.Text -- ^ 'getByronWalletResponseBody406Message'
  -> GetByronWalletResponseBody406
mkGetByronWalletResponseBody406 getByronWalletResponseBody406Message = GetByronWalletResponseBody406{getByronWalletResponseBody406Message = getByronWalletResponseBody406Message}
-- | > GET /byron-wallets/{walletId}
-- 
-- The same as 'getByronWallet' but accepts an explicit configuration.
getByronWalletWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> m (Network.HTTP.Client.Types.Response GetByronWalletResponse) -- ^ Monadic computation which returns the result of the operation
getByronWalletWithConfiguration config
                                walletId = GHC.Base.fmap (\response_4 -> GHC.Base.fmap (Data.Either.either GetByronWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetByronWalletResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                  GetByronWalletResponseBody200)
                                                                                                                                                                                    | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> GetByronWalletResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                  GetByronWalletResponseBody404)
                                                                                                                                                                                    | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> GetByronWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                  GetByronWalletResponseBody406)
                                                                                                                                                                                    | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_4) response_4) (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty)
-- | > GET /byron-wallets/{walletId}
-- 
-- The same as 'getByronWallet' but returns the raw 'Data.ByteString.ByteString'.
getByronWalletRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
getByronWalletRaw walletId = GHC.Base.id (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty)
-- | > GET /byron-wallets/{walletId}
-- 
-- The same as 'getByronWallet' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
getByronWalletWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
getByronWalletWithConfigurationRaw config
                                   walletId = GHC.Base.id (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty)
