-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation postWallet
module Wallet.Operations.PostWallet where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /wallets
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Create and restore a wallet from a mnemonic sentence or account public key.
postWallet :: forall m . Wallet.Common.MonadHTTP m => PostWalletRequestBodyVariants -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response PostWalletResponse) -- ^ Monadic computation which returns the result of the operation
postWallet body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PostWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 201) (Network.HTTP.Client.Types.responseStatus response) -> PostWalletResponse201 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                 PostWalletResponseBody201)
                                                                                                                                                       | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostWalletResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                 PostWalletResponseBody400)
                                                                                                                                                       | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                 PostWalletResponseBody406)
                                                                                                                                                       | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 409) (Network.HTTP.Client.Types.responseStatus response) -> PostWalletResponse409 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                 PostWalletResponseBody409)
                                                                                                                                                       | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostWalletResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                 PostWalletResponseBody415)
                                                                                                                                                       | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") "/wallets" GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/wallets.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- Restore from root private key
data PostWalletRequestBodyOneOf1 = PostWalletRequestBodyOneOf1 {
  -- | address_pool_gap: Number of consecutive unused addresses allowed.
  -- 
  -- **IMPORTANT DISCLAIMER:** Using values other than \`20\` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
  -- your wallet in a different software which is strictly following BIP-44.
  -- 
  -- Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
  -- 
  -- **IMPORTANT DISCLAIMER 2:** There is no way to \`import\` addresses generated outside (e.g. using cardano-addresses) into the wallet.
  -- Wallet only discovers transactions on its used and unused addresses that are within its currently seen \`address_pool_gap\`.
  -- Transactions on addresses that \"belong\" to the wallet but happen to be beyond its \`address_pool_gap\` will not be visible to the wallet.
  -- This is a technical limitation of the industry standard [BIP-44](https:\/\/github.com\/bitcoin\/bips\/blob\/master\/bip-0044.mediawiki). See also [CIP-1852](https:\/\/github.com\/cardano-foundation\/CIPs\/blob\/master\/CIP-1852\/CIP-1852.md).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100000.0
  -- * Minimum  of 10.0
  postWalletRequestBodyOneOf1Address_pool_gap :: (GHC.Maybe.Maybe GHC.Types.Int)
  -- | mnemonic_second_factor: An optional passphrase used to encrypt the mnemonic sentence.
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 12 items
  -- * Must have a minimum of 9 items
  , postWalletRequestBodyOneOf1Mnemonic_second_factor :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | mnemonic_sentence: A list of mnemonic words
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 24 items
  -- * Must have a minimum of 15 items
  , postWalletRequestBodyOneOf1Mnemonic_sentence :: ([Data.Text.Internal.Text])
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , postWalletRequestBodyOneOf1Name :: Data.Text.Internal.Text
  -- | passphrase: A master passphrase to lock and protect the wallet for sensitive operation (e.g. sending funds)
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 10
  , postWalletRequestBodyOneOf1Passphrase :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletRequestBodyOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address_pool_gap" Data.Aeson.Types.ToJSON..=)) (postWalletRequestBodyOneOf1Address_pool_gap obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mnemonic_second_factor" Data.Aeson.Types.ToJSON..=)) (postWalletRequestBodyOneOf1Mnemonic_second_factor obj) : ["mnemonic_sentence" Data.Aeson.Types.ToJSON..= postWalletRequestBodyOneOf1Mnemonic_sentence obj] : ["name" Data.Aeson.Types.ToJSON..= postWalletRequestBodyOneOf1Name obj] : ["passphrase" Data.Aeson.Types.ToJSON..= postWalletRequestBodyOneOf1Passphrase obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address_pool_gap" Data.Aeson.Types.ToJSON..=)) (postWalletRequestBodyOneOf1Address_pool_gap obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mnemonic_second_factor" Data.Aeson.Types.ToJSON..=)) (postWalletRequestBodyOneOf1Mnemonic_second_factor obj) : ["mnemonic_sentence" Data.Aeson.Types.ToJSON..= postWalletRequestBodyOneOf1Mnemonic_sentence obj] : ["name" Data.Aeson.Types.ToJSON..= postWalletRequestBodyOneOf1Name obj] : ["passphrase" Data.Aeson.Types.ToJSON..= postWalletRequestBodyOneOf1Passphrase obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletRequestBodyOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletRequestBodyOneOf1" (\obj -> ((((GHC.Base.pure PostWalletRequestBodyOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address_pool_gap")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mnemonic_second_factor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "mnemonic_sentence")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "passphrase"))
-- | Create a new 'PostWalletRequestBodyOneOf1' with all required fields.
mkPostWalletRequestBodyOneOf1 :: [Data.Text.Internal.Text] -- ^ 'postWalletRequestBodyOneOf1Mnemonic_sentence'
  -> Data.Text.Internal.Text -- ^ 'postWalletRequestBodyOneOf1Name'
  -> Data.Text.Internal.Text -- ^ 'postWalletRequestBodyOneOf1Passphrase'
  -> PostWalletRequestBodyOneOf1
mkPostWalletRequestBodyOneOf1 postWalletRequestBodyOneOf1Mnemonic_sentence postWalletRequestBodyOneOf1Name postWalletRequestBodyOneOf1Passphrase = PostWalletRequestBodyOneOf1{postWalletRequestBodyOneOf1Address_pool_gap = GHC.Maybe.Nothing,
                                                                                                                                                                               postWalletRequestBodyOneOf1Mnemonic_second_factor = GHC.Maybe.Nothing,
                                                                                                                                                                               postWalletRequestBodyOneOf1Mnemonic_sentence = postWalletRequestBodyOneOf1Mnemonic_sentence,
                                                                                                                                                                               postWalletRequestBodyOneOf1Name = postWalletRequestBodyOneOf1Name,
                                                                                                                                                                               postWalletRequestBodyOneOf1Passphrase = postWalletRequestBodyOneOf1Passphrase}
-- | Defines the object schema located at @paths.\/wallets.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- Restore from account public key
data PostWalletRequestBodyOneOf2 = PostWalletRequestBodyOneOf2 {
  -- | account_public_key: An extended account public key (public key + chain code)
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 128
  -- * Minimum length of 128
  postWalletRequestBodyOneOf2Account_public_key :: Data.Text.Internal.Text
  -- | address_pool_gap: Number of consecutive unused addresses allowed.
  -- 
  -- **IMPORTANT DISCLAIMER:** Using values other than \`20\` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
  -- your wallet in a different software which is strictly following BIP-44.
  -- 
  -- Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
  -- 
  -- **IMPORTANT DISCLAIMER 2:** There is no way to \`import\` addresses generated outside (e.g. using cardano-addresses) into the wallet.
  -- Wallet only discovers transactions on its used and unused addresses that are within its currently seen \`address_pool_gap\`.
  -- Transactions on addresses that \"belong\" to the wallet but happen to be beyond its \`address_pool_gap\` will not be visible to the wallet.
  -- This is a technical limitation of the industry standard [BIP-44](https:\/\/github.com\/bitcoin\/bips\/blob\/master\/bip-0044.mediawiki). See also [CIP-1852](https:\/\/github.com\/cardano-foundation\/CIPs\/blob\/master\/CIP-1852\/CIP-1852.md).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100000.0
  -- * Minimum  of 10.0
  , postWalletRequestBodyOneOf2Address_pool_gap :: (GHC.Maybe.Maybe GHC.Types.Int)
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , postWalletRequestBodyOneOf2Name :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletRequestBodyOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["account_public_key" Data.Aeson.Types.ToJSON..= postWalletRequestBodyOneOf2Account_public_key obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address_pool_gap" Data.Aeson.Types.ToJSON..=)) (postWalletRequestBodyOneOf2Address_pool_gap obj) : ["name" Data.Aeson.Types.ToJSON..= postWalletRequestBodyOneOf2Name obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["account_public_key" Data.Aeson.Types.ToJSON..= postWalletRequestBodyOneOf2Account_public_key obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address_pool_gap" Data.Aeson.Types.ToJSON..=)) (postWalletRequestBodyOneOf2Address_pool_gap obj) : ["name" Data.Aeson.Types.ToJSON..= postWalletRequestBodyOneOf2Name obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletRequestBodyOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletRequestBodyOneOf2" (\obj -> ((GHC.Base.pure PostWalletRequestBodyOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "account_public_key")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address_pool_gap")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name"))
-- | Create a new 'PostWalletRequestBodyOneOf2' with all required fields.
mkPostWalletRequestBodyOneOf2 :: Data.Text.Internal.Text -- ^ 'postWalletRequestBodyOneOf2Account_public_key'
  -> Data.Text.Internal.Text -- ^ 'postWalletRequestBodyOneOf2Name'
  -> PostWalletRequestBodyOneOf2
mkPostWalletRequestBodyOneOf2 postWalletRequestBodyOneOf2Account_public_key postWalletRequestBodyOneOf2Name = PostWalletRequestBodyOneOf2{postWalletRequestBodyOneOf2Account_public_key = postWalletRequestBodyOneOf2Account_public_key,
                                                                                                                                          postWalletRequestBodyOneOf2Address_pool_gap = GHC.Maybe.Nothing,
                                                                                                                                          postWalletRequestBodyOneOf2Name = postWalletRequestBodyOneOf2Name}
-- | Defines the oneOf schema located at @paths.\/wallets.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostWalletRequestBodyVariants =
   PostWalletRequestBodyVariant1 PostWalletRequestBodyOneOf1
  | PostWalletRequestBodyVariant2 PostWalletRequestBodyOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletRequestBodyVariants
    where toJSON (PostWalletRequestBodyVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostWalletRequestBodyVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletRequestBodyVariants
    where parseJSON val = case (PostWalletRequestBodyVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostWalletRequestBodyVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Represents a response of the operation 'postWallet'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PostWalletResponseError' is used.
data PostWalletResponse =
   PostWalletResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | PostWalletResponse201 PostWalletResponseBody201 -- ^ Created
  | PostWalletResponse400 PostWalletResponseBody400 -- ^ Bad Request
  | PostWalletResponse406 PostWalletResponseBody406 -- ^ Not Acceptable
  | PostWalletResponse409 PostWalletResponseBody409 -- ^ Conflict
  | PostWalletResponse415 PostWalletResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema@ in the specification.
-- 
-- 
data PostWalletResponseBody201 = PostWalletResponseBody201 {
  -- | address_pool_gap: Number of consecutive unused addresses allowed.
  -- 
  -- **IMPORTANT DISCLAIMER:** Using values other than \`20\` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
  -- your wallet in a different software which is strictly following BIP-44.
  -- 
  -- Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
  -- 
  -- **IMPORTANT DISCLAIMER 2:** There is no way to \`import\` addresses generated outside (e.g. using cardano-addresses) into the wallet.
  -- Wallet only discovers transactions on its used and unused addresses that are within its currently seen \`address_pool_gap\`.
  -- Transactions on addresses that \"belong\" to the wallet but happen to be beyond its \`address_pool_gap\` will not be visible to the wallet.
  -- This is a technical limitation of the industry standard [BIP-44](https:\/\/github.com\/bitcoin\/bips\/blob\/master\/bip-0044.mediawiki). See also [CIP-1852](https:\/\/github.com\/cardano-foundation\/CIPs\/blob\/master\/CIP-1852\/CIP-1852.md).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100000.0
  -- * Minimum  of 10.0
  postWalletResponseBody201Address_pool_gap :: GHC.Types.Int
  -- | assets: Current non-Ada asset holdings of the wallet.
  -- 
  -- The amount of assets available to spend may be less than the total
  -- unspent assets due to transaction change amounts which are yet to
  -- be fully confirmed (pending).
  , postWalletResponseBody201Assets :: PostWalletResponseBody201Assets
  -- | balance: Wallet current Ada balance(s).
  , postWalletResponseBody201Balance :: PostWalletResponseBody201Balance
  -- | delegation: Delegation settings
  , postWalletResponseBody201Delegation :: PostWalletResponseBody201Delegation
  -- | id: A unique identifier for the wallet
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  , postWalletResponseBody201Id :: Data.Text.Internal.Text
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , postWalletResponseBody201Name :: Data.Text.Internal.Text
  -- | passphrase: Information about the wallet\'s passphrase
  , postWalletResponseBody201Passphrase :: (GHC.Maybe.Maybe PostWalletResponseBody201Passphrase)
  -- | state: Whether a wallet is ready to use or still syncing
  , postWalletResponseBody201State :: PostWalletResponseBody201State
  -- | tip: A reference to a particular time slot, and the block height at that point.
  , postWalletResponseBody201Tip :: PostWalletResponseBody201Tip
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address_pool_gap" Data.Aeson.Types.ToJSON..= postWalletResponseBody201Address_pool_gap obj] : ["assets" Data.Aeson.Types.ToJSON..= postWalletResponseBody201Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= postWalletResponseBody201Balance obj] : ["delegation" Data.Aeson.Types.ToJSON..= postWalletResponseBody201Delegation obj] : ["id" Data.Aeson.Types.ToJSON..= postWalletResponseBody201Id obj] : ["name" Data.Aeson.Types.ToJSON..= postWalletResponseBody201Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (postWalletResponseBody201Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= postWalletResponseBody201State obj] : ["tip" Data.Aeson.Types.ToJSON..= postWalletResponseBody201Tip obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address_pool_gap" Data.Aeson.Types.ToJSON..= postWalletResponseBody201Address_pool_gap obj] : ["assets" Data.Aeson.Types.ToJSON..= postWalletResponseBody201Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= postWalletResponseBody201Balance obj] : ["delegation" Data.Aeson.Types.ToJSON..= postWalletResponseBody201Delegation obj] : ["id" Data.Aeson.Types.ToJSON..= postWalletResponseBody201Id obj] : ["name" Data.Aeson.Types.ToJSON..= postWalletResponseBody201Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (postWalletResponseBody201Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= postWalletResponseBody201State obj] : ["tip" Data.Aeson.Types.ToJSON..= postWalletResponseBody201Tip obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201" (\obj -> ((((((((GHC.Base.pure PostWalletResponseBody201 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address_pool_gap")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "balance")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delegation")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "state")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tip"))
-- | Create a new 'PostWalletResponseBody201' with all required fields.
mkPostWalletResponseBody201 :: GHC.Types.Int -- ^ 'postWalletResponseBody201Address_pool_gap'
  -> PostWalletResponseBody201Assets -- ^ 'postWalletResponseBody201Assets'
  -> PostWalletResponseBody201Balance -- ^ 'postWalletResponseBody201Balance'
  -> PostWalletResponseBody201Delegation -- ^ 'postWalletResponseBody201Delegation'
  -> Data.Text.Internal.Text -- ^ 'postWalletResponseBody201Id'
  -> Data.Text.Internal.Text -- ^ 'postWalletResponseBody201Name'
  -> PostWalletResponseBody201State -- ^ 'postWalletResponseBody201State'
  -> PostWalletResponseBody201Tip -- ^ 'postWalletResponseBody201Tip'
  -> PostWalletResponseBody201
mkPostWalletResponseBody201 postWalletResponseBody201Address_pool_gap postWalletResponseBody201Assets postWalletResponseBody201Balance postWalletResponseBody201Delegation postWalletResponseBody201Id postWalletResponseBody201Name postWalletResponseBody201State postWalletResponseBody201Tip = PostWalletResponseBody201{postWalletResponseBody201Address_pool_gap = postWalletResponseBody201Address_pool_gap,
                                                                                                                                                                                                                                                                                                                             postWalletResponseBody201Assets = postWalletResponseBody201Assets,
                                                                                                                                                                                                                                                                                                                             postWalletResponseBody201Balance = postWalletResponseBody201Balance,
                                                                                                                                                                                                                                                                                                                             postWalletResponseBody201Delegation = postWalletResponseBody201Delegation,
                                                                                                                                                                                                                                                                                                                             postWalletResponseBody201Id = postWalletResponseBody201Id,
                                                                                                                                                                                                                                                                                                                             postWalletResponseBody201Name = postWalletResponseBody201Name,
                                                                                                                                                                                                                                                                                                                             postWalletResponseBody201Passphrase = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                             postWalletResponseBody201State = postWalletResponseBody201State,
                                                                                                                                                                                                                                                                                                                             postWalletResponseBody201Tip = postWalletResponseBody201Tip}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.assets@ in the specification.
-- 
-- Current non-Ada asset holdings of the wallet.
-- 
-- The amount of assets available to spend may be less than the total
-- unspent assets due to transaction change amounts which are yet to
-- be fully confirmed (pending).
data PostWalletResponseBody201Assets = PostWalletResponseBody201Assets {
  -- | available: Available UTxO asset balances (funds that can be spent without
  -- condition).
  postWalletResponseBody201AssetsAvailable :: ([PostWalletResponseBody201AssetsAvailable])
  -- | total: Total asset balances (available balances plus pending change balances).
  , postWalletResponseBody201AssetsTotal :: ([PostWalletResponseBody201AssetsTotal])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201Assets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201Assets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201Assets" (\obj -> (GHC.Base.pure PostWalletResponseBody201Assets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'PostWalletResponseBody201Assets' with all required fields.
mkPostWalletResponseBody201Assets :: [PostWalletResponseBody201AssetsAvailable] -- ^ 'postWalletResponseBody201AssetsAvailable'
  -> [PostWalletResponseBody201AssetsTotal] -- ^ 'postWalletResponseBody201AssetsTotal'
  -> PostWalletResponseBody201Assets
mkPostWalletResponseBody201Assets postWalletResponseBody201AssetsAvailable postWalletResponseBody201AssetsTotal = PostWalletResponseBody201Assets{postWalletResponseBody201AssetsAvailable = postWalletResponseBody201AssetsAvailable,
                                                                                                                                                  postWalletResponseBody201AssetsTotal = postWalletResponseBody201AssetsTotal}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.assets.properties.available.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostWalletResponseBody201AssetsAvailable = PostWalletResponseBody201AssetsAvailable {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postWalletResponseBody201AssetsAvailableAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postWalletResponseBody201AssetsAvailablePolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postWalletResponseBody201AssetsAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201AssetsAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsAvailableQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsAvailableQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201AssetsAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201AssetsAvailable" (\obj -> ((GHC.Base.pure PostWalletResponseBody201AssetsAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostWalletResponseBody201AssetsAvailable' with all required fields.
mkPostWalletResponseBody201AssetsAvailable :: Data.Text.Internal.Text -- ^ 'postWalletResponseBody201AssetsAvailableAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postWalletResponseBody201AssetsAvailablePolicy_id'
  -> GHC.Types.Int -- ^ 'postWalletResponseBody201AssetsAvailableQuantity'
  -> PostWalletResponseBody201AssetsAvailable
mkPostWalletResponseBody201AssetsAvailable postWalletResponseBody201AssetsAvailableAsset_name postWalletResponseBody201AssetsAvailablePolicy_id postWalletResponseBody201AssetsAvailableQuantity = PostWalletResponseBody201AssetsAvailable{postWalletResponseBody201AssetsAvailableAsset_name = postWalletResponseBody201AssetsAvailableAsset_name,
                                                                                                                                                                                                                                            postWalletResponseBody201AssetsAvailablePolicy_id = postWalletResponseBody201AssetsAvailablePolicy_id,
                                                                                                                                                                                                                                            postWalletResponseBody201AssetsAvailableQuantity = postWalletResponseBody201AssetsAvailableQuantity}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.assets.properties.total.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostWalletResponseBody201AssetsTotal = PostWalletResponseBody201AssetsTotal {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postWalletResponseBody201AssetsTotalAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postWalletResponseBody201AssetsTotalPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postWalletResponseBody201AssetsTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201AssetsTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsTotalQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postWalletResponseBody201AssetsTotalQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201AssetsTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201AssetsTotal" (\obj -> ((GHC.Base.pure PostWalletResponseBody201AssetsTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostWalletResponseBody201AssetsTotal' with all required fields.
mkPostWalletResponseBody201AssetsTotal :: Data.Text.Internal.Text -- ^ 'postWalletResponseBody201AssetsTotalAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postWalletResponseBody201AssetsTotalPolicy_id'
  -> GHC.Types.Int -- ^ 'postWalletResponseBody201AssetsTotalQuantity'
  -> PostWalletResponseBody201AssetsTotal
mkPostWalletResponseBody201AssetsTotal postWalletResponseBody201AssetsTotalAsset_name postWalletResponseBody201AssetsTotalPolicy_id postWalletResponseBody201AssetsTotalQuantity = PostWalletResponseBody201AssetsTotal{postWalletResponseBody201AssetsTotalAsset_name = postWalletResponseBody201AssetsTotalAsset_name,
                                                                                                                                                                                                                        postWalletResponseBody201AssetsTotalPolicy_id = postWalletResponseBody201AssetsTotalPolicy_id,
                                                                                                                                                                                                                        postWalletResponseBody201AssetsTotalQuantity = postWalletResponseBody201AssetsTotalQuantity}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.balance@ in the specification.
-- 
-- Wallet current Ada balance(s).
data PostWalletResponseBody201Balance = PostWalletResponseBody201Balance {
  -- | available: Available Ada UTxO balance (funds that can be spent without condition).
  postWalletResponseBody201BalanceAvailable :: PostWalletResponseBody201BalanceAvailable
  -- | reward: The Ada balance of the reward account for this wallet.
  , postWalletResponseBody201BalanceReward :: PostWalletResponseBody201BalanceReward
  -- | total: Total Ada balance (available balance plus pending change and reward balance).
  , postWalletResponseBody201BalanceTotal :: PostWalletResponseBody201BalanceTotal
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201Balance
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= postWalletResponseBody201BalanceAvailable obj] : ["reward" Data.Aeson.Types.ToJSON..= postWalletResponseBody201BalanceReward obj] : ["total" Data.Aeson.Types.ToJSON..= postWalletResponseBody201BalanceTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= postWalletResponseBody201BalanceAvailable obj] : ["reward" Data.Aeson.Types.ToJSON..= postWalletResponseBody201BalanceReward obj] : ["total" Data.Aeson.Types.ToJSON..= postWalletResponseBody201BalanceTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201Balance
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201Balance" (\obj -> ((GHC.Base.pure PostWalletResponseBody201Balance GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'PostWalletResponseBody201Balance' with all required fields.
mkPostWalletResponseBody201Balance :: PostWalletResponseBody201BalanceAvailable -- ^ 'postWalletResponseBody201BalanceAvailable'
  -> PostWalletResponseBody201BalanceReward -- ^ 'postWalletResponseBody201BalanceReward'
  -> PostWalletResponseBody201BalanceTotal -- ^ 'postWalletResponseBody201BalanceTotal'
  -> PostWalletResponseBody201Balance
mkPostWalletResponseBody201Balance postWalletResponseBody201BalanceAvailable postWalletResponseBody201BalanceReward postWalletResponseBody201BalanceTotal = PostWalletResponseBody201Balance{postWalletResponseBody201BalanceAvailable = postWalletResponseBody201BalanceAvailable,
                                                                                                                                                                                             postWalletResponseBody201BalanceReward = postWalletResponseBody201BalanceReward,
                                                                                                                                                                                             postWalletResponseBody201BalanceTotal = postWalletResponseBody201BalanceTotal}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.balance.properties.available@ in the specification.
-- 
-- Available Ada UTxO balance (funds that can be spent without condition).
data PostWalletResponseBody201BalanceAvailable = PostWalletResponseBody201BalanceAvailable {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postWalletResponseBody201BalanceAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201BalanceAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postWalletResponseBody201BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postWalletResponseBody201BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201BalanceAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201BalanceAvailable" (\obj -> GHC.Base.pure PostWalletResponseBody201BalanceAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostWalletResponseBody201BalanceAvailable' with all required fields.
mkPostWalletResponseBody201BalanceAvailable :: GHC.Types.Int -- ^ 'postWalletResponseBody201BalanceAvailableQuantity'
  -> PostWalletResponseBody201BalanceAvailable
mkPostWalletResponseBody201BalanceAvailable postWalletResponseBody201BalanceAvailableQuantity = PostWalletResponseBody201BalanceAvailable{postWalletResponseBody201BalanceAvailableQuantity = postWalletResponseBody201BalanceAvailableQuantity}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.balance.properties.reward@ in the specification.
-- 
-- The Ada balance of the reward account for this wallet.
data PostWalletResponseBody201BalanceReward = PostWalletResponseBody201BalanceReward {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postWalletResponseBody201BalanceRewardQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201BalanceReward
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postWalletResponseBody201BalanceRewardQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postWalletResponseBody201BalanceRewardQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201BalanceReward
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201BalanceReward" (\obj -> GHC.Base.pure PostWalletResponseBody201BalanceReward GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostWalletResponseBody201BalanceReward' with all required fields.
mkPostWalletResponseBody201BalanceReward :: GHC.Types.Int -- ^ 'postWalletResponseBody201BalanceRewardQuantity'
  -> PostWalletResponseBody201BalanceReward
mkPostWalletResponseBody201BalanceReward postWalletResponseBody201BalanceRewardQuantity = PostWalletResponseBody201BalanceReward{postWalletResponseBody201BalanceRewardQuantity = postWalletResponseBody201BalanceRewardQuantity}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.balance.properties.total@ in the specification.
-- 
-- Total Ada balance (available balance plus pending change and reward balance).
data PostWalletResponseBody201BalanceTotal = PostWalletResponseBody201BalanceTotal {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postWalletResponseBody201BalanceTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201BalanceTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postWalletResponseBody201BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postWalletResponseBody201BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201BalanceTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201BalanceTotal" (\obj -> GHC.Base.pure PostWalletResponseBody201BalanceTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostWalletResponseBody201BalanceTotal' with all required fields.
mkPostWalletResponseBody201BalanceTotal :: GHC.Types.Int -- ^ 'postWalletResponseBody201BalanceTotalQuantity'
  -> PostWalletResponseBody201BalanceTotal
mkPostWalletResponseBody201BalanceTotal postWalletResponseBody201BalanceTotalQuantity = PostWalletResponseBody201BalanceTotal{postWalletResponseBody201BalanceTotalQuantity = postWalletResponseBody201BalanceTotalQuantity}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.delegation@ in the specification.
-- 
-- Delegation settings
data PostWalletResponseBody201Delegation = PostWalletResponseBody201Delegation {
  -- | active: Currently active delegation status.
  postWalletResponseBody201DelegationActive :: PostWalletResponseBody201DelegationActive
  -- | next
  , postWalletResponseBody201DelegationNext :: ([PostWalletResponseBody201DelegationNext])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201Delegation
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= postWalletResponseBody201DelegationActive obj] : ["next" Data.Aeson.Types.ToJSON..= postWalletResponseBody201DelegationNext obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= postWalletResponseBody201DelegationActive obj] : ["next" Data.Aeson.Types.ToJSON..= postWalletResponseBody201DelegationNext obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201Delegation
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201Delegation" (\obj -> (GHC.Base.pure PostWalletResponseBody201Delegation GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "next"))
-- | Create a new 'PostWalletResponseBody201Delegation' with all required fields.
mkPostWalletResponseBody201Delegation :: PostWalletResponseBody201DelegationActive -- ^ 'postWalletResponseBody201DelegationActive'
  -> [PostWalletResponseBody201DelegationNext] -- ^ 'postWalletResponseBody201DelegationNext'
  -> PostWalletResponseBody201Delegation
mkPostWalletResponseBody201Delegation postWalletResponseBody201DelegationActive postWalletResponseBody201DelegationNext = PostWalletResponseBody201Delegation{postWalletResponseBody201DelegationActive = postWalletResponseBody201DelegationActive,
                                                                                                                                                              postWalletResponseBody201DelegationNext = postWalletResponseBody201DelegationNext}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.delegation.properties.active@ in the specification.
-- 
-- Currently active delegation status.
data PostWalletResponseBody201DelegationActive = PostWalletResponseBody201DelegationActive {
  -- | status
  postWalletResponseBody201DelegationActiveStatus :: PostWalletResponseBody201DelegationActiveStatus
  -- | target: A unique Stake-Pool identifier (present only if status = \`delegating\`)
  , postWalletResponseBody201DelegationActiveTarget :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201DelegationActive
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["status" Data.Aeson.Types.ToJSON..= postWalletResponseBody201DelegationActiveStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (postWalletResponseBody201DelegationActiveTarget obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["status" Data.Aeson.Types.ToJSON..= postWalletResponseBody201DelegationActiveStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (postWalletResponseBody201DelegationActiveTarget obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201DelegationActive
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201DelegationActive" (\obj -> (GHC.Base.pure PostWalletResponseBody201DelegationActive GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "target"))
-- | Create a new 'PostWalletResponseBody201DelegationActive' with all required fields.
mkPostWalletResponseBody201DelegationActive :: PostWalletResponseBody201DelegationActiveStatus -- ^ 'postWalletResponseBody201DelegationActiveStatus'
  -> PostWalletResponseBody201DelegationActive
mkPostWalletResponseBody201DelegationActive postWalletResponseBody201DelegationActiveStatus = PostWalletResponseBody201DelegationActive{postWalletResponseBody201DelegationActiveStatus = postWalletResponseBody201DelegationActiveStatus,
                                                                                                                                        postWalletResponseBody201DelegationActiveTarget = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.delegation.properties.active.properties.status@ in the specification.
-- 
-- 
data PostWalletResponseBody201DelegationActiveStatus =
   PostWalletResponseBody201DelegationActiveStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostWalletResponseBody201DelegationActiveStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostWalletResponseBody201DelegationActiveStatusEnumNot_delegating -- ^ Represents the JSON value @"not_delegating"@
  | PostWalletResponseBody201DelegationActiveStatusEnumDelegating -- ^ Represents the JSON value @"delegating"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201DelegationActiveStatus
    where toJSON (PostWalletResponseBody201DelegationActiveStatusOther val) = val
          toJSON (PostWalletResponseBody201DelegationActiveStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostWalletResponseBody201DelegationActiveStatusEnumNot_delegating) = "not_delegating"
          toJSON (PostWalletResponseBody201DelegationActiveStatusEnumDelegating) = "delegating"
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201DelegationActiveStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "not_delegating" -> PostWalletResponseBody201DelegationActiveStatusEnumNot_delegating
                                            | val GHC.Classes.== "delegating" -> PostWalletResponseBody201DelegationActiveStatusEnumDelegating
                                            | GHC.Base.otherwise -> PostWalletResponseBody201DelegationActiveStatusOther val)
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.delegation.properties.next.items@ in the specification.
-- 
-- Next delegation status becomes active at the start of the second epoch after the corresponding delegation certificate was discovered. The exact moment is specified by changes_at
data PostWalletResponseBody201DelegationNext = PostWalletResponseBody201DelegationNext {
  -- | changes_at
  postWalletResponseBody201DelegationNextChanges_at :: PostWalletResponseBody201DelegationNextChanges_at
  -- | status
  , postWalletResponseBody201DelegationNextStatus :: PostWalletResponseBody201DelegationNextStatus
  -- | target: A unique Stake-Pool identifier (present only if status = \`delegating\`)
  , postWalletResponseBody201DelegationNextTarget :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201DelegationNext
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["changes_at" Data.Aeson.Types.ToJSON..= postWalletResponseBody201DelegationNextChanges_at obj] : ["status" Data.Aeson.Types.ToJSON..= postWalletResponseBody201DelegationNextStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (postWalletResponseBody201DelegationNextTarget obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["changes_at" Data.Aeson.Types.ToJSON..= postWalletResponseBody201DelegationNextChanges_at obj] : ["status" Data.Aeson.Types.ToJSON..= postWalletResponseBody201DelegationNextStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (postWalletResponseBody201DelegationNextTarget obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201DelegationNext
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201DelegationNext" (\obj -> ((GHC.Base.pure PostWalletResponseBody201DelegationNext GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "changes_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "target"))
-- | Create a new 'PostWalletResponseBody201DelegationNext' with all required fields.
mkPostWalletResponseBody201DelegationNext :: PostWalletResponseBody201DelegationNextChanges_at -- ^ 'postWalletResponseBody201DelegationNextChanges_at'
  -> PostWalletResponseBody201DelegationNextStatus -- ^ 'postWalletResponseBody201DelegationNextStatus'
  -> PostWalletResponseBody201DelegationNext
mkPostWalletResponseBody201DelegationNext postWalletResponseBody201DelegationNextChanges_at postWalletResponseBody201DelegationNextStatus = PostWalletResponseBody201DelegationNext{postWalletResponseBody201DelegationNextChanges_at = postWalletResponseBody201DelegationNextChanges_at,
                                                                                                                                                                                    postWalletResponseBody201DelegationNextStatus = postWalletResponseBody201DelegationNextStatus,
                                                                                                                                                                                    postWalletResponseBody201DelegationNextTarget = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.delegation.properties.next.items.properties.changes_at@ in the specification.
-- 
-- 
data PostWalletResponseBody201DelegationNextChanges_at = PostWalletResponseBody201DelegationNextChanges_at {
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postWalletResponseBody201DelegationNextChanges_atEpoch_number :: GHC.Types.Int
  -- | epoch_start_time
  , postWalletResponseBody201DelegationNextChanges_atEpoch_start_time :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201DelegationNextChanges_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["epoch_number" Data.Aeson.Types.ToJSON..= postWalletResponseBody201DelegationNextChanges_atEpoch_number obj] : ["epoch_start_time" Data.Aeson.Types.ToJSON..= postWalletResponseBody201DelegationNextChanges_atEpoch_start_time obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["epoch_number" Data.Aeson.Types.ToJSON..= postWalletResponseBody201DelegationNextChanges_atEpoch_number obj] : ["epoch_start_time" Data.Aeson.Types.ToJSON..= postWalletResponseBody201DelegationNextChanges_atEpoch_start_time obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201DelegationNextChanges_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201DelegationNextChanges_at" (\obj -> (GHC.Base.pure PostWalletResponseBody201DelegationNextChanges_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_start_time"))
-- | Create a new 'PostWalletResponseBody201DelegationNextChanges_at' with all required fields.
mkPostWalletResponseBody201DelegationNextChanges_at :: GHC.Types.Int -- ^ 'postWalletResponseBody201DelegationNextChanges_atEpoch_number'
  -> Data.Text.Internal.Text -- ^ 'postWalletResponseBody201DelegationNextChanges_atEpoch_start_time'
  -> PostWalletResponseBody201DelegationNextChanges_at
mkPostWalletResponseBody201DelegationNextChanges_at postWalletResponseBody201DelegationNextChanges_atEpoch_number postWalletResponseBody201DelegationNextChanges_atEpoch_start_time = PostWalletResponseBody201DelegationNextChanges_at{postWalletResponseBody201DelegationNextChanges_atEpoch_number = postWalletResponseBody201DelegationNextChanges_atEpoch_number,
                                                                                                                                                                                                                                        postWalletResponseBody201DelegationNextChanges_atEpoch_start_time = postWalletResponseBody201DelegationNextChanges_atEpoch_start_time}
-- | Defines the enum schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.delegation.properties.next.items.properties.status@ in the specification.
-- 
-- 
data PostWalletResponseBody201DelegationNextStatus =
   PostWalletResponseBody201DelegationNextStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostWalletResponseBody201DelegationNextStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostWalletResponseBody201DelegationNextStatusEnumNot_delegating -- ^ Represents the JSON value @"not_delegating"@
  | PostWalletResponseBody201DelegationNextStatusEnumDelegating -- ^ Represents the JSON value @"delegating"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201DelegationNextStatus
    where toJSON (PostWalletResponseBody201DelegationNextStatusOther val) = val
          toJSON (PostWalletResponseBody201DelegationNextStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostWalletResponseBody201DelegationNextStatusEnumNot_delegating) = "not_delegating"
          toJSON (PostWalletResponseBody201DelegationNextStatusEnumDelegating) = "delegating"
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201DelegationNextStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "not_delegating" -> PostWalletResponseBody201DelegationNextStatusEnumNot_delegating
                                            | val GHC.Classes.== "delegating" -> PostWalletResponseBody201DelegationNextStatusEnumDelegating
                                            | GHC.Base.otherwise -> PostWalletResponseBody201DelegationNextStatusOther val)
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.passphrase@ in the specification.
-- 
-- Information about the wallet\'s passphrase
data PostWalletResponseBody201Passphrase = PostWalletResponseBody201Passphrase {
  -- | last_updated_at
  postWalletResponseBody201PassphraseLast_updated_at :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201Passphrase
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= postWalletResponseBody201PassphraseLast_updated_at obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= postWalletResponseBody201PassphraseLast_updated_at obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201Passphrase
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201Passphrase" (\obj -> GHC.Base.pure PostWalletResponseBody201Passphrase GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "last_updated_at"))
-- | Create a new 'PostWalletResponseBody201Passphrase' with all required fields.
mkPostWalletResponseBody201Passphrase :: Data.Text.Internal.Text -- ^ 'postWalletResponseBody201PassphraseLast_updated_at'
  -> PostWalletResponseBody201Passphrase
mkPostWalletResponseBody201Passphrase postWalletResponseBody201PassphraseLast_updated_at = PostWalletResponseBody201Passphrase{postWalletResponseBody201PassphraseLast_updated_at = postWalletResponseBody201PassphraseLast_updated_at}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.state@ in the specification.
-- 
-- Whether a wallet is ready to use or still syncing
data PostWalletResponseBody201State = PostWalletResponseBody201State {
  -- | progress: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == syncing
  -- \<\/span>\<br\/>
  postWalletResponseBody201StateProgress :: (GHC.Maybe.Maybe PostWalletResponseBody201StateProgress)
  -- | status
  , postWalletResponseBody201StateStatus :: PostWalletResponseBody201StateStatus
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201State
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (postWalletResponseBody201StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= postWalletResponseBody201StateStatus obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (postWalletResponseBody201StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= postWalletResponseBody201StateStatus obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201State
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201State" (\obj -> (GHC.Base.pure PostWalletResponseBody201State GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "progress")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status"))
-- | Create a new 'PostWalletResponseBody201State' with all required fields.
mkPostWalletResponseBody201State :: PostWalletResponseBody201StateStatus -- ^ 'postWalletResponseBody201StateStatus'
  -> PostWalletResponseBody201State
mkPostWalletResponseBody201State postWalletResponseBody201StateStatus = PostWalletResponseBody201State{postWalletResponseBody201StateProgress = GHC.Maybe.Nothing,
                                                                                                       postWalletResponseBody201StateStatus = postWalletResponseBody201StateStatus}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.state.properties.progress@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == syncing
-- \<\/span>\<br\/>
data PostWalletResponseBody201StateProgress = PostWalletResponseBody201StateProgress {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  postWalletResponseBody201StateProgressQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201StateProgress
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postWalletResponseBody201StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postWalletResponseBody201StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201StateProgress
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201StateProgress" (\obj -> GHC.Base.pure PostWalletResponseBody201StateProgress GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostWalletResponseBody201StateProgress' with all required fields.
mkPostWalletResponseBody201StateProgress :: GHC.Types.Double -- ^ 'postWalletResponseBody201StateProgressQuantity'
  -> PostWalletResponseBody201StateProgress
mkPostWalletResponseBody201StateProgress postWalletResponseBody201StateProgressQuantity = PostWalletResponseBody201StateProgress{postWalletResponseBody201StateProgressQuantity = postWalletResponseBody201StateProgressQuantity}
-- | Defines the enum schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.state.properties.status@ in the specification.
-- 
-- 
data PostWalletResponseBody201StateStatus =
   PostWalletResponseBody201StateStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostWalletResponseBody201StateStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostWalletResponseBody201StateStatusEnumReady -- ^ Represents the JSON value @"ready"@
  | PostWalletResponseBody201StateStatusEnumSyncing -- ^ Represents the JSON value @"syncing"@
  | PostWalletResponseBody201StateStatusEnumNot_responding -- ^ Represents the JSON value @"not_responding"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201StateStatus
    where toJSON (PostWalletResponseBody201StateStatusOther val) = val
          toJSON (PostWalletResponseBody201StateStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostWalletResponseBody201StateStatusEnumReady) = "ready"
          toJSON (PostWalletResponseBody201StateStatusEnumSyncing) = "syncing"
          toJSON (PostWalletResponseBody201StateStatusEnumNot_responding) = "not_responding"
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201StateStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "ready" -> PostWalletResponseBody201StateStatusEnumReady
                                            | val GHC.Classes.== "syncing" -> PostWalletResponseBody201StateStatusEnumSyncing
                                            | val GHC.Classes.== "not_responding" -> PostWalletResponseBody201StateStatusEnumNot_responding
                                            | GHC.Base.otherwise -> PostWalletResponseBody201StateStatusOther val)
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.tip@ in the specification.
-- 
-- A reference to a particular time slot, and the block height at that point.
data PostWalletResponseBody201Tip = PostWalletResponseBody201Tip {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postWalletResponseBody201TipAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postWalletResponseBody201TipEpoch_number :: GHC.Types.Int
  -- | height
  , postWalletResponseBody201TipHeight :: PostWalletResponseBody201TipHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postWalletResponseBody201TipSlot_number :: GHC.Types.Int
  -- | time
  , postWalletResponseBody201TipTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201Tip
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postWalletResponseBody201TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postWalletResponseBody201TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= postWalletResponseBody201TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postWalletResponseBody201TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postWalletResponseBody201TipTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postWalletResponseBody201TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postWalletResponseBody201TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= postWalletResponseBody201TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postWalletResponseBody201TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postWalletResponseBody201TipTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201Tip
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201Tip" (\obj -> ((((GHC.Base.pure PostWalletResponseBody201Tip GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'PostWalletResponseBody201Tip' with all required fields.
mkPostWalletResponseBody201Tip :: GHC.Types.Int -- ^ 'postWalletResponseBody201TipAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'postWalletResponseBody201TipEpoch_number'
  -> PostWalletResponseBody201TipHeight -- ^ 'postWalletResponseBody201TipHeight'
  -> GHC.Types.Int -- ^ 'postWalletResponseBody201TipSlot_number'
  -> Data.Text.Internal.Text -- ^ 'postWalletResponseBody201TipTime'
  -> PostWalletResponseBody201Tip
mkPostWalletResponseBody201Tip postWalletResponseBody201TipAbsolute_slot_number postWalletResponseBody201TipEpoch_number postWalletResponseBody201TipHeight postWalletResponseBody201TipSlot_number postWalletResponseBody201TipTime = PostWalletResponseBody201Tip{postWalletResponseBody201TipAbsolute_slot_number = postWalletResponseBody201TipAbsolute_slot_number,
                                                                                                                                                                                                                                                                    postWalletResponseBody201TipEpoch_number = postWalletResponseBody201TipEpoch_number,
                                                                                                                                                                                                                                                                    postWalletResponseBody201TipHeight = postWalletResponseBody201TipHeight,
                                                                                                                                                                                                                                                                    postWalletResponseBody201TipSlot_number = postWalletResponseBody201TipSlot_number,
                                                                                                                                                                                                                                                                    postWalletResponseBody201TipTime = postWalletResponseBody201TipTime}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.201.content.application\/json.schema.properties.tip.properties.height@ in the specification.
-- 
-- 
data PostWalletResponseBody201TipHeight = PostWalletResponseBody201TipHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postWalletResponseBody201TipHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody201TipHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postWalletResponseBody201TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postWalletResponseBody201TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody201TipHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody201TipHeight" (\obj -> GHC.Base.pure PostWalletResponseBody201TipHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostWalletResponseBody201TipHeight' with all required fields.
mkPostWalletResponseBody201TipHeight :: GHC.Types.Int -- ^ 'postWalletResponseBody201TipHeightQuantity'
  -> PostWalletResponseBody201TipHeight
mkPostWalletResponseBody201TipHeight postWalletResponseBody201TipHeightQuantity = PostWalletResponseBody201TipHeight{postWalletResponseBody201TipHeightQuantity = postWalletResponseBody201TipHeightQuantity}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data PostWalletResponseBody400 = PostWalletResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  postWalletResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postWalletResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postWalletResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody400" (\obj -> GHC.Base.pure PostWalletResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostWalletResponseBody400' with all required fields.
mkPostWalletResponseBody400 :: Data.Text.Internal.Text -- ^ 'postWalletResponseBody400Message'
  -> PostWalletResponseBody400
mkPostWalletResponseBody400 postWalletResponseBody400Message = PostWalletResponseBody400{postWalletResponseBody400Message = postWalletResponseBody400Message}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data PostWalletResponseBody406 = PostWalletResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  postWalletResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody406" (\obj -> GHC.Base.pure PostWalletResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostWalletResponseBody406' with all required fields.
mkPostWalletResponseBody406 :: Data.Text.Internal.Text -- ^ 'postWalletResponseBody406Message'
  -> PostWalletResponseBody406
mkPostWalletResponseBody406 postWalletResponseBody406Message = PostWalletResponseBody406{postWalletResponseBody406Message = postWalletResponseBody406Message}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.409.content.application\/json.schema@ in the specification.
-- 
-- 
data PostWalletResponseBody409 = PostWalletResponseBody409 {
  -- | message: May occur when a otherwise valid request would yield a wallet that already exists.
  postWalletResponseBody409Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody409
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postWalletResponseBody409Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wallet_already_exists"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postWalletResponseBody409Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wallet_already_exists"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody409
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody409" (\obj -> GHC.Base.pure PostWalletResponseBody409 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostWalletResponseBody409' with all required fields.
mkPostWalletResponseBody409 :: Data.Text.Internal.Text -- ^ 'postWalletResponseBody409Message'
  -> PostWalletResponseBody409
mkPostWalletResponseBody409 postWalletResponseBody409Message = PostWalletResponseBody409{postWalletResponseBody409Message = postWalletResponseBody409Message}
-- | Defines the object schema located at @paths.\/wallets.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data PostWalletResponseBody415 = PostWalletResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  postWalletResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostWalletResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postWalletResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postWalletResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostWalletResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostWalletResponseBody415" (\obj -> GHC.Base.pure PostWalletResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostWalletResponseBody415' with all required fields.
mkPostWalletResponseBody415 :: Data.Text.Internal.Text -- ^ 'postWalletResponseBody415Message'
  -> PostWalletResponseBody415
mkPostWalletResponseBody415 postWalletResponseBody415Message = PostWalletResponseBody415{postWalletResponseBody415Message = postWalletResponseBody415Message}
-- | > POST /wallets
-- 
-- The same as 'postWallet' but accepts an explicit configuration.
postWalletWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> PostWalletRequestBodyVariants -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response PostWalletResponse) -- ^ Monadic computation which returns the result of the operation
postWalletWithConfiguration config
                            body = GHC.Base.fmap (\response_6 -> GHC.Base.fmap (Data.Either.either PostWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 201) (Network.HTTP.Client.Types.responseStatus response) -> PostWalletResponse201 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                  PostWalletResponseBody201)
                                                                                                                                                                        | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostWalletResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                  PostWalletResponseBody400)
                                                                                                                                                                        | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                  PostWalletResponseBody406)
                                                                                                                                                                        | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 409) (Network.HTTP.Client.Types.responseStatus response) -> PostWalletResponse409 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                    PostWalletResponseBody409)
                                                                                                                                                                        | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostWalletResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                    PostWalletResponseBody415)
                                                                                                                                                                        | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_6) response_6) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") "/wallets" GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets
-- 
-- The same as 'postWallet' but returns the raw 'Data.ByteString.ByteString'.
postWalletRaw :: forall m . Wallet.Common.MonadHTTP m => PostWalletRequestBodyVariants -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postWalletRaw body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") "/wallets" GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets
-- 
-- The same as 'postWallet' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
postWalletWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> PostWalletRequestBodyVariants -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postWalletWithConfigurationRaw config
                               body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") "/wallets" GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
