-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation getByronAsset
module Wallet.Operations.GetByronAsset where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > GET /byron-wallets/{walletId}/assets/{policyId}/{assetName}
-- 
-- Fetch a single asset from its \`policy_id\` and \`asset_name\`,
-- with its metadata if any.
-- 
-- The asset must be associated with the wallet.
getByronAsset :: forall m . Wallet.Common.MonadHTTP m => GetByronAssetParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response GetByronAssetResponse) -- ^ Monadic computation which returns the result of the operation
getByronAsset parameters = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either GetByronAssetResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetByronAssetResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                GetByronAssetResponseBody200)
                                                                                                                                                                   | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> GetByronAssetResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                GetByronAssetResponseBody404)
                                                                                                                                                                   | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> GetByronAssetResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                GetByronAssetResponseBody406)
                                                                                                                                                                   | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronAssetParametersPathWalletId parameters))) GHC.Base.<> ("/assets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronAssetParametersPathPolicyId parameters))) GHC.Base.<> ("/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronAssetParametersPathAssetName parameters))) GHC.Base.<> "")))))) GHC.Base.mempty)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/assets\/{policyId}\/{assetName}.GET.parameters@ in the specification.
-- 
-- 
data GetByronAssetParameters = GetByronAssetParameters {
  -- | pathAssetName: Represents the parameter named \'assetName\'
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getByronAssetParametersPathAssetName :: Data.Text.Internal.Text
  -- | pathPolicyId: Represents the parameter named \'policyId\'
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getByronAssetParametersPathPolicyId :: Data.Text.Internal.Text
  -- | pathWalletId: Represents the parameter named \'walletId\'
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  , getByronAssetParametersPathWalletId :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronAssetParameters
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pathAssetName" Data.Aeson.Types.ToJSON..= getByronAssetParametersPathAssetName obj] : ["pathPolicyId" Data.Aeson.Types.ToJSON..= getByronAssetParametersPathPolicyId obj] : ["pathWalletId" Data.Aeson.Types.ToJSON..= getByronAssetParametersPathWalletId obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pathAssetName" Data.Aeson.Types.ToJSON..= getByronAssetParametersPathAssetName obj] : ["pathPolicyId" Data.Aeson.Types.ToJSON..= getByronAssetParametersPathPolicyId obj] : ["pathWalletId" Data.Aeson.Types.ToJSON..= getByronAssetParametersPathWalletId obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronAssetParameters
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronAssetParameters" (\obj -> ((GHC.Base.pure GetByronAssetParameters GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pathAssetName")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pathPolicyId")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pathWalletId"))
-- | Create a new 'GetByronAssetParameters' with all required fields.
mkGetByronAssetParameters :: Data.Text.Internal.Text -- ^ 'getByronAssetParametersPathAssetName'
  -> Data.Text.Internal.Text -- ^ 'getByronAssetParametersPathPolicyId'
  -> Data.Text.Internal.Text -- ^ 'getByronAssetParametersPathWalletId'
  -> GetByronAssetParameters
mkGetByronAssetParameters getByronAssetParametersPathAssetName getByronAssetParametersPathPolicyId getByronAssetParametersPathWalletId = GetByronAssetParameters{getByronAssetParametersPathAssetName = getByronAssetParametersPathAssetName,
                                                                                                                                                                 getByronAssetParametersPathPolicyId = getByronAssetParametersPathPolicyId,
                                                                                                                                                                 getByronAssetParametersPathWalletId = getByronAssetParametersPathWalletId}
-- | Represents a response of the operation 'getByronAsset'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'GetByronAssetResponseError' is used.
data GetByronAssetResponse =
   GetByronAssetResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | GetByronAssetResponse200 GetByronAssetResponseBody200 -- ^ Ok
  | GetByronAssetResponse404 GetByronAssetResponseBody404 -- ^ Not Found
  | GetByronAssetResponse406 GetByronAssetResponseBody406 -- ^ Not Acceptable
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/assets\/{policyId}\/{assetName}.GET.responses.200.content.application\/json.schema@ in the specification.
-- 
-- 
data GetByronAssetResponseBody200 = GetByronAssetResponseBody200 {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getByronAssetResponseBody200Asset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , getByronAssetResponseBody200Fingerprint :: Data.Text.Internal.Text
  -- | metadata: In the Mary era of Cardano, UTxO may contain native assets. These
  -- assets are represented on-chain by opaque identifiers which are
  -- meaningless to end-users. Therefore, user-facing metadata
  -- regarding each token must be stored off-chain, in a metadata
  -- registry.
  -- 
  -- Token creators may publish metadata into the registry and client
  -- applications can consume these metadata for display to end
  -- users. This will work in a similar way to how it is done for stake
  -- pool metadata.
  , getByronAssetResponseBody200Metadata :: (GHC.Maybe.Maybe GetByronAssetResponseBody200Metadata)
  -- | metadata_error: If there was an error fetching metadata from the server,
  -- this will be set to one of \`fetch\` or \`parse\`, to indicate
  -- the kind of error.
  , getByronAssetResponseBody200Metadata_error :: (GHC.Maybe.Maybe GetByronAssetResponseBody200Metadata_error)
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getByronAssetResponseBody200Policy_id :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronAssetResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronAssetResponseBody200Asset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= getByronAssetResponseBody200Fingerprint obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (getByronAssetResponseBody200Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata_error" Data.Aeson.Types.ToJSON..=)) (getByronAssetResponseBody200Metadata_error obj) : ["policy_id" Data.Aeson.Types.ToJSON..= getByronAssetResponseBody200Policy_id obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronAssetResponseBody200Asset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= getByronAssetResponseBody200Fingerprint obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (getByronAssetResponseBody200Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata_error" Data.Aeson.Types.ToJSON..=)) (getByronAssetResponseBody200Metadata_error obj) : ["policy_id" Data.Aeson.Types.ToJSON..= getByronAssetResponseBody200Policy_id obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronAssetResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronAssetResponseBody200" (\obj -> ((((GHC.Base.pure GetByronAssetResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata_error")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id"))
-- | Create a new 'GetByronAssetResponseBody200' with all required fields.
mkGetByronAssetResponseBody200 :: Data.Text.Internal.Text -- ^ 'getByronAssetResponseBody200Asset_name'
  -> Data.Text.Internal.Text -- ^ 'getByronAssetResponseBody200Fingerprint'
  -> Data.Text.Internal.Text -- ^ 'getByronAssetResponseBody200Policy_id'
  -> GetByronAssetResponseBody200
mkGetByronAssetResponseBody200 getByronAssetResponseBody200Asset_name getByronAssetResponseBody200Fingerprint getByronAssetResponseBody200Policy_id = GetByronAssetResponseBody200{getByronAssetResponseBody200Asset_name = getByronAssetResponseBody200Asset_name,
                                                                                                                                                                                   getByronAssetResponseBody200Fingerprint = getByronAssetResponseBody200Fingerprint,
                                                                                                                                                                                   getByronAssetResponseBody200Metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                   getByronAssetResponseBody200Metadata_error = GHC.Maybe.Nothing,
                                                                                                                                                                                   getByronAssetResponseBody200Policy_id = getByronAssetResponseBody200Policy_id}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/assets\/{policyId}\/{assetName}.GET.responses.200.content.application\/json.schema.properties.metadata@ in the specification.
-- 
-- In the Mary era of Cardano, UTxO may contain native assets. These
-- assets are represented on-chain by opaque identifiers which are
-- meaningless to end-users. Therefore, user-facing metadata
-- regarding each token must be stored off-chain, in a metadata
-- registry.
-- 
-- Token creators may publish metadata into the registry and client
-- applications can consume these metadata for display to end
-- users. This will work in a similar way to how it is done for stake
-- pool metadata.
data GetByronAssetResponseBody200Metadata = GetByronAssetResponseBody200Metadata {
  -- | decimals: Defines a scaling factor for the asset of 10\<sup>-n\<\/sup>. The
  -- decimals value _n_ is therefore the number of digits after the
  -- decimal point for quantities of this token.
  -- 
  -- It is up to API clients to use this metadata field to decimalize
  -- asset quantities before displaying to users. The wallet backend
  -- will always return unscaled token quantities as whole numbers.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 0.0
  getByronAssetResponseBody200MetadataDecimals :: (GHC.Maybe.Maybe GHC.Types.Int)
  -- | description: A human-readable description for the asset. Good for display in
  -- user interfaces.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 500
  , getByronAssetResponseBody200MetadataDescription :: Data.Text.Internal.Text
  -- | logo: A base64-encoded \`image\/png\` for displaying the asset. The end image can be expected
  -- to be smaller than 64KB.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 87400
  , getByronAssetResponseBody200MetadataLogo :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | name: A human-readable name for the asset, intended for display in user
  -- interfaces.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 50
  -- * Minimum length of 1
  , getByronAssetResponseBody200MetadataName :: Data.Text.Internal.Text
  -- | ticker: An optional human-readable very short name or acronym for the
  -- asset, intended for display in user interfaces. If \`ticker\` is not
  -- present, then \`name\` will be used, but it might be truncated to
  -- fit within the available space.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 5
  -- * Minimum length of 2
  , getByronAssetResponseBody200MetadataTicker :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | url: A URL to the policy\'s owner(s) or the entity website in charge of the asset.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 250
  -- * Must match pattern \'^https:\/\/.+\'
  , getByronAssetResponseBody200MetadataUrl :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronAssetResponseBody200Metadata
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("decimals" Data.Aeson.Types.ToJSON..=)) (getByronAssetResponseBody200MetadataDecimals obj) : ["description" Data.Aeson.Types.ToJSON..= getByronAssetResponseBody200MetadataDescription obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("logo" Data.Aeson.Types.ToJSON..=)) (getByronAssetResponseBody200MetadataLogo obj) : ["name" Data.Aeson.Types.ToJSON..= getByronAssetResponseBody200MetadataName obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("ticker" Data.Aeson.Types.ToJSON..=)) (getByronAssetResponseBody200MetadataTicker obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("url" Data.Aeson.Types.ToJSON..=)) (getByronAssetResponseBody200MetadataUrl obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("decimals" Data.Aeson.Types.ToJSON..=)) (getByronAssetResponseBody200MetadataDecimals obj) : ["description" Data.Aeson.Types.ToJSON..= getByronAssetResponseBody200MetadataDescription obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("logo" Data.Aeson.Types.ToJSON..=)) (getByronAssetResponseBody200MetadataLogo obj) : ["name" Data.Aeson.Types.ToJSON..= getByronAssetResponseBody200MetadataName obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("ticker" Data.Aeson.Types.ToJSON..=)) (getByronAssetResponseBody200MetadataTicker obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("url" Data.Aeson.Types.ToJSON..=)) (getByronAssetResponseBody200MetadataUrl obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronAssetResponseBody200Metadata
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronAssetResponseBody200Metadata" (\obj -> (((((GHC.Base.pure GetByronAssetResponseBody200Metadata GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "decimals")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "description")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "logo")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "ticker")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "url"))
-- | Create a new 'GetByronAssetResponseBody200Metadata' with all required fields.
mkGetByronAssetResponseBody200Metadata :: Data.Text.Internal.Text -- ^ 'getByronAssetResponseBody200MetadataDescription'
  -> Data.Text.Internal.Text -- ^ 'getByronAssetResponseBody200MetadataName'
  -> GetByronAssetResponseBody200Metadata
mkGetByronAssetResponseBody200Metadata getByronAssetResponseBody200MetadataDescription getByronAssetResponseBody200MetadataName = GetByronAssetResponseBody200Metadata{getByronAssetResponseBody200MetadataDecimals = GHC.Maybe.Nothing,
                                                                                                                                                                       getByronAssetResponseBody200MetadataDescription = getByronAssetResponseBody200MetadataDescription,
                                                                                                                                                                       getByronAssetResponseBody200MetadataLogo = GHC.Maybe.Nothing,
                                                                                                                                                                       getByronAssetResponseBody200MetadataName = getByronAssetResponseBody200MetadataName,
                                                                                                                                                                       getByronAssetResponseBody200MetadataTicker = GHC.Maybe.Nothing,
                                                                                                                                                                       getByronAssetResponseBody200MetadataUrl = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/assets\/{policyId}\/{assetName}.GET.responses.200.content.application\/json.schema.properties.metadata_error@ in the specification.
-- 
-- If there was an error fetching metadata from the server,
-- this will be set to one of \`fetch\` or \`parse\`, to indicate
-- the kind of error.
data GetByronAssetResponseBody200Metadata_error =
   GetByronAssetResponseBody200Metadata_errorOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetByronAssetResponseBody200Metadata_errorTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetByronAssetResponseBody200Metadata_errorEnumFetch -- ^ Represents the JSON value @"fetch"@
  | GetByronAssetResponseBody200Metadata_errorEnumParse -- ^ Represents the JSON value @"parse"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronAssetResponseBody200Metadata_error
    where toJSON (GetByronAssetResponseBody200Metadata_errorOther val) = val
          toJSON (GetByronAssetResponseBody200Metadata_errorTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetByronAssetResponseBody200Metadata_errorEnumFetch) = "fetch"
          toJSON (GetByronAssetResponseBody200Metadata_errorEnumParse) = "parse"
instance Data.Aeson.Types.FromJSON.FromJSON GetByronAssetResponseBody200Metadata_error
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "fetch" -> GetByronAssetResponseBody200Metadata_errorEnumFetch
                                            | val GHC.Classes.== "parse" -> GetByronAssetResponseBody200Metadata_errorEnumParse
                                            | GHC.Base.otherwise -> GetByronAssetResponseBody200Metadata_errorOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/assets\/{policyId}\/{assetName}.GET.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data GetByronAssetResponseBody404 = GetByronAssetResponseBody404 {
  -- | message: Occurs when requesting information about an asset which is not
  -- involved in any transaction related to the wallet.
  getByronAssetResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronAssetResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronAssetResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "asset_not_present"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronAssetResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "asset_not_present"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronAssetResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronAssetResponseBody404" (\obj -> GHC.Base.pure GetByronAssetResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetByronAssetResponseBody404' with all required fields.
mkGetByronAssetResponseBody404 :: Data.Text.Internal.Text -- ^ 'getByronAssetResponseBody404Message'
  -> GetByronAssetResponseBody404
mkGetByronAssetResponseBody404 getByronAssetResponseBody404Message = GetByronAssetResponseBody404{getByronAssetResponseBody404Message = getByronAssetResponseBody404Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/assets\/{policyId}\/{assetName}.GET.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data GetByronAssetResponseBody406 = GetByronAssetResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  getByronAssetResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronAssetResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronAssetResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronAssetResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronAssetResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronAssetResponseBody406" (\obj -> GHC.Base.pure GetByronAssetResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetByronAssetResponseBody406' with all required fields.
mkGetByronAssetResponseBody406 :: Data.Text.Internal.Text -- ^ 'getByronAssetResponseBody406Message'
  -> GetByronAssetResponseBody406
mkGetByronAssetResponseBody406 getByronAssetResponseBody406Message = GetByronAssetResponseBody406{getByronAssetResponseBody406Message = getByronAssetResponseBody406Message}
-- | > GET /byron-wallets/{walletId}/assets/{policyId}/{assetName}
-- 
-- The same as 'getByronAsset' but accepts an explicit configuration.
getByronAssetWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> GetByronAssetParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response GetByronAssetResponse) -- ^ Monadic computation which returns the result of the operation
getByronAssetWithConfiguration config
                               parameters = GHC.Base.fmap (\response_4 -> GHC.Base.fmap (Data.Either.either GetByronAssetResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetByronAssetResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                 GetByronAssetResponseBody200)
                                                                                                                                                                                    | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> GetByronAssetResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                 GetByronAssetResponseBody404)
                                                                                                                                                                                    | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> GetByronAssetResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                 GetByronAssetResponseBody406)
                                                                                                                                                                                    | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_4) response_4) (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronAssetParametersPathWalletId parameters))) GHC.Base.<> ("/assets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronAssetParametersPathPolicyId parameters))) GHC.Base.<> ("/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronAssetParametersPathAssetName parameters))) GHC.Base.<> "")))))) GHC.Base.mempty)
-- | > GET /byron-wallets/{walletId}/assets/{policyId}/{assetName}
-- 
-- The same as 'getByronAsset' but returns the raw 'Data.ByteString.ByteString'.
getByronAssetRaw :: forall m . Wallet.Common.MonadHTTP m => GetByronAssetParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
getByronAssetRaw parameters = GHC.Base.id (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronAssetParametersPathWalletId parameters))) GHC.Base.<> ("/assets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronAssetParametersPathPolicyId parameters))) GHC.Base.<> ("/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronAssetParametersPathAssetName parameters))) GHC.Base.<> "")))))) GHC.Base.mempty)
-- | > GET /byron-wallets/{walletId}/assets/{policyId}/{assetName}
-- 
-- The same as 'getByronAsset' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
getByronAssetWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> GetByronAssetParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
getByronAssetWithConfigurationRaw config
                                  parameters = GHC.Base.id (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronAssetParametersPathWalletId parameters))) GHC.Base.<> ("/assets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronAssetParametersPathPolicyId parameters))) GHC.Base.<> ("/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronAssetParametersPathAssetName parameters))) GHC.Base.<> "")))))) GHC.Base.mempty)
