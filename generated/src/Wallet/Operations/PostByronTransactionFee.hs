-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation postByronTransactionFee
module Wallet.Operations.PostByronTransactionFee where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /byron-wallets/{walletId}/payment-fees
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Estimate fee for the transaction.
postByronTransactionFee :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostByronTransactionFeeRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response PostByronTransactionFeeResponse) -- ^ Monadic computation which returns the result of the operation
postByronTransactionFee walletId
                        body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PostByronTransactionFeeResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionFeeResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                        PostByronTransactionFeeResponseBody202)
                                                                                                                                                                                 | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionFeeResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                        PostByronTransactionFeeResponseBody400Variants)
                                                                                                                                                                                 | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionFeeResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                        PostByronTransactionFeeResponseBody403Variants)
                                                                                                                                                                                 | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionFeeResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                        PostByronTransactionFeeResponseBody404)
                                                                                                                                                                                 | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionFeeResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                        PostByronTransactionFeeResponseBody406)
                                                                                                                                                                                 | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionFeeResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                        PostByronTransactionFeeResponseBody415)
                                                                                                                                                                                 | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/payment-fees")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.requestBody.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronTransactionFeeRequestBody = PostByronTransactionFeeRequestBody {
  -- | payments: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  postByronTransactionFeeRequestBodyPayments :: ([PostByronTransactionFeeRequestBodyPayments])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["payments" Data.Aeson.Types.ToJSON..= postByronTransactionFeeRequestBodyPayments obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["payments" Data.Aeson.Types.ToJSON..= postByronTransactionFeeRequestBodyPayments obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeRequestBody" (\obj -> GHC.Base.pure PostByronTransactionFeeRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "payments"))
-- | Create a new 'PostByronTransactionFeeRequestBody' with all required fields.
mkPostByronTransactionFeeRequestBody :: [PostByronTransactionFeeRequestBodyPayments] -- ^ 'postByronTransactionFeeRequestBodyPayments'
  -> PostByronTransactionFeeRequestBody
mkPostByronTransactionFeeRequestBody postByronTransactionFeeRequestBodyPayments = PostByronTransactionFeeRequestBody{postByronTransactionFeeRequestBodyPayments = postByronTransactionFeeRequestBodyPayments}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.requestBody.content.application\/json.schema.properties.payments.items@ in the specification.
-- 
-- 
data PostByronTransactionFeeRequestBodyPayments = PostByronTransactionFeeRequestBodyPayments {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  postByronTransactionFeeRequestBodyPaymentsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postByronTransactionFeeRequestBodyPaymentsAmount :: PostByronTransactionFeeRequestBodyPaymentsAmount
  -- | assets: A flat list of assets (possibly empty).
  , postByronTransactionFeeRequestBodyPaymentsAssets :: (GHC.Maybe.Maybe ([PostByronTransactionFeeRequestBodyPaymentsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeRequestBodyPayments
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postByronTransactionFeeRequestBodyPaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postByronTransactionFeeRequestBodyPaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postByronTransactionFeeRequestBodyPaymentsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postByronTransactionFeeRequestBodyPaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postByronTransactionFeeRequestBodyPaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postByronTransactionFeeRequestBodyPaymentsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeRequestBodyPayments
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeRequestBodyPayments" (\obj -> ((GHC.Base.pure PostByronTransactionFeeRequestBodyPayments GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'PostByronTransactionFeeRequestBodyPayments' with all required fields.
mkPostByronTransactionFeeRequestBodyPayments :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeRequestBodyPaymentsAddress'
  -> PostByronTransactionFeeRequestBodyPaymentsAmount -- ^ 'postByronTransactionFeeRequestBodyPaymentsAmount'
  -> PostByronTransactionFeeRequestBodyPayments
mkPostByronTransactionFeeRequestBodyPayments postByronTransactionFeeRequestBodyPaymentsAddress postByronTransactionFeeRequestBodyPaymentsAmount = PostByronTransactionFeeRequestBodyPayments{postByronTransactionFeeRequestBodyPaymentsAddress = postByronTransactionFeeRequestBodyPaymentsAddress,
                                                                                                                                                                                             postByronTransactionFeeRequestBodyPaymentsAmount = postByronTransactionFeeRequestBodyPaymentsAmount,
                                                                                                                                                                                             postByronTransactionFeeRequestBodyPaymentsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.requestBody.content.application\/json.schema.properties.payments.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionFeeRequestBodyPaymentsAmount = PostByronTransactionFeeRequestBodyPaymentsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionFeeRequestBodyPaymentsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeRequestBodyPaymentsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeRequestBodyPaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeRequestBodyPaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeRequestBodyPaymentsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeRequestBodyPaymentsAmount" (\obj -> GHC.Base.pure PostByronTransactionFeeRequestBodyPaymentsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionFeeRequestBodyPaymentsAmount' with all required fields.
mkPostByronTransactionFeeRequestBodyPaymentsAmount :: GHC.Types.Int -- ^ 'postByronTransactionFeeRequestBodyPaymentsAmountQuantity'
  -> PostByronTransactionFeeRequestBodyPaymentsAmount
mkPostByronTransactionFeeRequestBodyPaymentsAmount postByronTransactionFeeRequestBodyPaymentsAmountQuantity = PostByronTransactionFeeRequestBodyPaymentsAmount{postByronTransactionFeeRequestBodyPaymentsAmountQuantity = postByronTransactionFeeRequestBodyPaymentsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.requestBody.content.application\/json.schema.properties.payments.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostByronTransactionFeeRequestBodyPaymentsAssets = PostByronTransactionFeeRequestBodyPaymentsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postByronTransactionFeeRequestBodyPaymentsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postByronTransactionFeeRequestBodyPaymentsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionFeeRequestBodyPaymentsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeRequestBodyPaymentsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronTransactionFeeRequestBodyPaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronTransactionFeeRequestBodyPaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeRequestBodyPaymentsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronTransactionFeeRequestBodyPaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronTransactionFeeRequestBodyPaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeRequestBodyPaymentsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeRequestBodyPaymentsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeRequestBodyPaymentsAssets" (\obj -> ((GHC.Base.pure PostByronTransactionFeeRequestBodyPaymentsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionFeeRequestBodyPaymentsAssets' with all required fields.
mkPostByronTransactionFeeRequestBodyPaymentsAssets :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeRequestBodyPaymentsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionFeeRequestBodyPaymentsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'postByronTransactionFeeRequestBodyPaymentsAssetsQuantity'
  -> PostByronTransactionFeeRequestBodyPaymentsAssets
mkPostByronTransactionFeeRequestBodyPaymentsAssets postByronTransactionFeeRequestBodyPaymentsAssetsAsset_name postByronTransactionFeeRequestBodyPaymentsAssetsPolicy_id postByronTransactionFeeRequestBodyPaymentsAssetsQuantity = PostByronTransactionFeeRequestBodyPaymentsAssets{postByronTransactionFeeRequestBodyPaymentsAssetsAsset_name = postByronTransactionFeeRequestBodyPaymentsAssetsAsset_name,
                                                                                                                                                                                                                                                                                    postByronTransactionFeeRequestBodyPaymentsAssetsPolicy_id = postByronTransactionFeeRequestBodyPaymentsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                    postByronTransactionFeeRequestBodyPaymentsAssetsQuantity = postByronTransactionFeeRequestBodyPaymentsAssetsQuantity}
-- | Represents a response of the operation 'postByronTransactionFee'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PostByronTransactionFeeResponseError' is used.
data PostByronTransactionFeeResponse =
   PostByronTransactionFeeResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | PostByronTransactionFeeResponse202 PostByronTransactionFeeResponseBody202 -- ^ Accepted
  | PostByronTransactionFeeResponse400 PostByronTransactionFeeResponseBody400Variants -- ^ Bad Request
  | PostByronTransactionFeeResponse403 PostByronTransactionFeeResponseBody403Variants -- ^ Forbidden
  | PostByronTransactionFeeResponse404 PostByronTransactionFeeResponseBody404 -- ^ Not Found
  | PostByronTransactionFeeResponse406 PostByronTransactionFeeResponseBody406 -- ^ Not Acceptable
  | PostByronTransactionFeeResponse415 PostByronTransactionFeeResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.202.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody202 = PostByronTransactionFeeResponseBody202 {
  -- | deposit: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  postByronTransactionFeeResponseBody202Deposit :: PostByronTransactionFeeResponseBody202Deposit
  -- | estimated_max: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postByronTransactionFeeResponseBody202Estimated_max :: PostByronTransactionFeeResponseBody202Estimated_max
  -- | estimated_min: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postByronTransactionFeeResponseBody202Estimated_min :: PostByronTransactionFeeResponseBody202Estimated_min
  -- | minimum_coins: A list of minimum coin values that each output in a payment must satisfy. The values themselves depends on two things:
  -- 
  --   - (a) Some updatable protocol parameters fixed by the network.
  --   - (b) The nature of the outputs (i.e. the kind of assets it includes).
  -- 
  -- The list is a direct 1:1 mapping of the requested outputs. Said differently, it has the **same number of items** and **items
  -- are ordered in the same way** as **requested outputs** are ordered. In the case where there\'s no explicitly requested outputs (e.g.
  -- when calculating fee for delegation), this list is empty.
  -- 
  -- For example, an output containing only \`Ada\` may require to be of at least \`1 Ada\`. An output containing only an hypothetical \`AppleCoin\`
  -- may require to also carry a minimum of \`1.2 Ada\`. Note that no matter what, a minimum coin value is always given in Lovelace \/ Ada.
  -- 
  -- > ℹ️ This mechanism is used by the protocol to protect against flooding of the network with worthless assets. By requiring a minimum coin value to every
  -- UTxO, they are given an intrinsic value indexed itself on the value of Ada.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postByronTransactionFeeResponseBody202Minimum_coins :: ([PostByronTransactionFeeResponseBody202Minimum_coins])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody202
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["deposit" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202Deposit obj] : ["estimated_max" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202Estimated_max obj] : ["estimated_min" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202Estimated_min obj] : ["minimum_coins" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202Minimum_coins obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["deposit" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202Deposit obj] : ["estimated_max" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202Estimated_max obj] : ["estimated_min" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202Estimated_min obj] : ["minimum_coins" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202Minimum_coins obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody202
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody202" (\obj -> (((GHC.Base.pure PostByronTransactionFeeResponseBody202 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "estimated_max")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "estimated_min")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "minimum_coins"))
-- | Create a new 'PostByronTransactionFeeResponseBody202' with all required fields.
mkPostByronTransactionFeeResponseBody202 :: PostByronTransactionFeeResponseBody202Deposit -- ^ 'postByronTransactionFeeResponseBody202Deposit'
  -> PostByronTransactionFeeResponseBody202Estimated_max -- ^ 'postByronTransactionFeeResponseBody202Estimated_max'
  -> PostByronTransactionFeeResponseBody202Estimated_min -- ^ 'postByronTransactionFeeResponseBody202Estimated_min'
  -> [PostByronTransactionFeeResponseBody202Minimum_coins] -- ^ 'postByronTransactionFeeResponseBody202Minimum_coins'
  -> PostByronTransactionFeeResponseBody202
mkPostByronTransactionFeeResponseBody202 postByronTransactionFeeResponseBody202Deposit postByronTransactionFeeResponseBody202Estimated_max postByronTransactionFeeResponseBody202Estimated_min postByronTransactionFeeResponseBody202Minimum_coins = PostByronTransactionFeeResponseBody202{postByronTransactionFeeResponseBody202Deposit = postByronTransactionFeeResponseBody202Deposit,
                                                                                                                                                                                                                                                                                            postByronTransactionFeeResponseBody202Estimated_max = postByronTransactionFeeResponseBody202Estimated_max,
                                                                                                                                                                                                                                                                                            postByronTransactionFeeResponseBody202Estimated_min = postByronTransactionFeeResponseBody202Estimated_min,
                                                                                                                                                                                                                                                                                            postByronTransactionFeeResponseBody202Minimum_coins = postByronTransactionFeeResponseBody202Minimum_coins}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.202.content.application\/json.schema.properties.deposit@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionFeeResponseBody202Deposit = PostByronTransactionFeeResponseBody202Deposit {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionFeeResponseBody202DepositQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody202Deposit
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202DepositQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202DepositQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody202Deposit
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody202Deposit" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody202Deposit GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionFeeResponseBody202Deposit' with all required fields.
mkPostByronTransactionFeeResponseBody202Deposit :: GHC.Types.Int -- ^ 'postByronTransactionFeeResponseBody202DepositQuantity'
  -> PostByronTransactionFeeResponseBody202Deposit
mkPostByronTransactionFeeResponseBody202Deposit postByronTransactionFeeResponseBody202DepositQuantity = PostByronTransactionFeeResponseBody202Deposit{postByronTransactionFeeResponseBody202DepositQuantity = postByronTransactionFeeResponseBody202DepositQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.202.content.application\/json.schema.properties.estimated_max@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionFeeResponseBody202Estimated_max = PostByronTransactionFeeResponseBody202Estimated_max {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionFeeResponseBody202Estimated_maxQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody202Estimated_max
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202Estimated_maxQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202Estimated_maxQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody202Estimated_max
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody202Estimated_max" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody202Estimated_max GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionFeeResponseBody202Estimated_max' with all required fields.
mkPostByronTransactionFeeResponseBody202Estimated_max :: GHC.Types.Int -- ^ 'postByronTransactionFeeResponseBody202Estimated_maxQuantity'
  -> PostByronTransactionFeeResponseBody202Estimated_max
mkPostByronTransactionFeeResponseBody202Estimated_max postByronTransactionFeeResponseBody202Estimated_maxQuantity = PostByronTransactionFeeResponseBody202Estimated_max{postByronTransactionFeeResponseBody202Estimated_maxQuantity = postByronTransactionFeeResponseBody202Estimated_maxQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.202.content.application\/json.schema.properties.estimated_min@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionFeeResponseBody202Estimated_min = PostByronTransactionFeeResponseBody202Estimated_min {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionFeeResponseBody202Estimated_minQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody202Estimated_min
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202Estimated_minQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202Estimated_minQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody202Estimated_min
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody202Estimated_min" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody202Estimated_min GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionFeeResponseBody202Estimated_min' with all required fields.
mkPostByronTransactionFeeResponseBody202Estimated_min :: GHC.Types.Int -- ^ 'postByronTransactionFeeResponseBody202Estimated_minQuantity'
  -> PostByronTransactionFeeResponseBody202Estimated_min
mkPostByronTransactionFeeResponseBody202Estimated_min postByronTransactionFeeResponseBody202Estimated_minQuantity = PostByronTransactionFeeResponseBody202Estimated_min{postByronTransactionFeeResponseBody202Estimated_minQuantity = postByronTransactionFeeResponseBody202Estimated_minQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.202.content.application\/json.schema.properties.minimum_coins.items@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionFeeResponseBody202Minimum_coins = PostByronTransactionFeeResponseBody202Minimum_coins {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionFeeResponseBody202Minimum_coinsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody202Minimum_coins
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202Minimum_coinsQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody202Minimum_coinsQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody202Minimum_coins
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody202Minimum_coins" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody202Minimum_coins GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionFeeResponseBody202Minimum_coins' with all required fields.
mkPostByronTransactionFeeResponseBody202Minimum_coins :: GHC.Types.Int -- ^ 'postByronTransactionFeeResponseBody202Minimum_coinsQuantity'
  -> PostByronTransactionFeeResponseBody202Minimum_coins
mkPostByronTransactionFeeResponseBody202Minimum_coins postByronTransactionFeeResponseBody202Minimum_coinsQuantity = PostByronTransactionFeeResponseBody202Minimum_coins{postByronTransactionFeeResponseBody202Minimum_coinsQuantity = postByronTransactionFeeResponseBody202Minimum_coinsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody400OneOf1 = PostByronTransactionFeeResponseBody400OneOf1 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  postByronTransactionFeeResponseBody400OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody400OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody400OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody400OneOf1" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody400OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionFeeResponseBody400OneOf1' with all required fields.
mkPostByronTransactionFeeResponseBody400OneOf1 :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeResponseBody400OneOf1Message'
  -> PostByronTransactionFeeResponseBody400OneOf1
mkPostByronTransactionFeeResponseBody400OneOf1 postByronTransactionFeeResponseBody400OneOf1Message = PostByronTransactionFeeResponseBody400OneOf1{postByronTransactionFeeResponseBody400OneOf1Message = postByronTransactionFeeResponseBody400OneOf1Message}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody400Variants =
   PostByronTransactionFeeResponseBody400Variant1 PostByronTransactionFeeResponseBody400OneOf1
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody400Variants
    where toJSON (PostByronTransactionFeeResponseBody400Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody400Variants
    where parseJSON val = case (PostByronTransactionFeeResponseBody400Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched" of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody403OneOf1 = PostByronTransactionFeeResponseBody403OneOf1 {
  -- | message: May occur when trying to perform an operation not supported by this type of wallet.
  postByronTransactionFeeResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody403OneOf1" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionFeeResponseBody403OneOf1' with all required fields.
mkPostByronTransactionFeeResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeResponseBody403OneOf1Message'
  -> PostByronTransactionFeeResponseBody403OneOf1
mkPostByronTransactionFeeResponseBody403OneOf1 postByronTransactionFeeResponseBody403OneOf1Message = PostByronTransactionFeeResponseBody403OneOf1{postByronTransactionFeeResponseBody403OneOf1Message = postByronTransactionFeeResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody403OneOf2 = PostByronTransactionFeeResponseBody403OneOf2 {
  -- | message: May occur when submitting a withdrawal while another withdrawal is pending.
  postByronTransactionFeeResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody403OneOf2" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionFeeResponseBody403OneOf2' with all required fields.
mkPostByronTransactionFeeResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeResponseBody403OneOf2Message'
  -> PostByronTransactionFeeResponseBody403OneOf2
mkPostByronTransactionFeeResponseBody403OneOf2 postByronTransactionFeeResponseBody403OneOf2Message = PostByronTransactionFeeResponseBody403OneOf2{postByronTransactionFeeResponseBody403OneOf2Message = postByronTransactionFeeResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody403OneOf3 = PostByronTransactionFeeResponseBody403OneOf3 {
  -- | info
  postByronTransactionFeeResponseBody403OneOf3Info :: (GHC.Maybe.Maybe PostByronTransactionFeeResponseBody403OneOf3Info)
  -- | message: Occurs when a requested output has a quantity of lovelace that is below the minimum required by the ledger.
  , postByronTransactionFeeResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (postByronTransactionFeeResponseBody403OneOf3Info obj) : ["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (postByronTransactionFeeResponseBody403OneOf3Info obj) : ["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody403OneOf3" (\obj -> (GHC.Base.pure PostByronTransactionFeeResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "info")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionFeeResponseBody403OneOf3' with all required fields.
mkPostByronTransactionFeeResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeResponseBody403OneOf3Message'
  -> PostByronTransactionFeeResponseBody403OneOf3
mkPostByronTransactionFeeResponseBody403OneOf3 postByronTransactionFeeResponseBody403OneOf3Message = PostByronTransactionFeeResponseBody403OneOf3{postByronTransactionFeeResponseBody403OneOf3Info = GHC.Maybe.Nothing,
                                                                                                                                                  postByronTransactionFeeResponseBody403OneOf3Message = postByronTransactionFeeResponseBody403OneOf3Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf.properties.info@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody403OneOf3Info = PostByronTransactionFeeResponseBody403OneOf3Info {
  -- | tx_output_index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionFeeResponseBody403OneOf3InfoTx_output_index :: GHC.Types.Int
  -- | tx_output_lovelace_required_minimum: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum :: PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
  -- | tx_output_lovelace_specified: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified :: PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody403OneOf3Info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf3InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf3InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody403OneOf3Info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody403OneOf3Info" (\obj -> ((GHC.Base.pure PostByronTransactionFeeResponseBody403OneOf3Info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_index")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_required_minimum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_specified"))
-- | Create a new 'PostByronTransactionFeeResponseBody403OneOf3Info' with all required fields.
mkPostByronTransactionFeeResponseBody403OneOf3Info :: GHC.Types.Int -- ^ 'postByronTransactionFeeResponseBody403OneOf3InfoTx_output_index'
  -> PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum -- ^ 'postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum'
  -> PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified -- ^ 'postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified'
  -> PostByronTransactionFeeResponseBody403OneOf3Info
mkPostByronTransactionFeeResponseBody403OneOf3Info postByronTransactionFeeResponseBody403OneOf3InfoTx_output_index postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified = PostByronTransactionFeeResponseBody403OneOf3Info{postByronTransactionFeeResponseBody403OneOf3InfoTx_output_index = postByronTransactionFeeResponseBody403OneOf3InfoTx_output_index,
                                                                                                                                                                                                                                                                                                                                       postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum = postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum,
                                                                                                                                                                                                                                                                                                                                       postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified = postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_required_minimum@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum = PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum' with all required fields.
mkPostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum :: GHC.Types.Int -- ^ 'postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity'
  -> PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
mkPostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity = PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimum{postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity = postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_specified@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified = PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified' with all required fields.
mkPostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified :: GHC.Types.Int -- ^ 'postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity'
  -> PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified
mkPostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity = PostByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specified{postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity = postByronTransactionFeeResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody403OneOf4 = PostByronTransactionFeeResponseBody403OneOf4 {
  -- | message: May occur when a transaction can\'t be balanced for fees.
  postByronTransactionFeeResponseBody403OneOf4Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody403OneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody403OneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody403OneOf4" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody403OneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionFeeResponseBody403OneOf4' with all required fields.
mkPostByronTransactionFeeResponseBody403OneOf4 :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeResponseBody403OneOf4Message'
  -> PostByronTransactionFeeResponseBody403OneOf4
mkPostByronTransactionFeeResponseBody403OneOf4 postByronTransactionFeeResponseBody403OneOf4Message = PostByronTransactionFeeResponseBody403OneOf4{postByronTransactionFeeResponseBody403OneOf4Message = postByronTransactionFeeResponseBody403OneOf4Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody403OneOf5 = PostByronTransactionFeeResponseBody403OneOf5 {
  -- | message: May occur when there\'s not enough money in the wallet to cover a requested payment.
  postByronTransactionFeeResponseBody403OneOf5Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody403OneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody403OneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody403OneOf5" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody403OneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionFeeResponseBody403OneOf5' with all required fields.
mkPostByronTransactionFeeResponseBody403OneOf5 :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeResponseBody403OneOf5Message'
  -> PostByronTransactionFeeResponseBody403OneOf5
mkPostByronTransactionFeeResponseBody403OneOf5 postByronTransactionFeeResponseBody403OneOf5Message = PostByronTransactionFeeResponseBody403OneOf5{postByronTransactionFeeResponseBody403OneOf5Message = postByronTransactionFeeResponseBody403OneOf5Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody403OneOf6 = PostByronTransactionFeeResponseBody403OneOf6 {
  -- | message: May occur when the total balance of pure ada UTxOs in the wallet is
  -- insufficient to cover the minimum collateral amount required for a
  -- transaction requiring collateral.
  postByronTransactionFeeResponseBody403OneOf6Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody403OneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody403OneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody403OneOf6" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody403OneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionFeeResponseBody403OneOf6' with all required fields.
mkPostByronTransactionFeeResponseBody403OneOf6 :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeResponseBody403OneOf6Message'
  -> PostByronTransactionFeeResponseBody403OneOf6
mkPostByronTransactionFeeResponseBody403OneOf6 postByronTransactionFeeResponseBody403OneOf6Message = PostByronTransactionFeeResponseBody403OneOf6{postByronTransactionFeeResponseBody403OneOf6Message = postByronTransactionFeeResponseBody403OneOf6Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody403OneOf7 = PostByronTransactionFeeResponseBody403OneOf7 {
  -- | message: May occur when there\'s enough money to pay for a payment, but not enough UTxO to allow for paying each output independently.
  postByronTransactionFeeResponseBody403OneOf7Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody403OneOf7
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "inputs_depleted"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "inputs_depleted"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody403OneOf7
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody403OneOf7" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody403OneOf7 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionFeeResponseBody403OneOf7' with all required fields.
mkPostByronTransactionFeeResponseBody403OneOf7 :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeResponseBody403OneOf7Message'
  -> PostByronTransactionFeeResponseBody403OneOf7
mkPostByronTransactionFeeResponseBody403OneOf7 postByronTransactionFeeResponseBody403OneOf7Message = PostByronTransactionFeeResponseBody403OneOf7{postByronTransactionFeeResponseBody403OneOf7Message = postByronTransactionFeeResponseBody403OneOf7Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody403OneOf8 = PostByronTransactionFeeResponseBody403OneOf8 {
  -- | message: Should never happen unless the server screwed up with the creation of a coin selection.
  postByronTransactionFeeResponseBody403OneOf8Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody403OneOf8
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_coin_selection"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_coin_selection"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody403OneOf8
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody403OneOf8" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody403OneOf8 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionFeeResponseBody403OneOf8' with all required fields.
mkPostByronTransactionFeeResponseBody403OneOf8 :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeResponseBody403OneOf8Message'
  -> PostByronTransactionFeeResponseBody403OneOf8
mkPostByronTransactionFeeResponseBody403OneOf8 postByronTransactionFeeResponseBody403OneOf8Message = PostByronTransactionFeeResponseBody403OneOf8{postByronTransactionFeeResponseBody403OneOf8Message = postByronTransactionFeeResponseBody403OneOf8Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody403OneOf9 = PostByronTransactionFeeResponseBody403OneOf9 {
  -- | message: Returned when a user-specified transaction output contains, for some
  -- asset, a token quantity that exceeds the limit supported by the
  -- protocol.
  postByronTransactionFeeResponseBody403OneOf9Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody403OneOf9
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_quantity_exceeds_limit"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_quantity_exceeds_limit"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody403OneOf9
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody403OneOf9" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody403OneOf9 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionFeeResponseBody403OneOf9' with all required fields.
mkPostByronTransactionFeeResponseBody403OneOf9 :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeResponseBody403OneOf9Message'
  -> PostByronTransactionFeeResponseBody403OneOf9
mkPostByronTransactionFeeResponseBody403OneOf9 postByronTransactionFeeResponseBody403OneOf9Message = PostByronTransactionFeeResponseBody403OneOf9{postByronTransactionFeeResponseBody403OneOf9Message = postByronTransactionFeeResponseBody403OneOf9Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody403OneOf10 = PostByronTransactionFeeResponseBody403OneOf10 {
  -- | message: Returned when a user-specified transaction output contains a token
  -- bundle whose serialized length exceeds the limit supported by the
  -- protocol.
  postByronTransactionFeeResponseBody403OneOf10Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody403OneOf10
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf10Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_bundle_size_exceeds_limit"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf10Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_bundle_size_exceeds_limit"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody403OneOf10
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody403OneOf10" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody403OneOf10 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionFeeResponseBody403OneOf10' with all required fields.
mkPostByronTransactionFeeResponseBody403OneOf10 :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeResponseBody403OneOf10Message'
  -> PostByronTransactionFeeResponseBody403OneOf10
mkPostByronTransactionFeeResponseBody403OneOf10 postByronTransactionFeeResponseBody403OneOf10Message = PostByronTransactionFeeResponseBody403OneOf10{postByronTransactionFeeResponseBody403OneOf10Message = postByronTransactionFeeResponseBody403OneOf10Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody403OneOf11 = PostByronTransactionFeeResponseBody403OneOf11 {
  -- | message: May occur when the wallet can\'t cover for all requested outputs without making the transaction too large.
  postByronTransactionFeeResponseBody403OneOf11Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody403OneOf11
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf11Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_is_too_big"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody403OneOf11Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_is_too_big"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody403OneOf11
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody403OneOf11" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody403OneOf11 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionFeeResponseBody403OneOf11' with all required fields.
mkPostByronTransactionFeeResponseBody403OneOf11 :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeResponseBody403OneOf11Message'
  -> PostByronTransactionFeeResponseBody403OneOf11
mkPostByronTransactionFeeResponseBody403OneOf11 postByronTransactionFeeResponseBody403OneOf11Message = PostByronTransactionFeeResponseBody403OneOf11{postByronTransactionFeeResponseBody403OneOf11Message = postByronTransactionFeeResponseBody403OneOf11Message}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody403Variants =
   PostByronTransactionFeeResponseBody403Variant1 PostByronTransactionFeeResponseBody403OneOf1
  | PostByronTransactionFeeResponseBody403Variant2 PostByronTransactionFeeResponseBody403OneOf2
  | PostByronTransactionFeeResponseBody403Variant3 PostByronTransactionFeeResponseBody403OneOf3
  | PostByronTransactionFeeResponseBody403Variant4 PostByronTransactionFeeResponseBody403OneOf4
  | PostByronTransactionFeeResponseBody403Variant5 PostByronTransactionFeeResponseBody403OneOf5
  | PostByronTransactionFeeResponseBody403Variant6 PostByronTransactionFeeResponseBody403OneOf6
  | PostByronTransactionFeeResponseBody403Variant7 PostByronTransactionFeeResponseBody403OneOf7
  | PostByronTransactionFeeResponseBody403Variant8 PostByronTransactionFeeResponseBody403OneOf8
  | PostByronTransactionFeeResponseBody403Variant9 PostByronTransactionFeeResponseBody403OneOf9
  | PostByronTransactionFeeResponseBody403Variant10 PostByronTransactionFeeResponseBody403OneOf10
  | PostByronTransactionFeeResponseBody403Variant11 PostByronTransactionFeeResponseBody403OneOf11
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody403Variants
    where toJSON (PostByronTransactionFeeResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionFeeResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionFeeResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionFeeResponseBody403Variant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionFeeResponseBody403Variant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionFeeResponseBody403Variant6 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionFeeResponseBody403Variant7 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionFeeResponseBody403Variant8 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionFeeResponseBody403Variant9 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionFeeResponseBody403Variant10 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionFeeResponseBody403Variant11 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody403Variants
    where parseJSON val = case (PostByronTransactionFeeResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionFeeResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionFeeResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionFeeResponseBody403Variant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionFeeResponseBody403Variant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionFeeResponseBody403Variant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionFeeResponseBody403Variant7 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionFeeResponseBody403Variant8 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionFeeResponseBody403Variant9 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionFeeResponseBody403Variant10 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionFeeResponseBody403Variant11 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))))))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody404 = PostByronTransactionFeeResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  postByronTransactionFeeResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody404" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionFeeResponseBody404' with all required fields.
mkPostByronTransactionFeeResponseBody404 :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeResponseBody404Message'
  -> PostByronTransactionFeeResponseBody404
mkPostByronTransactionFeeResponseBody404 postByronTransactionFeeResponseBody404Message = PostByronTransactionFeeResponseBody404{postByronTransactionFeeResponseBody404Message = postByronTransactionFeeResponseBody404Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody406 = PostByronTransactionFeeResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  postByronTransactionFeeResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody406" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionFeeResponseBody406' with all required fields.
mkPostByronTransactionFeeResponseBody406 :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeResponseBody406Message'
  -> PostByronTransactionFeeResponseBody406
mkPostByronTransactionFeeResponseBody406 postByronTransactionFeeResponseBody406Message = PostByronTransactionFeeResponseBody406{postByronTransactionFeeResponseBody406Message = postByronTransactionFeeResponseBody406Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/payment-fees.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronTransactionFeeResponseBody415 = PostByronTransactionFeeResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  postByronTransactionFeeResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionFeeResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionFeeResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionFeeResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionFeeResponseBody415" (\obj -> GHC.Base.pure PostByronTransactionFeeResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionFeeResponseBody415' with all required fields.
mkPostByronTransactionFeeResponseBody415 :: Data.Text.Internal.Text -- ^ 'postByronTransactionFeeResponseBody415Message'
  -> PostByronTransactionFeeResponseBody415
mkPostByronTransactionFeeResponseBody415 postByronTransactionFeeResponseBody415Message = PostByronTransactionFeeResponseBody415{postByronTransactionFeeResponseBody415Message = postByronTransactionFeeResponseBody415Message}
-- | > POST /byron-wallets/{walletId}/payment-fees
-- 
-- The same as 'postByronTransactionFee' but accepts an explicit configuration.
postByronTransactionFeeWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostByronTransactionFeeRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response PostByronTransactionFeeResponse) -- ^ Monadic computation which returns the result of the operation
postByronTransactionFeeWithConfiguration config
                                         walletId
                                         body = GHC.Base.fmap (\response_7 -> GHC.Base.fmap (Data.Either.either PostByronTransactionFeeResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionFeeResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                         PostByronTransactionFeeResponseBody202)
                                                                                                                                                                                                  | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionFeeResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                         PostByronTransactionFeeResponseBody400Variants)
                                                                                                                                                                                                  | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionFeeResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                           PostByronTransactionFeeResponseBody403Variants)
                                                                                                                                                                                                  | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionFeeResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                           PostByronTransactionFeeResponseBody404)
                                                                                                                                                                                                  | (\status_12 -> Network.HTTP.Types.Status.statusCode status_12 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionFeeResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                           PostByronTransactionFeeResponseBody406)
                                                                                                                                                                                                  | (\status_13 -> Network.HTTP.Types.Status.statusCode status_13 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionFeeResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                           PostByronTransactionFeeResponseBody415)
                                                                                                                                                                                                  | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_7) response_7) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/payment-fees")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /byron-wallets/{walletId}/payment-fees
-- 
-- The same as 'postByronTransactionFee' but returns the raw 'Data.ByteString.ByteString'.
postByronTransactionFeeRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostByronTransactionFeeRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postByronTransactionFeeRaw walletId
                           body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/payment-fees")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /byron-wallets/{walletId}/payment-fees
-- 
-- The same as 'postByronTransactionFee' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
postByronTransactionFeeWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostByronTransactionFeeRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postByronTransactionFeeWithConfigurationRaw config
                                            walletId
                                            body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/payment-fees")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
