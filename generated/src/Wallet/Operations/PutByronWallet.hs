-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation putByronWallet
module Wallet.Operations.PutByronWallet where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > PUT /byron-wallets/{walletId}
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
putByronWallet :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutByronWalletRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response PutByronWalletResponse) -- ^ Monadic computation which returns the result of the operation
putByronWallet walletId
               body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PutByronWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                             PutByronWalletResponseBody200)
                                                                                                                                                               | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                             PutByronWalletResponseBody400)
                                                                                                                                                               | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                             PutByronWalletResponseBody404)
                                                                                                                                                               | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                             PutByronWalletResponseBody406)
                                                                                                                                                               | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                             PutByronWalletResponseBody415)
                                                                                                                                                               | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.requestBody.content.application\/json.schema@ in the specification.
-- 
-- 
data PutByronWalletRequestBody = PutByronWalletRequestBody {
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  putByronWalletRequestBodyName :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("name" Data.Aeson.Types.ToJSON..=)) (putByronWalletRequestBodyName obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("name" Data.Aeson.Types.ToJSON..=)) (putByronWalletRequestBodyName obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletRequestBody" (\obj -> GHC.Base.pure PutByronWalletRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "name"))
-- | Create a new 'PutByronWalletRequestBody' with all required fields.
mkPutByronWalletRequestBody :: PutByronWalletRequestBody
mkPutByronWalletRequestBody = PutByronWalletRequestBody{putByronWalletRequestBodyName = GHC.Maybe.Nothing}
-- | Represents a response of the operation 'putByronWallet'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PutByronWalletResponseError' is used.
data PutByronWalletResponse =
   PutByronWalletResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | PutByronWalletResponse200 PutByronWalletResponseBody200 -- ^ Ok
  | PutByronWalletResponse400 PutByronWalletResponseBody400 -- ^ Bad Request
  | PutByronWalletResponse404 PutByronWalletResponseBody404 -- ^ Not Found
  | PutByronWalletResponse406 PutByronWalletResponseBody406 -- ^ Not Acceptable
  | PutByronWalletResponse415 PutByronWalletResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema@ in the specification.
-- 
-- 
data PutByronWalletResponseBody200 = PutByronWalletResponseBody200 {
  -- | address_pool_gap: Number of consecutive unused addresses allowed.
  -- 
  -- **IMPORTANT DISCLAIMER:** Using values other than \`20\` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
  -- your wallet in a different software which is strictly following BIP-44.
  -- 
  -- Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
  -- 
  -- **IMPORTANT DISCLAIMER 2:** There is no way to \`import\` addresses generated outside (e.g. using cardano-addresses) into the wallet.
  -- Wallet only discovers transactions on its used and unused addresses that are within its currently seen \`address_pool_gap\`.
  -- Transactions on addresses that \"belong\" to the wallet but happen to be beyond its \`address_pool_gap\` will not be visible to the wallet.
  -- This is a technical limitation of the industry standard [BIP-44](https:\/\/github.com\/bitcoin\/bips\/blob\/master\/bip-0044.mediawiki). See also [CIP-1852](https:\/\/github.com\/cardano-foundation\/CIPs\/blob\/master\/CIP-1852\/CIP-1852.md).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100000.0
  -- * Minimum  of 10.0
  putByronWalletResponseBody200Address_pool_gap :: GHC.Types.Int
  -- | assets: Current non-Ada asset holdings of the wallet.
  -- 
  -- The amount of assets available to spend may be less than the total
  -- unspent assets due to transaction change amounts which are yet to
  -- be fully confirmed (pending).
  , putByronWalletResponseBody200Assets :: PutByronWalletResponseBody200Assets
  -- | balance: Wallet current Ada balance(s).
  , putByronWalletResponseBody200Balance :: PutByronWalletResponseBody200Balance
  -- | delegation: Delegation settings
  , putByronWalletResponseBody200Delegation :: PutByronWalletResponseBody200Delegation
  -- | id: A unique identifier for the wallet
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  , putByronWalletResponseBody200Id :: Data.Text.Internal.Text
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , putByronWalletResponseBody200Name :: Data.Text.Internal.Text
  -- | passphrase: Information about the wallet\'s passphrase
  , putByronWalletResponseBody200Passphrase :: (GHC.Maybe.Maybe PutByronWalletResponseBody200Passphrase)
  -- | state: Whether a wallet is ready to use or still syncing
  , putByronWalletResponseBody200State :: PutByronWalletResponseBody200State
  -- | tip: A reference to a particular time slot, and the block height at that point.
  , putByronWalletResponseBody200Tip :: PutByronWalletResponseBody200Tip
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address_pool_gap" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200Address_pool_gap obj] : ["assets" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200Balance obj] : ["delegation" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200Delegation obj] : ["id" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200Id obj] : ["name" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (putByronWalletResponseBody200Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200State obj] : ["tip" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200Tip obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address_pool_gap" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200Address_pool_gap obj] : ["assets" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200Balance obj] : ["delegation" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200Delegation obj] : ["id" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200Id obj] : ["name" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (putByronWalletResponseBody200Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200State obj] : ["tip" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200Tip obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200" (\obj -> ((((((((GHC.Base.pure PutByronWalletResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address_pool_gap")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "balance")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "delegation")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "state")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tip"))
-- | Create a new 'PutByronWalletResponseBody200' with all required fields.
mkPutByronWalletResponseBody200 :: GHC.Types.Int -- ^ 'putByronWalletResponseBody200Address_pool_gap'
  -> PutByronWalletResponseBody200Assets -- ^ 'putByronWalletResponseBody200Assets'
  -> PutByronWalletResponseBody200Balance -- ^ 'putByronWalletResponseBody200Balance'
  -> PutByronWalletResponseBody200Delegation -- ^ 'putByronWalletResponseBody200Delegation'
  -> Data.Text.Internal.Text -- ^ 'putByronWalletResponseBody200Id'
  -> Data.Text.Internal.Text -- ^ 'putByronWalletResponseBody200Name'
  -> PutByronWalletResponseBody200State -- ^ 'putByronWalletResponseBody200State'
  -> PutByronWalletResponseBody200Tip -- ^ 'putByronWalletResponseBody200Tip'
  -> PutByronWalletResponseBody200
mkPutByronWalletResponseBody200 putByronWalletResponseBody200Address_pool_gap putByronWalletResponseBody200Assets putByronWalletResponseBody200Balance putByronWalletResponseBody200Delegation putByronWalletResponseBody200Id putByronWalletResponseBody200Name putByronWalletResponseBody200State putByronWalletResponseBody200Tip = PutByronWalletResponseBody200{putByronWalletResponseBody200Address_pool_gap = putByronWalletResponseBody200Address_pool_gap,
                                                                                                                                                                                                                                                                                                                                                                     putByronWalletResponseBody200Assets = putByronWalletResponseBody200Assets,
                                                                                                                                                                                                                                                                                                                                                                     putByronWalletResponseBody200Balance = putByronWalletResponseBody200Balance,
                                                                                                                                                                                                                                                                                                                                                                     putByronWalletResponseBody200Delegation = putByronWalletResponseBody200Delegation,
                                                                                                                                                                                                                                                                                                                                                                     putByronWalletResponseBody200Id = putByronWalletResponseBody200Id,
                                                                                                                                                                                                                                                                                                                                                                     putByronWalletResponseBody200Name = putByronWalletResponseBody200Name,
                                                                                                                                                                                                                                                                                                                                                                     putByronWalletResponseBody200Passphrase = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                     putByronWalletResponseBody200State = putByronWalletResponseBody200State,
                                                                                                                                                                                                                                                                                                                                                                     putByronWalletResponseBody200Tip = putByronWalletResponseBody200Tip}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.assets@ in the specification.
-- 
-- Current non-Ada asset holdings of the wallet.
-- 
-- The amount of assets available to spend may be less than the total
-- unspent assets due to transaction change amounts which are yet to
-- be fully confirmed (pending).
data PutByronWalletResponseBody200Assets = PutByronWalletResponseBody200Assets {
  -- | available: Available UTxO asset balances (funds that can be spent without
  -- condition).
  putByronWalletResponseBody200AssetsAvailable :: ([PutByronWalletResponseBody200AssetsAvailable])
  -- | total: Total asset balances (available balances plus pending change balances).
  , putByronWalletResponseBody200AssetsTotal :: ([PutByronWalletResponseBody200AssetsTotal])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200Assets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200Assets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200Assets" (\obj -> (GHC.Base.pure PutByronWalletResponseBody200Assets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'PutByronWalletResponseBody200Assets' with all required fields.
mkPutByronWalletResponseBody200Assets :: [PutByronWalletResponseBody200AssetsAvailable] -- ^ 'putByronWalletResponseBody200AssetsAvailable'
  -> [PutByronWalletResponseBody200AssetsTotal] -- ^ 'putByronWalletResponseBody200AssetsTotal'
  -> PutByronWalletResponseBody200Assets
mkPutByronWalletResponseBody200Assets putByronWalletResponseBody200AssetsAvailable putByronWalletResponseBody200AssetsTotal = PutByronWalletResponseBody200Assets{putByronWalletResponseBody200AssetsAvailable = putByronWalletResponseBody200AssetsAvailable,
                                                                                                                                                                  putByronWalletResponseBody200AssetsTotal = putByronWalletResponseBody200AssetsTotal}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.assets.properties.available.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PutByronWalletResponseBody200AssetsAvailable = PutByronWalletResponseBody200AssetsAvailable {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  putByronWalletResponseBody200AssetsAvailableAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , putByronWalletResponseBody200AssetsAvailablePolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , putByronWalletResponseBody200AssetsAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200AssetsAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsAvailableQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsAvailableQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200AssetsAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200AssetsAvailable" (\obj -> ((GHC.Base.pure PutByronWalletResponseBody200AssetsAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PutByronWalletResponseBody200AssetsAvailable' with all required fields.
mkPutByronWalletResponseBody200AssetsAvailable :: Data.Text.Internal.Text -- ^ 'putByronWalletResponseBody200AssetsAvailableAsset_name'
  -> Data.Text.Internal.Text -- ^ 'putByronWalletResponseBody200AssetsAvailablePolicy_id'
  -> GHC.Types.Int -- ^ 'putByronWalletResponseBody200AssetsAvailableQuantity'
  -> PutByronWalletResponseBody200AssetsAvailable
mkPutByronWalletResponseBody200AssetsAvailable putByronWalletResponseBody200AssetsAvailableAsset_name putByronWalletResponseBody200AssetsAvailablePolicy_id putByronWalletResponseBody200AssetsAvailableQuantity = PutByronWalletResponseBody200AssetsAvailable{putByronWalletResponseBody200AssetsAvailableAsset_name = putByronWalletResponseBody200AssetsAvailableAsset_name,
                                                                                                                                                                                                                                                                putByronWalletResponseBody200AssetsAvailablePolicy_id = putByronWalletResponseBody200AssetsAvailablePolicy_id,
                                                                                                                                                                                                                                                                putByronWalletResponseBody200AssetsAvailableQuantity = putByronWalletResponseBody200AssetsAvailableQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.assets.properties.total.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PutByronWalletResponseBody200AssetsTotal = PutByronWalletResponseBody200AssetsTotal {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  putByronWalletResponseBody200AssetsTotalAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , putByronWalletResponseBody200AssetsTotalPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , putByronWalletResponseBody200AssetsTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200AssetsTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsTotalQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200AssetsTotalQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200AssetsTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200AssetsTotal" (\obj -> ((GHC.Base.pure PutByronWalletResponseBody200AssetsTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PutByronWalletResponseBody200AssetsTotal' with all required fields.
mkPutByronWalletResponseBody200AssetsTotal :: Data.Text.Internal.Text -- ^ 'putByronWalletResponseBody200AssetsTotalAsset_name'
  -> Data.Text.Internal.Text -- ^ 'putByronWalletResponseBody200AssetsTotalPolicy_id'
  -> GHC.Types.Int -- ^ 'putByronWalletResponseBody200AssetsTotalQuantity'
  -> PutByronWalletResponseBody200AssetsTotal
mkPutByronWalletResponseBody200AssetsTotal putByronWalletResponseBody200AssetsTotalAsset_name putByronWalletResponseBody200AssetsTotalPolicy_id putByronWalletResponseBody200AssetsTotalQuantity = PutByronWalletResponseBody200AssetsTotal{putByronWalletResponseBody200AssetsTotalAsset_name = putByronWalletResponseBody200AssetsTotalAsset_name,
                                                                                                                                                                                                                                            putByronWalletResponseBody200AssetsTotalPolicy_id = putByronWalletResponseBody200AssetsTotalPolicy_id,
                                                                                                                                                                                                                                            putByronWalletResponseBody200AssetsTotalQuantity = putByronWalletResponseBody200AssetsTotalQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.balance@ in the specification.
-- 
-- Wallet current Ada balance(s).
data PutByronWalletResponseBody200Balance = PutByronWalletResponseBody200Balance {
  -- | available: Available Ada UTxO balance (funds that can be spent without condition).
  putByronWalletResponseBody200BalanceAvailable :: PutByronWalletResponseBody200BalanceAvailable
  -- | reward: The Ada balance of the reward account for this wallet.
  , putByronWalletResponseBody200BalanceReward :: PutByronWalletResponseBody200BalanceReward
  -- | total: Total Ada balance (available balance plus pending change and reward balance).
  , putByronWalletResponseBody200BalanceTotal :: PutByronWalletResponseBody200BalanceTotal
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200Balance
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200BalanceAvailable obj] : ["reward" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200BalanceReward obj] : ["total" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200BalanceTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200BalanceAvailable obj] : ["reward" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200BalanceReward obj] : ["total" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200BalanceTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200Balance
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200Balance" (\obj -> ((GHC.Base.pure PutByronWalletResponseBody200Balance GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'PutByronWalletResponseBody200Balance' with all required fields.
mkPutByronWalletResponseBody200Balance :: PutByronWalletResponseBody200BalanceAvailable -- ^ 'putByronWalletResponseBody200BalanceAvailable'
  -> PutByronWalletResponseBody200BalanceReward -- ^ 'putByronWalletResponseBody200BalanceReward'
  -> PutByronWalletResponseBody200BalanceTotal -- ^ 'putByronWalletResponseBody200BalanceTotal'
  -> PutByronWalletResponseBody200Balance
mkPutByronWalletResponseBody200Balance putByronWalletResponseBody200BalanceAvailable putByronWalletResponseBody200BalanceReward putByronWalletResponseBody200BalanceTotal = PutByronWalletResponseBody200Balance{putByronWalletResponseBody200BalanceAvailable = putByronWalletResponseBody200BalanceAvailable,
                                                                                                                                                                                                                 putByronWalletResponseBody200BalanceReward = putByronWalletResponseBody200BalanceReward,
                                                                                                                                                                                                                 putByronWalletResponseBody200BalanceTotal = putByronWalletResponseBody200BalanceTotal}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.balance.properties.available@ in the specification.
-- 
-- Available Ada UTxO balance (funds that can be spent without condition).
data PutByronWalletResponseBody200BalanceAvailable = PutByronWalletResponseBody200BalanceAvailable {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  putByronWalletResponseBody200BalanceAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200BalanceAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200BalanceAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200BalanceAvailable" (\obj -> GHC.Base.pure PutByronWalletResponseBody200BalanceAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PutByronWalletResponseBody200BalanceAvailable' with all required fields.
mkPutByronWalletResponseBody200BalanceAvailable :: GHC.Types.Int -- ^ 'putByronWalletResponseBody200BalanceAvailableQuantity'
  -> PutByronWalletResponseBody200BalanceAvailable
mkPutByronWalletResponseBody200BalanceAvailable putByronWalletResponseBody200BalanceAvailableQuantity = PutByronWalletResponseBody200BalanceAvailable{putByronWalletResponseBody200BalanceAvailableQuantity = putByronWalletResponseBody200BalanceAvailableQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.balance.properties.reward@ in the specification.
-- 
-- The Ada balance of the reward account for this wallet.
data PutByronWalletResponseBody200BalanceReward = PutByronWalletResponseBody200BalanceReward {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  putByronWalletResponseBody200BalanceRewardQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200BalanceReward
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200BalanceRewardQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200BalanceRewardQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200BalanceReward
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200BalanceReward" (\obj -> GHC.Base.pure PutByronWalletResponseBody200BalanceReward GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PutByronWalletResponseBody200BalanceReward' with all required fields.
mkPutByronWalletResponseBody200BalanceReward :: GHC.Types.Int -- ^ 'putByronWalletResponseBody200BalanceRewardQuantity'
  -> PutByronWalletResponseBody200BalanceReward
mkPutByronWalletResponseBody200BalanceReward putByronWalletResponseBody200BalanceRewardQuantity = PutByronWalletResponseBody200BalanceReward{putByronWalletResponseBody200BalanceRewardQuantity = putByronWalletResponseBody200BalanceRewardQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.balance.properties.total@ in the specification.
-- 
-- Total Ada balance (available balance plus pending change and reward balance).
data PutByronWalletResponseBody200BalanceTotal = PutByronWalletResponseBody200BalanceTotal {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  putByronWalletResponseBody200BalanceTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200BalanceTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200BalanceTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200BalanceTotal" (\obj -> GHC.Base.pure PutByronWalletResponseBody200BalanceTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PutByronWalletResponseBody200BalanceTotal' with all required fields.
mkPutByronWalletResponseBody200BalanceTotal :: GHC.Types.Int -- ^ 'putByronWalletResponseBody200BalanceTotalQuantity'
  -> PutByronWalletResponseBody200BalanceTotal
mkPutByronWalletResponseBody200BalanceTotal putByronWalletResponseBody200BalanceTotalQuantity = PutByronWalletResponseBody200BalanceTotal{putByronWalletResponseBody200BalanceTotalQuantity = putByronWalletResponseBody200BalanceTotalQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.delegation@ in the specification.
-- 
-- Delegation settings
data PutByronWalletResponseBody200Delegation = PutByronWalletResponseBody200Delegation {
  -- | active: Currently active delegation status.
  putByronWalletResponseBody200DelegationActive :: PutByronWalletResponseBody200DelegationActive
  -- | next
  , putByronWalletResponseBody200DelegationNext :: ([PutByronWalletResponseBody200DelegationNext])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200Delegation
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200DelegationActive obj] : ["next" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200DelegationNext obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200DelegationActive obj] : ["next" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200DelegationNext obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200Delegation
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200Delegation" (\obj -> (GHC.Base.pure PutByronWalletResponseBody200Delegation GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "next"))
-- | Create a new 'PutByronWalletResponseBody200Delegation' with all required fields.
mkPutByronWalletResponseBody200Delegation :: PutByronWalletResponseBody200DelegationActive -- ^ 'putByronWalletResponseBody200DelegationActive'
  -> [PutByronWalletResponseBody200DelegationNext] -- ^ 'putByronWalletResponseBody200DelegationNext'
  -> PutByronWalletResponseBody200Delegation
mkPutByronWalletResponseBody200Delegation putByronWalletResponseBody200DelegationActive putByronWalletResponseBody200DelegationNext = PutByronWalletResponseBody200Delegation{putByronWalletResponseBody200DelegationActive = putByronWalletResponseBody200DelegationActive,
                                                                                                                                                                              putByronWalletResponseBody200DelegationNext = putByronWalletResponseBody200DelegationNext}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.delegation.properties.active@ in the specification.
-- 
-- Currently active delegation status.
data PutByronWalletResponseBody200DelegationActive = PutByronWalletResponseBody200DelegationActive {
  -- | status
  putByronWalletResponseBody200DelegationActiveStatus :: PutByronWalletResponseBody200DelegationActiveStatus
  -- | target: A unique Stake-Pool identifier (present only if status = \`delegating\`)
  , putByronWalletResponseBody200DelegationActiveTarget :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200DelegationActive
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["status" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200DelegationActiveStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (putByronWalletResponseBody200DelegationActiveTarget obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["status" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200DelegationActiveStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (putByronWalletResponseBody200DelegationActiveTarget obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200DelegationActive
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200DelegationActive" (\obj -> (GHC.Base.pure PutByronWalletResponseBody200DelegationActive GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "target"))
-- | Create a new 'PutByronWalletResponseBody200DelegationActive' with all required fields.
mkPutByronWalletResponseBody200DelegationActive :: PutByronWalletResponseBody200DelegationActiveStatus -- ^ 'putByronWalletResponseBody200DelegationActiveStatus'
  -> PutByronWalletResponseBody200DelegationActive
mkPutByronWalletResponseBody200DelegationActive putByronWalletResponseBody200DelegationActiveStatus = PutByronWalletResponseBody200DelegationActive{putByronWalletResponseBody200DelegationActiveStatus = putByronWalletResponseBody200DelegationActiveStatus,
                                                                                                                                                    putByronWalletResponseBody200DelegationActiveTarget = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.delegation.properties.active.properties.status@ in the specification.
-- 
-- 
data PutByronWalletResponseBody200DelegationActiveStatus =
   PutByronWalletResponseBody200DelegationActiveStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PutByronWalletResponseBody200DelegationActiveStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PutByronWalletResponseBody200DelegationActiveStatusEnumNot_delegating -- ^ Represents the JSON value @"not_delegating"@
  | PutByronWalletResponseBody200DelegationActiveStatusEnumDelegating -- ^ Represents the JSON value @"delegating"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200DelegationActiveStatus
    where toJSON (PutByronWalletResponseBody200DelegationActiveStatusOther val) = val
          toJSON (PutByronWalletResponseBody200DelegationActiveStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PutByronWalletResponseBody200DelegationActiveStatusEnumNot_delegating) = "not_delegating"
          toJSON (PutByronWalletResponseBody200DelegationActiveStatusEnumDelegating) = "delegating"
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200DelegationActiveStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "not_delegating" -> PutByronWalletResponseBody200DelegationActiveStatusEnumNot_delegating
                                            | val GHC.Classes.== "delegating" -> PutByronWalletResponseBody200DelegationActiveStatusEnumDelegating
                                            | GHC.Base.otherwise -> PutByronWalletResponseBody200DelegationActiveStatusOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.delegation.properties.next.items@ in the specification.
-- 
-- Next delegation status becomes active at the start of the second epoch after the corresponding delegation certificate was discovered. The exact moment is specified by changes_at
data PutByronWalletResponseBody200DelegationNext = PutByronWalletResponseBody200DelegationNext {
  -- | changes_at
  putByronWalletResponseBody200DelegationNextChanges_at :: PutByronWalletResponseBody200DelegationNextChanges_at
  -- | status
  , putByronWalletResponseBody200DelegationNextStatus :: PutByronWalletResponseBody200DelegationNextStatus
  -- | target: A unique Stake-Pool identifier (present only if status = \`delegating\`)
  , putByronWalletResponseBody200DelegationNextTarget :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200DelegationNext
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["changes_at" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200DelegationNextChanges_at obj] : ["status" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200DelegationNextStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (putByronWalletResponseBody200DelegationNextTarget obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["changes_at" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200DelegationNextChanges_at obj] : ["status" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200DelegationNextStatus obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("target" Data.Aeson.Types.ToJSON..=)) (putByronWalletResponseBody200DelegationNextTarget obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200DelegationNext
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200DelegationNext" (\obj -> ((GHC.Base.pure PutByronWalletResponseBody200DelegationNext GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "changes_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "target"))
-- | Create a new 'PutByronWalletResponseBody200DelegationNext' with all required fields.
mkPutByronWalletResponseBody200DelegationNext :: PutByronWalletResponseBody200DelegationNextChanges_at -- ^ 'putByronWalletResponseBody200DelegationNextChanges_at'
  -> PutByronWalletResponseBody200DelegationNextStatus -- ^ 'putByronWalletResponseBody200DelegationNextStatus'
  -> PutByronWalletResponseBody200DelegationNext
mkPutByronWalletResponseBody200DelegationNext putByronWalletResponseBody200DelegationNextChanges_at putByronWalletResponseBody200DelegationNextStatus = PutByronWalletResponseBody200DelegationNext{putByronWalletResponseBody200DelegationNextChanges_at = putByronWalletResponseBody200DelegationNextChanges_at,
                                                                                                                                                                                                    putByronWalletResponseBody200DelegationNextStatus = putByronWalletResponseBody200DelegationNextStatus,
                                                                                                                                                                                                    putByronWalletResponseBody200DelegationNextTarget = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.delegation.properties.next.items.properties.changes_at@ in the specification.
-- 
-- 
data PutByronWalletResponseBody200DelegationNextChanges_at = PutByronWalletResponseBody200DelegationNextChanges_at {
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  putByronWalletResponseBody200DelegationNextChanges_atEpoch_number :: GHC.Types.Int
  -- | epoch_start_time
  , putByronWalletResponseBody200DelegationNextChanges_atEpoch_start_time :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200DelegationNextChanges_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["epoch_number" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200DelegationNextChanges_atEpoch_number obj] : ["epoch_start_time" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200DelegationNextChanges_atEpoch_start_time obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["epoch_number" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200DelegationNextChanges_atEpoch_number obj] : ["epoch_start_time" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200DelegationNextChanges_atEpoch_start_time obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200DelegationNextChanges_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200DelegationNextChanges_at" (\obj -> (GHC.Base.pure PutByronWalletResponseBody200DelegationNextChanges_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_start_time"))
-- | Create a new 'PutByronWalletResponseBody200DelegationNextChanges_at' with all required fields.
mkPutByronWalletResponseBody200DelegationNextChanges_at :: GHC.Types.Int -- ^ 'putByronWalletResponseBody200DelegationNextChanges_atEpoch_number'
  -> Data.Text.Internal.Text -- ^ 'putByronWalletResponseBody200DelegationNextChanges_atEpoch_start_time'
  -> PutByronWalletResponseBody200DelegationNextChanges_at
mkPutByronWalletResponseBody200DelegationNextChanges_at putByronWalletResponseBody200DelegationNextChanges_atEpoch_number putByronWalletResponseBody200DelegationNextChanges_atEpoch_start_time = PutByronWalletResponseBody200DelegationNextChanges_at{putByronWalletResponseBody200DelegationNextChanges_atEpoch_number = putByronWalletResponseBody200DelegationNextChanges_atEpoch_number,
                                                                                                                                                                                                                                                        putByronWalletResponseBody200DelegationNextChanges_atEpoch_start_time = putByronWalletResponseBody200DelegationNextChanges_atEpoch_start_time}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.delegation.properties.next.items.properties.status@ in the specification.
-- 
-- 
data PutByronWalletResponseBody200DelegationNextStatus =
   PutByronWalletResponseBody200DelegationNextStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PutByronWalletResponseBody200DelegationNextStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PutByronWalletResponseBody200DelegationNextStatusEnumNot_delegating -- ^ Represents the JSON value @"not_delegating"@
  | PutByronWalletResponseBody200DelegationNextStatusEnumDelegating -- ^ Represents the JSON value @"delegating"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200DelegationNextStatus
    where toJSON (PutByronWalletResponseBody200DelegationNextStatusOther val) = val
          toJSON (PutByronWalletResponseBody200DelegationNextStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PutByronWalletResponseBody200DelegationNextStatusEnumNot_delegating) = "not_delegating"
          toJSON (PutByronWalletResponseBody200DelegationNextStatusEnumDelegating) = "delegating"
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200DelegationNextStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "not_delegating" -> PutByronWalletResponseBody200DelegationNextStatusEnumNot_delegating
                                            | val GHC.Classes.== "delegating" -> PutByronWalletResponseBody200DelegationNextStatusEnumDelegating
                                            | GHC.Base.otherwise -> PutByronWalletResponseBody200DelegationNextStatusOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.passphrase@ in the specification.
-- 
-- Information about the wallet\'s passphrase
data PutByronWalletResponseBody200Passphrase = PutByronWalletResponseBody200Passphrase {
  -- | last_updated_at
  putByronWalletResponseBody200PassphraseLast_updated_at :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200Passphrase
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200PassphraseLast_updated_at obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200PassphraseLast_updated_at obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200Passphrase
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200Passphrase" (\obj -> GHC.Base.pure PutByronWalletResponseBody200Passphrase GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "last_updated_at"))
-- | Create a new 'PutByronWalletResponseBody200Passphrase' with all required fields.
mkPutByronWalletResponseBody200Passphrase :: Data.Text.Internal.Text -- ^ 'putByronWalletResponseBody200PassphraseLast_updated_at'
  -> PutByronWalletResponseBody200Passphrase
mkPutByronWalletResponseBody200Passphrase putByronWalletResponseBody200PassphraseLast_updated_at = PutByronWalletResponseBody200Passphrase{putByronWalletResponseBody200PassphraseLast_updated_at = putByronWalletResponseBody200PassphraseLast_updated_at}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.state@ in the specification.
-- 
-- Whether a wallet is ready to use or still syncing
data PutByronWalletResponseBody200State = PutByronWalletResponseBody200State {
  -- | progress: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == syncing
  -- \<\/span>\<br\/>
  putByronWalletResponseBody200StateProgress :: (GHC.Maybe.Maybe PutByronWalletResponseBody200StateProgress)
  -- | status
  , putByronWalletResponseBody200StateStatus :: PutByronWalletResponseBody200StateStatus
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200State
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (putByronWalletResponseBody200StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200StateStatus obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (putByronWalletResponseBody200StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200StateStatus obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200State
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200State" (\obj -> (GHC.Base.pure PutByronWalletResponseBody200State GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "progress")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status"))
-- | Create a new 'PutByronWalletResponseBody200State' with all required fields.
mkPutByronWalletResponseBody200State :: PutByronWalletResponseBody200StateStatus -- ^ 'putByronWalletResponseBody200StateStatus'
  -> PutByronWalletResponseBody200State
mkPutByronWalletResponseBody200State putByronWalletResponseBody200StateStatus = PutByronWalletResponseBody200State{putByronWalletResponseBody200StateProgress = GHC.Maybe.Nothing,
                                                                                                                   putByronWalletResponseBody200StateStatus = putByronWalletResponseBody200StateStatus}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.state.properties.progress@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == syncing
-- \<\/span>\<br\/>
data PutByronWalletResponseBody200StateProgress = PutByronWalletResponseBody200StateProgress {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  putByronWalletResponseBody200StateProgressQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200StateProgress
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200StateProgress
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200StateProgress" (\obj -> GHC.Base.pure PutByronWalletResponseBody200StateProgress GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PutByronWalletResponseBody200StateProgress' with all required fields.
mkPutByronWalletResponseBody200StateProgress :: GHC.Types.Double -- ^ 'putByronWalletResponseBody200StateProgressQuantity'
  -> PutByronWalletResponseBody200StateProgress
mkPutByronWalletResponseBody200StateProgress putByronWalletResponseBody200StateProgressQuantity = PutByronWalletResponseBody200StateProgress{putByronWalletResponseBody200StateProgressQuantity = putByronWalletResponseBody200StateProgressQuantity}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.state.properties.status@ in the specification.
-- 
-- 
data PutByronWalletResponseBody200StateStatus =
   PutByronWalletResponseBody200StateStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PutByronWalletResponseBody200StateStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PutByronWalletResponseBody200StateStatusEnumReady -- ^ Represents the JSON value @"ready"@
  | PutByronWalletResponseBody200StateStatusEnumSyncing -- ^ Represents the JSON value @"syncing"@
  | PutByronWalletResponseBody200StateStatusEnumNot_responding -- ^ Represents the JSON value @"not_responding"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200StateStatus
    where toJSON (PutByronWalletResponseBody200StateStatusOther val) = val
          toJSON (PutByronWalletResponseBody200StateStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PutByronWalletResponseBody200StateStatusEnumReady) = "ready"
          toJSON (PutByronWalletResponseBody200StateStatusEnumSyncing) = "syncing"
          toJSON (PutByronWalletResponseBody200StateStatusEnumNot_responding) = "not_responding"
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200StateStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "ready" -> PutByronWalletResponseBody200StateStatusEnumReady
                                            | val GHC.Classes.== "syncing" -> PutByronWalletResponseBody200StateStatusEnumSyncing
                                            | val GHC.Classes.== "not_responding" -> PutByronWalletResponseBody200StateStatusEnumNot_responding
                                            | GHC.Base.otherwise -> PutByronWalletResponseBody200StateStatusOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.tip@ in the specification.
-- 
-- A reference to a particular time slot, and the block height at that point.
data PutByronWalletResponseBody200Tip = PutByronWalletResponseBody200Tip {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  putByronWalletResponseBody200TipAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , putByronWalletResponseBody200TipEpoch_number :: GHC.Types.Int
  -- | height
  , putByronWalletResponseBody200TipHeight :: PutByronWalletResponseBody200TipHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , putByronWalletResponseBody200TipSlot_number :: GHC.Types.Int
  -- | time
  , putByronWalletResponseBody200TipTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200Tip
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200TipTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200TipTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200Tip
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200Tip" (\obj -> ((((GHC.Base.pure PutByronWalletResponseBody200Tip GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'PutByronWalletResponseBody200Tip' with all required fields.
mkPutByronWalletResponseBody200Tip :: GHC.Types.Int -- ^ 'putByronWalletResponseBody200TipAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'putByronWalletResponseBody200TipEpoch_number'
  -> PutByronWalletResponseBody200TipHeight -- ^ 'putByronWalletResponseBody200TipHeight'
  -> GHC.Types.Int -- ^ 'putByronWalletResponseBody200TipSlot_number'
  -> Data.Text.Internal.Text -- ^ 'putByronWalletResponseBody200TipTime'
  -> PutByronWalletResponseBody200Tip
mkPutByronWalletResponseBody200Tip putByronWalletResponseBody200TipAbsolute_slot_number putByronWalletResponseBody200TipEpoch_number putByronWalletResponseBody200TipHeight putByronWalletResponseBody200TipSlot_number putByronWalletResponseBody200TipTime = PutByronWalletResponseBody200Tip{putByronWalletResponseBody200TipAbsolute_slot_number = putByronWalletResponseBody200TipAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                putByronWalletResponseBody200TipEpoch_number = putByronWalletResponseBody200TipEpoch_number,
                                                                                                                                                                                                                                                                                                putByronWalletResponseBody200TipHeight = putByronWalletResponseBody200TipHeight,
                                                                                                                                                                                                                                                                                                putByronWalletResponseBody200TipSlot_number = putByronWalletResponseBody200TipSlot_number,
                                                                                                                                                                                                                                                                                                putByronWalletResponseBody200TipTime = putByronWalletResponseBody200TipTime}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.200.content.application\/json.schema.properties.tip.properties.height@ in the specification.
-- 
-- 
data PutByronWalletResponseBody200TipHeight = PutByronWalletResponseBody200TipHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  putByronWalletResponseBody200TipHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody200TipHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody200TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody200TipHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody200TipHeight" (\obj -> GHC.Base.pure PutByronWalletResponseBody200TipHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PutByronWalletResponseBody200TipHeight' with all required fields.
mkPutByronWalletResponseBody200TipHeight :: GHC.Types.Int -- ^ 'putByronWalletResponseBody200TipHeightQuantity'
  -> PutByronWalletResponseBody200TipHeight
mkPutByronWalletResponseBody200TipHeight putByronWalletResponseBody200TipHeightQuantity = PutByronWalletResponseBody200TipHeight{putByronWalletResponseBody200TipHeightQuantity = putByronWalletResponseBody200TipHeightQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data PutByronWalletResponseBody400 = PutByronWalletResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  putByronWalletResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody400" (\obj -> GHC.Base.pure PutByronWalletResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutByronWalletResponseBody400' with all required fields.
mkPutByronWalletResponseBody400 :: Data.Text.Internal.Text -- ^ 'putByronWalletResponseBody400Message'
  -> PutByronWalletResponseBody400
mkPutByronWalletResponseBody400 putByronWalletResponseBody400Message = PutByronWalletResponseBody400{putByronWalletResponseBody400Message = putByronWalletResponseBody400Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data PutByronWalletResponseBody404 = PutByronWalletResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  putByronWalletResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody404" (\obj -> GHC.Base.pure PutByronWalletResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutByronWalletResponseBody404' with all required fields.
mkPutByronWalletResponseBody404 :: Data.Text.Internal.Text -- ^ 'putByronWalletResponseBody404Message'
  -> PutByronWalletResponseBody404
mkPutByronWalletResponseBody404 putByronWalletResponseBody404Message = PutByronWalletResponseBody404{putByronWalletResponseBody404Message = putByronWalletResponseBody404Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data PutByronWalletResponseBody406 = PutByronWalletResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  putByronWalletResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody406" (\obj -> GHC.Base.pure PutByronWalletResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutByronWalletResponseBody406' with all required fields.
mkPutByronWalletResponseBody406 :: Data.Text.Internal.Text -- ^ 'putByronWalletResponseBody406Message'
  -> PutByronWalletResponseBody406
mkPutByronWalletResponseBody406 putByronWalletResponseBody406Message = PutByronWalletResponseBody406{putByronWalletResponseBody406Message = putByronWalletResponseBody406Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}.PUT.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data PutByronWalletResponseBody415 = PutByronWalletResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  putByronWalletResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutByronWalletResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putByronWalletResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutByronWalletResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutByronWalletResponseBody415" (\obj -> GHC.Base.pure PutByronWalletResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutByronWalletResponseBody415' with all required fields.
mkPutByronWalletResponseBody415 :: Data.Text.Internal.Text -- ^ 'putByronWalletResponseBody415Message'
  -> PutByronWalletResponseBody415
mkPutByronWalletResponseBody415 putByronWalletResponseBody415Message = PutByronWalletResponseBody415{putByronWalletResponseBody415Message = putByronWalletResponseBody415Message}
-- | > PUT /byron-wallets/{walletId}
-- 
-- The same as 'putByronWallet' but accepts an explicit configuration.
putByronWalletWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutByronWalletRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response PutByronWalletResponse) -- ^ Monadic computation which returns the result of the operation
putByronWalletWithConfiguration config
                                walletId
                                body = GHC.Base.fmap (\response_6 -> GHC.Base.fmap (Data.Either.either PutByronWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                              PutByronWalletResponseBody200)
                                                                                                                                                                                | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                              PutByronWalletResponseBody400)
                                                                                                                                                                                | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                              PutByronWalletResponseBody404)
                                                                                                                                                                                | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                PutByronWalletResponseBody406)
                                                                                                                                                                                | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PutByronWalletResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                PutByronWalletResponseBody415)
                                                                                                                                                                                | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_6) response_6) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > PUT /byron-wallets/{walletId}
-- 
-- The same as 'putByronWallet' but returns the raw 'Data.ByteString.ByteString'.
putByronWalletRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutByronWalletRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
putByronWalletRaw walletId
                  body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > PUT /byron-wallets/{walletId}
-- 
-- The same as 'putByronWallet' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
putByronWalletWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutByronWalletRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
putByronWalletWithConfigurationRaw config
                                   walletId
                                   body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
