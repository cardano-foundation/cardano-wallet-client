-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation getTransaction
module Wallet.Operations.GetTransaction where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > GET /wallets/{walletId}/transactions/{transactionId}
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Get transaction by id.
getTransaction :: forall m . Wallet.Common.MonadHTTP m => GetTransactionParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response GetTransactionResponse) -- ^ Monadic computation which returns the result of the operation
getTransaction parameters = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either GetTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetTransactionResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                   GetTransactionResponseBody200)
                                                                                                                                                                     | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> GetTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                   GetTransactionResponseBody404Variants)
                                                                                                                                                                     | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> GetTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                   GetTransactionResponseBody406)
                                                                                                                                                                     | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getTransactionParametersPathWalletId parameters))) GHC.Base.<> ("/transactions/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getTransactionParametersPathTransactionId parameters))) GHC.Base.<> "")))) [Wallet.Common.QueryParameter (Data.Text.pack "simple-metadata") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> getTransactionParametersQuerySimple_metadata parameters) (Data.Text.pack "form") GHC.Types.False])
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.parameters@ in the specification.
-- 
-- 
data GetTransactionParameters = GetTransactionParameters {
  -- | pathTransactionId: Represents the parameter named \'transactionId\'
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getTransactionParametersPathTransactionId :: Data.Text.Internal.Text
  -- | pathWalletId: Represents the parameter named \'walletId\'
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  , getTransactionParametersPathWalletId :: Data.Text.Internal.Text
  -- | querySimple-metadata: Represents the parameter named \'simple-metadata\'
  -- 
  -- When present (or equal to true) in the query, the metadata format for the
  -- transaction(s) in the output will be untyped plain json as specified in
  -- [CIP 25](https:\/\/cips.cardano.org\/cips\/cip25\/)
  , getTransactionParametersQuerySimple_metadata :: (GHC.Maybe.Maybe GHC.Types.Bool)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionParameters
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pathTransactionId" Data.Aeson.Types.ToJSON..= getTransactionParametersPathTransactionId obj] : ["pathWalletId" Data.Aeson.Types.ToJSON..= getTransactionParametersPathWalletId obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("querySimple-metadata" Data.Aeson.Types.ToJSON..=)) (getTransactionParametersQuerySimple_metadata obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pathTransactionId" Data.Aeson.Types.ToJSON..= getTransactionParametersPathTransactionId obj] : ["pathWalletId" Data.Aeson.Types.ToJSON..= getTransactionParametersPathWalletId obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("querySimple-metadata" Data.Aeson.Types.ToJSON..=)) (getTransactionParametersQuerySimple_metadata obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionParameters
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionParameters" (\obj -> ((GHC.Base.pure GetTransactionParameters GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pathTransactionId")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pathWalletId")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "querySimple-metadata"))
-- | Create a new 'GetTransactionParameters' with all required fields.
mkGetTransactionParameters :: Data.Text.Internal.Text -- ^ 'getTransactionParametersPathTransactionId'
  -> Data.Text.Internal.Text -- ^ 'getTransactionParametersPathWalletId'
  -> GetTransactionParameters
mkGetTransactionParameters getTransactionParametersPathTransactionId getTransactionParametersPathWalletId = GetTransactionParameters{getTransactionParametersPathTransactionId = getTransactionParametersPathTransactionId,
                                                                                                                                     getTransactionParametersPathWalletId = getTransactionParametersPathWalletId,
                                                                                                                                     getTransactionParametersQuerySimple_metadata = GHC.Maybe.Nothing}
-- | Represents a response of the operation 'getTransaction'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'GetTransactionResponseError' is used.
data GetTransactionResponse =
   GetTransactionResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | GetTransactionResponse200 GetTransactionResponseBody200 -- ^ OK
  | GetTransactionResponse404 GetTransactionResponseBody404Variants -- ^ Not Found
  | GetTransactionResponse406 GetTransactionResponseBody406 -- ^ Not Acceptable
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema@ in the specification.
-- 
-- 
data GetTransactionResponseBody200 = GetTransactionResponseBody200 {
  -- | amount: An amount of Ada spent or received, from the perspective of the wallet.
  -- 
  -- That is, for outgoing transaction, it represents the amount of Ada consumed
  -- as inputs including the amount of Ada spent as fees or deposits.
  -- 
  -- For incoming transaction, it represents the total amount of Ada received to
  -- addresses that belong to the wallet.
  getTransactionResponseBody200Amount :: GetTransactionResponseBody200Amount
  -- | burn
  , getTransactionResponseBody200Burn :: (GHC.Maybe.Maybe GetTransactionResponseBody200Burn)
  -- | certificates
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , getTransactionResponseBody200Certificates :: (GHC.Maybe.Maybe ([GetTransactionResponseBody200CertificatesVariants]))
  -- | collateral: A list of transaction inputs used for collateral.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , getTransactionResponseBody200Collateral :: (GHC.Maybe.Maybe ([GetTransactionResponseBody200Collateral]))
  -- | collateral_outputs: A list of collateral return outputs with amounts specified.
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 1 items
  -- * Must have a minimum of 0 items
  , getTransactionResponseBody200Collateral_outputs :: (GHC.Maybe.Maybe ([GetTransactionResponseBody200Collateral_outputs]))
  -- | deposit_returned: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , getTransactionResponseBody200Deposit_returned :: GetTransactionResponseBody200Deposit_returned
  -- | deposit_taken: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , getTransactionResponseBody200Deposit_taken :: GetTransactionResponseBody200Deposit_taken
  -- | depth: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Current depth of the transaction in the local chain
  , getTransactionResponseBody200Depth :: (GHC.Maybe.Maybe GetTransactionResponseBody200Depth)
  -- | direction
  , getTransactionResponseBody200Direction :: GetTransactionResponseBody200Direction
  -- | expires_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending OR status == expired
  -- \<\/span>\<br\/>
  -- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
  , getTransactionResponseBody200Expires_at :: (GHC.Maybe.Maybe GetTransactionResponseBody200Expires_at)
  -- | extra_signatures
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , getTransactionResponseBody200Extra_signatures :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | fee: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , getTransactionResponseBody200Fee :: GetTransactionResponseBody200Fee
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , getTransactionResponseBody200Id :: Data.Text.Internal.Text
  -- | inputs: A list of transaction inputs.
  -- 
  -- \`assets\` and \`address\` are always present for \`outgoing\`
  -- transactions but generally absent for \`incoming\`
  -- transactions. This information is present on the Cardano explorer,
  -- but is not tracked by the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , getTransactionResponseBody200Inputs :: ([GetTransactionResponseBody200Inputs])
  -- | inserted_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Absolute time at which the transaction was inserted in a block.
  , getTransactionResponseBody200Inserted_at :: (GHC.Maybe.Maybe GetTransactionResponseBody200Inserted_at)
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  , getTransactionResponseBody200Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | mint
  , getTransactionResponseBody200Mint :: (GHC.Maybe.Maybe GetTransactionResponseBody200Mint)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , getTransactionResponseBody200Outputs :: ([GetTransactionResponseBody200Outputs])
  -- | pending_since: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending
  -- \<\/span>\<br\/>
  -- The point in time at which a transaction became pending.
  , getTransactionResponseBody200Pending_since :: (GHC.Maybe.Maybe GetTransactionResponseBody200Pending_since)
  -- | script_integrity: A script data integrity hash - 32 bytes
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^(script_data)1[0-9a-z]*\$\'
  , getTransactionResponseBody200Script_integrity :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | script_validity: Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
  -- used in the transaction validated or not. Validity may be null if this
  -- transaction was from an era that doesn\'t support phase-2 monetary policy
  -- scripts, or is a pending transaction (we don\'t know if validation passed or
  -- failed until the transaction hits the ledger).
  , getTransactionResponseBody200Script_validity :: (GHC.Maybe.Maybe (Wallet.Common.Nullable GetTransactionResponseBody200Script_validityNonNullable))
  -- | status: Current transaction status.
  -- 
  --   \`\`\`
  --        *-----------*
  --   ---> |  PENDING  |----------------*
  --        *-----------*                |
  --              |                      |
  --              V                      V
  --        *-----------*          *-----------*
  --        |           |---------->  EXPIRED  |
  --        |           |  (ttl)   *-----------*
  --        | SUBMITTED |
  --        |           \<----------------*
  --        |           |                |
  --        *-----------*           (rollback)
  --               |                     |
  --          (in ledger)          *-----------*
  --               |               |           |
  --               *---------------> IN_LEDGER |
  --                               |           |
  --                               *-----------*
  --   \`\`\`
  , getTransactionResponseBody200Status :: GetTransactionResponseBody200Status
  -- | validity_interval
  , getTransactionResponseBody200Validity_interval :: (GHC.Maybe.Maybe GetTransactionResponseBody200Validity_interval)
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , getTransactionResponseBody200Withdrawals :: ([GetTransactionResponseBody200Withdrawals])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Fee obj] : ["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Withdrawals obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Fee obj] : ["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Withdrawals obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200" (\obj -> (((((((((((((((((((((((GHC.Base.pure GetTransactionResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "burn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral_outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "depth")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "direction")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "expires_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "extra_signatures")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fee")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "inserted_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pending_since")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_integrity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_validity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "validity_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "withdrawals"))
-- | Create a new 'GetTransactionResponseBody200' with all required fields.
mkGetTransactionResponseBody200 :: GetTransactionResponseBody200Amount -- ^ 'getTransactionResponseBody200Amount'
  -> GetTransactionResponseBody200Deposit_returned -- ^ 'getTransactionResponseBody200Deposit_returned'
  -> GetTransactionResponseBody200Deposit_taken -- ^ 'getTransactionResponseBody200Deposit_taken'
  -> GetTransactionResponseBody200Direction -- ^ 'getTransactionResponseBody200Direction'
  -> GetTransactionResponseBody200Fee -- ^ 'getTransactionResponseBody200Fee'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200Id'
  -> [GetTransactionResponseBody200Inputs] -- ^ 'getTransactionResponseBody200Inputs'
  -> [GetTransactionResponseBody200Outputs] -- ^ 'getTransactionResponseBody200Outputs'
  -> GetTransactionResponseBody200Status -- ^ 'getTransactionResponseBody200Status'
  -> [GetTransactionResponseBody200Withdrawals] -- ^ 'getTransactionResponseBody200Withdrawals'
  -> GetTransactionResponseBody200
mkGetTransactionResponseBody200 getTransactionResponseBody200Amount getTransactionResponseBody200Deposit_returned getTransactionResponseBody200Deposit_taken getTransactionResponseBody200Direction getTransactionResponseBody200Fee getTransactionResponseBody200Id getTransactionResponseBody200Inputs getTransactionResponseBody200Outputs getTransactionResponseBody200Status getTransactionResponseBody200Withdrawals = GetTransactionResponseBody200{getTransactionResponseBody200Amount = getTransactionResponseBody200Amount,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Burn = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Certificates = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Collateral = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Collateral_outputs = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Deposit_returned = getTransactionResponseBody200Deposit_returned,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Deposit_taken = getTransactionResponseBody200Deposit_taken,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Depth = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Direction = getTransactionResponseBody200Direction,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Expires_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Extra_signatures = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Fee = getTransactionResponseBody200Fee,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Id = getTransactionResponseBody200Id,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Inputs = getTransactionResponseBody200Inputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Inserted_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Mint = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Outputs = getTransactionResponseBody200Outputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Pending_since = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Script_integrity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Script_validity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Status = getTransactionResponseBody200Status,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Validity_interval = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                           getTransactionResponseBody200Withdrawals = getTransactionResponseBody200Withdrawals}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.amount@ in the specification.
-- 
-- An amount of Ada spent or received, from the perspective of the wallet.
-- 
-- That is, for outgoing transaction, it represents the amount of Ada consumed
-- as inputs including the amount of Ada spent as fees or deposits.
-- 
-- For incoming transaction, it represents the total amount of Ada received to
-- addresses that belong to the wallet.
data GetTransactionResponseBody200Amount = GetTransactionResponseBody200Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Amount" (\obj -> GHC.Base.pure GetTransactionResponseBody200Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200Amount' with all required fields.
mkGetTransactionResponseBody200Amount :: GHC.Types.Int -- ^ 'getTransactionResponseBody200AmountQuantity'
  -> GetTransactionResponseBody200Amount
mkGetTransactionResponseBody200Amount getTransactionResponseBody200AmountQuantity = GetTransactionResponseBody200Amount{getTransactionResponseBody200AmountQuantity = getTransactionResponseBody200AmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn@ in the specification.
-- 
-- 
data GetTransactionResponseBody200Burn = GetTransactionResponseBody200Burn {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  getTransactionResponseBody200BurnTokens :: ([GetTransactionResponseBody200BurnTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , getTransactionResponseBody200BurnWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , getTransactionResponseBody200BurnWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200BurnWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200BurnWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Burn" (\obj -> ((GHC.Base.pure GetTransactionResponseBody200Burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'GetTransactionResponseBody200Burn' with all required fields.
mkGetTransactionResponseBody200Burn :: [GetTransactionResponseBody200BurnTokens] -- ^ 'getTransactionResponseBody200BurnTokens'
  -> GetTransactionResponseBody200Burn
mkGetTransactionResponseBody200Burn getTransactionResponseBody200BurnTokens = GetTransactionResponseBody200Burn{getTransactionResponseBody200BurnTokens = getTransactionResponseBody200BurnTokens,
                                                                                                                getTransactionResponseBody200BurnWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                getTransactionResponseBody200BurnWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items@ in the specification.
-- 
-- 
data GetTransactionResponseBody200BurnTokens = GetTransactionResponseBody200BurnTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getTransactionResponseBody200BurnTokensAssets :: ([GetTransactionResponseBody200BurnTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getTransactionResponseBody200BurnTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , getTransactionResponseBody200BurnTokensPolicy_script :: GetTransactionResponseBody200BurnTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200BurnTokens" (\obj -> ((GHC.Base.pure GetTransactionResponseBody200BurnTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'GetTransactionResponseBody200BurnTokens' with all required fields.
mkGetTransactionResponseBody200BurnTokens :: [GetTransactionResponseBody200BurnTokensAssets] -- ^ 'getTransactionResponseBody200BurnTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200BurnTokensPolicy_id'
  -> GetTransactionResponseBody200BurnTokensPolicy_scriptVariants -- ^ 'getTransactionResponseBody200BurnTokensPolicy_script'
  -> GetTransactionResponseBody200BurnTokens
mkGetTransactionResponseBody200BurnTokens getTransactionResponseBody200BurnTokensAssets getTransactionResponseBody200BurnTokensPolicy_id getTransactionResponseBody200BurnTokensPolicy_script = GetTransactionResponseBody200BurnTokens{getTransactionResponseBody200BurnTokensAssets = getTransactionResponseBody200BurnTokensAssets,
                                                                                                                                                                                                                                        getTransactionResponseBody200BurnTokensPolicy_id = getTransactionResponseBody200BurnTokensPolicy_id,
                                                                                                                                                                                                                                        getTransactionResponseBody200BurnTokensPolicy_script = getTransactionResponseBody200BurnTokensPolicy_script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data GetTransactionResponseBody200BurnTokensAssets = GetTransactionResponseBody200BurnTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getTransactionResponseBody200BurnTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , getTransactionResponseBody200BurnTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200BurnTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200BurnTokensAssets" (\obj -> ((GHC.Base.pure GetTransactionResponseBody200BurnTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200BurnTokensAssets' with all required fields.
mkGetTransactionResponseBody200BurnTokensAssets :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200BurnTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200BurnTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200BurnTokensAssetsQuantity'
  -> GetTransactionResponseBody200BurnTokensAssets
mkGetTransactionResponseBody200BurnTokensAssets getTransactionResponseBody200BurnTokensAssetsAsset_name getTransactionResponseBody200BurnTokensAssetsFingerprint getTransactionResponseBody200BurnTokensAssetsQuantity = GetTransactionResponseBody200BurnTokensAssets{getTransactionResponseBody200BurnTokensAssetsAsset_name = getTransactionResponseBody200BurnTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                       getTransactionResponseBody200BurnTokensAssetsFingerprint = getTransactionResponseBody200BurnTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                       getTransactionResponseBody200BurnTokensAssetsQuantity = getTransactionResponseBody200BurnTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1 = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference)
  -- | script
  , getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Script :: GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1' with all required fields.
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1 :: GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Script'
  -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1 getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Script = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1{getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                           getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Script = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference' with all required fields.
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex'
  -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference{getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                           getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2{getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3{getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 :: GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4{getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some{getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                            getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5{getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6{getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants =
   GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant2 GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
  | GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant3 GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
  | GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant4 GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
  | GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant5 GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
  | GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant6 GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2 = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info :: GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2' with all required fields.
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2 :: GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info'
  -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2 getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2{getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference' with all required fields.
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex'
  -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference{getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                           getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version :: GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info :: GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info{getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                       getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3 = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References :: ([GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3' with all required fields.
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3 :: [GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References] -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash'
  -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3 getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3{getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                     getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References' with all required fields.
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex'
  -> GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References
mkGetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex = GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References{getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                               getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex = getTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200BurnTokensPolicy_scriptVariants =
   GetTransactionResponseBody200BurnTokensPolicy_scriptVariant1 GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf1
  | GetTransactionResponseBody200BurnTokensPolicy_scriptVariant2 GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf2
  | GetTransactionResponseBody200BurnTokensPolicy_scriptVariant3 GetTransactionResponseBody200BurnTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200BurnTokensPolicy_scriptVariants
    where toJSON (GetTransactionResponseBody200BurnTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200BurnTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200BurnTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200BurnTokensPolicy_scriptVariants
    where parseJSON val = case (GetTransactionResponseBody200BurnTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200BurnTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200BurnTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data GetTransactionResponseBody200CertificatesOneOf1 = GetTransactionResponseBody200CertificatesOneOf1 {
  -- | certificate_type
  getTransactionResponseBody200CertificatesOneOf1Certificate_type :: GetTransactionResponseBody200CertificatesOneOf1Certificate_type
  -- | pool: A unique identifier for the pool.
  , getTransactionResponseBody200CertificatesOneOf1Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , getTransactionResponseBody200CertificatesOneOf1Reward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200CertificatesOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200CertificatesOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200CertificatesOneOf1" (\obj -> ((GHC.Base.pure GetTransactionResponseBody200CertificatesOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'GetTransactionResponseBody200CertificatesOneOf1' with all required fields.
mkGetTransactionResponseBody200CertificatesOneOf1 :: GetTransactionResponseBody200CertificatesOneOf1Certificate_type -- ^ 'getTransactionResponseBody200CertificatesOneOf1Certificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'getTransactionResponseBody200CertificatesOneOf1Reward_account_path'
  -> GetTransactionResponseBody200CertificatesOneOf1
mkGetTransactionResponseBody200CertificatesOneOf1 getTransactionResponseBody200CertificatesOneOf1Certificate_type getTransactionResponseBody200CertificatesOneOf1Reward_account_path = GetTransactionResponseBody200CertificatesOneOf1{getTransactionResponseBody200CertificatesOneOf1Certificate_type = getTransactionResponseBody200CertificatesOneOf1Certificate_type,
                                                                                                                                                                                                                                       getTransactionResponseBody200CertificatesOneOf1Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                       getTransactionResponseBody200CertificatesOneOf1Reward_account_path = getTransactionResponseBody200CertificatesOneOf1Reward_account_path}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data GetTransactionResponseBody200CertificatesOneOf1Certificate_type =
   GetTransactionResponseBody200CertificatesOneOf1Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetTransactionResponseBody200CertificatesOneOf1Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | GetTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | GetTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200CertificatesOneOf1Certificate_type
    where toJSON (GetTransactionResponseBody200CertificatesOneOf1Certificate_typeOther val) = val
          toJSON (GetTransactionResponseBody200CertificatesOneOf1Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumJoin_pool) = "join_pool"
          toJSON (GetTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (GetTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200CertificatesOneOf1Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> GetTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> GetTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> GetTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> GetTransactionResponseBody200CertificatesOneOf1Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate not belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data GetTransactionResponseBody200CertificatesOneOf2 = GetTransactionResponseBody200CertificatesOneOf2 {
  -- | certificate_type
  getTransactionResponseBody200CertificatesOneOf2Certificate_type :: GetTransactionResponseBody200CertificatesOneOf2Certificate_type
  -- | pool: A unique identifier for the pool.
  , getTransactionResponseBody200CertificatesOneOf2Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account
  , getTransactionResponseBody200CertificatesOneOf2Reward_account :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200CertificatesOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf2Reward_account obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf2Reward_account obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200CertificatesOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200CertificatesOneOf2" (\obj -> ((GHC.Base.pure GetTransactionResponseBody200CertificatesOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account"))
-- | Create a new 'GetTransactionResponseBody200CertificatesOneOf2' with all required fields.
mkGetTransactionResponseBody200CertificatesOneOf2 :: GetTransactionResponseBody200CertificatesOneOf2Certificate_type -- ^ 'getTransactionResponseBody200CertificatesOneOf2Certificate_type'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200CertificatesOneOf2Reward_account'
  -> GetTransactionResponseBody200CertificatesOneOf2
mkGetTransactionResponseBody200CertificatesOneOf2 getTransactionResponseBody200CertificatesOneOf2Certificate_type getTransactionResponseBody200CertificatesOneOf2Reward_account = GetTransactionResponseBody200CertificatesOneOf2{getTransactionResponseBody200CertificatesOneOf2Certificate_type = getTransactionResponseBody200CertificatesOneOf2Certificate_type,
                                                                                                                                                                                                                                  getTransactionResponseBody200CertificatesOneOf2Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                  getTransactionResponseBody200CertificatesOneOf2Reward_account = getTransactionResponseBody200CertificatesOneOf2Reward_account}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data GetTransactionResponseBody200CertificatesOneOf2Certificate_type =
   GetTransactionResponseBody200CertificatesOneOf2Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetTransactionResponseBody200CertificatesOneOf2Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumJoin_pool_external -- ^ Represents the JSON value @"join_pool_external"@
  | GetTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumQuit_pool_external -- ^ Represents the JSON value @"quit_pool_external"@
  | GetTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external -- ^ Represents the JSON value @"register_reward_account_external"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200CertificatesOneOf2Certificate_type
    where toJSON (GetTransactionResponseBody200CertificatesOneOf2Certificate_typeOther val) = val
          toJSON (GetTransactionResponseBody200CertificatesOneOf2Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumJoin_pool_external) = "join_pool_external"
          toJSON (GetTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumQuit_pool_external) = "quit_pool_external"
          toJSON (GetTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external) = "register_reward_account_external"
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200CertificatesOneOf2Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool_external" -> GetTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumJoin_pool_external
                                            | val GHC.Classes.== "quit_pool_external" -> GetTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumQuit_pool_external
                                            | val GHC.Classes.== "register_reward_account_external" -> GetTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external
                                            | GHC.Base.otherwise -> GetTransactionResponseBody200CertificatesOneOf2Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200CertificatesOneOf3 = GetTransactionResponseBody200CertificatesOneOf3 {
  -- | pool_cost: Estimated cost set by the pool operator when registering his pool.
  -- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  getTransactionResponseBody200CertificatesOneOf3Pool_cost :: GetTransactionResponseBody200CertificatesOneOf3Pool_cost
  -- | pool_id: A unique identifier for the pool.
  , getTransactionResponseBody200CertificatesOneOf3Pool_id :: Data.Text.Internal.Text
  -- | pool_margin: Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , getTransactionResponseBody200CertificatesOneOf3Pool_margin :: GetTransactionResponseBody200CertificatesOneOf3Pool_margin
  -- | pool_metadata
  , getTransactionResponseBody200CertificatesOneOf3Pool_metadata :: (GHC.Maybe.Maybe GetTransactionResponseBody200CertificatesOneOf3Pool_metadata)
  -- | pool_owners
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , getTransactionResponseBody200CertificatesOneOf3Pool_owners :: ([Data.Text.Internal.Text])
  -- | pool_pledge: Minimal stake amount that a stake pool is willing to honor.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , getTransactionResponseBody200CertificatesOneOf3Pool_pledge :: GetTransactionResponseBody200CertificatesOneOf3Pool_pledge
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200CertificatesOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200CertificatesOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200CertificatesOneOf3" (\obj -> (((((GHC.Base.pure GetTransactionResponseBody200CertificatesOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_cost")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_margin")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool_metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_owners")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_pledge"))
-- | Create a new 'GetTransactionResponseBody200CertificatesOneOf3' with all required fields.
mkGetTransactionResponseBody200CertificatesOneOf3 :: GetTransactionResponseBody200CertificatesOneOf3Pool_cost -- ^ 'getTransactionResponseBody200CertificatesOneOf3Pool_cost'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200CertificatesOneOf3Pool_id'
  -> GetTransactionResponseBody200CertificatesOneOf3Pool_margin -- ^ 'getTransactionResponseBody200CertificatesOneOf3Pool_margin'
  -> [Data.Text.Internal.Text] -- ^ 'getTransactionResponseBody200CertificatesOneOf3Pool_owners'
  -> GetTransactionResponseBody200CertificatesOneOf3Pool_pledge -- ^ 'getTransactionResponseBody200CertificatesOneOf3Pool_pledge'
  -> GetTransactionResponseBody200CertificatesOneOf3
mkGetTransactionResponseBody200CertificatesOneOf3 getTransactionResponseBody200CertificatesOneOf3Pool_cost getTransactionResponseBody200CertificatesOneOf3Pool_id getTransactionResponseBody200CertificatesOneOf3Pool_margin getTransactionResponseBody200CertificatesOneOf3Pool_owners getTransactionResponseBody200CertificatesOneOf3Pool_pledge = GetTransactionResponseBody200CertificatesOneOf3{getTransactionResponseBody200CertificatesOneOf3Pool_cost = getTransactionResponseBody200CertificatesOneOf3Pool_cost,
                                                                                                                                                                                                                                                                                                                                                                                                     getTransactionResponseBody200CertificatesOneOf3Pool_id = getTransactionResponseBody200CertificatesOneOf3Pool_id,
                                                                                                                                                                                                                                                                                                                                                                                                     getTransactionResponseBody200CertificatesOneOf3Pool_margin = getTransactionResponseBody200CertificatesOneOf3Pool_margin,
                                                                                                                                                                                                                                                                                                                                                                                                     getTransactionResponseBody200CertificatesOneOf3Pool_metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                     getTransactionResponseBody200CertificatesOneOf3Pool_owners = getTransactionResponseBody200CertificatesOneOf3Pool_owners,
                                                                                                                                                                                                                                                                                                                                                                                                     getTransactionResponseBody200CertificatesOneOf3Pool_pledge = getTransactionResponseBody200CertificatesOneOf3Pool_pledge}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_cost@ in the specification.
-- 
-- Estimated cost set by the pool operator when registering his pool.
-- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data GetTransactionResponseBody200CertificatesOneOf3Pool_cost = GetTransactionResponseBody200CertificatesOneOf3Pool_cost {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200CertificatesOneOf3Pool_costQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200CertificatesOneOf3Pool_cost
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200CertificatesOneOf3Pool_cost
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200CertificatesOneOf3Pool_cost" (\obj -> GHC.Base.pure GetTransactionResponseBody200CertificatesOneOf3Pool_cost GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200CertificatesOneOf3Pool_cost' with all required fields.
mkGetTransactionResponseBody200CertificatesOneOf3Pool_cost :: GHC.Types.Int -- ^ 'getTransactionResponseBody200CertificatesOneOf3Pool_costQuantity'
  -> GetTransactionResponseBody200CertificatesOneOf3Pool_cost
mkGetTransactionResponseBody200CertificatesOneOf3Pool_cost getTransactionResponseBody200CertificatesOneOf3Pool_costQuantity = GetTransactionResponseBody200CertificatesOneOf3Pool_cost{getTransactionResponseBody200CertificatesOneOf3Pool_costQuantity = getTransactionResponseBody200CertificatesOneOf3Pool_costQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_margin@ in the specification.
-- 
-- Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data GetTransactionResponseBody200CertificatesOneOf3Pool_margin = GetTransactionResponseBody200CertificatesOneOf3Pool_margin {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  getTransactionResponseBody200CertificatesOneOf3Pool_marginQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200CertificatesOneOf3Pool_margin
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200CertificatesOneOf3Pool_margin
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200CertificatesOneOf3Pool_margin" (\obj -> GHC.Base.pure GetTransactionResponseBody200CertificatesOneOf3Pool_margin GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200CertificatesOneOf3Pool_margin' with all required fields.
mkGetTransactionResponseBody200CertificatesOneOf3Pool_margin :: GHC.Types.Double -- ^ 'getTransactionResponseBody200CertificatesOneOf3Pool_marginQuantity'
  -> GetTransactionResponseBody200CertificatesOneOf3Pool_margin
mkGetTransactionResponseBody200CertificatesOneOf3Pool_margin getTransactionResponseBody200CertificatesOneOf3Pool_marginQuantity = GetTransactionResponseBody200CertificatesOneOf3Pool_margin{getTransactionResponseBody200CertificatesOneOf3Pool_marginQuantity = getTransactionResponseBody200CertificatesOneOf3Pool_marginQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_metadata@ in the specification.
-- 
-- 
data GetTransactionResponseBody200CertificatesOneOf3Pool_metadata = GetTransactionResponseBody200CertificatesOneOf3Pool_metadata {
  -- | hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getTransactionResponseBody200CertificatesOneOf3Pool_metadataHash :: Data.Text.Internal.Text
  -- | url: A URL to the stake pool\'s website.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 250
  -- * Must match pattern \'^https:\/\/.+\'
  , getTransactionResponseBody200CertificatesOneOf3Pool_metadataUrl :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200CertificatesOneOf3Pool_metadata
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200CertificatesOneOf3Pool_metadata
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200CertificatesOneOf3Pool_metadata" (\obj -> (GHC.Base.pure GetTransactionResponseBody200CertificatesOneOf3Pool_metadata GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))
-- | Create a new 'GetTransactionResponseBody200CertificatesOneOf3Pool_metadata' with all required fields.
mkGetTransactionResponseBody200CertificatesOneOf3Pool_metadata :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200CertificatesOneOf3Pool_metadataHash'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200CertificatesOneOf3Pool_metadataUrl'
  -> GetTransactionResponseBody200CertificatesOneOf3Pool_metadata
mkGetTransactionResponseBody200CertificatesOneOf3Pool_metadata getTransactionResponseBody200CertificatesOneOf3Pool_metadataHash getTransactionResponseBody200CertificatesOneOf3Pool_metadataUrl = GetTransactionResponseBody200CertificatesOneOf3Pool_metadata{getTransactionResponseBody200CertificatesOneOf3Pool_metadataHash = getTransactionResponseBody200CertificatesOneOf3Pool_metadataHash,
                                                                                                                                                                                                                                                               getTransactionResponseBody200CertificatesOneOf3Pool_metadataUrl = getTransactionResponseBody200CertificatesOneOf3Pool_metadataUrl}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_pledge@ in the specification.
-- 
-- Minimal stake amount that a stake pool is willing to honor.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data GetTransactionResponseBody200CertificatesOneOf3Pool_pledge = GetTransactionResponseBody200CertificatesOneOf3Pool_pledge {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200CertificatesOneOf3Pool_pledgeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200CertificatesOneOf3Pool_pledge
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200CertificatesOneOf3Pool_pledge
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200CertificatesOneOf3Pool_pledge" (\obj -> GHC.Base.pure GetTransactionResponseBody200CertificatesOneOf3Pool_pledge GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200CertificatesOneOf3Pool_pledge' with all required fields.
mkGetTransactionResponseBody200CertificatesOneOf3Pool_pledge :: GHC.Types.Int -- ^ 'getTransactionResponseBody200CertificatesOneOf3Pool_pledgeQuantity'
  -> GetTransactionResponseBody200CertificatesOneOf3Pool_pledge
mkGetTransactionResponseBody200CertificatesOneOf3Pool_pledge getTransactionResponseBody200CertificatesOneOf3Pool_pledgeQuantity = GetTransactionResponseBody200CertificatesOneOf3Pool_pledge{getTransactionResponseBody200CertificatesOneOf3Pool_pledgeQuantity = getTransactionResponseBody200CertificatesOneOf3Pool_pledgeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200CertificatesOneOf4 = GetTransactionResponseBody200CertificatesOneOf4 {
  -- | pool_id: A unique identifier for the pool.
  getTransactionResponseBody200CertificatesOneOf4Pool_id :: Data.Text.Internal.Text
  -- | retirement_epoch: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200CertificatesOneOf4Retirement_epoch :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200CertificatesOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200CertificatesOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200CertificatesOneOf4" (\obj -> (GHC.Base.pure GetTransactionResponseBody200CertificatesOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "retirement_epoch"))
-- | Create a new 'GetTransactionResponseBody200CertificatesOneOf4' with all required fields.
mkGetTransactionResponseBody200CertificatesOneOf4 :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200CertificatesOneOf4Pool_id'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200CertificatesOneOf4Retirement_epoch'
  -> GetTransactionResponseBody200CertificatesOneOf4
mkGetTransactionResponseBody200CertificatesOneOf4 getTransactionResponseBody200CertificatesOneOf4Pool_id getTransactionResponseBody200CertificatesOneOf4Retirement_epoch = GetTransactionResponseBody200CertificatesOneOf4{getTransactionResponseBody200CertificatesOneOf4Pool_id = getTransactionResponseBody200CertificatesOneOf4Pool_id,
                                                                                                                                                                                                                           getTransactionResponseBody200CertificatesOneOf4Retirement_epoch = getTransactionResponseBody200CertificatesOneOf4Retirement_epoch}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200CertificatesOneOf5 = GetTransactionResponseBody200CertificatesOneOf5 {
  -- | certificate_type
  getTransactionResponseBody200CertificatesOneOf5Certificate_type :: GetTransactionResponseBody200CertificatesOneOf5Certificate_type
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200CertificatesOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200CertificatesOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200CertificatesOneOf5" (\obj -> GHC.Base.pure GetTransactionResponseBody200CertificatesOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type"))
-- | Create a new 'GetTransactionResponseBody200CertificatesOneOf5' with all required fields.
mkGetTransactionResponseBody200CertificatesOneOf5 :: GetTransactionResponseBody200CertificatesOneOf5Certificate_type -- ^ 'getTransactionResponseBody200CertificatesOneOf5Certificate_type'
  -> GetTransactionResponseBody200CertificatesOneOf5
mkGetTransactionResponseBody200CertificatesOneOf5 getTransactionResponseBody200CertificatesOneOf5Certificate_type = GetTransactionResponseBody200CertificatesOneOf5{getTransactionResponseBody200CertificatesOneOf5Certificate_type = getTransactionResponseBody200CertificatesOneOf5Certificate_type}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data GetTransactionResponseBody200CertificatesOneOf5Certificate_type =
   GetTransactionResponseBody200CertificatesOneOf5Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetTransactionResponseBody200CertificatesOneOf5Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetTransactionResponseBody200CertificatesOneOf5Certificate_typeEnumMir -- ^ Represents the JSON value @"mir"@
  | GetTransactionResponseBody200CertificatesOneOf5Certificate_typeEnumGenesis -- ^ Represents the JSON value @"genesis"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200CertificatesOneOf5Certificate_type
    where toJSON (GetTransactionResponseBody200CertificatesOneOf5Certificate_typeOther val) = val
          toJSON (GetTransactionResponseBody200CertificatesOneOf5Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetTransactionResponseBody200CertificatesOneOf5Certificate_typeEnumMir) = "mir"
          toJSON (GetTransactionResponseBody200CertificatesOneOf5Certificate_typeEnumGenesis) = "genesis"
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200CertificatesOneOf5Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "mir" -> GetTransactionResponseBody200CertificatesOneOf5Certificate_typeEnumMir
                                            | val GHC.Classes.== "genesis" -> GetTransactionResponseBody200CertificatesOneOf5Certificate_typeEnumGenesis
                                            | GHC.Base.otherwise -> GetTransactionResponseBody200CertificatesOneOf5Certificate_typeOther val)
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- Any certificate that could occur in an arbitrary transaction:
-- might be related to delegation, pool activities, genesis or MIR.
data GetTransactionResponseBody200CertificatesVariants =
   GetTransactionResponseBody200CertificatesVariant1 GetTransactionResponseBody200CertificatesOneOf1
  | GetTransactionResponseBody200CertificatesVariant2 GetTransactionResponseBody200CertificatesOneOf2
  | GetTransactionResponseBody200CertificatesVariant3 GetTransactionResponseBody200CertificatesOneOf3
  | GetTransactionResponseBody200CertificatesVariant4 GetTransactionResponseBody200CertificatesOneOf4
  | GetTransactionResponseBody200CertificatesVariant5 GetTransactionResponseBody200CertificatesOneOf5
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200CertificatesVariants
    where toJSON (GetTransactionResponseBody200CertificatesVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200CertificatesVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200CertificatesVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200CertificatesVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200CertificatesVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200CertificatesVariants
    where parseJSON val = case (GetTransactionResponseBody200CertificatesVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200CertificatesVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200CertificatesVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200CertificatesVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200CertificatesVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.collateral.items@ in the specification.
-- 
-- 
data GetTransactionResponseBody200Collateral = GetTransactionResponseBody200Collateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  getTransactionResponseBody200CollateralAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , getTransactionResponseBody200CollateralAmount :: (GHC.Maybe.Maybe GetTransactionResponseBody200CollateralAmount)
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , getTransactionResponseBody200CollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200CollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Collateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Collateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Collateral" (\obj -> (((GHC.Base.pure GetTransactionResponseBody200Collateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetTransactionResponseBody200Collateral' with all required fields.
mkGetTransactionResponseBody200Collateral :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200CollateralId'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200CollateralIndex'
  -> GetTransactionResponseBody200Collateral
mkGetTransactionResponseBody200Collateral getTransactionResponseBody200CollateralId getTransactionResponseBody200CollateralIndex = GetTransactionResponseBody200Collateral{getTransactionResponseBody200CollateralAddress = GHC.Maybe.Nothing,
                                                                                                                                                                           getTransactionResponseBody200CollateralAmount = GHC.Maybe.Nothing,
                                                                                                                                                                           getTransactionResponseBody200CollateralId = getTransactionResponseBody200CollateralId,
                                                                                                                                                                           getTransactionResponseBody200CollateralIndex = getTransactionResponseBody200CollateralIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetTransactionResponseBody200CollateralAmount = GetTransactionResponseBody200CollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200CollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200CollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200CollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200CollateralAmount" (\obj -> GHC.Base.pure GetTransactionResponseBody200CollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200CollateralAmount' with all required fields.
mkGetTransactionResponseBody200CollateralAmount :: GHC.Types.Int -- ^ 'getTransactionResponseBody200CollateralAmountQuantity'
  -> GetTransactionResponseBody200CollateralAmount
mkGetTransactionResponseBody200CollateralAmount getTransactionResponseBody200CollateralAmountQuantity = GetTransactionResponseBody200CollateralAmount{getTransactionResponseBody200CollateralAmountQuantity = getTransactionResponseBody200CollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.collateral_outputs.items@ in the specification.
-- 
-- 
data GetTransactionResponseBody200Collateral_outputs = GetTransactionResponseBody200Collateral_outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  getTransactionResponseBody200Collateral_outputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , getTransactionResponseBody200Collateral_outputsAmount :: GetTransactionResponseBody200Collateral_outputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , getTransactionResponseBody200Collateral_outputsAssets :: (GHC.Maybe.Maybe ([GetTransactionResponseBody200Collateral_outputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Collateral_outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Collateral_outputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200Collateral_outputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Collateral_outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Collateral_outputs" (\obj -> ((GHC.Base.pure GetTransactionResponseBody200Collateral_outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'GetTransactionResponseBody200Collateral_outputs' with all required fields.
mkGetTransactionResponseBody200Collateral_outputs :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200Collateral_outputsAddress'
  -> GetTransactionResponseBody200Collateral_outputsAmount -- ^ 'getTransactionResponseBody200Collateral_outputsAmount'
  -> GetTransactionResponseBody200Collateral_outputs
mkGetTransactionResponseBody200Collateral_outputs getTransactionResponseBody200Collateral_outputsAddress getTransactionResponseBody200Collateral_outputsAmount = GetTransactionResponseBody200Collateral_outputs{getTransactionResponseBody200Collateral_outputsAddress = getTransactionResponseBody200Collateral_outputsAddress,
                                                                                                                                                                                                                 getTransactionResponseBody200Collateral_outputsAmount = getTransactionResponseBody200Collateral_outputsAmount,
                                                                                                                                                                                                                 getTransactionResponseBody200Collateral_outputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.collateral_outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetTransactionResponseBody200Collateral_outputsAmount = GetTransactionResponseBody200Collateral_outputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200Collateral_outputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Collateral_outputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Collateral_outputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Collateral_outputsAmount" (\obj -> GHC.Base.pure GetTransactionResponseBody200Collateral_outputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200Collateral_outputsAmount' with all required fields.
mkGetTransactionResponseBody200Collateral_outputsAmount :: GHC.Types.Int -- ^ 'getTransactionResponseBody200Collateral_outputsAmountQuantity'
  -> GetTransactionResponseBody200Collateral_outputsAmount
mkGetTransactionResponseBody200Collateral_outputsAmount getTransactionResponseBody200Collateral_outputsAmountQuantity = GetTransactionResponseBody200Collateral_outputsAmount{getTransactionResponseBody200Collateral_outputsAmountQuantity = getTransactionResponseBody200Collateral_outputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.collateral_outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data GetTransactionResponseBody200Collateral_outputsAssets = GetTransactionResponseBody200Collateral_outputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getTransactionResponseBody200Collateral_outputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getTransactionResponseBody200Collateral_outputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200Collateral_outputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Collateral_outputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Collateral_outputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Collateral_outputsAssets" (\obj -> ((GHC.Base.pure GetTransactionResponseBody200Collateral_outputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200Collateral_outputsAssets' with all required fields.
mkGetTransactionResponseBody200Collateral_outputsAssets :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200Collateral_outputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200Collateral_outputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200Collateral_outputsAssetsQuantity'
  -> GetTransactionResponseBody200Collateral_outputsAssets
mkGetTransactionResponseBody200Collateral_outputsAssets getTransactionResponseBody200Collateral_outputsAssetsAsset_name getTransactionResponseBody200Collateral_outputsAssetsPolicy_id getTransactionResponseBody200Collateral_outputsAssetsQuantity = GetTransactionResponseBody200Collateral_outputsAssets{getTransactionResponseBody200Collateral_outputsAssetsAsset_name = getTransactionResponseBody200Collateral_outputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                             getTransactionResponseBody200Collateral_outputsAssetsPolicy_id = getTransactionResponseBody200Collateral_outputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                             getTransactionResponseBody200Collateral_outputsAssetsQuantity = getTransactionResponseBody200Collateral_outputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.deposit_returned@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetTransactionResponseBody200Deposit_returned = GetTransactionResponseBody200Deposit_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200Deposit_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Deposit_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Deposit_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Deposit_returned" (\obj -> GHC.Base.pure GetTransactionResponseBody200Deposit_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200Deposit_returned' with all required fields.
mkGetTransactionResponseBody200Deposit_returned :: GHC.Types.Int -- ^ 'getTransactionResponseBody200Deposit_returnedQuantity'
  -> GetTransactionResponseBody200Deposit_returned
mkGetTransactionResponseBody200Deposit_returned getTransactionResponseBody200Deposit_returnedQuantity = GetTransactionResponseBody200Deposit_returned{getTransactionResponseBody200Deposit_returnedQuantity = getTransactionResponseBody200Deposit_returnedQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.deposit_taken@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetTransactionResponseBody200Deposit_taken = GetTransactionResponseBody200Deposit_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200Deposit_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Deposit_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Deposit_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Deposit_taken" (\obj -> GHC.Base.pure GetTransactionResponseBody200Deposit_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200Deposit_taken' with all required fields.
mkGetTransactionResponseBody200Deposit_taken :: GHC.Types.Int -- ^ 'getTransactionResponseBody200Deposit_takenQuantity'
  -> GetTransactionResponseBody200Deposit_taken
mkGetTransactionResponseBody200Deposit_taken getTransactionResponseBody200Deposit_takenQuantity = GetTransactionResponseBody200Deposit_taken{getTransactionResponseBody200Deposit_takenQuantity = getTransactionResponseBody200Deposit_takenQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.depth@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Current depth of the transaction in the local chain
data GetTransactionResponseBody200Depth = GetTransactionResponseBody200Depth {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200DepthQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Depth
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Depth
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Depth" (\obj -> GHC.Base.pure GetTransactionResponseBody200Depth GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200Depth' with all required fields.
mkGetTransactionResponseBody200Depth :: GHC.Types.Int -- ^ 'getTransactionResponseBody200DepthQuantity'
  -> GetTransactionResponseBody200Depth
mkGetTransactionResponseBody200Depth getTransactionResponseBody200DepthQuantity = GetTransactionResponseBody200Depth{getTransactionResponseBody200DepthQuantity = getTransactionResponseBody200DepthQuantity}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.direction@ in the specification.
-- 
-- 
data GetTransactionResponseBody200Direction =
   GetTransactionResponseBody200DirectionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetTransactionResponseBody200DirectionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetTransactionResponseBody200DirectionEnumOutgoing -- ^ Represents the JSON value @"outgoing"@
  | GetTransactionResponseBody200DirectionEnumIncoming -- ^ Represents the JSON value @"incoming"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Direction
    where toJSON (GetTransactionResponseBody200DirectionOther val) = val
          toJSON (GetTransactionResponseBody200DirectionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetTransactionResponseBody200DirectionEnumOutgoing) = "outgoing"
          toJSON (GetTransactionResponseBody200DirectionEnumIncoming) = "incoming"
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Direction
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "outgoing" -> GetTransactionResponseBody200DirectionEnumOutgoing
                                            | val GHC.Classes.== "incoming" -> GetTransactionResponseBody200DirectionEnumIncoming
                                            | GHC.Base.otherwise -> GetTransactionResponseBody200DirectionOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.expires_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending OR status == expired
-- \<\/span>\<br\/>
-- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
data GetTransactionResponseBody200Expires_at = GetTransactionResponseBody200Expires_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200Expires_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200Expires_atEpoch_number :: GHC.Types.Int
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200Expires_atSlot_number :: GHC.Types.Int
  -- | time
  , getTransactionResponseBody200Expires_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Expires_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Expires_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Expires_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Expires_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Expires_at" (\obj -> (((GHC.Base.pure GetTransactionResponseBody200Expires_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'GetTransactionResponseBody200Expires_at' with all required fields.
mkGetTransactionResponseBody200Expires_at :: GHC.Types.Int -- ^ 'getTransactionResponseBody200Expires_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200Expires_atEpoch_number'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200Expires_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200Expires_atTime'
  -> GetTransactionResponseBody200Expires_at
mkGetTransactionResponseBody200Expires_at getTransactionResponseBody200Expires_atAbsolute_slot_number getTransactionResponseBody200Expires_atEpoch_number getTransactionResponseBody200Expires_atSlot_number getTransactionResponseBody200Expires_atTime = GetTransactionResponseBody200Expires_at{getTransactionResponseBody200Expires_atAbsolute_slot_number = getTransactionResponseBody200Expires_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                   getTransactionResponseBody200Expires_atEpoch_number = getTransactionResponseBody200Expires_atEpoch_number,
                                                                                                                                                                                                                                                                                                   getTransactionResponseBody200Expires_atSlot_number = getTransactionResponseBody200Expires_atSlot_number,
                                                                                                                                                                                                                                                                                                   getTransactionResponseBody200Expires_atTime = getTransactionResponseBody200Expires_atTime}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.fee@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetTransactionResponseBody200Fee = GetTransactionResponseBody200Fee {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200FeeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Fee
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Fee
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Fee" (\obj -> GHC.Base.pure GetTransactionResponseBody200Fee GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200Fee' with all required fields.
mkGetTransactionResponseBody200Fee :: GHC.Types.Int -- ^ 'getTransactionResponseBody200FeeQuantity'
  -> GetTransactionResponseBody200Fee
mkGetTransactionResponseBody200Fee getTransactionResponseBody200FeeQuantity = GetTransactionResponseBody200Fee{getTransactionResponseBody200FeeQuantity = getTransactionResponseBody200FeeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.inputs.items@ in the specification.
-- 
-- 
data GetTransactionResponseBody200Inputs = GetTransactionResponseBody200Inputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  getTransactionResponseBody200InputsAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , getTransactionResponseBody200InputsAmount :: (GHC.Maybe.Maybe GetTransactionResponseBody200InputsAmount)
  -- | assets: A flat list of assets (possibly empty).
  , getTransactionResponseBody200InputsAssets :: (GHC.Maybe.Maybe ([GetTransactionResponseBody200InputsAssets]))
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , getTransactionResponseBody200InputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200InputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Inputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200InputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200InputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Inputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Inputs" (\obj -> ((((GHC.Base.pure GetTransactionResponseBody200Inputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetTransactionResponseBody200Inputs' with all required fields.
mkGetTransactionResponseBody200Inputs :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200InputsId'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200InputsIndex'
  -> GetTransactionResponseBody200Inputs
mkGetTransactionResponseBody200Inputs getTransactionResponseBody200InputsId getTransactionResponseBody200InputsIndex = GetTransactionResponseBody200Inputs{getTransactionResponseBody200InputsAddress = GHC.Maybe.Nothing,
                                                                                                                                                           getTransactionResponseBody200InputsAmount = GHC.Maybe.Nothing,
                                                                                                                                                           getTransactionResponseBody200InputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                           getTransactionResponseBody200InputsId = getTransactionResponseBody200InputsId,
                                                                                                                                                           getTransactionResponseBody200InputsIndex = getTransactionResponseBody200InputsIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetTransactionResponseBody200InputsAmount = GetTransactionResponseBody200InputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200InputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200InputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200InputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200InputsAmount" (\obj -> GHC.Base.pure GetTransactionResponseBody200InputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200InputsAmount' with all required fields.
mkGetTransactionResponseBody200InputsAmount :: GHC.Types.Int -- ^ 'getTransactionResponseBody200InputsAmountQuantity'
  -> GetTransactionResponseBody200InputsAmount
mkGetTransactionResponseBody200InputsAmount getTransactionResponseBody200InputsAmountQuantity = GetTransactionResponseBody200InputsAmount{getTransactionResponseBody200InputsAmountQuantity = getTransactionResponseBody200InputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data GetTransactionResponseBody200InputsAssets = GetTransactionResponseBody200InputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getTransactionResponseBody200InputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getTransactionResponseBody200InputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200InputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200InputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200InputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200InputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200InputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200InputsAssets" (\obj -> ((GHC.Base.pure GetTransactionResponseBody200InputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200InputsAssets' with all required fields.
mkGetTransactionResponseBody200InputsAssets :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200InputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200InputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200InputsAssetsQuantity'
  -> GetTransactionResponseBody200InputsAssets
mkGetTransactionResponseBody200InputsAssets getTransactionResponseBody200InputsAssetsAsset_name getTransactionResponseBody200InputsAssetsPolicy_id getTransactionResponseBody200InputsAssetsQuantity = GetTransactionResponseBody200InputsAssets{getTransactionResponseBody200InputsAssetsAsset_name = getTransactionResponseBody200InputsAssetsAsset_name,
                                                                                                                                                                                                                                                 getTransactionResponseBody200InputsAssetsPolicy_id = getTransactionResponseBody200InputsAssetsPolicy_id,
                                                                                                                                                                                                                                                 getTransactionResponseBody200InputsAssetsQuantity = getTransactionResponseBody200InputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.inserted_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Absolute time at which the transaction was inserted in a block.
data GetTransactionResponseBody200Inserted_at = GetTransactionResponseBody200Inserted_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200Inserted_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200Inserted_atEpoch_number :: GHC.Types.Int
  -- | height
  , getTransactionResponseBody200Inserted_atHeight :: GetTransactionResponseBody200Inserted_atHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200Inserted_atSlot_number :: GHC.Types.Int
  -- | time
  , getTransactionResponseBody200Inserted_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Inserted_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Inserted_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Inserted_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Inserted_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Inserted_at" (\obj -> ((((GHC.Base.pure GetTransactionResponseBody200Inserted_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'GetTransactionResponseBody200Inserted_at' with all required fields.
mkGetTransactionResponseBody200Inserted_at :: GHC.Types.Int -- ^ 'getTransactionResponseBody200Inserted_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200Inserted_atEpoch_number'
  -> GetTransactionResponseBody200Inserted_atHeight -- ^ 'getTransactionResponseBody200Inserted_atHeight'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200Inserted_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200Inserted_atTime'
  -> GetTransactionResponseBody200Inserted_at
mkGetTransactionResponseBody200Inserted_at getTransactionResponseBody200Inserted_atAbsolute_slot_number getTransactionResponseBody200Inserted_atEpoch_number getTransactionResponseBody200Inserted_atHeight getTransactionResponseBody200Inserted_atSlot_number getTransactionResponseBody200Inserted_atTime = GetTransactionResponseBody200Inserted_at{getTransactionResponseBody200Inserted_atAbsolute_slot_number = getTransactionResponseBody200Inserted_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                        getTransactionResponseBody200Inserted_atEpoch_number = getTransactionResponseBody200Inserted_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                                        getTransactionResponseBody200Inserted_atHeight = getTransactionResponseBody200Inserted_atHeight,
                                                                                                                                                                                                                                                                                                                                                        getTransactionResponseBody200Inserted_atSlot_number = getTransactionResponseBody200Inserted_atSlot_number,
                                                                                                                                                                                                                                                                                                                                                        getTransactionResponseBody200Inserted_atTime = getTransactionResponseBody200Inserted_atTime}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.inserted_at.properties.height@ in the specification.
-- 
-- 
data GetTransactionResponseBody200Inserted_atHeight = GetTransactionResponseBody200Inserted_atHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200Inserted_atHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Inserted_atHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Inserted_atHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Inserted_atHeight" (\obj -> GHC.Base.pure GetTransactionResponseBody200Inserted_atHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200Inserted_atHeight' with all required fields.
mkGetTransactionResponseBody200Inserted_atHeight :: GHC.Types.Int -- ^ 'getTransactionResponseBody200Inserted_atHeightQuantity'
  -> GetTransactionResponseBody200Inserted_atHeight
mkGetTransactionResponseBody200Inserted_atHeight getTransactionResponseBody200Inserted_atHeightQuantity = GetTransactionResponseBody200Inserted_atHeight{getTransactionResponseBody200Inserted_atHeightQuantity = getTransactionResponseBody200Inserted_atHeightQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint@ in the specification.
-- 
-- 
data GetTransactionResponseBody200Mint = GetTransactionResponseBody200Mint {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  getTransactionResponseBody200MintTokens :: ([GetTransactionResponseBody200MintTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , getTransactionResponseBody200MintWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , getTransactionResponseBody200MintWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Mint
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200MintWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200MintWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Mint
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Mint" (\obj -> ((GHC.Base.pure GetTransactionResponseBody200Mint GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'GetTransactionResponseBody200Mint' with all required fields.
mkGetTransactionResponseBody200Mint :: [GetTransactionResponseBody200MintTokens] -- ^ 'getTransactionResponseBody200MintTokens'
  -> GetTransactionResponseBody200Mint
mkGetTransactionResponseBody200Mint getTransactionResponseBody200MintTokens = GetTransactionResponseBody200Mint{getTransactionResponseBody200MintTokens = getTransactionResponseBody200MintTokens,
                                                                                                                getTransactionResponseBody200MintWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                getTransactionResponseBody200MintWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items@ in the specification.
-- 
-- 
data GetTransactionResponseBody200MintTokens = GetTransactionResponseBody200MintTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getTransactionResponseBody200MintTokensAssets :: ([GetTransactionResponseBody200MintTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getTransactionResponseBody200MintTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , getTransactionResponseBody200MintTokensPolicy_script :: GetTransactionResponseBody200MintTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200MintTokens" (\obj -> ((GHC.Base.pure GetTransactionResponseBody200MintTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'GetTransactionResponseBody200MintTokens' with all required fields.
mkGetTransactionResponseBody200MintTokens :: [GetTransactionResponseBody200MintTokensAssets] -- ^ 'getTransactionResponseBody200MintTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200MintTokensPolicy_id'
  -> GetTransactionResponseBody200MintTokensPolicy_scriptVariants -- ^ 'getTransactionResponseBody200MintTokensPolicy_script'
  -> GetTransactionResponseBody200MintTokens
mkGetTransactionResponseBody200MintTokens getTransactionResponseBody200MintTokensAssets getTransactionResponseBody200MintTokensPolicy_id getTransactionResponseBody200MintTokensPolicy_script = GetTransactionResponseBody200MintTokens{getTransactionResponseBody200MintTokensAssets = getTransactionResponseBody200MintTokensAssets,
                                                                                                                                                                                                                                        getTransactionResponseBody200MintTokensPolicy_id = getTransactionResponseBody200MintTokensPolicy_id,
                                                                                                                                                                                                                                        getTransactionResponseBody200MintTokensPolicy_script = getTransactionResponseBody200MintTokensPolicy_script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data GetTransactionResponseBody200MintTokensAssets = GetTransactionResponseBody200MintTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getTransactionResponseBody200MintTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , getTransactionResponseBody200MintTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200MintTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200MintTokensAssets" (\obj -> ((GHC.Base.pure GetTransactionResponseBody200MintTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200MintTokensAssets' with all required fields.
mkGetTransactionResponseBody200MintTokensAssets :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200MintTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200MintTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200MintTokensAssetsQuantity'
  -> GetTransactionResponseBody200MintTokensAssets
mkGetTransactionResponseBody200MintTokensAssets getTransactionResponseBody200MintTokensAssetsAsset_name getTransactionResponseBody200MintTokensAssetsFingerprint getTransactionResponseBody200MintTokensAssetsQuantity = GetTransactionResponseBody200MintTokensAssets{getTransactionResponseBody200MintTokensAssetsAsset_name = getTransactionResponseBody200MintTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                       getTransactionResponseBody200MintTokensAssetsFingerprint = getTransactionResponseBody200MintTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                       getTransactionResponseBody200MintTokensAssetsQuantity = getTransactionResponseBody200MintTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1 = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  getTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference)
  -- | script
  , getTransactionResponseBody200MintTokensPolicy_scriptOneOf1Script :: GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1' with all required fields.
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1 :: GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf1Script'
  -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1 getTransactionResponseBody200MintTokensPolicy_scriptOneOf1Script = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1{getTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                           getTransactionResponseBody200MintTokensPolicy_scriptOneOf1Script = getTransactionResponseBody200MintTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference' with all required fields.
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex'
  -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference{getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId = getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                           getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex = getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2{getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All = getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3{getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 :: GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4{getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some{getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                            getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5{getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6{getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = getTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants =
   GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant2 GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
  | GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant3 GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
  | GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant4 GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
  | GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant5 GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
  | GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant6 GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2 = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info :: GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2' with all required fields.
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf2 :: GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info'
  -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf2 getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2{getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info = getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference' with all required fields.
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex'
  -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference getTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId getTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference{getTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId = getTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                           getTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex = getTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version :: GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info :: GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info{getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version = getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                       getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash = getTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3 = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getTransactionResponseBody200MintTokensPolicy_scriptOneOf3References :: ([GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getTransactionResponseBody200MintTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3' with all required fields.
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf3 :: [GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3References] -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf3Script_hash'
  -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf3 getTransactionResponseBody200MintTokensPolicy_scriptOneOf3References getTransactionResponseBody200MintTokensPolicy_scriptOneOf3Script_hash = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3{getTransactionResponseBody200MintTokensPolicy_scriptOneOf3References = getTransactionResponseBody200MintTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                     getTransactionResponseBody200MintTokensPolicy_scriptOneOf3Script_hash = getTransactionResponseBody200MintTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3References = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3References' with all required fields.
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex'
  -> GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3References
mkGetTransactionResponseBody200MintTokensPolicy_scriptOneOf3References getTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId getTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex = GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3References{getTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId = getTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                               getTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex = getTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody200MintTokensPolicy_scriptVariants =
   GetTransactionResponseBody200MintTokensPolicy_scriptVariant1 GetTransactionResponseBody200MintTokensPolicy_scriptOneOf1
  | GetTransactionResponseBody200MintTokensPolicy_scriptVariant2 GetTransactionResponseBody200MintTokensPolicy_scriptOneOf2
  | GetTransactionResponseBody200MintTokensPolicy_scriptVariant3 GetTransactionResponseBody200MintTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200MintTokensPolicy_scriptVariants
    where toJSON (GetTransactionResponseBody200MintTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200MintTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody200MintTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200MintTokensPolicy_scriptVariants
    where parseJSON val = case (GetTransactionResponseBody200MintTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200MintTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody200MintTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.outputs.items@ in the specification.
-- 
-- 
data GetTransactionResponseBody200Outputs = GetTransactionResponseBody200Outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  getTransactionResponseBody200OutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , getTransactionResponseBody200OutputsAmount :: GetTransactionResponseBody200OutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , getTransactionResponseBody200OutputsAssets :: (GHC.Maybe.Maybe ([GetTransactionResponseBody200OutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200OutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (getTransactionResponseBody200OutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Outputs" (\obj -> ((GHC.Base.pure GetTransactionResponseBody200Outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'GetTransactionResponseBody200Outputs' with all required fields.
mkGetTransactionResponseBody200Outputs :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200OutputsAddress'
  -> GetTransactionResponseBody200OutputsAmount -- ^ 'getTransactionResponseBody200OutputsAmount'
  -> GetTransactionResponseBody200Outputs
mkGetTransactionResponseBody200Outputs getTransactionResponseBody200OutputsAddress getTransactionResponseBody200OutputsAmount = GetTransactionResponseBody200Outputs{getTransactionResponseBody200OutputsAddress = getTransactionResponseBody200OutputsAddress,
                                                                                                                                                                     getTransactionResponseBody200OutputsAmount = getTransactionResponseBody200OutputsAmount,
                                                                                                                                                                     getTransactionResponseBody200OutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetTransactionResponseBody200OutputsAmount = GetTransactionResponseBody200OutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200OutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200OutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200OutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200OutputsAmount" (\obj -> GHC.Base.pure GetTransactionResponseBody200OutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200OutputsAmount' with all required fields.
mkGetTransactionResponseBody200OutputsAmount :: GHC.Types.Int -- ^ 'getTransactionResponseBody200OutputsAmountQuantity'
  -> GetTransactionResponseBody200OutputsAmount
mkGetTransactionResponseBody200OutputsAmount getTransactionResponseBody200OutputsAmountQuantity = GetTransactionResponseBody200OutputsAmount{getTransactionResponseBody200OutputsAmountQuantity = getTransactionResponseBody200OutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data GetTransactionResponseBody200OutputsAssets = GetTransactionResponseBody200OutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getTransactionResponseBody200OutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getTransactionResponseBody200OutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200OutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200OutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200OutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200OutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200OutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200OutputsAssets" (\obj -> ((GHC.Base.pure GetTransactionResponseBody200OutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200OutputsAssets' with all required fields.
mkGetTransactionResponseBody200OutputsAssets :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200OutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200OutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200OutputsAssetsQuantity'
  -> GetTransactionResponseBody200OutputsAssets
mkGetTransactionResponseBody200OutputsAssets getTransactionResponseBody200OutputsAssetsAsset_name getTransactionResponseBody200OutputsAssetsPolicy_id getTransactionResponseBody200OutputsAssetsQuantity = GetTransactionResponseBody200OutputsAssets{getTransactionResponseBody200OutputsAssetsAsset_name = getTransactionResponseBody200OutputsAssetsAsset_name,
                                                                                                                                                                                                                                                      getTransactionResponseBody200OutputsAssetsPolicy_id = getTransactionResponseBody200OutputsAssetsPolicy_id,
                                                                                                                                                                                                                                                      getTransactionResponseBody200OutputsAssetsQuantity = getTransactionResponseBody200OutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.pending_since@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending
-- \<\/span>\<br\/>
-- The point in time at which a transaction became pending.
data GetTransactionResponseBody200Pending_since = GetTransactionResponseBody200Pending_since {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200Pending_sinceAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200Pending_sinceEpoch_number :: GHC.Types.Int
  -- | height
  , getTransactionResponseBody200Pending_sinceHeight :: GetTransactionResponseBody200Pending_sinceHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getTransactionResponseBody200Pending_sinceSlot_number :: GHC.Types.Int
  -- | time
  , getTransactionResponseBody200Pending_sinceTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Pending_since
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Pending_sinceTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Pending_sinceTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Pending_since
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Pending_since" (\obj -> ((((GHC.Base.pure GetTransactionResponseBody200Pending_since GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'GetTransactionResponseBody200Pending_since' with all required fields.
mkGetTransactionResponseBody200Pending_since :: GHC.Types.Int -- ^ 'getTransactionResponseBody200Pending_sinceAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200Pending_sinceEpoch_number'
  -> GetTransactionResponseBody200Pending_sinceHeight -- ^ 'getTransactionResponseBody200Pending_sinceHeight'
  -> GHC.Types.Int -- ^ 'getTransactionResponseBody200Pending_sinceSlot_number'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200Pending_sinceTime'
  -> GetTransactionResponseBody200Pending_since
mkGetTransactionResponseBody200Pending_since getTransactionResponseBody200Pending_sinceAbsolute_slot_number getTransactionResponseBody200Pending_sinceEpoch_number getTransactionResponseBody200Pending_sinceHeight getTransactionResponseBody200Pending_sinceSlot_number getTransactionResponseBody200Pending_sinceTime = GetTransactionResponseBody200Pending_since{getTransactionResponseBody200Pending_sinceAbsolute_slot_number = getTransactionResponseBody200Pending_sinceAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                      getTransactionResponseBody200Pending_sinceEpoch_number = getTransactionResponseBody200Pending_sinceEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                      getTransactionResponseBody200Pending_sinceHeight = getTransactionResponseBody200Pending_sinceHeight,
                                                                                                                                                                                                                                                                                                                                                                      getTransactionResponseBody200Pending_sinceSlot_number = getTransactionResponseBody200Pending_sinceSlot_number,
                                                                                                                                                                                                                                                                                                                                                                      getTransactionResponseBody200Pending_sinceTime = getTransactionResponseBody200Pending_sinceTime}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.pending_since.properties.height@ in the specification.
-- 
-- 
data GetTransactionResponseBody200Pending_sinceHeight = GetTransactionResponseBody200Pending_sinceHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200Pending_sinceHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Pending_sinceHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Pending_sinceHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Pending_sinceHeight" (\obj -> GHC.Base.pure GetTransactionResponseBody200Pending_sinceHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200Pending_sinceHeight' with all required fields.
mkGetTransactionResponseBody200Pending_sinceHeight :: GHC.Types.Int -- ^ 'getTransactionResponseBody200Pending_sinceHeightQuantity'
  -> GetTransactionResponseBody200Pending_sinceHeight
mkGetTransactionResponseBody200Pending_sinceHeight getTransactionResponseBody200Pending_sinceHeightQuantity = GetTransactionResponseBody200Pending_sinceHeight{getTransactionResponseBody200Pending_sinceHeightQuantity = getTransactionResponseBody200Pending_sinceHeightQuantity}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.script_validity@ in the specification.
-- 
-- Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
-- used in the transaction validated or not. Validity may be null if this
-- transaction was from an era that doesn\'t support phase-2 monetary policy
-- scripts, or is a pending transaction (we don\'t know if validation passed or
-- failed until the transaction hits the ledger).
data GetTransactionResponseBody200Script_validityNonNullable =
   GetTransactionResponseBody200Script_validityNonNullableOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetTransactionResponseBody200Script_validityNonNullableTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetTransactionResponseBody200Script_validityNonNullableEnumValid -- ^ Represents the JSON value @"valid"@
  | GetTransactionResponseBody200Script_validityNonNullableEnumInvalid -- ^ Represents the JSON value @"invalid"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Script_validityNonNullable
    where toJSON (GetTransactionResponseBody200Script_validityNonNullableOther val) = val
          toJSON (GetTransactionResponseBody200Script_validityNonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetTransactionResponseBody200Script_validityNonNullableEnumValid) = "valid"
          toJSON (GetTransactionResponseBody200Script_validityNonNullableEnumInvalid) = "invalid"
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Script_validityNonNullable
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "valid" -> GetTransactionResponseBody200Script_validityNonNullableEnumValid
                                            | val GHC.Classes.== "invalid" -> GetTransactionResponseBody200Script_validityNonNullableEnumInvalid
                                            | GHC.Base.otherwise -> GetTransactionResponseBody200Script_validityNonNullableOther val)
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.status@ in the specification.
-- 
-- Current transaction status.
-- 
--   \`\`\`
--        *-----------*
--   ---> |  PENDING  |----------------*
--        *-----------*                |
--              |                      |
--              V                      V
--        *-----------*          *-----------*
--        |           |---------->  EXPIRED  |
--        |           |  (ttl)   *-----------*
--        | SUBMITTED |
--        |           \<----------------*
--        |           |                |
--        *-----------*           (rollback)
--               |                     |
--          (in ledger)          *-----------*
--               |               |           |
--               *---------------> IN_LEDGER |
--                               |           |
--                               *-----------*
--   \`\`\`
data GetTransactionResponseBody200Status =
   GetTransactionResponseBody200StatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetTransactionResponseBody200StatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetTransactionResponseBody200StatusEnumPending -- ^ Represents the JSON value @"pending"@
  | GetTransactionResponseBody200StatusEnumSubmitted -- ^ Represents the JSON value @"submitted"@
  | GetTransactionResponseBody200StatusEnumIn_ledger -- ^ Represents the JSON value @"in_ledger"@
  | GetTransactionResponseBody200StatusEnumExpired -- ^ Represents the JSON value @"expired"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Status
    where toJSON (GetTransactionResponseBody200StatusOther val) = val
          toJSON (GetTransactionResponseBody200StatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetTransactionResponseBody200StatusEnumPending) = "pending"
          toJSON (GetTransactionResponseBody200StatusEnumSubmitted) = "submitted"
          toJSON (GetTransactionResponseBody200StatusEnumIn_ledger) = "in_ledger"
          toJSON (GetTransactionResponseBody200StatusEnumExpired) = "expired"
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Status
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "pending" -> GetTransactionResponseBody200StatusEnumPending
                                            | val GHC.Classes.== "submitted" -> GetTransactionResponseBody200StatusEnumSubmitted
                                            | val GHC.Classes.== "in_ledger" -> GetTransactionResponseBody200StatusEnumIn_ledger
                                            | val GHC.Classes.== "expired" -> GetTransactionResponseBody200StatusEnumExpired
                                            | GHC.Base.otherwise -> GetTransactionResponseBody200StatusOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.validity_interval@ in the specification.
-- 
-- 
data GetTransactionResponseBody200Validity_interval = GetTransactionResponseBody200Validity_interval {
  -- | invalid_before
  getTransactionResponseBody200Validity_intervalInvalid_before :: GetTransactionResponseBody200Validity_intervalInvalid_before
  -- | invalid_hereafter
  , getTransactionResponseBody200Validity_intervalInvalid_hereafter :: GetTransactionResponseBody200Validity_intervalInvalid_hereafter
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Validity_interval
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Validity_interval
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Validity_interval" (\obj -> (GHC.Base.pure GetTransactionResponseBody200Validity_interval GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_before")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_hereafter"))
-- | Create a new 'GetTransactionResponseBody200Validity_interval' with all required fields.
mkGetTransactionResponseBody200Validity_interval :: GetTransactionResponseBody200Validity_intervalInvalid_before -- ^ 'getTransactionResponseBody200Validity_intervalInvalid_before'
  -> GetTransactionResponseBody200Validity_intervalInvalid_hereafter -- ^ 'getTransactionResponseBody200Validity_intervalInvalid_hereafter'
  -> GetTransactionResponseBody200Validity_interval
mkGetTransactionResponseBody200Validity_interval getTransactionResponseBody200Validity_intervalInvalid_before getTransactionResponseBody200Validity_intervalInvalid_hereafter = GetTransactionResponseBody200Validity_interval{getTransactionResponseBody200Validity_intervalInvalid_before = getTransactionResponseBody200Validity_intervalInvalid_before,
                                                                                                                                                                                                                               getTransactionResponseBody200Validity_intervalInvalid_hereafter = getTransactionResponseBody200Validity_intervalInvalid_hereafter}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.validity_interval.properties.invalid_before@ in the specification.
-- 
-- 
data GetTransactionResponseBody200Validity_intervalInvalid_before = GetTransactionResponseBody200Validity_intervalInvalid_before {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200Validity_intervalInvalid_beforeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Validity_intervalInvalid_before
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Validity_intervalInvalid_before
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Validity_intervalInvalid_before" (\obj -> GHC.Base.pure GetTransactionResponseBody200Validity_intervalInvalid_before GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200Validity_intervalInvalid_before' with all required fields.
mkGetTransactionResponseBody200Validity_intervalInvalid_before :: GHC.Types.Int -- ^ 'getTransactionResponseBody200Validity_intervalInvalid_beforeQuantity'
  -> GetTransactionResponseBody200Validity_intervalInvalid_before
mkGetTransactionResponseBody200Validity_intervalInvalid_before getTransactionResponseBody200Validity_intervalInvalid_beforeQuantity = GetTransactionResponseBody200Validity_intervalInvalid_before{getTransactionResponseBody200Validity_intervalInvalid_beforeQuantity = getTransactionResponseBody200Validity_intervalInvalid_beforeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.validity_interval.properties.invalid_hereafter@ in the specification.
-- 
-- 
data GetTransactionResponseBody200Validity_intervalInvalid_hereafter = GetTransactionResponseBody200Validity_intervalInvalid_hereafter {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200Validity_intervalInvalid_hereafterQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Validity_intervalInvalid_hereafter
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Validity_intervalInvalid_hereafter
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Validity_intervalInvalid_hereafter" (\obj -> GHC.Base.pure GetTransactionResponseBody200Validity_intervalInvalid_hereafter GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200Validity_intervalInvalid_hereafter' with all required fields.
mkGetTransactionResponseBody200Validity_intervalInvalid_hereafter :: GHC.Types.Int -- ^ 'getTransactionResponseBody200Validity_intervalInvalid_hereafterQuantity'
  -> GetTransactionResponseBody200Validity_intervalInvalid_hereafter
mkGetTransactionResponseBody200Validity_intervalInvalid_hereafter getTransactionResponseBody200Validity_intervalInvalid_hereafterQuantity = GetTransactionResponseBody200Validity_intervalInvalid_hereafter{getTransactionResponseBody200Validity_intervalInvalid_hereafterQuantity = getTransactionResponseBody200Validity_intervalInvalid_hereafterQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.withdrawals.items@ in the specification.
-- 
-- 
data GetTransactionResponseBody200Withdrawals = GetTransactionResponseBody200Withdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  getTransactionResponseBody200WithdrawalsAmount :: GetTransactionResponseBody200WithdrawalsAmount
  -- | stake_address
  , getTransactionResponseBody200WithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200Withdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200WithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200WithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200Withdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200Withdrawals" (\obj -> (GHC.Base.pure GetTransactionResponseBody200Withdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'GetTransactionResponseBody200Withdrawals' with all required fields.
mkGetTransactionResponseBody200Withdrawals :: GetTransactionResponseBody200WithdrawalsAmount -- ^ 'getTransactionResponseBody200WithdrawalsAmount'
  -> Data.Text.Internal.Text -- ^ 'getTransactionResponseBody200WithdrawalsStake_address'
  -> GetTransactionResponseBody200Withdrawals
mkGetTransactionResponseBody200Withdrawals getTransactionResponseBody200WithdrawalsAmount getTransactionResponseBody200WithdrawalsStake_address = GetTransactionResponseBody200Withdrawals{getTransactionResponseBody200WithdrawalsAmount = getTransactionResponseBody200WithdrawalsAmount,
                                                                                                                                                                                           getTransactionResponseBody200WithdrawalsStake_address = getTransactionResponseBody200WithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetTransactionResponseBody200WithdrawalsAmount = GetTransactionResponseBody200WithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getTransactionResponseBody200WithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody200WithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getTransactionResponseBody200WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody200WithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody200WithdrawalsAmount" (\obj -> GHC.Base.pure GetTransactionResponseBody200WithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetTransactionResponseBody200WithdrawalsAmount' with all required fields.
mkGetTransactionResponseBody200WithdrawalsAmount :: GHC.Types.Int -- ^ 'getTransactionResponseBody200WithdrawalsAmountQuantity'
  -> GetTransactionResponseBody200WithdrawalsAmount
mkGetTransactionResponseBody200WithdrawalsAmount getTransactionResponseBody200WithdrawalsAmountQuantity = GetTransactionResponseBody200WithdrawalsAmount{getTransactionResponseBody200WithdrawalsAmountQuantity = getTransactionResponseBody200WithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.404.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody404OneOf1 = GetTransactionResponseBody404OneOf1 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  getTransactionResponseBody404OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody404OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getTransactionResponseBody404OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getTransactionResponseBody404OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody404OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody404OneOf1" (\obj -> GHC.Base.pure GetTransactionResponseBody404OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetTransactionResponseBody404OneOf1' with all required fields.
mkGetTransactionResponseBody404OneOf1 :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody404OneOf1Message'
  -> GetTransactionResponseBody404OneOf1
mkGetTransactionResponseBody404OneOf1 getTransactionResponseBody404OneOf1Message = GetTransactionResponseBody404OneOf1{getTransactionResponseBody404OneOf1Message = getTransactionResponseBody404OneOf1Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.404.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody404OneOf2 = GetTransactionResponseBody404OneOf2 {
  -- | message: May occur when a given transactionId does not match with any known transactions.
  getTransactionResponseBody404OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody404OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getTransactionResponseBody404OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_transaction"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getTransactionResponseBody404OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_transaction"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody404OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody404OneOf2" (\obj -> GHC.Base.pure GetTransactionResponseBody404OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetTransactionResponseBody404OneOf2' with all required fields.
mkGetTransactionResponseBody404OneOf2 :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody404OneOf2Message'
  -> GetTransactionResponseBody404OneOf2
mkGetTransactionResponseBody404OneOf2 getTransactionResponseBody404OneOf2Message = GetTransactionResponseBody404OneOf2{getTransactionResponseBody404OneOf2Message = getTransactionResponseBody404OneOf2Message}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.404.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data GetTransactionResponseBody404Variants =
   GetTransactionResponseBody404Variant1 GetTransactionResponseBody404OneOf1
  | GetTransactionResponseBody404Variant2 GetTransactionResponseBody404OneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody404Variants
    where toJSON (GetTransactionResponseBody404Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetTransactionResponseBody404Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody404Variants
    where parseJSON val = case (GetTransactionResponseBody404Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetTransactionResponseBody404Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data GetTransactionResponseBody406 = GetTransactionResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  getTransactionResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetTransactionResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetTransactionResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetTransactionResponseBody406" (\obj -> GHC.Base.pure GetTransactionResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetTransactionResponseBody406' with all required fields.
mkGetTransactionResponseBody406 :: Data.Text.Internal.Text -- ^ 'getTransactionResponseBody406Message'
  -> GetTransactionResponseBody406
mkGetTransactionResponseBody406 getTransactionResponseBody406Message = GetTransactionResponseBody406{getTransactionResponseBody406Message = getTransactionResponseBody406Message}
-- | > GET /wallets/{walletId}/transactions/{transactionId}
-- 
-- The same as 'getTransaction' but accepts an explicit configuration.
getTransactionWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> GetTransactionParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response GetTransactionResponse) -- ^ Monadic computation which returns the result of the operation
getTransactionWithConfiguration config
                                parameters = GHC.Base.fmap (\response_4 -> GHC.Base.fmap (Data.Either.either GetTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetTransactionResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                    GetTransactionResponseBody200)
                                                                                                                                                                                      | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> GetTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                    GetTransactionResponseBody404Variants)
                                                                                                                                                                                      | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> GetTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                    GetTransactionResponseBody406)
                                                                                                                                                                                      | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_4) response_4) (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getTransactionParametersPathWalletId parameters))) GHC.Base.<> ("/transactions/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getTransactionParametersPathTransactionId parameters))) GHC.Base.<> "")))) [Wallet.Common.QueryParameter (Data.Text.pack "simple-metadata") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> getTransactionParametersQuerySimple_metadata parameters) (Data.Text.pack "form") GHC.Types.False])
-- | > GET /wallets/{walletId}/transactions/{transactionId}
-- 
-- The same as 'getTransaction' but returns the raw 'Data.ByteString.ByteString'.
getTransactionRaw :: forall m . Wallet.Common.MonadHTTP m => GetTransactionParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
getTransactionRaw parameters = GHC.Base.id (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getTransactionParametersPathWalletId parameters))) GHC.Base.<> ("/transactions/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getTransactionParametersPathTransactionId parameters))) GHC.Base.<> "")))) [Wallet.Common.QueryParameter (Data.Text.pack "simple-metadata") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> getTransactionParametersQuerySimple_metadata parameters) (Data.Text.pack "form") GHC.Types.False])
-- | > GET /wallets/{walletId}/transactions/{transactionId}
-- 
-- The same as 'getTransaction' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
getTransactionWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> GetTransactionParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
getTransactionWithConfigurationRaw config
                                   parameters = GHC.Base.id (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getTransactionParametersPathWalletId parameters))) GHC.Base.<> ("/transactions/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getTransactionParametersPathTransactionId parameters))) GHC.Base.<> "")))) [Wallet.Common.QueryParameter (Data.Text.pack "simple-metadata") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> getTransactionParametersQuerySimple_metadata parameters) (Data.Text.pack "form") GHC.Types.False])
