-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation listTransactions
module Wallet.Operations.ListTransactions where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > GET /wallets/{walletId}/transactions
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Lists all incoming and outgoing wallet\'s transactions.
listTransactions :: forall m . Wallet.Common.MonadHTTP m => ListTransactionsParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response ListTransactionsResponse) -- ^ Monadic computation which returns the result of the operation
listTransactions parameters = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either ListTransactionsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ListTransactionsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         ([ListTransactionsResponseBody200]))
                                                                                                                                                                         | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> ListTransactionsResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         ListTransactionsResponseBody400Variants)
                                                                                                                                                                         | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> ListTransactionsResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         ListTransactionsResponseBody404)
                                                                                                                                                                         | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ListTransactionsResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                         ListTransactionsResponseBody406)
                                                                                                                                                                         | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listTransactionsParametersPathWalletId parameters))) GHC.Base.<> "/transactions")) [Wallet.Common.QueryParameter (Data.Text.pack "start") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryStart parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Wallet.Common.QueryParameter (Data.Text.pack "end") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryEnd parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Wallet.Common.QueryParameter (Data.Text.pack "order") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryOrder parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Wallet.Common.QueryParameter (Data.Text.pack "max_count") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryMax_count parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Wallet.Common.QueryParameter (Data.Text.pack "minWithdrawal") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryMinWithdrawal parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 Wallet.Common.QueryParameter (Data.Text.pack "simple-metadata") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQuerySimple_metadata parameters) (Data.Text.pack "form") GHC.Types.False])
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.parameters@ in the specification.
-- 
-- 
data ListTransactionsParameters = ListTransactionsParameters {
  -- | pathWalletId: Represents the parameter named \'walletId\'
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  listTransactionsParametersPathWalletId :: Data.Text.Internal.Text
  -- | queryEnd: Represents the parameter named \'end\'
  -- 
  -- An optional end time in ISO 8601 date-and-time format. Basic and
  -- extended formats are both accepted. Times can be local (with a
  -- timezone offset) or UTC.
  -- 
  -- If both a start time and an end time are specified, then the start
  -- time must not be later than the end time.
  -- 
  -- Example: \`2008-08-08T08:08:08Z\`
  , listTransactionsParametersQueryEnd :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | queryMax_count: Represents the parameter named \'max_count\'
  -- 
  -- An optional maximum count.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 1.0
  , listTransactionsParametersQueryMax_count :: (GHC.Maybe.Maybe GHC.Types.Int)
  -- | queryMinWithdrawal: Represents the parameter named \'minWithdrawal\'
  -- 
  -- Returns only transactions that have at least one withdrawal above the given amount.
  -- This is particularly useful when set to \`1\` in order to list the withdrawal history of a wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 1.0
  , listTransactionsParametersQueryMinWithdrawal :: (GHC.Maybe.Maybe GHC.Types.Int)
  -- | queryOrder: Represents the parameter named \'order\'
  -- 
  -- An optional sort order.
  , listTransactionsParametersQueryOrder :: (GHC.Maybe.Maybe ListTransactionsParametersQueryOrder)
  -- | querySimple-metadata: Represents the parameter named \'simple-metadata\'
  -- 
  -- When present (or equal to true) in the query, the metadata format for the
  -- transaction(s) in the output will be untyped plain json as specified in
  -- [CIP 25](https:\/\/cips.cardano.org\/cips\/cip25\/)
  , listTransactionsParametersQuerySimple_metadata :: (GHC.Maybe.Maybe GHC.Types.Bool)
  -- | queryStart: Represents the parameter named \'start\'
  -- 
  -- An optional start time in ISO 8601 date-and-time format. Basic and
  -- extended formats are both accepted. Times can be local (with a
  -- timezone offset) or UTC.
  -- 
  -- If both a start time and an end time are specified, then the start
  -- time must not be later than the end time.
  -- 
  -- Example: \`2008-08-08T08:08:08Z\`
  , listTransactionsParametersQueryStart :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsParameters
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pathWalletId" Data.Aeson.Types.ToJSON..= listTransactionsParametersPathWalletId obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryEnd" Data.Aeson.Types.ToJSON..=)) (listTransactionsParametersQueryEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryMax_count" Data.Aeson.Types.ToJSON..=)) (listTransactionsParametersQueryMax_count obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryMinWithdrawal" Data.Aeson.Types.ToJSON..=)) (listTransactionsParametersQueryMinWithdrawal obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryOrder" Data.Aeson.Types.ToJSON..=)) (listTransactionsParametersQueryOrder obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("querySimple-metadata" Data.Aeson.Types.ToJSON..=)) (listTransactionsParametersQuerySimple_metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryStart" Data.Aeson.Types.ToJSON..=)) (listTransactionsParametersQueryStart obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pathWalletId" Data.Aeson.Types.ToJSON..= listTransactionsParametersPathWalletId obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryEnd" Data.Aeson.Types.ToJSON..=)) (listTransactionsParametersQueryEnd obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryMax_count" Data.Aeson.Types.ToJSON..=)) (listTransactionsParametersQueryMax_count obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryMinWithdrawal" Data.Aeson.Types.ToJSON..=)) (listTransactionsParametersQueryMinWithdrawal obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryOrder" Data.Aeson.Types.ToJSON..=)) (listTransactionsParametersQueryOrder obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("querySimple-metadata" Data.Aeson.Types.ToJSON..=)) (listTransactionsParametersQuerySimple_metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryStart" Data.Aeson.Types.ToJSON..=)) (listTransactionsParametersQueryStart obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsParameters
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsParameters" (\obj -> ((((((GHC.Base.pure ListTransactionsParameters GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pathWalletId")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "queryEnd")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "queryMax_count")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "queryMinWithdrawal")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "queryOrder")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "querySimple-metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "queryStart"))
-- | Create a new 'ListTransactionsParameters' with all required fields.
mkListTransactionsParameters :: Data.Text.Internal.Text -- ^ 'listTransactionsParametersPathWalletId'
  -> ListTransactionsParameters
mkListTransactionsParameters listTransactionsParametersPathWalletId = ListTransactionsParameters{listTransactionsParametersPathWalletId = listTransactionsParametersPathWalletId,
                                                                                                 listTransactionsParametersQueryEnd = GHC.Maybe.Nothing,
                                                                                                 listTransactionsParametersQueryMax_count = GHC.Maybe.Nothing,
                                                                                                 listTransactionsParametersQueryMinWithdrawal = GHC.Maybe.Nothing,
                                                                                                 listTransactionsParametersQueryOrder = GHC.Maybe.Nothing,
                                                                                                 listTransactionsParametersQuerySimple_metadata = GHC.Maybe.Nothing,
                                                                                                 listTransactionsParametersQueryStart = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.GET.parameters.properties.queryOrder@ in the specification.
-- 
-- Represents the parameter named \'order\'
-- 
-- An optional sort order.
data ListTransactionsParametersQueryOrder =
   ListTransactionsParametersQueryOrderOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListTransactionsParametersQueryOrderTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListTransactionsParametersQueryOrderEnumAscending -- ^ Represents the JSON value @"ascending"@
  | ListTransactionsParametersQueryOrderEnumDescending -- ^ Represents the JSON value @"descending"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsParametersQueryOrder
    where toJSON (ListTransactionsParametersQueryOrderOther val) = val
          toJSON (ListTransactionsParametersQueryOrderTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListTransactionsParametersQueryOrderEnumAscending) = "ascending"
          toJSON (ListTransactionsParametersQueryOrderEnumDescending) = "descending"
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsParametersQueryOrder
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "ascending" -> ListTransactionsParametersQueryOrderEnumAscending
                                            | val GHC.Classes.== "descending" -> ListTransactionsParametersQueryOrderEnumDescending
                                            | GHC.Base.otherwise -> ListTransactionsParametersQueryOrderOther val)
-- | Represents a response of the operation 'listTransactions'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'ListTransactionsResponseError' is used.
data ListTransactionsResponse =
   ListTransactionsResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | ListTransactionsResponse200 ([ListTransactionsResponseBody200]) -- ^ Ok
  | ListTransactionsResponse400 ListTransactionsResponseBody400Variants -- ^ Bad Request
  | ListTransactionsResponse404 ListTransactionsResponseBody404 -- ^ Not Found
  | ListTransactionsResponse406 ListTransactionsResponseBody406 -- ^ Not Acceptable
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200 = ListTransactionsResponseBody200 {
  -- | amount: An amount of Ada spent or received, from the perspective of the wallet.
  -- 
  -- That is, for outgoing transaction, it represents the amount of Ada consumed
  -- as inputs including the amount of Ada spent as fees or deposits.
  -- 
  -- For incoming transaction, it represents the total amount of Ada received to
  -- addresses that belong to the wallet.
  listTransactionsResponseBody200Amount :: ListTransactionsResponseBody200Amount
  -- | burn
  , listTransactionsResponseBody200Burn :: (GHC.Maybe.Maybe ListTransactionsResponseBody200Burn)
  -- | certificates
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listTransactionsResponseBody200Certificates :: (GHC.Maybe.Maybe ([ListTransactionsResponseBody200CertificatesVariants]))
  -- | collateral: A list of transaction inputs used for collateral.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listTransactionsResponseBody200Collateral :: (GHC.Maybe.Maybe ([ListTransactionsResponseBody200Collateral]))
  -- | collateral_outputs: A list of collateral return outputs with amounts specified.
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 1 items
  -- * Must have a minimum of 0 items
  , listTransactionsResponseBody200Collateral_outputs :: (GHC.Maybe.Maybe ([ListTransactionsResponseBody200Collateral_outputs]))
  -- | deposit_returned: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listTransactionsResponseBody200Deposit_returned :: ListTransactionsResponseBody200Deposit_returned
  -- | deposit_taken: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listTransactionsResponseBody200Deposit_taken :: ListTransactionsResponseBody200Deposit_taken
  -- | depth: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Current depth of the transaction in the local chain
  , listTransactionsResponseBody200Depth :: (GHC.Maybe.Maybe ListTransactionsResponseBody200Depth)
  -- | direction
  , listTransactionsResponseBody200Direction :: ListTransactionsResponseBody200Direction
  -- | expires_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending OR status == expired
  -- \<\/span>\<br\/>
  -- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
  , listTransactionsResponseBody200Expires_at :: (GHC.Maybe.Maybe ListTransactionsResponseBody200Expires_at)
  -- | extra_signatures
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listTransactionsResponseBody200Extra_signatures :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | fee: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listTransactionsResponseBody200Fee :: ListTransactionsResponseBody200Fee
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , listTransactionsResponseBody200Id :: Data.Text.Internal.Text
  -- | inputs: A list of transaction inputs.
  -- 
  -- \`assets\` and \`address\` are always present for \`outgoing\`
  -- transactions but generally absent for \`incoming\`
  -- transactions. This information is present on the Cardano explorer,
  -- but is not tracked by the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listTransactionsResponseBody200Inputs :: ([ListTransactionsResponseBody200Inputs])
  -- | inserted_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Absolute time at which the transaction was inserted in a block.
  , listTransactionsResponseBody200Inserted_at :: (GHC.Maybe.Maybe ListTransactionsResponseBody200Inserted_at)
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  , listTransactionsResponseBody200Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | mint
  , listTransactionsResponseBody200Mint :: (GHC.Maybe.Maybe ListTransactionsResponseBody200Mint)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listTransactionsResponseBody200Outputs :: ([ListTransactionsResponseBody200Outputs])
  -- | pending_since: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending
  -- \<\/span>\<br\/>
  -- The point in time at which a transaction became pending.
  , listTransactionsResponseBody200Pending_since :: (GHC.Maybe.Maybe ListTransactionsResponseBody200Pending_since)
  -- | script_integrity: A script data integrity hash - 32 bytes
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^(script_data)1[0-9a-z]*\$\'
  , listTransactionsResponseBody200Script_integrity :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | script_validity: Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
  -- used in the transaction validated or not. Validity may be null if this
  -- transaction was from an era that doesn\'t support phase-2 monetary policy
  -- scripts, or is a pending transaction (we don\'t know if validation passed or
  -- failed until the transaction hits the ledger).
  , listTransactionsResponseBody200Script_validity :: (GHC.Maybe.Maybe (Wallet.Common.Nullable ListTransactionsResponseBody200Script_validityNonNullable))
  -- | status: Current transaction status.
  -- 
  --   \`\`\`
  --        *-----------*
  --   ---> |  PENDING  |----------------*
  --        *-----------*                |
  --              |                      |
  --              V                      V
  --        *-----------*          *-----------*
  --        |           |---------->  EXPIRED  |
  --        |           |  (ttl)   *-----------*
  --        | SUBMITTED |
  --        |           \<----------------*
  --        |           |                |
  --        *-----------*           (rollback)
  --               |                     |
  --          (in ledger)          *-----------*
  --               |               |           |
  --               *---------------> IN_LEDGER |
  --                               |           |
  --                               *-----------*
  --   \`\`\`
  , listTransactionsResponseBody200Status :: ListTransactionsResponseBody200Status
  -- | validity_interval
  , listTransactionsResponseBody200Validity_interval :: (GHC.Maybe.Maybe ListTransactionsResponseBody200Validity_interval)
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listTransactionsResponseBody200Withdrawals :: ([ListTransactionsResponseBody200Withdrawals])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Fee obj] : ["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Withdrawals obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Fee obj] : ["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Withdrawals obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200" (\obj -> (((((((((((((((((((((((GHC.Base.pure ListTransactionsResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "burn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral_outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "depth")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "direction")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "expires_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "extra_signatures")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fee")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "inserted_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pending_since")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_integrity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_validity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "validity_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "withdrawals"))
-- | Create a new 'ListTransactionsResponseBody200' with all required fields.
mkListTransactionsResponseBody200 :: ListTransactionsResponseBody200Amount -- ^ 'listTransactionsResponseBody200Amount'
  -> ListTransactionsResponseBody200Deposit_returned -- ^ 'listTransactionsResponseBody200Deposit_returned'
  -> ListTransactionsResponseBody200Deposit_taken -- ^ 'listTransactionsResponseBody200Deposit_taken'
  -> ListTransactionsResponseBody200Direction -- ^ 'listTransactionsResponseBody200Direction'
  -> ListTransactionsResponseBody200Fee -- ^ 'listTransactionsResponseBody200Fee'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200Id'
  -> [ListTransactionsResponseBody200Inputs] -- ^ 'listTransactionsResponseBody200Inputs'
  -> [ListTransactionsResponseBody200Outputs] -- ^ 'listTransactionsResponseBody200Outputs'
  -> ListTransactionsResponseBody200Status -- ^ 'listTransactionsResponseBody200Status'
  -> [ListTransactionsResponseBody200Withdrawals] -- ^ 'listTransactionsResponseBody200Withdrawals'
  -> ListTransactionsResponseBody200
mkListTransactionsResponseBody200 listTransactionsResponseBody200Amount listTransactionsResponseBody200Deposit_returned listTransactionsResponseBody200Deposit_taken listTransactionsResponseBody200Direction listTransactionsResponseBody200Fee listTransactionsResponseBody200Id listTransactionsResponseBody200Inputs listTransactionsResponseBody200Outputs listTransactionsResponseBody200Status listTransactionsResponseBody200Withdrawals = ListTransactionsResponseBody200{listTransactionsResponseBody200Amount = listTransactionsResponseBody200Amount,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Burn = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Certificates = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Collateral = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Collateral_outputs = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Deposit_returned = listTransactionsResponseBody200Deposit_returned,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Deposit_taken = listTransactionsResponseBody200Deposit_taken,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Depth = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Direction = listTransactionsResponseBody200Direction,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Expires_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Extra_signatures = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Fee = listTransactionsResponseBody200Fee,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Id = listTransactionsResponseBody200Id,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Inputs = listTransactionsResponseBody200Inputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Inserted_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Mint = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Outputs = listTransactionsResponseBody200Outputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Pending_since = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Script_integrity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Script_validity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Status = listTransactionsResponseBody200Status,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Validity_interval = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200Withdrawals = listTransactionsResponseBody200Withdrawals}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.amount@ in the specification.
-- 
-- An amount of Ada spent or received, from the perspective of the wallet.
-- 
-- That is, for outgoing transaction, it represents the amount of Ada consumed
-- as inputs including the amount of Ada spent as fees or deposits.
-- 
-- For incoming transaction, it represents the total amount of Ada received to
-- addresses that belong to the wallet.
data ListTransactionsResponseBody200Amount = ListTransactionsResponseBody200Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Amount" (\obj -> GHC.Base.pure ListTransactionsResponseBody200Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200Amount' with all required fields.
mkListTransactionsResponseBody200Amount :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200AmountQuantity'
  -> ListTransactionsResponseBody200Amount
mkListTransactionsResponseBody200Amount listTransactionsResponseBody200AmountQuantity = ListTransactionsResponseBody200Amount{listTransactionsResponseBody200AmountQuantity = listTransactionsResponseBody200AmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200Burn = ListTransactionsResponseBody200Burn {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  listTransactionsResponseBody200BurnTokens :: ([ListTransactionsResponseBody200BurnTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , listTransactionsResponseBody200BurnWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , listTransactionsResponseBody200BurnWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200BurnWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200BurnWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Burn" (\obj -> ((GHC.Base.pure ListTransactionsResponseBody200Burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'ListTransactionsResponseBody200Burn' with all required fields.
mkListTransactionsResponseBody200Burn :: [ListTransactionsResponseBody200BurnTokens] -- ^ 'listTransactionsResponseBody200BurnTokens'
  -> ListTransactionsResponseBody200Burn
mkListTransactionsResponseBody200Burn listTransactionsResponseBody200BurnTokens = ListTransactionsResponseBody200Burn{listTransactionsResponseBody200BurnTokens = listTransactionsResponseBody200BurnTokens,
                                                                                                                      listTransactionsResponseBody200BurnWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                      listTransactionsResponseBody200BurnWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200BurnTokens = ListTransactionsResponseBody200BurnTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listTransactionsResponseBody200BurnTokensAssets :: ([ListTransactionsResponseBody200BurnTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listTransactionsResponseBody200BurnTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , listTransactionsResponseBody200BurnTokensPolicy_script :: ListTransactionsResponseBody200BurnTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200BurnTokens" (\obj -> ((GHC.Base.pure ListTransactionsResponseBody200BurnTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'ListTransactionsResponseBody200BurnTokens' with all required fields.
mkListTransactionsResponseBody200BurnTokens :: [ListTransactionsResponseBody200BurnTokensAssets] -- ^ 'listTransactionsResponseBody200BurnTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_id'
  -> ListTransactionsResponseBody200BurnTokensPolicy_scriptVariants -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_script'
  -> ListTransactionsResponseBody200BurnTokens
mkListTransactionsResponseBody200BurnTokens listTransactionsResponseBody200BurnTokensAssets listTransactionsResponseBody200BurnTokensPolicy_id listTransactionsResponseBody200BurnTokensPolicy_script = ListTransactionsResponseBody200BurnTokens{listTransactionsResponseBody200BurnTokensAssets = listTransactionsResponseBody200BurnTokensAssets,
                                                                                                                                                                                                                                                  listTransactionsResponseBody200BurnTokensPolicy_id = listTransactionsResponseBody200BurnTokensPolicy_id,
                                                                                                                                                                                                                                                  listTransactionsResponseBody200BurnTokensPolicy_script = listTransactionsResponseBody200BurnTokensPolicy_script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200BurnTokensAssets = ListTransactionsResponseBody200BurnTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listTransactionsResponseBody200BurnTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , listTransactionsResponseBody200BurnTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200BurnTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200BurnTokensAssets" (\obj -> ((GHC.Base.pure ListTransactionsResponseBody200BurnTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200BurnTokensAssets' with all required fields.
mkListTransactionsResponseBody200BurnTokensAssets :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200BurnTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200BurnTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200BurnTokensAssetsQuantity'
  -> ListTransactionsResponseBody200BurnTokensAssets
mkListTransactionsResponseBody200BurnTokensAssets listTransactionsResponseBody200BurnTokensAssetsAsset_name listTransactionsResponseBody200BurnTokensAssetsFingerprint listTransactionsResponseBody200BurnTokensAssetsQuantity = ListTransactionsResponseBody200BurnTokensAssets{listTransactionsResponseBody200BurnTokensAssetsAsset_name = listTransactionsResponseBody200BurnTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                 listTransactionsResponseBody200BurnTokensAssetsFingerprint = listTransactionsResponseBody200BurnTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                 listTransactionsResponseBody200BurnTokensAssetsQuantity = listTransactionsResponseBody200BurnTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1 = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference)
  -- | script
  , listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script :: ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1' with all required fields.
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1 :: ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script'
  -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1 listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1{listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                 listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference' with all required fields.
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex'
  -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1Reference{listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2{listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3{listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 :: ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4{listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some{listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                    listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5{listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6{listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants =
   ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant2 ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
  | ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant3 ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
  | ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant4 ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
  | ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant5 ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
  | ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant6 ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2 = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info :: ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2' with all required fields.
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2 :: ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info'
  -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2 listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2{listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                      listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference' with all required fields.
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex'
  -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Reference{listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version :: ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info :: ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_info{listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                               listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3 = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References :: ([ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3' with all required fields.
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3 :: [ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References] -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash'
  -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3 listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3{listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                             listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References' with all required fields.
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex'
  -> ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References
mkListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex = ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3References{listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                       listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex = listTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200BurnTokensPolicy_scriptVariants =
   ListTransactionsResponseBody200BurnTokensPolicy_scriptVariant1 ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf1
  | ListTransactionsResponseBody200BurnTokensPolicy_scriptVariant2 ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf2
  | ListTransactionsResponseBody200BurnTokensPolicy_scriptVariant3 ListTransactionsResponseBody200BurnTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptVariants
    where toJSON (ListTransactionsResponseBody200BurnTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200BurnTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200BurnTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200BurnTokensPolicy_scriptVariants
    where parseJSON val = case (ListTransactionsResponseBody200BurnTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200BurnTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200BurnTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data ListTransactionsResponseBody200CertificatesOneOf1 = ListTransactionsResponseBody200CertificatesOneOf1 {
  -- | certificate_type
  listTransactionsResponseBody200CertificatesOneOf1Certificate_type :: ListTransactionsResponseBody200CertificatesOneOf1Certificate_type
  -- | pool: A unique identifier for the pool.
  , listTransactionsResponseBody200CertificatesOneOf1Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , listTransactionsResponseBody200CertificatesOneOf1Reward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200CertificatesOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200CertificatesOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200CertificatesOneOf1" (\obj -> ((GHC.Base.pure ListTransactionsResponseBody200CertificatesOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'ListTransactionsResponseBody200CertificatesOneOf1' with all required fields.
mkListTransactionsResponseBody200CertificatesOneOf1 :: ListTransactionsResponseBody200CertificatesOneOf1Certificate_type -- ^ 'listTransactionsResponseBody200CertificatesOneOf1Certificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'listTransactionsResponseBody200CertificatesOneOf1Reward_account_path'
  -> ListTransactionsResponseBody200CertificatesOneOf1
mkListTransactionsResponseBody200CertificatesOneOf1 listTransactionsResponseBody200CertificatesOneOf1Certificate_type listTransactionsResponseBody200CertificatesOneOf1Reward_account_path = ListTransactionsResponseBody200CertificatesOneOf1{listTransactionsResponseBody200CertificatesOneOf1Certificate_type = listTransactionsResponseBody200CertificatesOneOf1Certificate_type,
                                                                                                                                                                                                                                               listTransactionsResponseBody200CertificatesOneOf1Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                               listTransactionsResponseBody200CertificatesOneOf1Reward_account_path = listTransactionsResponseBody200CertificatesOneOf1Reward_account_path}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200CertificatesOneOf1Certificate_type =
   ListTransactionsResponseBody200CertificatesOneOf1Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListTransactionsResponseBody200CertificatesOneOf1Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | ListTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | ListTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200CertificatesOneOf1Certificate_type
    where toJSON (ListTransactionsResponseBody200CertificatesOneOf1Certificate_typeOther val) = val
          toJSON (ListTransactionsResponseBody200CertificatesOneOf1Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumJoin_pool) = "join_pool"
          toJSON (ListTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (ListTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200CertificatesOneOf1Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> ListTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> ListTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> ListTransactionsResponseBody200CertificatesOneOf1Certificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> ListTransactionsResponseBody200CertificatesOneOf1Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate not belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data ListTransactionsResponseBody200CertificatesOneOf2 = ListTransactionsResponseBody200CertificatesOneOf2 {
  -- | certificate_type
  listTransactionsResponseBody200CertificatesOneOf2Certificate_type :: ListTransactionsResponseBody200CertificatesOneOf2Certificate_type
  -- | pool: A unique identifier for the pool.
  , listTransactionsResponseBody200CertificatesOneOf2Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account
  , listTransactionsResponseBody200CertificatesOneOf2Reward_account :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200CertificatesOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf2Reward_account obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf2Reward_account obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200CertificatesOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200CertificatesOneOf2" (\obj -> ((GHC.Base.pure ListTransactionsResponseBody200CertificatesOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account"))
-- | Create a new 'ListTransactionsResponseBody200CertificatesOneOf2' with all required fields.
mkListTransactionsResponseBody200CertificatesOneOf2 :: ListTransactionsResponseBody200CertificatesOneOf2Certificate_type -- ^ 'listTransactionsResponseBody200CertificatesOneOf2Certificate_type'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200CertificatesOneOf2Reward_account'
  -> ListTransactionsResponseBody200CertificatesOneOf2
mkListTransactionsResponseBody200CertificatesOneOf2 listTransactionsResponseBody200CertificatesOneOf2Certificate_type listTransactionsResponseBody200CertificatesOneOf2Reward_account = ListTransactionsResponseBody200CertificatesOneOf2{listTransactionsResponseBody200CertificatesOneOf2Certificate_type = listTransactionsResponseBody200CertificatesOneOf2Certificate_type,
                                                                                                                                                                                                                                          listTransactionsResponseBody200CertificatesOneOf2Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                          listTransactionsResponseBody200CertificatesOneOf2Reward_account = listTransactionsResponseBody200CertificatesOneOf2Reward_account}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200CertificatesOneOf2Certificate_type =
   ListTransactionsResponseBody200CertificatesOneOf2Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListTransactionsResponseBody200CertificatesOneOf2Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumJoin_pool_external -- ^ Represents the JSON value @"join_pool_external"@
  | ListTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumQuit_pool_external -- ^ Represents the JSON value @"quit_pool_external"@
  | ListTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external -- ^ Represents the JSON value @"register_reward_account_external"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200CertificatesOneOf2Certificate_type
    where toJSON (ListTransactionsResponseBody200CertificatesOneOf2Certificate_typeOther val) = val
          toJSON (ListTransactionsResponseBody200CertificatesOneOf2Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumJoin_pool_external) = "join_pool_external"
          toJSON (ListTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumQuit_pool_external) = "quit_pool_external"
          toJSON (ListTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external) = "register_reward_account_external"
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200CertificatesOneOf2Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool_external" -> ListTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumJoin_pool_external
                                            | val GHC.Classes.== "quit_pool_external" -> ListTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumQuit_pool_external
                                            | val GHC.Classes.== "register_reward_account_external" -> ListTransactionsResponseBody200CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external
                                            | GHC.Base.otherwise -> ListTransactionsResponseBody200CertificatesOneOf2Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200CertificatesOneOf3 = ListTransactionsResponseBody200CertificatesOneOf3 {
  -- | pool_cost: Estimated cost set by the pool operator when registering his pool.
  -- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  listTransactionsResponseBody200CertificatesOneOf3Pool_cost :: ListTransactionsResponseBody200CertificatesOneOf3Pool_cost
  -- | pool_id: A unique identifier for the pool.
  , listTransactionsResponseBody200CertificatesOneOf3Pool_id :: Data.Text.Internal.Text
  -- | pool_margin: Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , listTransactionsResponseBody200CertificatesOneOf3Pool_margin :: ListTransactionsResponseBody200CertificatesOneOf3Pool_margin
  -- | pool_metadata
  , listTransactionsResponseBody200CertificatesOneOf3Pool_metadata :: (GHC.Maybe.Maybe ListTransactionsResponseBody200CertificatesOneOf3Pool_metadata)
  -- | pool_owners
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , listTransactionsResponseBody200CertificatesOneOf3Pool_owners :: ([Data.Text.Internal.Text])
  -- | pool_pledge: Minimal stake amount that a stake pool is willing to honor.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , listTransactionsResponseBody200CertificatesOneOf3Pool_pledge :: ListTransactionsResponseBody200CertificatesOneOf3Pool_pledge
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200CertificatesOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200CertificatesOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200CertificatesOneOf3" (\obj -> (((((GHC.Base.pure ListTransactionsResponseBody200CertificatesOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_cost")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_margin")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool_metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_owners")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_pledge"))
-- | Create a new 'ListTransactionsResponseBody200CertificatesOneOf3' with all required fields.
mkListTransactionsResponseBody200CertificatesOneOf3 :: ListTransactionsResponseBody200CertificatesOneOf3Pool_cost -- ^ 'listTransactionsResponseBody200CertificatesOneOf3Pool_cost'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200CertificatesOneOf3Pool_id'
  -> ListTransactionsResponseBody200CertificatesOneOf3Pool_margin -- ^ 'listTransactionsResponseBody200CertificatesOneOf3Pool_margin'
  -> [Data.Text.Internal.Text] -- ^ 'listTransactionsResponseBody200CertificatesOneOf3Pool_owners'
  -> ListTransactionsResponseBody200CertificatesOneOf3Pool_pledge -- ^ 'listTransactionsResponseBody200CertificatesOneOf3Pool_pledge'
  -> ListTransactionsResponseBody200CertificatesOneOf3
mkListTransactionsResponseBody200CertificatesOneOf3 listTransactionsResponseBody200CertificatesOneOf3Pool_cost listTransactionsResponseBody200CertificatesOneOf3Pool_id listTransactionsResponseBody200CertificatesOneOf3Pool_margin listTransactionsResponseBody200CertificatesOneOf3Pool_owners listTransactionsResponseBody200CertificatesOneOf3Pool_pledge = ListTransactionsResponseBody200CertificatesOneOf3{listTransactionsResponseBody200CertificatesOneOf3Pool_cost = listTransactionsResponseBody200CertificatesOneOf3Pool_cost,
                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200CertificatesOneOf3Pool_id = listTransactionsResponseBody200CertificatesOneOf3Pool_id,
                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200CertificatesOneOf3Pool_margin = listTransactionsResponseBody200CertificatesOneOf3Pool_margin,
                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200CertificatesOneOf3Pool_metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200CertificatesOneOf3Pool_owners = listTransactionsResponseBody200CertificatesOneOf3Pool_owners,
                                                                                                                                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200CertificatesOneOf3Pool_pledge = listTransactionsResponseBody200CertificatesOneOf3Pool_pledge}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_cost@ in the specification.
-- 
-- Estimated cost set by the pool operator when registering his pool.
-- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data ListTransactionsResponseBody200CertificatesOneOf3Pool_cost = ListTransactionsResponseBody200CertificatesOneOf3Pool_cost {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200CertificatesOneOf3Pool_cost
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200CertificatesOneOf3Pool_cost
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200CertificatesOneOf3Pool_cost" (\obj -> GHC.Base.pure ListTransactionsResponseBody200CertificatesOneOf3Pool_cost GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200CertificatesOneOf3Pool_cost' with all required fields.
mkListTransactionsResponseBody200CertificatesOneOf3Pool_cost :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity'
  -> ListTransactionsResponseBody200CertificatesOneOf3Pool_cost
mkListTransactionsResponseBody200CertificatesOneOf3Pool_cost listTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity = ListTransactionsResponseBody200CertificatesOneOf3Pool_cost{listTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity = listTransactionsResponseBody200CertificatesOneOf3Pool_costQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_margin@ in the specification.
-- 
-- Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data ListTransactionsResponseBody200CertificatesOneOf3Pool_margin = ListTransactionsResponseBody200CertificatesOneOf3Pool_margin {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  listTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200CertificatesOneOf3Pool_margin
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200CertificatesOneOf3Pool_margin
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200CertificatesOneOf3Pool_margin" (\obj -> GHC.Base.pure ListTransactionsResponseBody200CertificatesOneOf3Pool_margin GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200CertificatesOneOf3Pool_margin' with all required fields.
mkListTransactionsResponseBody200CertificatesOneOf3Pool_margin :: GHC.Types.Double -- ^ 'listTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity'
  -> ListTransactionsResponseBody200CertificatesOneOf3Pool_margin
mkListTransactionsResponseBody200CertificatesOneOf3Pool_margin listTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity = ListTransactionsResponseBody200CertificatesOneOf3Pool_margin{listTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity = listTransactionsResponseBody200CertificatesOneOf3Pool_marginQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_metadata@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200CertificatesOneOf3Pool_metadata = ListTransactionsResponseBody200CertificatesOneOf3Pool_metadata {
  -- | hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash :: Data.Text.Internal.Text
  -- | url: A URL to the stake pool\'s website.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 250
  -- * Must match pattern \'^https:\/\/.+\'
  , listTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200CertificatesOneOf3Pool_metadata
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200CertificatesOneOf3Pool_metadata
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200CertificatesOneOf3Pool_metadata" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200CertificatesOneOf3Pool_metadata GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))
-- | Create a new 'ListTransactionsResponseBody200CertificatesOneOf3Pool_metadata' with all required fields.
mkListTransactionsResponseBody200CertificatesOneOf3Pool_metadata :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl'
  -> ListTransactionsResponseBody200CertificatesOneOf3Pool_metadata
mkListTransactionsResponseBody200CertificatesOneOf3Pool_metadata listTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash listTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl = ListTransactionsResponseBody200CertificatesOneOf3Pool_metadata{listTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash = listTransactionsResponseBody200CertificatesOneOf3Pool_metadataHash,
                                                                                                                                                                                                                                                                       listTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl = listTransactionsResponseBody200CertificatesOneOf3Pool_metadataUrl}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_pledge@ in the specification.
-- 
-- Minimal stake amount that a stake pool is willing to honor.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data ListTransactionsResponseBody200CertificatesOneOf3Pool_pledge = ListTransactionsResponseBody200CertificatesOneOf3Pool_pledge {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200CertificatesOneOf3Pool_pledge
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200CertificatesOneOf3Pool_pledge
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200CertificatesOneOf3Pool_pledge" (\obj -> GHC.Base.pure ListTransactionsResponseBody200CertificatesOneOf3Pool_pledge GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200CertificatesOneOf3Pool_pledge' with all required fields.
mkListTransactionsResponseBody200CertificatesOneOf3Pool_pledge :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity'
  -> ListTransactionsResponseBody200CertificatesOneOf3Pool_pledge
mkListTransactionsResponseBody200CertificatesOneOf3Pool_pledge listTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity = ListTransactionsResponseBody200CertificatesOneOf3Pool_pledge{listTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity = listTransactionsResponseBody200CertificatesOneOf3Pool_pledgeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200CertificatesOneOf4 = ListTransactionsResponseBody200CertificatesOneOf4 {
  -- | pool_id: A unique identifier for the pool.
  listTransactionsResponseBody200CertificatesOneOf4Pool_id :: Data.Text.Internal.Text
  -- | retirement_epoch: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200CertificatesOneOf4Retirement_epoch :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200CertificatesOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200CertificatesOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200CertificatesOneOf4" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200CertificatesOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "retirement_epoch"))
-- | Create a new 'ListTransactionsResponseBody200CertificatesOneOf4' with all required fields.
mkListTransactionsResponseBody200CertificatesOneOf4 :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200CertificatesOneOf4Pool_id'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200CertificatesOneOf4Retirement_epoch'
  -> ListTransactionsResponseBody200CertificatesOneOf4
mkListTransactionsResponseBody200CertificatesOneOf4 listTransactionsResponseBody200CertificatesOneOf4Pool_id listTransactionsResponseBody200CertificatesOneOf4Retirement_epoch = ListTransactionsResponseBody200CertificatesOneOf4{listTransactionsResponseBody200CertificatesOneOf4Pool_id = listTransactionsResponseBody200CertificatesOneOf4Pool_id,
                                                                                                                                                                                                                                   listTransactionsResponseBody200CertificatesOneOf4Retirement_epoch = listTransactionsResponseBody200CertificatesOneOf4Retirement_epoch}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200CertificatesOneOf5 = ListTransactionsResponseBody200CertificatesOneOf5 {
  -- | certificate_type
  listTransactionsResponseBody200CertificatesOneOf5Certificate_type :: ListTransactionsResponseBody200CertificatesOneOf5Certificate_type
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200CertificatesOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200CertificatesOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200CertificatesOneOf5" (\obj -> GHC.Base.pure ListTransactionsResponseBody200CertificatesOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type"))
-- | Create a new 'ListTransactionsResponseBody200CertificatesOneOf5' with all required fields.
mkListTransactionsResponseBody200CertificatesOneOf5 :: ListTransactionsResponseBody200CertificatesOneOf5Certificate_type -- ^ 'listTransactionsResponseBody200CertificatesOneOf5Certificate_type'
  -> ListTransactionsResponseBody200CertificatesOneOf5
mkListTransactionsResponseBody200CertificatesOneOf5 listTransactionsResponseBody200CertificatesOneOf5Certificate_type = ListTransactionsResponseBody200CertificatesOneOf5{listTransactionsResponseBody200CertificatesOneOf5Certificate_type = listTransactionsResponseBody200CertificatesOneOf5Certificate_type}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200CertificatesOneOf5Certificate_type =
   ListTransactionsResponseBody200CertificatesOneOf5Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListTransactionsResponseBody200CertificatesOneOf5Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumMir -- ^ Represents the JSON value @"mir"@
  | ListTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumGenesis -- ^ Represents the JSON value @"genesis"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200CertificatesOneOf5Certificate_type
    where toJSON (ListTransactionsResponseBody200CertificatesOneOf5Certificate_typeOther val) = val
          toJSON (ListTransactionsResponseBody200CertificatesOneOf5Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumMir) = "mir"
          toJSON (ListTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumGenesis) = "genesis"
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200CertificatesOneOf5Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "mir" -> ListTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumMir
                                            | val GHC.Classes.== "genesis" -> ListTransactionsResponseBody200CertificatesOneOf5Certificate_typeEnumGenesis
                                            | GHC.Base.otherwise -> ListTransactionsResponseBody200CertificatesOneOf5Certificate_typeOther val)
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- Any certificate that could occur in an arbitrary transaction:
-- might be related to delegation, pool activities, genesis or MIR.
data ListTransactionsResponseBody200CertificatesVariants =
   ListTransactionsResponseBody200CertificatesVariant1 ListTransactionsResponseBody200CertificatesOneOf1
  | ListTransactionsResponseBody200CertificatesVariant2 ListTransactionsResponseBody200CertificatesOneOf2
  | ListTransactionsResponseBody200CertificatesVariant3 ListTransactionsResponseBody200CertificatesOneOf3
  | ListTransactionsResponseBody200CertificatesVariant4 ListTransactionsResponseBody200CertificatesOneOf4
  | ListTransactionsResponseBody200CertificatesVariant5 ListTransactionsResponseBody200CertificatesOneOf5
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200CertificatesVariants
    where toJSON (ListTransactionsResponseBody200CertificatesVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200CertificatesVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200CertificatesVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200CertificatesVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200CertificatesVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200CertificatesVariants
    where parseJSON val = case (ListTransactionsResponseBody200CertificatesVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200CertificatesVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200CertificatesVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200CertificatesVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200CertificatesVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.collateral.items@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200Collateral = ListTransactionsResponseBody200Collateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  listTransactionsResponseBody200CollateralAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listTransactionsResponseBody200CollateralAmount :: (GHC.Maybe.Maybe ListTransactionsResponseBody200CollateralAmount)
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , listTransactionsResponseBody200CollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200CollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Collateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Collateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Collateral" (\obj -> (((GHC.Base.pure ListTransactionsResponseBody200Collateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListTransactionsResponseBody200Collateral' with all required fields.
mkListTransactionsResponseBody200Collateral :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200CollateralId'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200CollateralIndex'
  -> ListTransactionsResponseBody200Collateral
mkListTransactionsResponseBody200Collateral listTransactionsResponseBody200CollateralId listTransactionsResponseBody200CollateralIndex = ListTransactionsResponseBody200Collateral{listTransactionsResponseBody200CollateralAddress = GHC.Maybe.Nothing,
                                                                                                                                                                                   listTransactionsResponseBody200CollateralAmount = GHC.Maybe.Nothing,
                                                                                                                                                                                   listTransactionsResponseBody200CollateralId = listTransactionsResponseBody200CollateralId,
                                                                                                                                                                                   listTransactionsResponseBody200CollateralIndex = listTransactionsResponseBody200CollateralIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListTransactionsResponseBody200CollateralAmount = ListTransactionsResponseBody200CollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200CollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200CollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200CollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200CollateralAmount" (\obj -> GHC.Base.pure ListTransactionsResponseBody200CollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200CollateralAmount' with all required fields.
mkListTransactionsResponseBody200CollateralAmount :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200CollateralAmountQuantity'
  -> ListTransactionsResponseBody200CollateralAmount
mkListTransactionsResponseBody200CollateralAmount listTransactionsResponseBody200CollateralAmountQuantity = ListTransactionsResponseBody200CollateralAmount{listTransactionsResponseBody200CollateralAmountQuantity = listTransactionsResponseBody200CollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.collateral_outputs.items@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200Collateral_outputs = ListTransactionsResponseBody200Collateral_outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  listTransactionsResponseBody200Collateral_outputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listTransactionsResponseBody200Collateral_outputsAmount :: ListTransactionsResponseBody200Collateral_outputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , listTransactionsResponseBody200Collateral_outputsAssets :: (GHC.Maybe.Maybe ([ListTransactionsResponseBody200Collateral_outputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Collateral_outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Collateral_outputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200Collateral_outputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Collateral_outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Collateral_outputs" (\obj -> ((GHC.Base.pure ListTransactionsResponseBody200Collateral_outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'ListTransactionsResponseBody200Collateral_outputs' with all required fields.
mkListTransactionsResponseBody200Collateral_outputs :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200Collateral_outputsAddress'
  -> ListTransactionsResponseBody200Collateral_outputsAmount -- ^ 'listTransactionsResponseBody200Collateral_outputsAmount'
  -> ListTransactionsResponseBody200Collateral_outputs
mkListTransactionsResponseBody200Collateral_outputs listTransactionsResponseBody200Collateral_outputsAddress listTransactionsResponseBody200Collateral_outputsAmount = ListTransactionsResponseBody200Collateral_outputs{listTransactionsResponseBody200Collateral_outputsAddress = listTransactionsResponseBody200Collateral_outputsAddress,
                                                                                                                                                                                                                         listTransactionsResponseBody200Collateral_outputsAmount = listTransactionsResponseBody200Collateral_outputsAmount,
                                                                                                                                                                                                                         listTransactionsResponseBody200Collateral_outputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.collateral_outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListTransactionsResponseBody200Collateral_outputsAmount = ListTransactionsResponseBody200Collateral_outputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200Collateral_outputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Collateral_outputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Collateral_outputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Collateral_outputsAmount" (\obj -> GHC.Base.pure ListTransactionsResponseBody200Collateral_outputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200Collateral_outputsAmount' with all required fields.
mkListTransactionsResponseBody200Collateral_outputsAmount :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200Collateral_outputsAmountQuantity'
  -> ListTransactionsResponseBody200Collateral_outputsAmount
mkListTransactionsResponseBody200Collateral_outputsAmount listTransactionsResponseBody200Collateral_outputsAmountQuantity = ListTransactionsResponseBody200Collateral_outputsAmount{listTransactionsResponseBody200Collateral_outputsAmountQuantity = listTransactionsResponseBody200Collateral_outputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.collateral_outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ListTransactionsResponseBody200Collateral_outputsAssets = ListTransactionsResponseBody200Collateral_outputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listTransactionsResponseBody200Collateral_outputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listTransactionsResponseBody200Collateral_outputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200Collateral_outputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Collateral_outputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Collateral_outputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Collateral_outputsAssets" (\obj -> ((GHC.Base.pure ListTransactionsResponseBody200Collateral_outputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200Collateral_outputsAssets' with all required fields.
mkListTransactionsResponseBody200Collateral_outputsAssets :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200Collateral_outputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200Collateral_outputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200Collateral_outputsAssetsQuantity'
  -> ListTransactionsResponseBody200Collateral_outputsAssets
mkListTransactionsResponseBody200Collateral_outputsAssets listTransactionsResponseBody200Collateral_outputsAssetsAsset_name listTransactionsResponseBody200Collateral_outputsAssetsPolicy_id listTransactionsResponseBody200Collateral_outputsAssetsQuantity = ListTransactionsResponseBody200Collateral_outputsAssets{listTransactionsResponseBody200Collateral_outputsAssetsAsset_name = listTransactionsResponseBody200Collateral_outputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                       listTransactionsResponseBody200Collateral_outputsAssetsPolicy_id = listTransactionsResponseBody200Collateral_outputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                       listTransactionsResponseBody200Collateral_outputsAssetsQuantity = listTransactionsResponseBody200Collateral_outputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.deposit_returned@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListTransactionsResponseBody200Deposit_returned = ListTransactionsResponseBody200Deposit_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200Deposit_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Deposit_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Deposit_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Deposit_returned" (\obj -> GHC.Base.pure ListTransactionsResponseBody200Deposit_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200Deposit_returned' with all required fields.
mkListTransactionsResponseBody200Deposit_returned :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200Deposit_returnedQuantity'
  -> ListTransactionsResponseBody200Deposit_returned
mkListTransactionsResponseBody200Deposit_returned listTransactionsResponseBody200Deposit_returnedQuantity = ListTransactionsResponseBody200Deposit_returned{listTransactionsResponseBody200Deposit_returnedQuantity = listTransactionsResponseBody200Deposit_returnedQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.deposit_taken@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListTransactionsResponseBody200Deposit_taken = ListTransactionsResponseBody200Deposit_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200Deposit_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Deposit_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Deposit_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Deposit_taken" (\obj -> GHC.Base.pure ListTransactionsResponseBody200Deposit_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200Deposit_taken' with all required fields.
mkListTransactionsResponseBody200Deposit_taken :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200Deposit_takenQuantity'
  -> ListTransactionsResponseBody200Deposit_taken
mkListTransactionsResponseBody200Deposit_taken listTransactionsResponseBody200Deposit_takenQuantity = ListTransactionsResponseBody200Deposit_taken{listTransactionsResponseBody200Deposit_takenQuantity = listTransactionsResponseBody200Deposit_takenQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.depth@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Current depth of the transaction in the local chain
data ListTransactionsResponseBody200Depth = ListTransactionsResponseBody200Depth {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200DepthQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Depth
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Depth
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Depth" (\obj -> GHC.Base.pure ListTransactionsResponseBody200Depth GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200Depth' with all required fields.
mkListTransactionsResponseBody200Depth :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200DepthQuantity'
  -> ListTransactionsResponseBody200Depth
mkListTransactionsResponseBody200Depth listTransactionsResponseBody200DepthQuantity = ListTransactionsResponseBody200Depth{listTransactionsResponseBody200DepthQuantity = listTransactionsResponseBody200DepthQuantity}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.direction@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200Direction =
   ListTransactionsResponseBody200DirectionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListTransactionsResponseBody200DirectionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListTransactionsResponseBody200DirectionEnumOutgoing -- ^ Represents the JSON value @"outgoing"@
  | ListTransactionsResponseBody200DirectionEnumIncoming -- ^ Represents the JSON value @"incoming"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Direction
    where toJSON (ListTransactionsResponseBody200DirectionOther val) = val
          toJSON (ListTransactionsResponseBody200DirectionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListTransactionsResponseBody200DirectionEnumOutgoing) = "outgoing"
          toJSON (ListTransactionsResponseBody200DirectionEnumIncoming) = "incoming"
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Direction
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "outgoing" -> ListTransactionsResponseBody200DirectionEnumOutgoing
                                            | val GHC.Classes.== "incoming" -> ListTransactionsResponseBody200DirectionEnumIncoming
                                            | GHC.Base.otherwise -> ListTransactionsResponseBody200DirectionOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.expires_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending OR status == expired
-- \<\/span>\<br\/>
-- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
data ListTransactionsResponseBody200Expires_at = ListTransactionsResponseBody200Expires_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200Expires_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200Expires_atEpoch_number :: GHC.Types.Int
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200Expires_atSlot_number :: GHC.Types.Int
  -- | time
  , listTransactionsResponseBody200Expires_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Expires_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Expires_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Expires_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Expires_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Expires_at" (\obj -> (((GHC.Base.pure ListTransactionsResponseBody200Expires_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'ListTransactionsResponseBody200Expires_at' with all required fields.
mkListTransactionsResponseBody200Expires_at :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200Expires_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200Expires_atEpoch_number'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200Expires_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200Expires_atTime'
  -> ListTransactionsResponseBody200Expires_at
mkListTransactionsResponseBody200Expires_at listTransactionsResponseBody200Expires_atAbsolute_slot_number listTransactionsResponseBody200Expires_atEpoch_number listTransactionsResponseBody200Expires_atSlot_number listTransactionsResponseBody200Expires_atTime = ListTransactionsResponseBody200Expires_at{listTransactionsResponseBody200Expires_atAbsolute_slot_number = listTransactionsResponseBody200Expires_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                               listTransactionsResponseBody200Expires_atEpoch_number = listTransactionsResponseBody200Expires_atEpoch_number,
                                                                                                                                                                                                                                                                                                               listTransactionsResponseBody200Expires_atSlot_number = listTransactionsResponseBody200Expires_atSlot_number,
                                                                                                                                                                                                                                                                                                               listTransactionsResponseBody200Expires_atTime = listTransactionsResponseBody200Expires_atTime}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.fee@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListTransactionsResponseBody200Fee = ListTransactionsResponseBody200Fee {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200FeeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Fee
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Fee
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Fee" (\obj -> GHC.Base.pure ListTransactionsResponseBody200Fee GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200Fee' with all required fields.
mkListTransactionsResponseBody200Fee :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200FeeQuantity'
  -> ListTransactionsResponseBody200Fee
mkListTransactionsResponseBody200Fee listTransactionsResponseBody200FeeQuantity = ListTransactionsResponseBody200Fee{listTransactionsResponseBody200FeeQuantity = listTransactionsResponseBody200FeeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.inputs.items@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200Inputs = ListTransactionsResponseBody200Inputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  listTransactionsResponseBody200InputsAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listTransactionsResponseBody200InputsAmount :: (GHC.Maybe.Maybe ListTransactionsResponseBody200InputsAmount)
  -- | assets: A flat list of assets (possibly empty).
  , listTransactionsResponseBody200InputsAssets :: (GHC.Maybe.Maybe ([ListTransactionsResponseBody200InputsAssets]))
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , listTransactionsResponseBody200InputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200InputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Inputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200InputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200InputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Inputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Inputs" (\obj -> ((((GHC.Base.pure ListTransactionsResponseBody200Inputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListTransactionsResponseBody200Inputs' with all required fields.
mkListTransactionsResponseBody200Inputs :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200InputsId'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200InputsIndex'
  -> ListTransactionsResponseBody200Inputs
mkListTransactionsResponseBody200Inputs listTransactionsResponseBody200InputsId listTransactionsResponseBody200InputsIndex = ListTransactionsResponseBody200Inputs{listTransactionsResponseBody200InputsAddress = GHC.Maybe.Nothing,
                                                                                                                                                                   listTransactionsResponseBody200InputsAmount = GHC.Maybe.Nothing,
                                                                                                                                                                   listTransactionsResponseBody200InputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                                   listTransactionsResponseBody200InputsId = listTransactionsResponseBody200InputsId,
                                                                                                                                                                   listTransactionsResponseBody200InputsIndex = listTransactionsResponseBody200InputsIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListTransactionsResponseBody200InputsAmount = ListTransactionsResponseBody200InputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200InputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200InputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200InputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200InputsAmount" (\obj -> GHC.Base.pure ListTransactionsResponseBody200InputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200InputsAmount' with all required fields.
mkListTransactionsResponseBody200InputsAmount :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200InputsAmountQuantity'
  -> ListTransactionsResponseBody200InputsAmount
mkListTransactionsResponseBody200InputsAmount listTransactionsResponseBody200InputsAmountQuantity = ListTransactionsResponseBody200InputsAmount{listTransactionsResponseBody200InputsAmountQuantity = listTransactionsResponseBody200InputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ListTransactionsResponseBody200InputsAssets = ListTransactionsResponseBody200InputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listTransactionsResponseBody200InputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listTransactionsResponseBody200InputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200InputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200InputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200InputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200InputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200InputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200InputsAssets" (\obj -> ((GHC.Base.pure ListTransactionsResponseBody200InputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200InputsAssets' with all required fields.
mkListTransactionsResponseBody200InputsAssets :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200InputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200InputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200InputsAssetsQuantity'
  -> ListTransactionsResponseBody200InputsAssets
mkListTransactionsResponseBody200InputsAssets listTransactionsResponseBody200InputsAssetsAsset_name listTransactionsResponseBody200InputsAssetsPolicy_id listTransactionsResponseBody200InputsAssetsQuantity = ListTransactionsResponseBody200InputsAssets{listTransactionsResponseBody200InputsAssetsAsset_name = listTransactionsResponseBody200InputsAssetsAsset_name,
                                                                                                                                                                                                                                                           listTransactionsResponseBody200InputsAssetsPolicy_id = listTransactionsResponseBody200InputsAssetsPolicy_id,
                                                                                                                                                                                                                                                           listTransactionsResponseBody200InputsAssetsQuantity = listTransactionsResponseBody200InputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.inserted_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Absolute time at which the transaction was inserted in a block.
data ListTransactionsResponseBody200Inserted_at = ListTransactionsResponseBody200Inserted_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200Inserted_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200Inserted_atEpoch_number :: GHC.Types.Int
  -- | height
  , listTransactionsResponseBody200Inserted_atHeight :: ListTransactionsResponseBody200Inserted_atHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200Inserted_atSlot_number :: GHC.Types.Int
  -- | time
  , listTransactionsResponseBody200Inserted_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Inserted_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Inserted_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Inserted_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Inserted_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Inserted_at" (\obj -> ((((GHC.Base.pure ListTransactionsResponseBody200Inserted_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'ListTransactionsResponseBody200Inserted_at' with all required fields.
mkListTransactionsResponseBody200Inserted_at :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200Inserted_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200Inserted_atEpoch_number'
  -> ListTransactionsResponseBody200Inserted_atHeight -- ^ 'listTransactionsResponseBody200Inserted_atHeight'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200Inserted_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200Inserted_atTime'
  -> ListTransactionsResponseBody200Inserted_at
mkListTransactionsResponseBody200Inserted_at listTransactionsResponseBody200Inserted_atAbsolute_slot_number listTransactionsResponseBody200Inserted_atEpoch_number listTransactionsResponseBody200Inserted_atHeight listTransactionsResponseBody200Inserted_atSlot_number listTransactionsResponseBody200Inserted_atTime = ListTransactionsResponseBody200Inserted_at{listTransactionsResponseBody200Inserted_atAbsolute_slot_number = listTransactionsResponseBody200Inserted_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                      listTransactionsResponseBody200Inserted_atEpoch_number = listTransactionsResponseBody200Inserted_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                      listTransactionsResponseBody200Inserted_atHeight = listTransactionsResponseBody200Inserted_atHeight,
                                                                                                                                                                                                                                                                                                                                                                      listTransactionsResponseBody200Inserted_atSlot_number = listTransactionsResponseBody200Inserted_atSlot_number,
                                                                                                                                                                                                                                                                                                                                                                      listTransactionsResponseBody200Inserted_atTime = listTransactionsResponseBody200Inserted_atTime}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.inserted_at.properties.height@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200Inserted_atHeight = ListTransactionsResponseBody200Inserted_atHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200Inserted_atHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Inserted_atHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Inserted_atHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Inserted_atHeight" (\obj -> GHC.Base.pure ListTransactionsResponseBody200Inserted_atHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200Inserted_atHeight' with all required fields.
mkListTransactionsResponseBody200Inserted_atHeight :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200Inserted_atHeightQuantity'
  -> ListTransactionsResponseBody200Inserted_atHeight
mkListTransactionsResponseBody200Inserted_atHeight listTransactionsResponseBody200Inserted_atHeightQuantity = ListTransactionsResponseBody200Inserted_atHeight{listTransactionsResponseBody200Inserted_atHeightQuantity = listTransactionsResponseBody200Inserted_atHeightQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200Mint = ListTransactionsResponseBody200Mint {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  listTransactionsResponseBody200MintTokens :: ([ListTransactionsResponseBody200MintTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , listTransactionsResponseBody200MintWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , listTransactionsResponseBody200MintWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Mint
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200MintWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200MintWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Mint
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Mint" (\obj -> ((GHC.Base.pure ListTransactionsResponseBody200Mint GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'ListTransactionsResponseBody200Mint' with all required fields.
mkListTransactionsResponseBody200Mint :: [ListTransactionsResponseBody200MintTokens] -- ^ 'listTransactionsResponseBody200MintTokens'
  -> ListTransactionsResponseBody200Mint
mkListTransactionsResponseBody200Mint listTransactionsResponseBody200MintTokens = ListTransactionsResponseBody200Mint{listTransactionsResponseBody200MintTokens = listTransactionsResponseBody200MintTokens,
                                                                                                                      listTransactionsResponseBody200MintWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                      listTransactionsResponseBody200MintWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200MintTokens = ListTransactionsResponseBody200MintTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listTransactionsResponseBody200MintTokensAssets :: ([ListTransactionsResponseBody200MintTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listTransactionsResponseBody200MintTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , listTransactionsResponseBody200MintTokensPolicy_script :: ListTransactionsResponseBody200MintTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200MintTokens" (\obj -> ((GHC.Base.pure ListTransactionsResponseBody200MintTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'ListTransactionsResponseBody200MintTokens' with all required fields.
mkListTransactionsResponseBody200MintTokens :: [ListTransactionsResponseBody200MintTokensAssets] -- ^ 'listTransactionsResponseBody200MintTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200MintTokensPolicy_id'
  -> ListTransactionsResponseBody200MintTokensPolicy_scriptVariants -- ^ 'listTransactionsResponseBody200MintTokensPolicy_script'
  -> ListTransactionsResponseBody200MintTokens
mkListTransactionsResponseBody200MintTokens listTransactionsResponseBody200MintTokensAssets listTransactionsResponseBody200MintTokensPolicy_id listTransactionsResponseBody200MintTokensPolicy_script = ListTransactionsResponseBody200MintTokens{listTransactionsResponseBody200MintTokensAssets = listTransactionsResponseBody200MintTokensAssets,
                                                                                                                                                                                                                                                  listTransactionsResponseBody200MintTokensPolicy_id = listTransactionsResponseBody200MintTokensPolicy_id,
                                                                                                                                                                                                                                                  listTransactionsResponseBody200MintTokensPolicy_script = listTransactionsResponseBody200MintTokensPolicy_script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200MintTokensAssets = ListTransactionsResponseBody200MintTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listTransactionsResponseBody200MintTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , listTransactionsResponseBody200MintTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200MintTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200MintTokensAssets" (\obj -> ((GHC.Base.pure ListTransactionsResponseBody200MintTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200MintTokensAssets' with all required fields.
mkListTransactionsResponseBody200MintTokensAssets :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200MintTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200MintTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200MintTokensAssetsQuantity'
  -> ListTransactionsResponseBody200MintTokensAssets
mkListTransactionsResponseBody200MintTokensAssets listTransactionsResponseBody200MintTokensAssetsAsset_name listTransactionsResponseBody200MintTokensAssetsFingerprint listTransactionsResponseBody200MintTokensAssetsQuantity = ListTransactionsResponseBody200MintTokensAssets{listTransactionsResponseBody200MintTokensAssetsAsset_name = listTransactionsResponseBody200MintTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                 listTransactionsResponseBody200MintTokensAssetsFingerprint = listTransactionsResponseBody200MintTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                 listTransactionsResponseBody200MintTokensAssetsQuantity = listTransactionsResponseBody200MintTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1 = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference)
  -- | script
  , listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script :: ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1' with all required fields.
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1 :: ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script'
  -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1 listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1{listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                 listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference' with all required fields.
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex'
  -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1Reference{listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2{listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3{listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 :: ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4{listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some{listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                    listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5{listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6{listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants =
   ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant2 ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
  | ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant3 ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
  | ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant4 ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
  | ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant5 ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
  | ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant6 ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2 = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info :: ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2' with all required fields.
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2 :: ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info'
  -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2 listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2{listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                      listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference' with all required fields.
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex'
  -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Reference{listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                   listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version :: ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info :: ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_info{listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                               listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3 = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References :: ([ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3' with all required fields.
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3 :: [ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References] -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash'
  -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3 listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3{listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                             listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References' with all required fields.
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex'
  -> ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References
mkListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex = ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3References{listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                       listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex = listTransactionsResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200MintTokensPolicy_scriptVariants =
   ListTransactionsResponseBody200MintTokensPolicy_scriptVariant1 ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf1
  | ListTransactionsResponseBody200MintTokensPolicy_scriptVariant2 ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf2
  | ListTransactionsResponseBody200MintTokensPolicy_scriptVariant3 ListTransactionsResponseBody200MintTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200MintTokensPolicy_scriptVariants
    where toJSON (ListTransactionsResponseBody200MintTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200MintTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody200MintTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200MintTokensPolicy_scriptVariants
    where parseJSON val = case (ListTransactionsResponseBody200MintTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200MintTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody200MintTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.outputs.items@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200Outputs = ListTransactionsResponseBody200Outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  listTransactionsResponseBody200OutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , listTransactionsResponseBody200OutputsAmount :: ListTransactionsResponseBody200OutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , listTransactionsResponseBody200OutputsAssets :: (GHC.Maybe.Maybe ([ListTransactionsResponseBody200OutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200OutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (listTransactionsResponseBody200OutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Outputs" (\obj -> ((GHC.Base.pure ListTransactionsResponseBody200Outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'ListTransactionsResponseBody200Outputs' with all required fields.
mkListTransactionsResponseBody200Outputs :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200OutputsAddress'
  -> ListTransactionsResponseBody200OutputsAmount -- ^ 'listTransactionsResponseBody200OutputsAmount'
  -> ListTransactionsResponseBody200Outputs
mkListTransactionsResponseBody200Outputs listTransactionsResponseBody200OutputsAddress listTransactionsResponseBody200OutputsAmount = ListTransactionsResponseBody200Outputs{listTransactionsResponseBody200OutputsAddress = listTransactionsResponseBody200OutputsAddress,
                                                                                                                                                                             listTransactionsResponseBody200OutputsAmount = listTransactionsResponseBody200OutputsAmount,
                                                                                                                                                                             listTransactionsResponseBody200OutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListTransactionsResponseBody200OutputsAmount = ListTransactionsResponseBody200OutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200OutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200OutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200OutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200OutputsAmount" (\obj -> GHC.Base.pure ListTransactionsResponseBody200OutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200OutputsAmount' with all required fields.
mkListTransactionsResponseBody200OutputsAmount :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200OutputsAmountQuantity'
  -> ListTransactionsResponseBody200OutputsAmount
mkListTransactionsResponseBody200OutputsAmount listTransactionsResponseBody200OutputsAmountQuantity = ListTransactionsResponseBody200OutputsAmount{listTransactionsResponseBody200OutputsAmountQuantity = listTransactionsResponseBody200OutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ListTransactionsResponseBody200OutputsAssets = ListTransactionsResponseBody200OutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listTransactionsResponseBody200OutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listTransactionsResponseBody200OutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200OutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200OutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200OutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200OutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200OutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200OutputsAssets" (\obj -> ((GHC.Base.pure ListTransactionsResponseBody200OutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200OutputsAssets' with all required fields.
mkListTransactionsResponseBody200OutputsAssets :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200OutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200OutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200OutputsAssetsQuantity'
  -> ListTransactionsResponseBody200OutputsAssets
mkListTransactionsResponseBody200OutputsAssets listTransactionsResponseBody200OutputsAssetsAsset_name listTransactionsResponseBody200OutputsAssetsPolicy_id listTransactionsResponseBody200OutputsAssetsQuantity = ListTransactionsResponseBody200OutputsAssets{listTransactionsResponseBody200OutputsAssetsAsset_name = listTransactionsResponseBody200OutputsAssetsAsset_name,
                                                                                                                                                                                                                                                                listTransactionsResponseBody200OutputsAssetsPolicy_id = listTransactionsResponseBody200OutputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                listTransactionsResponseBody200OutputsAssetsQuantity = listTransactionsResponseBody200OutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.pending_since@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending
-- \<\/span>\<br\/>
-- The point in time at which a transaction became pending.
data ListTransactionsResponseBody200Pending_since = ListTransactionsResponseBody200Pending_since {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200Pending_sinceAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200Pending_sinceEpoch_number :: GHC.Types.Int
  -- | height
  , listTransactionsResponseBody200Pending_sinceHeight :: ListTransactionsResponseBody200Pending_sinceHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listTransactionsResponseBody200Pending_sinceSlot_number :: GHC.Types.Int
  -- | time
  , listTransactionsResponseBody200Pending_sinceTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Pending_since
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Pending_sinceTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Pending_sinceTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Pending_since
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Pending_since" (\obj -> ((((GHC.Base.pure ListTransactionsResponseBody200Pending_since GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'ListTransactionsResponseBody200Pending_since' with all required fields.
mkListTransactionsResponseBody200Pending_since :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200Pending_sinceAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200Pending_sinceEpoch_number'
  -> ListTransactionsResponseBody200Pending_sinceHeight -- ^ 'listTransactionsResponseBody200Pending_sinceHeight'
  -> GHC.Types.Int -- ^ 'listTransactionsResponseBody200Pending_sinceSlot_number'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200Pending_sinceTime'
  -> ListTransactionsResponseBody200Pending_since
mkListTransactionsResponseBody200Pending_since listTransactionsResponseBody200Pending_sinceAbsolute_slot_number listTransactionsResponseBody200Pending_sinceEpoch_number listTransactionsResponseBody200Pending_sinceHeight listTransactionsResponseBody200Pending_sinceSlot_number listTransactionsResponseBody200Pending_sinceTime = ListTransactionsResponseBody200Pending_since{listTransactionsResponseBody200Pending_sinceAbsolute_slot_number = listTransactionsResponseBody200Pending_sinceAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                                    listTransactionsResponseBody200Pending_sinceEpoch_number = listTransactionsResponseBody200Pending_sinceEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                                    listTransactionsResponseBody200Pending_sinceHeight = listTransactionsResponseBody200Pending_sinceHeight,
                                                                                                                                                                                                                                                                                                                                                                                    listTransactionsResponseBody200Pending_sinceSlot_number = listTransactionsResponseBody200Pending_sinceSlot_number,
                                                                                                                                                                                                                                                                                                                                                                                    listTransactionsResponseBody200Pending_sinceTime = listTransactionsResponseBody200Pending_sinceTime}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.pending_since.properties.height@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200Pending_sinceHeight = ListTransactionsResponseBody200Pending_sinceHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200Pending_sinceHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Pending_sinceHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Pending_sinceHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Pending_sinceHeight" (\obj -> GHC.Base.pure ListTransactionsResponseBody200Pending_sinceHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200Pending_sinceHeight' with all required fields.
mkListTransactionsResponseBody200Pending_sinceHeight :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200Pending_sinceHeightQuantity'
  -> ListTransactionsResponseBody200Pending_sinceHeight
mkListTransactionsResponseBody200Pending_sinceHeight listTransactionsResponseBody200Pending_sinceHeightQuantity = ListTransactionsResponseBody200Pending_sinceHeight{listTransactionsResponseBody200Pending_sinceHeightQuantity = listTransactionsResponseBody200Pending_sinceHeightQuantity}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.script_validity@ in the specification.
-- 
-- Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
-- used in the transaction validated or not. Validity may be null if this
-- transaction was from an era that doesn\'t support phase-2 monetary policy
-- scripts, or is a pending transaction (we don\'t know if validation passed or
-- failed until the transaction hits the ledger).
data ListTransactionsResponseBody200Script_validityNonNullable =
   ListTransactionsResponseBody200Script_validityNonNullableOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListTransactionsResponseBody200Script_validityNonNullableTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListTransactionsResponseBody200Script_validityNonNullableEnumValid -- ^ Represents the JSON value @"valid"@
  | ListTransactionsResponseBody200Script_validityNonNullableEnumInvalid -- ^ Represents the JSON value @"invalid"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Script_validityNonNullable
    where toJSON (ListTransactionsResponseBody200Script_validityNonNullableOther val) = val
          toJSON (ListTransactionsResponseBody200Script_validityNonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListTransactionsResponseBody200Script_validityNonNullableEnumValid) = "valid"
          toJSON (ListTransactionsResponseBody200Script_validityNonNullableEnumInvalid) = "invalid"
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Script_validityNonNullable
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "valid" -> ListTransactionsResponseBody200Script_validityNonNullableEnumValid
                                            | val GHC.Classes.== "invalid" -> ListTransactionsResponseBody200Script_validityNonNullableEnumInvalid
                                            | GHC.Base.otherwise -> ListTransactionsResponseBody200Script_validityNonNullableOther val)
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.status@ in the specification.
-- 
-- Current transaction status.
-- 
--   \`\`\`
--        *-----------*
--   ---> |  PENDING  |----------------*
--        *-----------*                |
--              |                      |
--              V                      V
--        *-----------*          *-----------*
--        |           |---------->  EXPIRED  |
--        |           |  (ttl)   *-----------*
--        | SUBMITTED |
--        |           \<----------------*
--        |           |                |
--        *-----------*           (rollback)
--               |                     |
--          (in ledger)          *-----------*
--               |               |           |
--               *---------------> IN_LEDGER |
--                               |           |
--                               *-----------*
--   \`\`\`
data ListTransactionsResponseBody200Status =
   ListTransactionsResponseBody200StatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListTransactionsResponseBody200StatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListTransactionsResponseBody200StatusEnumPending -- ^ Represents the JSON value @"pending"@
  | ListTransactionsResponseBody200StatusEnumSubmitted -- ^ Represents the JSON value @"submitted"@
  | ListTransactionsResponseBody200StatusEnumIn_ledger -- ^ Represents the JSON value @"in_ledger"@
  | ListTransactionsResponseBody200StatusEnumExpired -- ^ Represents the JSON value @"expired"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Status
    where toJSON (ListTransactionsResponseBody200StatusOther val) = val
          toJSON (ListTransactionsResponseBody200StatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListTransactionsResponseBody200StatusEnumPending) = "pending"
          toJSON (ListTransactionsResponseBody200StatusEnumSubmitted) = "submitted"
          toJSON (ListTransactionsResponseBody200StatusEnumIn_ledger) = "in_ledger"
          toJSON (ListTransactionsResponseBody200StatusEnumExpired) = "expired"
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Status
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "pending" -> ListTransactionsResponseBody200StatusEnumPending
                                            | val GHC.Classes.== "submitted" -> ListTransactionsResponseBody200StatusEnumSubmitted
                                            | val GHC.Classes.== "in_ledger" -> ListTransactionsResponseBody200StatusEnumIn_ledger
                                            | val GHC.Classes.== "expired" -> ListTransactionsResponseBody200StatusEnumExpired
                                            | GHC.Base.otherwise -> ListTransactionsResponseBody200StatusOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.validity_interval@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200Validity_interval = ListTransactionsResponseBody200Validity_interval {
  -- | invalid_before
  listTransactionsResponseBody200Validity_intervalInvalid_before :: ListTransactionsResponseBody200Validity_intervalInvalid_before
  -- | invalid_hereafter
  , listTransactionsResponseBody200Validity_intervalInvalid_hereafter :: ListTransactionsResponseBody200Validity_intervalInvalid_hereafter
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Validity_interval
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Validity_interval
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Validity_interval" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200Validity_interval GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_before")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_hereafter"))
-- | Create a new 'ListTransactionsResponseBody200Validity_interval' with all required fields.
mkListTransactionsResponseBody200Validity_interval :: ListTransactionsResponseBody200Validity_intervalInvalid_before -- ^ 'listTransactionsResponseBody200Validity_intervalInvalid_before'
  -> ListTransactionsResponseBody200Validity_intervalInvalid_hereafter -- ^ 'listTransactionsResponseBody200Validity_intervalInvalid_hereafter'
  -> ListTransactionsResponseBody200Validity_interval
mkListTransactionsResponseBody200Validity_interval listTransactionsResponseBody200Validity_intervalInvalid_before listTransactionsResponseBody200Validity_intervalInvalid_hereafter = ListTransactionsResponseBody200Validity_interval{listTransactionsResponseBody200Validity_intervalInvalid_before = listTransactionsResponseBody200Validity_intervalInvalid_before,
                                                                                                                                                                                                                                       listTransactionsResponseBody200Validity_intervalInvalid_hereafter = listTransactionsResponseBody200Validity_intervalInvalid_hereafter}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.validity_interval.properties.invalid_before@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200Validity_intervalInvalid_before = ListTransactionsResponseBody200Validity_intervalInvalid_before {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Validity_intervalInvalid_before
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Validity_intervalInvalid_before
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Validity_intervalInvalid_before" (\obj -> GHC.Base.pure ListTransactionsResponseBody200Validity_intervalInvalid_before GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200Validity_intervalInvalid_before' with all required fields.
mkListTransactionsResponseBody200Validity_intervalInvalid_before :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity'
  -> ListTransactionsResponseBody200Validity_intervalInvalid_before
mkListTransactionsResponseBody200Validity_intervalInvalid_before listTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity = ListTransactionsResponseBody200Validity_intervalInvalid_before{listTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity = listTransactionsResponseBody200Validity_intervalInvalid_beforeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.validity_interval.properties.invalid_hereafter@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200Validity_intervalInvalid_hereafter = ListTransactionsResponseBody200Validity_intervalInvalid_hereafter {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Validity_intervalInvalid_hereafter
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Validity_intervalInvalid_hereafter
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Validity_intervalInvalid_hereafter" (\obj -> GHC.Base.pure ListTransactionsResponseBody200Validity_intervalInvalid_hereafter GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200Validity_intervalInvalid_hereafter' with all required fields.
mkListTransactionsResponseBody200Validity_intervalInvalid_hereafter :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity'
  -> ListTransactionsResponseBody200Validity_intervalInvalid_hereafter
mkListTransactionsResponseBody200Validity_intervalInvalid_hereafter listTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity = ListTransactionsResponseBody200Validity_intervalInvalid_hereafter{listTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity = listTransactionsResponseBody200Validity_intervalInvalid_hereafterQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.withdrawals.items@ in the specification.
-- 
-- 
data ListTransactionsResponseBody200Withdrawals = ListTransactionsResponseBody200Withdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  listTransactionsResponseBody200WithdrawalsAmount :: ListTransactionsResponseBody200WithdrawalsAmount
  -- | stake_address
  , listTransactionsResponseBody200WithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200Withdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200WithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200WithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200Withdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200Withdrawals" (\obj -> (GHC.Base.pure ListTransactionsResponseBody200Withdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'ListTransactionsResponseBody200Withdrawals' with all required fields.
mkListTransactionsResponseBody200Withdrawals :: ListTransactionsResponseBody200WithdrawalsAmount -- ^ 'listTransactionsResponseBody200WithdrawalsAmount'
  -> Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody200WithdrawalsStake_address'
  -> ListTransactionsResponseBody200Withdrawals
mkListTransactionsResponseBody200Withdrawals listTransactionsResponseBody200WithdrawalsAmount listTransactionsResponseBody200WithdrawalsStake_address = ListTransactionsResponseBody200Withdrawals{listTransactionsResponseBody200WithdrawalsAmount = listTransactionsResponseBody200WithdrawalsAmount,
                                                                                                                                                                                                   listTransactionsResponseBody200WithdrawalsStake_address = listTransactionsResponseBody200WithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.200.content.application\/json.schema.items.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ListTransactionsResponseBody200WithdrawalsAmount = ListTransactionsResponseBody200WithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listTransactionsResponseBody200WithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody200WithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody200WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody200WithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody200WithdrawalsAmount" (\obj -> GHC.Base.pure ListTransactionsResponseBody200WithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListTransactionsResponseBody200WithdrawalsAmount' with all required fields.
mkListTransactionsResponseBody200WithdrawalsAmount :: GHC.Types.Int -- ^ 'listTransactionsResponseBody200WithdrawalsAmountQuantity'
  -> ListTransactionsResponseBody200WithdrawalsAmount
mkListTransactionsResponseBody200WithdrawalsAmount listTransactionsResponseBody200WithdrawalsAmountQuantity = ListTransactionsResponseBody200WithdrawalsAmount{listTransactionsResponseBody200WithdrawalsAmountQuantity = listTransactionsResponseBody200WithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody400OneOf1 = ListTransactionsResponseBody400OneOf1 {
  -- | message: May occur when trying to withdraw less than the minimal UTxO value.
  listTransactionsResponseBody400OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody400OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "min_withdrawal_wrong"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "min_withdrawal_wrong"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody400OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody400OneOf1" (\obj -> GHC.Base.pure ListTransactionsResponseBody400OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListTransactionsResponseBody400OneOf1' with all required fields.
mkListTransactionsResponseBody400OneOf1 :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody400OneOf1Message'
  -> ListTransactionsResponseBody400OneOf1
mkListTransactionsResponseBody400OneOf1 listTransactionsResponseBody400OneOf1Message = ListTransactionsResponseBody400OneOf1{listTransactionsResponseBody400OneOf1Message = listTransactionsResponseBody400OneOf1Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody400OneOf2 = ListTransactionsResponseBody400OneOf2 {
  -- | message: May occur when a provided time-range is unsound.
  listTransactionsResponseBody400OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody400OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody400OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "start_time_later_than_end_time"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody400OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "start_time_later_than_end_time"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody400OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody400OneOf2" (\obj -> GHC.Base.pure ListTransactionsResponseBody400OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListTransactionsResponseBody400OneOf2' with all required fields.
mkListTransactionsResponseBody400OneOf2 :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody400OneOf2Message'
  -> ListTransactionsResponseBody400OneOf2
mkListTransactionsResponseBody400OneOf2 listTransactionsResponseBody400OneOf2Message = ListTransactionsResponseBody400OneOf2{listTransactionsResponseBody400OneOf2Message = listTransactionsResponseBody400OneOf2Message}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ListTransactionsResponseBody400Variants =
   ListTransactionsResponseBody400Variant1 ListTransactionsResponseBody400OneOf1
  | ListTransactionsResponseBody400Variant2 ListTransactionsResponseBody400OneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody400Variants
    where toJSON (ListTransactionsResponseBody400Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ListTransactionsResponseBody400Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody400Variants
    where parseJSON val = case (ListTransactionsResponseBody400Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ListTransactionsResponseBody400Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data ListTransactionsResponseBody404 = ListTransactionsResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  listTransactionsResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody404" (\obj -> GHC.Base.pure ListTransactionsResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListTransactionsResponseBody404' with all required fields.
mkListTransactionsResponseBody404 :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody404Message'
  -> ListTransactionsResponseBody404
mkListTransactionsResponseBody404 listTransactionsResponseBody404Message = ListTransactionsResponseBody404{listTransactionsResponseBody404Message = listTransactionsResponseBody404Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.GET.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data ListTransactionsResponseBody406 = ListTransactionsResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  listTransactionsResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListTransactionsResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listTransactionsResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListTransactionsResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListTransactionsResponseBody406" (\obj -> GHC.Base.pure ListTransactionsResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListTransactionsResponseBody406' with all required fields.
mkListTransactionsResponseBody406 :: Data.Text.Internal.Text -- ^ 'listTransactionsResponseBody406Message'
  -> ListTransactionsResponseBody406
mkListTransactionsResponseBody406 listTransactionsResponseBody406Message = ListTransactionsResponseBody406{listTransactionsResponseBody406Message = listTransactionsResponseBody406Message}
-- | > GET /wallets/{walletId}/transactions
-- 
-- The same as 'listTransactions' but accepts an explicit configuration.
listTransactionsWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> ListTransactionsParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response ListTransactionsResponse) -- ^ Monadic computation which returns the result of the operation
listTransactionsWithConfiguration config
                                  parameters = GHC.Base.fmap (\response_5 -> GHC.Base.fmap (Data.Either.either ListTransactionsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ListTransactionsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                          ([ListTransactionsResponseBody200]))
                                                                                                                                                                                          | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> ListTransactionsResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                          ListTransactionsResponseBody400Variants)
                                                                                                                                                                                          | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> ListTransactionsResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                          ListTransactionsResponseBody404)
                                                                                                                                                                                          | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ListTransactionsResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                          ListTransactionsResponseBody406)
                                                                                                                                                                                          | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_5) response_5) (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listTransactionsParametersPathWalletId parameters))) GHC.Base.<> "/transactions")) [Wallet.Common.QueryParameter (Data.Text.pack "start") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryStart parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Wallet.Common.QueryParameter (Data.Text.pack "end") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryEnd parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Wallet.Common.QueryParameter (Data.Text.pack "order") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryOrder parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Wallet.Common.QueryParameter (Data.Text.pack "max_count") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryMax_count parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Wallet.Common.QueryParameter (Data.Text.pack "minWithdrawal") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryMinWithdrawal parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        Wallet.Common.QueryParameter (Data.Text.pack "simple-metadata") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQuerySimple_metadata parameters) (Data.Text.pack "form") GHC.Types.False])
-- | > GET /wallets/{walletId}/transactions
-- 
-- The same as 'listTransactions' but returns the raw 'Data.ByteString.ByteString'.
listTransactionsRaw :: forall m . Wallet.Common.MonadHTTP m => ListTransactionsParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
listTransactionsRaw parameters = GHC.Base.id (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listTransactionsParametersPathWalletId parameters))) GHC.Base.<> "/transactions")) [Wallet.Common.QueryParameter (Data.Text.pack "start") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryStart parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                   Wallet.Common.QueryParameter (Data.Text.pack "end") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryEnd parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                   Wallet.Common.QueryParameter (Data.Text.pack "order") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryOrder parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                   Wallet.Common.QueryParameter (Data.Text.pack "max_count") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryMax_count parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                   Wallet.Common.QueryParameter (Data.Text.pack "minWithdrawal") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryMinWithdrawal parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                   Wallet.Common.QueryParameter (Data.Text.pack "simple-metadata") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQuerySimple_metadata parameters) (Data.Text.pack "form") GHC.Types.False])
-- | > GET /wallets/{walletId}/transactions
-- 
-- The same as 'listTransactions' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
listTransactionsWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> ListTransactionsParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
listTransactionsWithConfigurationRaw config
                                     parameters = GHC.Base.id (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listTransactionsParametersPathWalletId parameters))) GHC.Base.<> "/transactions")) [Wallet.Common.QueryParameter (Data.Text.pack "start") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryStart parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                          Wallet.Common.QueryParameter (Data.Text.pack "end") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryEnd parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                          Wallet.Common.QueryParameter (Data.Text.pack "order") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryOrder parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                          Wallet.Common.QueryParameter (Data.Text.pack "max_count") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryMax_count parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                          Wallet.Common.QueryParameter (Data.Text.pack "minWithdrawal") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQueryMinWithdrawal parameters) (Data.Text.pack "form") GHC.Types.False,
                                                                                                                                                                                                                                                                                                                                                                                                                                          Wallet.Common.QueryParameter (Data.Text.pack "simple-metadata") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listTransactionsParametersQuerySimple_metadata parameters) (Data.Text.pack "form") GHC.Types.False])
