-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation getByronTransaction
module Wallet.Operations.GetByronTransaction where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > GET /byron-wallets/{walletId}/transactions/{transactionId}
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Get transaction by id.
getByronTransaction :: forall m . Wallet.Common.MonadHTTP m => GetByronTransactionParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response GetByronTransactionResponse) -- ^ Monadic computation which returns the result of the operation
getByronTransaction parameters = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either GetByronTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetByronTransactionResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                  GetByronTransactionResponseBody200)
                                                                                                                                                                               | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> GetByronTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                  GetByronTransactionResponseBody404Variants)
                                                                                                                                                                               | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> GetByronTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                  GetByronTransactionResponseBody406)
                                                                                                                                                                               | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronTransactionParametersPathWalletId parameters))) GHC.Base.<> ("/transactions/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronTransactionParametersPathTransactionId parameters))) GHC.Base.<> "")))) GHC.Base.mempty)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.parameters@ in the specification.
-- 
-- 
data GetByronTransactionParameters = GetByronTransactionParameters {
  -- | pathTransactionId: Represents the parameter named \'transactionId\'
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getByronTransactionParametersPathTransactionId :: Data.Text.Internal.Text
  -- | pathWalletId: Represents the parameter named \'walletId\'
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  , getByronTransactionParametersPathWalletId :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionParameters
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pathTransactionId" Data.Aeson.Types.ToJSON..= getByronTransactionParametersPathTransactionId obj] : ["pathWalletId" Data.Aeson.Types.ToJSON..= getByronTransactionParametersPathWalletId obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pathTransactionId" Data.Aeson.Types.ToJSON..= getByronTransactionParametersPathTransactionId obj] : ["pathWalletId" Data.Aeson.Types.ToJSON..= getByronTransactionParametersPathWalletId obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionParameters
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionParameters" (\obj -> (GHC.Base.pure GetByronTransactionParameters GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pathTransactionId")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pathWalletId"))
-- | Create a new 'GetByronTransactionParameters' with all required fields.
mkGetByronTransactionParameters :: Data.Text.Internal.Text -- ^ 'getByronTransactionParametersPathTransactionId'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionParametersPathWalletId'
  -> GetByronTransactionParameters
mkGetByronTransactionParameters getByronTransactionParametersPathTransactionId getByronTransactionParametersPathWalletId = GetByronTransactionParameters{getByronTransactionParametersPathTransactionId = getByronTransactionParametersPathTransactionId,
                                                                                                                                                         getByronTransactionParametersPathWalletId = getByronTransactionParametersPathWalletId}
-- | Represents a response of the operation 'getByronTransaction'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'GetByronTransactionResponseError' is used.
data GetByronTransactionResponse =
   GetByronTransactionResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | GetByronTransactionResponse200 GetByronTransactionResponseBody200 -- ^ OK
  | GetByronTransactionResponse404 GetByronTransactionResponseBody404Variants -- ^ Not Found
  | GetByronTransactionResponse406 GetByronTransactionResponseBody406 -- ^ Not Acceptable
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200 = GetByronTransactionResponseBody200 {
  -- | amount: An amount of Ada spent or received, from the perspective of the wallet.
  -- 
  -- That is, for outgoing transaction, it represents the amount of Ada consumed
  -- as inputs including the amount of Ada spent as fees or deposits.
  -- 
  -- For incoming transaction, it represents the total amount of Ada received to
  -- addresses that belong to the wallet.
  getByronTransactionResponseBody200Amount :: GetByronTransactionResponseBody200Amount
  -- | burn
  , getByronTransactionResponseBody200Burn :: (GHC.Maybe.Maybe GetByronTransactionResponseBody200Burn)
  -- | certificates
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , getByronTransactionResponseBody200Certificates :: (GHC.Maybe.Maybe ([GetByronTransactionResponseBody200CertificatesVariants]))
  -- | collateral: A list of transaction inputs used for collateral.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , getByronTransactionResponseBody200Collateral :: (GHC.Maybe.Maybe ([GetByronTransactionResponseBody200Collateral]))
  -- | collateral_outputs: A list of collateral return outputs with amounts specified.
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 1 items
  -- * Must have a minimum of 0 items
  , getByronTransactionResponseBody200Collateral_outputs :: (GHC.Maybe.Maybe ([GetByronTransactionResponseBody200Collateral_outputs]))
  -- | deposit_returned: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , getByronTransactionResponseBody200Deposit_returned :: GetByronTransactionResponseBody200Deposit_returned
  -- | deposit_taken: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , getByronTransactionResponseBody200Deposit_taken :: GetByronTransactionResponseBody200Deposit_taken
  -- | depth: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Current depth of the transaction in the local chain
  , getByronTransactionResponseBody200Depth :: (GHC.Maybe.Maybe GetByronTransactionResponseBody200Depth)
  -- | direction
  , getByronTransactionResponseBody200Direction :: GetByronTransactionResponseBody200Direction
  -- | expires_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending OR status == expired
  -- \<\/span>\<br\/>
  -- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
  , getByronTransactionResponseBody200Expires_at :: (GHC.Maybe.Maybe GetByronTransactionResponseBody200Expires_at)
  -- | extra_signatures
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , getByronTransactionResponseBody200Extra_signatures :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | fee: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , getByronTransactionResponseBody200Fee :: GetByronTransactionResponseBody200Fee
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , getByronTransactionResponseBody200Id :: Data.Text.Internal.Text
  -- | inputs: A list of transaction inputs.
  -- 
  -- \`assets\` and \`address\` are always present for \`outgoing\`
  -- transactions but generally absent for \`incoming\`
  -- transactions. This information is present on the Cardano explorer,
  -- but is not tracked by the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , getByronTransactionResponseBody200Inputs :: ([GetByronTransactionResponseBody200Inputs])
  -- | inserted_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Absolute time at which the transaction was inserted in a block.
  , getByronTransactionResponseBody200Inserted_at :: (GHC.Maybe.Maybe GetByronTransactionResponseBody200Inserted_at)
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  , getByronTransactionResponseBody200Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | mint
  , getByronTransactionResponseBody200Mint :: (GHC.Maybe.Maybe GetByronTransactionResponseBody200Mint)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , getByronTransactionResponseBody200Outputs :: ([GetByronTransactionResponseBody200Outputs])
  -- | pending_since: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending
  -- \<\/span>\<br\/>
  -- The point in time at which a transaction became pending.
  , getByronTransactionResponseBody200Pending_since :: (GHC.Maybe.Maybe GetByronTransactionResponseBody200Pending_since)
  -- | script_integrity: A script data integrity hash - 32 bytes
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^(script_data)1[0-9a-z]*\$\'
  , getByronTransactionResponseBody200Script_integrity :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | script_validity: Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
  -- used in the transaction validated or not. Validity may be null if this
  -- transaction was from an era that doesn\'t support phase-2 monetary policy
  -- scripts, or is a pending transaction (we don\'t know if validation passed or
  -- failed until the transaction hits the ledger).
  , getByronTransactionResponseBody200Script_validity :: (GHC.Maybe.Maybe (Wallet.Common.Nullable GetByronTransactionResponseBody200Script_validityNonNullable))
  -- | status: Current transaction status.
  -- 
  --   \`\`\`
  --        *-----------*
  --   ---> |  PENDING  |----------------*
  --        *-----------*                |
  --              |                      |
  --              V                      V
  --        *-----------*          *-----------*
  --        |           |---------->  EXPIRED  |
  --        |           |  (ttl)   *-----------*
  --        | SUBMITTED |
  --        |           \<----------------*
  --        |           |                |
  --        *-----------*           (rollback)
  --               |                     |
  --          (in ledger)          *-----------*
  --               |               |           |
  --               *---------------> IN_LEDGER |
  --                               |           |
  --                               *-----------*
  --   \`\`\`
  , getByronTransactionResponseBody200Status :: GetByronTransactionResponseBody200Status
  -- | validity_interval
  , getByronTransactionResponseBody200Validity_interval :: (GHC.Maybe.Maybe GetByronTransactionResponseBody200Validity_interval)
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , getByronTransactionResponseBody200Withdrawals :: ([GetByronTransactionResponseBody200Withdrawals])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Fee obj] : ["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Withdrawals obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Fee obj] : ["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Withdrawals obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200" (\obj -> (((((((((((((((((((((((GHC.Base.pure GetByronTransactionResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "burn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral_outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "depth")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "direction")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "expires_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "extra_signatures")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fee")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "inserted_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pending_since")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_integrity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_validity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "validity_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "withdrawals"))
-- | Create a new 'GetByronTransactionResponseBody200' with all required fields.
mkGetByronTransactionResponseBody200 :: GetByronTransactionResponseBody200Amount -- ^ 'getByronTransactionResponseBody200Amount'
  -> GetByronTransactionResponseBody200Deposit_returned -- ^ 'getByronTransactionResponseBody200Deposit_returned'
  -> GetByronTransactionResponseBody200Deposit_taken -- ^ 'getByronTransactionResponseBody200Deposit_taken'
  -> GetByronTransactionResponseBody200Direction -- ^ 'getByronTransactionResponseBody200Direction'
  -> GetByronTransactionResponseBody200Fee -- ^ 'getByronTransactionResponseBody200Fee'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200Id'
  -> [GetByronTransactionResponseBody200Inputs] -- ^ 'getByronTransactionResponseBody200Inputs'
  -> [GetByronTransactionResponseBody200Outputs] -- ^ 'getByronTransactionResponseBody200Outputs'
  -> GetByronTransactionResponseBody200Status -- ^ 'getByronTransactionResponseBody200Status'
  -> [GetByronTransactionResponseBody200Withdrawals] -- ^ 'getByronTransactionResponseBody200Withdrawals'
  -> GetByronTransactionResponseBody200
mkGetByronTransactionResponseBody200 getByronTransactionResponseBody200Amount getByronTransactionResponseBody200Deposit_returned getByronTransactionResponseBody200Deposit_taken getByronTransactionResponseBody200Direction getByronTransactionResponseBody200Fee getByronTransactionResponseBody200Id getByronTransactionResponseBody200Inputs getByronTransactionResponseBody200Outputs getByronTransactionResponseBody200Status getByronTransactionResponseBody200Withdrawals = GetByronTransactionResponseBody200{getByronTransactionResponseBody200Amount = getByronTransactionResponseBody200Amount,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Burn = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Certificates = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Collateral = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Collateral_outputs = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Deposit_returned = getByronTransactionResponseBody200Deposit_returned,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Deposit_taken = getByronTransactionResponseBody200Deposit_taken,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Depth = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Direction = getByronTransactionResponseBody200Direction,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Expires_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Extra_signatures = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Fee = getByronTransactionResponseBody200Fee,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Id = getByronTransactionResponseBody200Id,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Inputs = getByronTransactionResponseBody200Inputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Inserted_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Mint = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Outputs = getByronTransactionResponseBody200Outputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Pending_since = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Script_integrity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Script_validity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Status = getByronTransactionResponseBody200Status,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Validity_interval = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       getByronTransactionResponseBody200Withdrawals = getByronTransactionResponseBody200Withdrawals}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.amount@ in the specification.
-- 
-- An amount of Ada spent or received, from the perspective of the wallet.
-- 
-- That is, for outgoing transaction, it represents the amount of Ada consumed
-- as inputs including the amount of Ada spent as fees or deposits.
-- 
-- For incoming transaction, it represents the total amount of Ada received to
-- addresses that belong to the wallet.
data GetByronTransactionResponseBody200Amount = GetByronTransactionResponseBody200Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Amount" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200Amount' with all required fields.
mkGetByronTransactionResponseBody200Amount :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200AmountQuantity'
  -> GetByronTransactionResponseBody200Amount
mkGetByronTransactionResponseBody200Amount getByronTransactionResponseBody200AmountQuantity = GetByronTransactionResponseBody200Amount{getByronTransactionResponseBody200AmountQuantity = getByronTransactionResponseBody200AmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200Burn = GetByronTransactionResponseBody200Burn {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  getByronTransactionResponseBody200BurnTokens :: ([GetByronTransactionResponseBody200BurnTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , getByronTransactionResponseBody200BurnWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , getByronTransactionResponseBody200BurnWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200BurnWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200BurnWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Burn" (\obj -> ((GHC.Base.pure GetByronTransactionResponseBody200Burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'GetByronTransactionResponseBody200Burn' with all required fields.
mkGetByronTransactionResponseBody200Burn :: [GetByronTransactionResponseBody200BurnTokens] -- ^ 'getByronTransactionResponseBody200BurnTokens'
  -> GetByronTransactionResponseBody200Burn
mkGetByronTransactionResponseBody200Burn getByronTransactionResponseBody200BurnTokens = GetByronTransactionResponseBody200Burn{getByronTransactionResponseBody200BurnTokens = getByronTransactionResponseBody200BurnTokens,
                                                                                                                               getByronTransactionResponseBody200BurnWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                               getByronTransactionResponseBody200BurnWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200BurnTokens = GetByronTransactionResponseBody200BurnTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getByronTransactionResponseBody200BurnTokensAssets :: ([GetByronTransactionResponseBody200BurnTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getByronTransactionResponseBody200BurnTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , getByronTransactionResponseBody200BurnTokensPolicy_script :: GetByronTransactionResponseBody200BurnTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200BurnTokens" (\obj -> ((GHC.Base.pure GetByronTransactionResponseBody200BurnTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'GetByronTransactionResponseBody200BurnTokens' with all required fields.
mkGetByronTransactionResponseBody200BurnTokens :: [GetByronTransactionResponseBody200BurnTokensAssets] -- ^ 'getByronTransactionResponseBody200BurnTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_id'
  -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptVariants -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_script'
  -> GetByronTransactionResponseBody200BurnTokens
mkGetByronTransactionResponseBody200BurnTokens getByronTransactionResponseBody200BurnTokensAssets getByronTransactionResponseBody200BurnTokensPolicy_id getByronTransactionResponseBody200BurnTokensPolicy_script = GetByronTransactionResponseBody200BurnTokens{getByronTransactionResponseBody200BurnTokensAssets = getByronTransactionResponseBody200BurnTokensAssets,
                                                                                                                                                                                                                                                                 getByronTransactionResponseBody200BurnTokensPolicy_id = getByronTransactionResponseBody200BurnTokensPolicy_id,
                                                                                                                                                                                                                                                                 getByronTransactionResponseBody200BurnTokensPolicy_script = getByronTransactionResponseBody200BurnTokensPolicy_script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200BurnTokensAssets = GetByronTransactionResponseBody200BurnTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getByronTransactionResponseBody200BurnTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , getByronTransactionResponseBody200BurnTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200BurnTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200BurnTokensAssets" (\obj -> ((GHC.Base.pure GetByronTransactionResponseBody200BurnTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200BurnTokensAssets' with all required fields.
mkGetByronTransactionResponseBody200BurnTokensAssets :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200BurnTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200BurnTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200BurnTokensAssetsQuantity'
  -> GetByronTransactionResponseBody200BurnTokensAssets
mkGetByronTransactionResponseBody200BurnTokensAssets getByronTransactionResponseBody200BurnTokensAssetsAsset_name getByronTransactionResponseBody200BurnTokensAssetsFingerprint getByronTransactionResponseBody200BurnTokensAssetsQuantity = GetByronTransactionResponseBody200BurnTokensAssets{getByronTransactionResponseBody200BurnTokensAssetsAsset_name = getByronTransactionResponseBody200BurnTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                                getByronTransactionResponseBody200BurnTokensAssetsFingerprint = getByronTransactionResponseBody200BurnTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                                getByronTransactionResponseBody200BurnTokensAssetsQuantity = getByronTransactionResponseBody200BurnTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1 = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference)
  -- | script
  , getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Script :: GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1' with all required fields.
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1 :: GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Script'
  -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1 getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Script = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1{getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                          getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Script = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference' with all required fields.
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex'
  -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1Reference{getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                               getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2 getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2{getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3 getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3{getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 :: GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4 getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4{getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some{getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                                getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5 getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5{getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6 getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6{getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants =
   GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant2 GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf2
  | GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant3 GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf3
  | GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant4 GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf4
  | GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant5 GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf5
  | GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant6 GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2 = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info :: GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2' with all required fields.
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2 :: GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info'
  -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2 getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2{getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                               getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference' with all required fields.
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex'
  -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Reference{getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                               getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version :: GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info :: GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_info{getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                                           getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3 = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References :: ([GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3' with all required fields.
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3 :: [GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References] -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash'
  -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3 getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3{getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                                         getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References' with all required fields.
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex'
  -> GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References
mkGetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex = GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3References{getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                                   getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex = getByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200BurnTokensPolicy_scriptVariants =
   GetByronTransactionResponseBody200BurnTokensPolicy_scriptVariant1 GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf1
  | GetByronTransactionResponseBody200BurnTokensPolicy_scriptVariant2 GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf2
  | GetByronTransactionResponseBody200BurnTokensPolicy_scriptVariant3 GetByronTransactionResponseBody200BurnTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptVariants
    where toJSON (GetByronTransactionResponseBody200BurnTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200BurnTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200BurnTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200BurnTokensPolicy_scriptVariants
    where parseJSON val = case (GetByronTransactionResponseBody200BurnTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200BurnTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200BurnTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data GetByronTransactionResponseBody200CertificatesOneOf1 = GetByronTransactionResponseBody200CertificatesOneOf1 {
  -- | certificate_type
  getByronTransactionResponseBody200CertificatesOneOf1Certificate_type :: GetByronTransactionResponseBody200CertificatesOneOf1Certificate_type
  -- | pool: A unique identifier for the pool.
  , getByronTransactionResponseBody200CertificatesOneOf1Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , getByronTransactionResponseBody200CertificatesOneOf1Reward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200CertificatesOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200CertificatesOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200CertificatesOneOf1" (\obj -> ((GHC.Base.pure GetByronTransactionResponseBody200CertificatesOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'GetByronTransactionResponseBody200CertificatesOneOf1' with all required fields.
mkGetByronTransactionResponseBody200CertificatesOneOf1 :: GetByronTransactionResponseBody200CertificatesOneOf1Certificate_type -- ^ 'getByronTransactionResponseBody200CertificatesOneOf1Certificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'getByronTransactionResponseBody200CertificatesOneOf1Reward_account_path'
  -> GetByronTransactionResponseBody200CertificatesOneOf1
mkGetByronTransactionResponseBody200CertificatesOneOf1 getByronTransactionResponseBody200CertificatesOneOf1Certificate_type getByronTransactionResponseBody200CertificatesOneOf1Reward_account_path = GetByronTransactionResponseBody200CertificatesOneOf1{getByronTransactionResponseBody200CertificatesOneOf1Certificate_type = getByronTransactionResponseBody200CertificatesOneOf1Certificate_type,
                                                                                                                                                                                                                                                           getByronTransactionResponseBody200CertificatesOneOf1Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                           getByronTransactionResponseBody200CertificatesOneOf1Reward_account_path = getByronTransactionResponseBody200CertificatesOneOf1Reward_account_path}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200CertificatesOneOf1Certificate_type =
   GetByronTransactionResponseBody200CertificatesOneOf1Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetByronTransactionResponseBody200CertificatesOneOf1Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetByronTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | GetByronTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | GetByronTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200CertificatesOneOf1Certificate_type
    where toJSON (GetByronTransactionResponseBody200CertificatesOneOf1Certificate_typeOther val) = val
          toJSON (GetByronTransactionResponseBody200CertificatesOneOf1Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetByronTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumJoin_pool) = "join_pool"
          toJSON (GetByronTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (GetByronTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200CertificatesOneOf1Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> GetByronTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> GetByronTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> GetByronTransactionResponseBody200CertificatesOneOf1Certificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> GetByronTransactionResponseBody200CertificatesOneOf1Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate not belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data GetByronTransactionResponseBody200CertificatesOneOf2 = GetByronTransactionResponseBody200CertificatesOneOf2 {
  -- | certificate_type
  getByronTransactionResponseBody200CertificatesOneOf2Certificate_type :: GetByronTransactionResponseBody200CertificatesOneOf2Certificate_type
  -- | pool: A unique identifier for the pool.
  , getByronTransactionResponseBody200CertificatesOneOf2Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account
  , getByronTransactionResponseBody200CertificatesOneOf2Reward_account :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200CertificatesOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf2Reward_account obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf2Reward_account obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200CertificatesOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200CertificatesOneOf2" (\obj -> ((GHC.Base.pure GetByronTransactionResponseBody200CertificatesOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account"))
-- | Create a new 'GetByronTransactionResponseBody200CertificatesOneOf2' with all required fields.
mkGetByronTransactionResponseBody200CertificatesOneOf2 :: GetByronTransactionResponseBody200CertificatesOneOf2Certificate_type -- ^ 'getByronTransactionResponseBody200CertificatesOneOf2Certificate_type'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200CertificatesOneOf2Reward_account'
  -> GetByronTransactionResponseBody200CertificatesOneOf2
mkGetByronTransactionResponseBody200CertificatesOneOf2 getByronTransactionResponseBody200CertificatesOneOf2Certificate_type getByronTransactionResponseBody200CertificatesOneOf2Reward_account = GetByronTransactionResponseBody200CertificatesOneOf2{getByronTransactionResponseBody200CertificatesOneOf2Certificate_type = getByronTransactionResponseBody200CertificatesOneOf2Certificate_type,
                                                                                                                                                                                                                                                      getByronTransactionResponseBody200CertificatesOneOf2Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                      getByronTransactionResponseBody200CertificatesOneOf2Reward_account = getByronTransactionResponseBody200CertificatesOneOf2Reward_account}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200CertificatesOneOf2Certificate_type =
   GetByronTransactionResponseBody200CertificatesOneOf2Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetByronTransactionResponseBody200CertificatesOneOf2Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetByronTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumJoin_pool_external -- ^ Represents the JSON value @"join_pool_external"@
  | GetByronTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumQuit_pool_external -- ^ Represents the JSON value @"quit_pool_external"@
  | GetByronTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external -- ^ Represents the JSON value @"register_reward_account_external"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200CertificatesOneOf2Certificate_type
    where toJSON (GetByronTransactionResponseBody200CertificatesOneOf2Certificate_typeOther val) = val
          toJSON (GetByronTransactionResponseBody200CertificatesOneOf2Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetByronTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumJoin_pool_external) = "join_pool_external"
          toJSON (GetByronTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumQuit_pool_external) = "quit_pool_external"
          toJSON (GetByronTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external) = "register_reward_account_external"
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200CertificatesOneOf2Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool_external" -> GetByronTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumJoin_pool_external
                                            | val GHC.Classes.== "quit_pool_external" -> GetByronTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumQuit_pool_external
                                            | val GHC.Classes.== "register_reward_account_external" -> GetByronTransactionResponseBody200CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external
                                            | GHC.Base.otherwise -> GetByronTransactionResponseBody200CertificatesOneOf2Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200CertificatesOneOf3 = GetByronTransactionResponseBody200CertificatesOneOf3 {
  -- | pool_cost: Estimated cost set by the pool operator when registering his pool.
  -- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  getByronTransactionResponseBody200CertificatesOneOf3Pool_cost :: GetByronTransactionResponseBody200CertificatesOneOf3Pool_cost
  -- | pool_id: A unique identifier for the pool.
  , getByronTransactionResponseBody200CertificatesOneOf3Pool_id :: Data.Text.Internal.Text
  -- | pool_margin: Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , getByronTransactionResponseBody200CertificatesOneOf3Pool_margin :: GetByronTransactionResponseBody200CertificatesOneOf3Pool_margin
  -- | pool_metadata
  , getByronTransactionResponseBody200CertificatesOneOf3Pool_metadata :: (GHC.Maybe.Maybe GetByronTransactionResponseBody200CertificatesOneOf3Pool_metadata)
  -- | pool_owners
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , getByronTransactionResponseBody200CertificatesOneOf3Pool_owners :: ([Data.Text.Internal.Text])
  -- | pool_pledge: Minimal stake amount that a stake pool is willing to honor.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , getByronTransactionResponseBody200CertificatesOneOf3Pool_pledge :: GetByronTransactionResponseBody200CertificatesOneOf3Pool_pledge
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200CertificatesOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200CertificatesOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200CertificatesOneOf3" (\obj -> (((((GHC.Base.pure GetByronTransactionResponseBody200CertificatesOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_cost")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_margin")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool_metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_owners")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_pledge"))
-- | Create a new 'GetByronTransactionResponseBody200CertificatesOneOf3' with all required fields.
mkGetByronTransactionResponseBody200CertificatesOneOf3 :: GetByronTransactionResponseBody200CertificatesOneOf3Pool_cost -- ^ 'getByronTransactionResponseBody200CertificatesOneOf3Pool_cost'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200CertificatesOneOf3Pool_id'
  -> GetByronTransactionResponseBody200CertificatesOneOf3Pool_margin -- ^ 'getByronTransactionResponseBody200CertificatesOneOf3Pool_margin'
  -> [Data.Text.Internal.Text] -- ^ 'getByronTransactionResponseBody200CertificatesOneOf3Pool_owners'
  -> GetByronTransactionResponseBody200CertificatesOneOf3Pool_pledge -- ^ 'getByronTransactionResponseBody200CertificatesOneOf3Pool_pledge'
  -> GetByronTransactionResponseBody200CertificatesOneOf3
mkGetByronTransactionResponseBody200CertificatesOneOf3 getByronTransactionResponseBody200CertificatesOneOf3Pool_cost getByronTransactionResponseBody200CertificatesOneOf3Pool_id getByronTransactionResponseBody200CertificatesOneOf3Pool_margin getByronTransactionResponseBody200CertificatesOneOf3Pool_owners getByronTransactionResponseBody200CertificatesOneOf3Pool_pledge = GetByronTransactionResponseBody200CertificatesOneOf3{getByronTransactionResponseBody200CertificatesOneOf3Pool_cost = getByronTransactionResponseBody200CertificatesOneOf3Pool_cost,
                                                                                                                                                                                                                                                                                                                                                                                                                                        getByronTransactionResponseBody200CertificatesOneOf3Pool_id = getByronTransactionResponseBody200CertificatesOneOf3Pool_id,
                                                                                                                                                                                                                                                                                                                                                                                                                                        getByronTransactionResponseBody200CertificatesOneOf3Pool_margin = getByronTransactionResponseBody200CertificatesOneOf3Pool_margin,
                                                                                                                                                                                                                                                                                                                                                                                                                                        getByronTransactionResponseBody200CertificatesOneOf3Pool_metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                        getByronTransactionResponseBody200CertificatesOneOf3Pool_owners = getByronTransactionResponseBody200CertificatesOneOf3Pool_owners,
                                                                                                                                                                                                                                                                                                                                                                                                                                        getByronTransactionResponseBody200CertificatesOneOf3Pool_pledge = getByronTransactionResponseBody200CertificatesOneOf3Pool_pledge}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_cost@ in the specification.
-- 
-- Estimated cost set by the pool operator when registering his pool.
-- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data GetByronTransactionResponseBody200CertificatesOneOf3Pool_cost = GetByronTransactionResponseBody200CertificatesOneOf3Pool_cost {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200CertificatesOneOf3Pool_costQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200CertificatesOneOf3Pool_cost
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200CertificatesOneOf3Pool_cost
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200CertificatesOneOf3Pool_cost" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200CertificatesOneOf3Pool_cost GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200CertificatesOneOf3Pool_cost' with all required fields.
mkGetByronTransactionResponseBody200CertificatesOneOf3Pool_cost :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200CertificatesOneOf3Pool_costQuantity'
  -> GetByronTransactionResponseBody200CertificatesOneOf3Pool_cost
mkGetByronTransactionResponseBody200CertificatesOneOf3Pool_cost getByronTransactionResponseBody200CertificatesOneOf3Pool_costQuantity = GetByronTransactionResponseBody200CertificatesOneOf3Pool_cost{getByronTransactionResponseBody200CertificatesOneOf3Pool_costQuantity = getByronTransactionResponseBody200CertificatesOneOf3Pool_costQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_margin@ in the specification.
-- 
-- Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data GetByronTransactionResponseBody200CertificatesOneOf3Pool_margin = GetByronTransactionResponseBody200CertificatesOneOf3Pool_margin {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200CertificatesOneOf3Pool_marginQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200CertificatesOneOf3Pool_margin
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200CertificatesOneOf3Pool_margin
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200CertificatesOneOf3Pool_margin" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200CertificatesOneOf3Pool_margin GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200CertificatesOneOf3Pool_margin' with all required fields.
mkGetByronTransactionResponseBody200CertificatesOneOf3Pool_margin :: GHC.Types.Double -- ^ 'getByronTransactionResponseBody200CertificatesOneOf3Pool_marginQuantity'
  -> GetByronTransactionResponseBody200CertificatesOneOf3Pool_margin
mkGetByronTransactionResponseBody200CertificatesOneOf3Pool_margin getByronTransactionResponseBody200CertificatesOneOf3Pool_marginQuantity = GetByronTransactionResponseBody200CertificatesOneOf3Pool_margin{getByronTransactionResponseBody200CertificatesOneOf3Pool_marginQuantity = getByronTransactionResponseBody200CertificatesOneOf3Pool_marginQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_metadata@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200CertificatesOneOf3Pool_metadata = GetByronTransactionResponseBody200CertificatesOneOf3Pool_metadata {
  -- | hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getByronTransactionResponseBody200CertificatesOneOf3Pool_metadataHash :: Data.Text.Internal.Text
  -- | url: A URL to the stake pool\'s website.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 250
  -- * Must match pattern \'^https:\/\/.+\'
  , getByronTransactionResponseBody200CertificatesOneOf3Pool_metadataUrl :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200CertificatesOneOf3Pool_metadata
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200CertificatesOneOf3Pool_metadata
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200CertificatesOneOf3Pool_metadata" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200CertificatesOneOf3Pool_metadata GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))
-- | Create a new 'GetByronTransactionResponseBody200CertificatesOneOf3Pool_metadata' with all required fields.
mkGetByronTransactionResponseBody200CertificatesOneOf3Pool_metadata :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200CertificatesOneOf3Pool_metadataHash'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200CertificatesOneOf3Pool_metadataUrl'
  -> GetByronTransactionResponseBody200CertificatesOneOf3Pool_metadata
mkGetByronTransactionResponseBody200CertificatesOneOf3Pool_metadata getByronTransactionResponseBody200CertificatesOneOf3Pool_metadataHash getByronTransactionResponseBody200CertificatesOneOf3Pool_metadataUrl = GetByronTransactionResponseBody200CertificatesOneOf3Pool_metadata{getByronTransactionResponseBody200CertificatesOneOf3Pool_metadataHash = getByronTransactionResponseBody200CertificatesOneOf3Pool_metadataHash,
                                                                                                                                                                                                                                                                                   getByronTransactionResponseBody200CertificatesOneOf3Pool_metadataUrl = getByronTransactionResponseBody200CertificatesOneOf3Pool_metadataUrl}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_pledge@ in the specification.
-- 
-- Minimal stake amount that a stake pool is willing to honor.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data GetByronTransactionResponseBody200CertificatesOneOf3Pool_pledge = GetByronTransactionResponseBody200CertificatesOneOf3Pool_pledge {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200CertificatesOneOf3Pool_pledgeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200CertificatesOneOf3Pool_pledge
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200CertificatesOneOf3Pool_pledge
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200CertificatesOneOf3Pool_pledge" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200CertificatesOneOf3Pool_pledge GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200CertificatesOneOf3Pool_pledge' with all required fields.
mkGetByronTransactionResponseBody200CertificatesOneOf3Pool_pledge :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200CertificatesOneOf3Pool_pledgeQuantity'
  -> GetByronTransactionResponseBody200CertificatesOneOf3Pool_pledge
mkGetByronTransactionResponseBody200CertificatesOneOf3Pool_pledge getByronTransactionResponseBody200CertificatesOneOf3Pool_pledgeQuantity = GetByronTransactionResponseBody200CertificatesOneOf3Pool_pledge{getByronTransactionResponseBody200CertificatesOneOf3Pool_pledgeQuantity = getByronTransactionResponseBody200CertificatesOneOf3Pool_pledgeQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200CertificatesOneOf4 = GetByronTransactionResponseBody200CertificatesOneOf4 {
  -- | pool_id: A unique identifier for the pool.
  getByronTransactionResponseBody200CertificatesOneOf4Pool_id :: Data.Text.Internal.Text
  -- | retirement_epoch: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200CertificatesOneOf4Retirement_epoch :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200CertificatesOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200CertificatesOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200CertificatesOneOf4" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200CertificatesOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "retirement_epoch"))
-- | Create a new 'GetByronTransactionResponseBody200CertificatesOneOf4' with all required fields.
mkGetByronTransactionResponseBody200CertificatesOneOf4 :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200CertificatesOneOf4Pool_id'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200CertificatesOneOf4Retirement_epoch'
  -> GetByronTransactionResponseBody200CertificatesOneOf4
mkGetByronTransactionResponseBody200CertificatesOneOf4 getByronTransactionResponseBody200CertificatesOneOf4Pool_id getByronTransactionResponseBody200CertificatesOneOf4Retirement_epoch = GetByronTransactionResponseBody200CertificatesOneOf4{getByronTransactionResponseBody200CertificatesOneOf4Pool_id = getByronTransactionResponseBody200CertificatesOneOf4Pool_id,
                                                                                                                                                                                                                                               getByronTransactionResponseBody200CertificatesOneOf4Retirement_epoch = getByronTransactionResponseBody200CertificatesOneOf4Retirement_epoch}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200CertificatesOneOf5 = GetByronTransactionResponseBody200CertificatesOneOf5 {
  -- | certificate_type
  getByronTransactionResponseBody200CertificatesOneOf5Certificate_type :: GetByronTransactionResponseBody200CertificatesOneOf5Certificate_type
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200CertificatesOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200CertificatesOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200CertificatesOneOf5" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200CertificatesOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type"))
-- | Create a new 'GetByronTransactionResponseBody200CertificatesOneOf5' with all required fields.
mkGetByronTransactionResponseBody200CertificatesOneOf5 :: GetByronTransactionResponseBody200CertificatesOneOf5Certificate_type -- ^ 'getByronTransactionResponseBody200CertificatesOneOf5Certificate_type'
  -> GetByronTransactionResponseBody200CertificatesOneOf5
mkGetByronTransactionResponseBody200CertificatesOneOf5 getByronTransactionResponseBody200CertificatesOneOf5Certificate_type = GetByronTransactionResponseBody200CertificatesOneOf5{getByronTransactionResponseBody200CertificatesOneOf5Certificate_type = getByronTransactionResponseBody200CertificatesOneOf5Certificate_type}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200CertificatesOneOf5Certificate_type =
   GetByronTransactionResponseBody200CertificatesOneOf5Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetByronTransactionResponseBody200CertificatesOneOf5Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetByronTransactionResponseBody200CertificatesOneOf5Certificate_typeEnumMir -- ^ Represents the JSON value @"mir"@
  | GetByronTransactionResponseBody200CertificatesOneOf5Certificate_typeEnumGenesis -- ^ Represents the JSON value @"genesis"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200CertificatesOneOf5Certificate_type
    where toJSON (GetByronTransactionResponseBody200CertificatesOneOf5Certificate_typeOther val) = val
          toJSON (GetByronTransactionResponseBody200CertificatesOneOf5Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetByronTransactionResponseBody200CertificatesOneOf5Certificate_typeEnumMir) = "mir"
          toJSON (GetByronTransactionResponseBody200CertificatesOneOf5Certificate_typeEnumGenesis) = "genesis"
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200CertificatesOneOf5Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "mir" -> GetByronTransactionResponseBody200CertificatesOneOf5Certificate_typeEnumMir
                                            | val GHC.Classes.== "genesis" -> GetByronTransactionResponseBody200CertificatesOneOf5Certificate_typeEnumGenesis
                                            | GHC.Base.otherwise -> GetByronTransactionResponseBody200CertificatesOneOf5Certificate_typeOther val)
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- Any certificate that could occur in an arbitrary transaction:
-- might be related to delegation, pool activities, genesis or MIR.
data GetByronTransactionResponseBody200CertificatesVariants =
   GetByronTransactionResponseBody200CertificatesVariant1 GetByronTransactionResponseBody200CertificatesOneOf1
  | GetByronTransactionResponseBody200CertificatesVariant2 GetByronTransactionResponseBody200CertificatesOneOf2
  | GetByronTransactionResponseBody200CertificatesVariant3 GetByronTransactionResponseBody200CertificatesOneOf3
  | GetByronTransactionResponseBody200CertificatesVariant4 GetByronTransactionResponseBody200CertificatesOneOf4
  | GetByronTransactionResponseBody200CertificatesVariant5 GetByronTransactionResponseBody200CertificatesOneOf5
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200CertificatesVariants
    where toJSON (GetByronTransactionResponseBody200CertificatesVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200CertificatesVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200CertificatesVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200CertificatesVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200CertificatesVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200CertificatesVariants
    where parseJSON val = case (GetByronTransactionResponseBody200CertificatesVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200CertificatesVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200CertificatesVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200CertificatesVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200CertificatesVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.collateral.items@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200Collateral = GetByronTransactionResponseBody200Collateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  getByronTransactionResponseBody200CollateralAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , getByronTransactionResponseBody200CollateralAmount :: (GHC.Maybe.Maybe GetByronTransactionResponseBody200CollateralAmount)
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , getByronTransactionResponseBody200CollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200CollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Collateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Collateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Collateral" (\obj -> (((GHC.Base.pure GetByronTransactionResponseBody200Collateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetByronTransactionResponseBody200Collateral' with all required fields.
mkGetByronTransactionResponseBody200Collateral :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200CollateralId'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200CollateralIndex'
  -> GetByronTransactionResponseBody200Collateral
mkGetByronTransactionResponseBody200Collateral getByronTransactionResponseBody200CollateralId getByronTransactionResponseBody200CollateralIndex = GetByronTransactionResponseBody200Collateral{getByronTransactionResponseBody200CollateralAddress = GHC.Maybe.Nothing,
                                                                                                                                                                                               getByronTransactionResponseBody200CollateralAmount = GHC.Maybe.Nothing,
                                                                                                                                                                                               getByronTransactionResponseBody200CollateralId = getByronTransactionResponseBody200CollateralId,
                                                                                                                                                                                               getByronTransactionResponseBody200CollateralIndex = getByronTransactionResponseBody200CollateralIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetByronTransactionResponseBody200CollateralAmount = GetByronTransactionResponseBody200CollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200CollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200CollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200CollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200CollateralAmount" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200CollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200CollateralAmount' with all required fields.
mkGetByronTransactionResponseBody200CollateralAmount :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200CollateralAmountQuantity'
  -> GetByronTransactionResponseBody200CollateralAmount
mkGetByronTransactionResponseBody200CollateralAmount getByronTransactionResponseBody200CollateralAmountQuantity = GetByronTransactionResponseBody200CollateralAmount{getByronTransactionResponseBody200CollateralAmountQuantity = getByronTransactionResponseBody200CollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.collateral_outputs.items@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200Collateral_outputs = GetByronTransactionResponseBody200Collateral_outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  getByronTransactionResponseBody200Collateral_outputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , getByronTransactionResponseBody200Collateral_outputsAmount :: GetByronTransactionResponseBody200Collateral_outputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , getByronTransactionResponseBody200Collateral_outputsAssets :: (GHC.Maybe.Maybe ([GetByronTransactionResponseBody200Collateral_outputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Collateral_outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Collateral_outputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200Collateral_outputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Collateral_outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Collateral_outputs" (\obj -> ((GHC.Base.pure GetByronTransactionResponseBody200Collateral_outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'GetByronTransactionResponseBody200Collateral_outputs' with all required fields.
mkGetByronTransactionResponseBody200Collateral_outputs :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200Collateral_outputsAddress'
  -> GetByronTransactionResponseBody200Collateral_outputsAmount -- ^ 'getByronTransactionResponseBody200Collateral_outputsAmount'
  -> GetByronTransactionResponseBody200Collateral_outputs
mkGetByronTransactionResponseBody200Collateral_outputs getByronTransactionResponseBody200Collateral_outputsAddress getByronTransactionResponseBody200Collateral_outputsAmount = GetByronTransactionResponseBody200Collateral_outputs{getByronTransactionResponseBody200Collateral_outputsAddress = getByronTransactionResponseBody200Collateral_outputsAddress,
                                                                                                                                                                                                                                     getByronTransactionResponseBody200Collateral_outputsAmount = getByronTransactionResponseBody200Collateral_outputsAmount,
                                                                                                                                                                                                                                     getByronTransactionResponseBody200Collateral_outputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.collateral_outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetByronTransactionResponseBody200Collateral_outputsAmount = GetByronTransactionResponseBody200Collateral_outputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200Collateral_outputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Collateral_outputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Collateral_outputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Collateral_outputsAmount" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200Collateral_outputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200Collateral_outputsAmount' with all required fields.
mkGetByronTransactionResponseBody200Collateral_outputsAmount :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Collateral_outputsAmountQuantity'
  -> GetByronTransactionResponseBody200Collateral_outputsAmount
mkGetByronTransactionResponseBody200Collateral_outputsAmount getByronTransactionResponseBody200Collateral_outputsAmountQuantity = GetByronTransactionResponseBody200Collateral_outputsAmount{getByronTransactionResponseBody200Collateral_outputsAmountQuantity = getByronTransactionResponseBody200Collateral_outputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.collateral_outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data GetByronTransactionResponseBody200Collateral_outputsAssets = GetByronTransactionResponseBody200Collateral_outputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getByronTransactionResponseBody200Collateral_outputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getByronTransactionResponseBody200Collateral_outputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200Collateral_outputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Collateral_outputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Collateral_outputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Collateral_outputsAssets" (\obj -> ((GHC.Base.pure GetByronTransactionResponseBody200Collateral_outputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200Collateral_outputsAssets' with all required fields.
mkGetByronTransactionResponseBody200Collateral_outputsAssets :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200Collateral_outputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200Collateral_outputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Collateral_outputsAssetsQuantity'
  -> GetByronTransactionResponseBody200Collateral_outputsAssets
mkGetByronTransactionResponseBody200Collateral_outputsAssets getByronTransactionResponseBody200Collateral_outputsAssetsAsset_name getByronTransactionResponseBody200Collateral_outputsAssetsPolicy_id getByronTransactionResponseBody200Collateral_outputsAssetsQuantity = GetByronTransactionResponseBody200Collateral_outputsAssets{getByronTransactionResponseBody200Collateral_outputsAssetsAsset_name = getByronTransactionResponseBody200Collateral_outputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                      getByronTransactionResponseBody200Collateral_outputsAssetsPolicy_id = getByronTransactionResponseBody200Collateral_outputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                      getByronTransactionResponseBody200Collateral_outputsAssetsQuantity = getByronTransactionResponseBody200Collateral_outputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.deposit_returned@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetByronTransactionResponseBody200Deposit_returned = GetByronTransactionResponseBody200Deposit_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200Deposit_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Deposit_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Deposit_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Deposit_returned" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200Deposit_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200Deposit_returned' with all required fields.
mkGetByronTransactionResponseBody200Deposit_returned :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Deposit_returnedQuantity'
  -> GetByronTransactionResponseBody200Deposit_returned
mkGetByronTransactionResponseBody200Deposit_returned getByronTransactionResponseBody200Deposit_returnedQuantity = GetByronTransactionResponseBody200Deposit_returned{getByronTransactionResponseBody200Deposit_returnedQuantity = getByronTransactionResponseBody200Deposit_returnedQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.deposit_taken@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetByronTransactionResponseBody200Deposit_taken = GetByronTransactionResponseBody200Deposit_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200Deposit_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Deposit_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Deposit_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Deposit_taken" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200Deposit_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200Deposit_taken' with all required fields.
mkGetByronTransactionResponseBody200Deposit_taken :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Deposit_takenQuantity'
  -> GetByronTransactionResponseBody200Deposit_taken
mkGetByronTransactionResponseBody200Deposit_taken getByronTransactionResponseBody200Deposit_takenQuantity = GetByronTransactionResponseBody200Deposit_taken{getByronTransactionResponseBody200Deposit_takenQuantity = getByronTransactionResponseBody200Deposit_takenQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.depth@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Current depth of the transaction in the local chain
data GetByronTransactionResponseBody200Depth = GetByronTransactionResponseBody200Depth {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200DepthQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Depth
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Depth
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Depth" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200Depth GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200Depth' with all required fields.
mkGetByronTransactionResponseBody200Depth :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200DepthQuantity'
  -> GetByronTransactionResponseBody200Depth
mkGetByronTransactionResponseBody200Depth getByronTransactionResponseBody200DepthQuantity = GetByronTransactionResponseBody200Depth{getByronTransactionResponseBody200DepthQuantity = getByronTransactionResponseBody200DepthQuantity}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.direction@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200Direction =
   GetByronTransactionResponseBody200DirectionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetByronTransactionResponseBody200DirectionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetByronTransactionResponseBody200DirectionEnumOutgoing -- ^ Represents the JSON value @"outgoing"@
  | GetByronTransactionResponseBody200DirectionEnumIncoming -- ^ Represents the JSON value @"incoming"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Direction
    where toJSON (GetByronTransactionResponseBody200DirectionOther val) = val
          toJSON (GetByronTransactionResponseBody200DirectionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetByronTransactionResponseBody200DirectionEnumOutgoing) = "outgoing"
          toJSON (GetByronTransactionResponseBody200DirectionEnumIncoming) = "incoming"
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Direction
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "outgoing" -> GetByronTransactionResponseBody200DirectionEnumOutgoing
                                            | val GHC.Classes.== "incoming" -> GetByronTransactionResponseBody200DirectionEnumIncoming
                                            | GHC.Base.otherwise -> GetByronTransactionResponseBody200DirectionOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.expires_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending OR status == expired
-- \<\/span>\<br\/>
-- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
data GetByronTransactionResponseBody200Expires_at = GetByronTransactionResponseBody200Expires_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200Expires_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200Expires_atEpoch_number :: GHC.Types.Int
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200Expires_atSlot_number :: GHC.Types.Int
  -- | time
  , getByronTransactionResponseBody200Expires_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Expires_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Expires_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Expires_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Expires_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Expires_at" (\obj -> (((GHC.Base.pure GetByronTransactionResponseBody200Expires_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'GetByronTransactionResponseBody200Expires_at' with all required fields.
mkGetByronTransactionResponseBody200Expires_at :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Expires_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Expires_atEpoch_number'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Expires_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200Expires_atTime'
  -> GetByronTransactionResponseBody200Expires_at
mkGetByronTransactionResponseBody200Expires_at getByronTransactionResponseBody200Expires_atAbsolute_slot_number getByronTransactionResponseBody200Expires_atEpoch_number getByronTransactionResponseBody200Expires_atSlot_number getByronTransactionResponseBody200Expires_atTime = GetByronTransactionResponseBody200Expires_at{getByronTransactionResponseBody200Expires_atAbsolute_slot_number = getByronTransactionResponseBody200Expires_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                 getByronTransactionResponseBody200Expires_atEpoch_number = getByronTransactionResponseBody200Expires_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                 getByronTransactionResponseBody200Expires_atSlot_number = getByronTransactionResponseBody200Expires_atSlot_number,
                                                                                                                                                                                                                                                                                                                                 getByronTransactionResponseBody200Expires_atTime = getByronTransactionResponseBody200Expires_atTime}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.fee@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetByronTransactionResponseBody200Fee = GetByronTransactionResponseBody200Fee {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200FeeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Fee
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Fee
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Fee" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200Fee GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200Fee' with all required fields.
mkGetByronTransactionResponseBody200Fee :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200FeeQuantity'
  -> GetByronTransactionResponseBody200Fee
mkGetByronTransactionResponseBody200Fee getByronTransactionResponseBody200FeeQuantity = GetByronTransactionResponseBody200Fee{getByronTransactionResponseBody200FeeQuantity = getByronTransactionResponseBody200FeeQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.inputs.items@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200Inputs = GetByronTransactionResponseBody200Inputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  getByronTransactionResponseBody200InputsAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , getByronTransactionResponseBody200InputsAmount :: (GHC.Maybe.Maybe GetByronTransactionResponseBody200InputsAmount)
  -- | assets: A flat list of assets (possibly empty).
  , getByronTransactionResponseBody200InputsAssets :: (GHC.Maybe.Maybe ([GetByronTransactionResponseBody200InputsAssets]))
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , getByronTransactionResponseBody200InputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200InputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Inputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200InputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200InputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Inputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Inputs" (\obj -> ((((GHC.Base.pure GetByronTransactionResponseBody200Inputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetByronTransactionResponseBody200Inputs' with all required fields.
mkGetByronTransactionResponseBody200Inputs :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200InputsId'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200InputsIndex'
  -> GetByronTransactionResponseBody200Inputs
mkGetByronTransactionResponseBody200Inputs getByronTransactionResponseBody200InputsId getByronTransactionResponseBody200InputsIndex = GetByronTransactionResponseBody200Inputs{getByronTransactionResponseBody200InputsAddress = GHC.Maybe.Nothing,
                                                                                                                                                                               getByronTransactionResponseBody200InputsAmount = GHC.Maybe.Nothing,
                                                                                                                                                                               getByronTransactionResponseBody200InputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                                               getByronTransactionResponseBody200InputsId = getByronTransactionResponseBody200InputsId,
                                                                                                                                                                               getByronTransactionResponseBody200InputsIndex = getByronTransactionResponseBody200InputsIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetByronTransactionResponseBody200InputsAmount = GetByronTransactionResponseBody200InputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200InputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200InputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200InputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200InputsAmount" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200InputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200InputsAmount' with all required fields.
mkGetByronTransactionResponseBody200InputsAmount :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200InputsAmountQuantity'
  -> GetByronTransactionResponseBody200InputsAmount
mkGetByronTransactionResponseBody200InputsAmount getByronTransactionResponseBody200InputsAmountQuantity = GetByronTransactionResponseBody200InputsAmount{getByronTransactionResponseBody200InputsAmountQuantity = getByronTransactionResponseBody200InputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data GetByronTransactionResponseBody200InputsAssets = GetByronTransactionResponseBody200InputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getByronTransactionResponseBody200InputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getByronTransactionResponseBody200InputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200InputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200InputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200InputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200InputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200InputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200InputsAssets" (\obj -> ((GHC.Base.pure GetByronTransactionResponseBody200InputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200InputsAssets' with all required fields.
mkGetByronTransactionResponseBody200InputsAssets :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200InputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200InputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200InputsAssetsQuantity'
  -> GetByronTransactionResponseBody200InputsAssets
mkGetByronTransactionResponseBody200InputsAssets getByronTransactionResponseBody200InputsAssetsAsset_name getByronTransactionResponseBody200InputsAssetsPolicy_id getByronTransactionResponseBody200InputsAssetsQuantity = GetByronTransactionResponseBody200InputsAssets{getByronTransactionResponseBody200InputsAssetsAsset_name = getByronTransactionResponseBody200InputsAssetsAsset_name,
                                                                                                                                                                                                                                                                          getByronTransactionResponseBody200InputsAssetsPolicy_id = getByronTransactionResponseBody200InputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                          getByronTransactionResponseBody200InputsAssetsQuantity = getByronTransactionResponseBody200InputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.inserted_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Absolute time at which the transaction was inserted in a block.
data GetByronTransactionResponseBody200Inserted_at = GetByronTransactionResponseBody200Inserted_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200Inserted_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200Inserted_atEpoch_number :: GHC.Types.Int
  -- | height
  , getByronTransactionResponseBody200Inserted_atHeight :: GetByronTransactionResponseBody200Inserted_atHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200Inserted_atSlot_number :: GHC.Types.Int
  -- | time
  , getByronTransactionResponseBody200Inserted_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Inserted_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Inserted_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Inserted_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Inserted_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Inserted_at" (\obj -> ((((GHC.Base.pure GetByronTransactionResponseBody200Inserted_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'GetByronTransactionResponseBody200Inserted_at' with all required fields.
mkGetByronTransactionResponseBody200Inserted_at :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Inserted_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Inserted_atEpoch_number'
  -> GetByronTransactionResponseBody200Inserted_atHeight -- ^ 'getByronTransactionResponseBody200Inserted_atHeight'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Inserted_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200Inserted_atTime'
  -> GetByronTransactionResponseBody200Inserted_at
mkGetByronTransactionResponseBody200Inserted_at getByronTransactionResponseBody200Inserted_atAbsolute_slot_number getByronTransactionResponseBody200Inserted_atEpoch_number getByronTransactionResponseBody200Inserted_atHeight getByronTransactionResponseBody200Inserted_atSlot_number getByronTransactionResponseBody200Inserted_atTime = GetByronTransactionResponseBody200Inserted_at{getByronTransactionResponseBody200Inserted_atAbsolute_slot_number = getByronTransactionResponseBody200Inserted_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                                           getByronTransactionResponseBody200Inserted_atEpoch_number = getByronTransactionResponseBody200Inserted_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                                           getByronTransactionResponseBody200Inserted_atHeight = getByronTransactionResponseBody200Inserted_atHeight,
                                                                                                                                                                                                                                                                                                                                                                                           getByronTransactionResponseBody200Inserted_atSlot_number = getByronTransactionResponseBody200Inserted_atSlot_number,
                                                                                                                                                                                                                                                                                                                                                                                           getByronTransactionResponseBody200Inserted_atTime = getByronTransactionResponseBody200Inserted_atTime}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.inserted_at.properties.height@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200Inserted_atHeight = GetByronTransactionResponseBody200Inserted_atHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200Inserted_atHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Inserted_atHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Inserted_atHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Inserted_atHeight" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200Inserted_atHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200Inserted_atHeight' with all required fields.
mkGetByronTransactionResponseBody200Inserted_atHeight :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Inserted_atHeightQuantity'
  -> GetByronTransactionResponseBody200Inserted_atHeight
mkGetByronTransactionResponseBody200Inserted_atHeight getByronTransactionResponseBody200Inserted_atHeightQuantity = GetByronTransactionResponseBody200Inserted_atHeight{getByronTransactionResponseBody200Inserted_atHeightQuantity = getByronTransactionResponseBody200Inserted_atHeightQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200Mint = GetByronTransactionResponseBody200Mint {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  getByronTransactionResponseBody200MintTokens :: ([GetByronTransactionResponseBody200MintTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , getByronTransactionResponseBody200MintWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , getByronTransactionResponseBody200MintWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Mint
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200MintWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200MintWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Mint
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Mint" (\obj -> ((GHC.Base.pure GetByronTransactionResponseBody200Mint GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'GetByronTransactionResponseBody200Mint' with all required fields.
mkGetByronTransactionResponseBody200Mint :: [GetByronTransactionResponseBody200MintTokens] -- ^ 'getByronTransactionResponseBody200MintTokens'
  -> GetByronTransactionResponseBody200Mint
mkGetByronTransactionResponseBody200Mint getByronTransactionResponseBody200MintTokens = GetByronTransactionResponseBody200Mint{getByronTransactionResponseBody200MintTokens = getByronTransactionResponseBody200MintTokens,
                                                                                                                               getByronTransactionResponseBody200MintWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                               getByronTransactionResponseBody200MintWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200MintTokens = GetByronTransactionResponseBody200MintTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getByronTransactionResponseBody200MintTokensAssets :: ([GetByronTransactionResponseBody200MintTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getByronTransactionResponseBody200MintTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , getByronTransactionResponseBody200MintTokensPolicy_script :: GetByronTransactionResponseBody200MintTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200MintTokens" (\obj -> ((GHC.Base.pure GetByronTransactionResponseBody200MintTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'GetByronTransactionResponseBody200MintTokens' with all required fields.
mkGetByronTransactionResponseBody200MintTokens :: [GetByronTransactionResponseBody200MintTokensAssets] -- ^ 'getByronTransactionResponseBody200MintTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_id'
  -> GetByronTransactionResponseBody200MintTokensPolicy_scriptVariants -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_script'
  -> GetByronTransactionResponseBody200MintTokens
mkGetByronTransactionResponseBody200MintTokens getByronTransactionResponseBody200MintTokensAssets getByronTransactionResponseBody200MintTokensPolicy_id getByronTransactionResponseBody200MintTokensPolicy_script = GetByronTransactionResponseBody200MintTokens{getByronTransactionResponseBody200MintTokensAssets = getByronTransactionResponseBody200MintTokensAssets,
                                                                                                                                                                                                                                                                 getByronTransactionResponseBody200MintTokensPolicy_id = getByronTransactionResponseBody200MintTokensPolicy_id,
                                                                                                                                                                                                                                                                 getByronTransactionResponseBody200MintTokensPolicy_script = getByronTransactionResponseBody200MintTokensPolicy_script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200MintTokensAssets = GetByronTransactionResponseBody200MintTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getByronTransactionResponseBody200MintTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , getByronTransactionResponseBody200MintTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200MintTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200MintTokensAssets" (\obj -> ((GHC.Base.pure GetByronTransactionResponseBody200MintTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200MintTokensAssets' with all required fields.
mkGetByronTransactionResponseBody200MintTokensAssets :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200MintTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200MintTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200MintTokensAssetsQuantity'
  -> GetByronTransactionResponseBody200MintTokensAssets
mkGetByronTransactionResponseBody200MintTokensAssets getByronTransactionResponseBody200MintTokensAssetsAsset_name getByronTransactionResponseBody200MintTokensAssetsFingerprint getByronTransactionResponseBody200MintTokensAssetsQuantity = GetByronTransactionResponseBody200MintTokensAssets{getByronTransactionResponseBody200MintTokensAssetsAsset_name = getByronTransactionResponseBody200MintTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                                getByronTransactionResponseBody200MintTokensAssetsFingerprint = getByronTransactionResponseBody200MintTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                                getByronTransactionResponseBody200MintTokensAssetsQuantity = getByronTransactionResponseBody200MintTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1 = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference)
  -- | script
  , getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Script :: GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1' with all required fields.
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1 :: GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Script'
  -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1 getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Script = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1{getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                          getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Script = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference' with all required fields.
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex'
  -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1Reference{getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                               getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2 getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2{getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3 getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3{getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 :: GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4 getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4{getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4Some{getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                                getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5 getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5{getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6 getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6{getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants =
   GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant2 GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf2
  | GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant3 GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf3
  | GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant4 GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf4
  | GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant5 GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf5
  | GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant6 GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2 = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info :: GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2' with all required fields.
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2 :: GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info'
  -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2 getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2{getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                               getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference' with all required fields.
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex'
  -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Reference{getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                               getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version :: GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info :: GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_info{getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                                           getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3 = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References :: ([GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3' with all required fields.
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3 :: [GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References] -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3Script_hash'
  -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3 getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3Script_hash = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3{getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                                         getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3Script_hash = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References' with all required fields.
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex'
  -> GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References
mkGetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex = GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3References{getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                                   getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex = getByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200MintTokensPolicy_scriptVariants =
   GetByronTransactionResponseBody200MintTokensPolicy_scriptVariant1 GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf1
  | GetByronTransactionResponseBody200MintTokensPolicy_scriptVariant2 GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf2
  | GetByronTransactionResponseBody200MintTokensPolicy_scriptVariant3 GetByronTransactionResponseBody200MintTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptVariants
    where toJSON (GetByronTransactionResponseBody200MintTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200MintTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody200MintTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200MintTokensPolicy_scriptVariants
    where parseJSON val = case (GetByronTransactionResponseBody200MintTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200MintTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody200MintTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.outputs.items@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200Outputs = GetByronTransactionResponseBody200Outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  getByronTransactionResponseBody200OutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , getByronTransactionResponseBody200OutputsAmount :: GetByronTransactionResponseBody200OutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , getByronTransactionResponseBody200OutputsAssets :: (GHC.Maybe.Maybe ([GetByronTransactionResponseBody200OutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200OutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (getByronTransactionResponseBody200OutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Outputs" (\obj -> ((GHC.Base.pure GetByronTransactionResponseBody200Outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'GetByronTransactionResponseBody200Outputs' with all required fields.
mkGetByronTransactionResponseBody200Outputs :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200OutputsAddress'
  -> GetByronTransactionResponseBody200OutputsAmount -- ^ 'getByronTransactionResponseBody200OutputsAmount'
  -> GetByronTransactionResponseBody200Outputs
mkGetByronTransactionResponseBody200Outputs getByronTransactionResponseBody200OutputsAddress getByronTransactionResponseBody200OutputsAmount = GetByronTransactionResponseBody200Outputs{getByronTransactionResponseBody200OutputsAddress = getByronTransactionResponseBody200OutputsAddress,
                                                                                                                                                                                         getByronTransactionResponseBody200OutputsAmount = getByronTransactionResponseBody200OutputsAmount,
                                                                                                                                                                                         getByronTransactionResponseBody200OutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetByronTransactionResponseBody200OutputsAmount = GetByronTransactionResponseBody200OutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200OutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200OutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200OutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200OutputsAmount" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200OutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200OutputsAmount' with all required fields.
mkGetByronTransactionResponseBody200OutputsAmount :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200OutputsAmountQuantity'
  -> GetByronTransactionResponseBody200OutputsAmount
mkGetByronTransactionResponseBody200OutputsAmount getByronTransactionResponseBody200OutputsAmountQuantity = GetByronTransactionResponseBody200OutputsAmount{getByronTransactionResponseBody200OutputsAmountQuantity = getByronTransactionResponseBody200OutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data GetByronTransactionResponseBody200OutputsAssets = GetByronTransactionResponseBody200OutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getByronTransactionResponseBody200OutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getByronTransactionResponseBody200OutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200OutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200OutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200OutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200OutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200OutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200OutputsAssets" (\obj -> ((GHC.Base.pure GetByronTransactionResponseBody200OutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200OutputsAssets' with all required fields.
mkGetByronTransactionResponseBody200OutputsAssets :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200OutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200OutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200OutputsAssetsQuantity'
  -> GetByronTransactionResponseBody200OutputsAssets
mkGetByronTransactionResponseBody200OutputsAssets getByronTransactionResponseBody200OutputsAssetsAsset_name getByronTransactionResponseBody200OutputsAssetsPolicy_id getByronTransactionResponseBody200OutputsAssetsQuantity = GetByronTransactionResponseBody200OutputsAssets{getByronTransactionResponseBody200OutputsAssetsAsset_name = getByronTransactionResponseBody200OutputsAssetsAsset_name,
                                                                                                                                                                                                                                                                               getByronTransactionResponseBody200OutputsAssetsPolicy_id = getByronTransactionResponseBody200OutputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                               getByronTransactionResponseBody200OutputsAssetsQuantity = getByronTransactionResponseBody200OutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.pending_since@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending
-- \<\/span>\<br\/>
-- The point in time at which a transaction became pending.
data GetByronTransactionResponseBody200Pending_since = GetByronTransactionResponseBody200Pending_since {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200Pending_sinceAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200Pending_sinceEpoch_number :: GHC.Types.Int
  -- | height
  , getByronTransactionResponseBody200Pending_sinceHeight :: GetByronTransactionResponseBody200Pending_sinceHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronTransactionResponseBody200Pending_sinceSlot_number :: GHC.Types.Int
  -- | time
  , getByronTransactionResponseBody200Pending_sinceTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Pending_since
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Pending_sinceTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Pending_sinceTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Pending_since
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Pending_since" (\obj -> ((((GHC.Base.pure GetByronTransactionResponseBody200Pending_since GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'GetByronTransactionResponseBody200Pending_since' with all required fields.
mkGetByronTransactionResponseBody200Pending_since :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Pending_sinceAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Pending_sinceEpoch_number'
  -> GetByronTransactionResponseBody200Pending_sinceHeight -- ^ 'getByronTransactionResponseBody200Pending_sinceHeight'
  -> GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Pending_sinceSlot_number'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200Pending_sinceTime'
  -> GetByronTransactionResponseBody200Pending_since
mkGetByronTransactionResponseBody200Pending_since getByronTransactionResponseBody200Pending_sinceAbsolute_slot_number getByronTransactionResponseBody200Pending_sinceEpoch_number getByronTransactionResponseBody200Pending_sinceHeight getByronTransactionResponseBody200Pending_sinceSlot_number getByronTransactionResponseBody200Pending_sinceTime = GetByronTransactionResponseBody200Pending_since{getByronTransactionResponseBody200Pending_sinceAbsolute_slot_number = getByronTransactionResponseBody200Pending_sinceAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                                                         getByronTransactionResponseBody200Pending_sinceEpoch_number = getByronTransactionResponseBody200Pending_sinceEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                                                         getByronTransactionResponseBody200Pending_sinceHeight = getByronTransactionResponseBody200Pending_sinceHeight,
                                                                                                                                                                                                                                                                                                                                                                                                         getByronTransactionResponseBody200Pending_sinceSlot_number = getByronTransactionResponseBody200Pending_sinceSlot_number,
                                                                                                                                                                                                                                                                                                                                                                                                         getByronTransactionResponseBody200Pending_sinceTime = getByronTransactionResponseBody200Pending_sinceTime}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.pending_since.properties.height@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200Pending_sinceHeight = GetByronTransactionResponseBody200Pending_sinceHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200Pending_sinceHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Pending_sinceHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Pending_sinceHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Pending_sinceHeight" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200Pending_sinceHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200Pending_sinceHeight' with all required fields.
mkGetByronTransactionResponseBody200Pending_sinceHeight :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Pending_sinceHeightQuantity'
  -> GetByronTransactionResponseBody200Pending_sinceHeight
mkGetByronTransactionResponseBody200Pending_sinceHeight getByronTransactionResponseBody200Pending_sinceHeightQuantity = GetByronTransactionResponseBody200Pending_sinceHeight{getByronTransactionResponseBody200Pending_sinceHeightQuantity = getByronTransactionResponseBody200Pending_sinceHeightQuantity}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.script_validity@ in the specification.
-- 
-- Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
-- used in the transaction validated or not. Validity may be null if this
-- transaction was from an era that doesn\'t support phase-2 monetary policy
-- scripts, or is a pending transaction (we don\'t know if validation passed or
-- failed until the transaction hits the ledger).
data GetByronTransactionResponseBody200Script_validityNonNullable =
   GetByronTransactionResponseBody200Script_validityNonNullableOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetByronTransactionResponseBody200Script_validityNonNullableTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetByronTransactionResponseBody200Script_validityNonNullableEnumValid -- ^ Represents the JSON value @"valid"@
  | GetByronTransactionResponseBody200Script_validityNonNullableEnumInvalid -- ^ Represents the JSON value @"invalid"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Script_validityNonNullable
    where toJSON (GetByronTransactionResponseBody200Script_validityNonNullableOther val) = val
          toJSON (GetByronTransactionResponseBody200Script_validityNonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetByronTransactionResponseBody200Script_validityNonNullableEnumValid) = "valid"
          toJSON (GetByronTransactionResponseBody200Script_validityNonNullableEnumInvalid) = "invalid"
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Script_validityNonNullable
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "valid" -> GetByronTransactionResponseBody200Script_validityNonNullableEnumValid
                                            | val GHC.Classes.== "invalid" -> GetByronTransactionResponseBody200Script_validityNonNullableEnumInvalid
                                            | GHC.Base.otherwise -> GetByronTransactionResponseBody200Script_validityNonNullableOther val)
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.status@ in the specification.
-- 
-- Current transaction status.
-- 
--   \`\`\`
--        *-----------*
--   ---> |  PENDING  |----------------*
--        *-----------*                |
--              |                      |
--              V                      V
--        *-----------*          *-----------*
--        |           |---------->  EXPIRED  |
--        |           |  (ttl)   *-----------*
--        | SUBMITTED |
--        |           \<----------------*
--        |           |                |
--        *-----------*           (rollback)
--               |                     |
--          (in ledger)          *-----------*
--               |               |           |
--               *---------------> IN_LEDGER |
--                               |           |
--                               *-----------*
--   \`\`\`
data GetByronTransactionResponseBody200Status =
   GetByronTransactionResponseBody200StatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | GetByronTransactionResponseBody200StatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | GetByronTransactionResponseBody200StatusEnumPending -- ^ Represents the JSON value @"pending"@
  | GetByronTransactionResponseBody200StatusEnumSubmitted -- ^ Represents the JSON value @"submitted"@
  | GetByronTransactionResponseBody200StatusEnumIn_ledger -- ^ Represents the JSON value @"in_ledger"@
  | GetByronTransactionResponseBody200StatusEnumExpired -- ^ Represents the JSON value @"expired"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Status
    where toJSON (GetByronTransactionResponseBody200StatusOther val) = val
          toJSON (GetByronTransactionResponseBody200StatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (GetByronTransactionResponseBody200StatusEnumPending) = "pending"
          toJSON (GetByronTransactionResponseBody200StatusEnumSubmitted) = "submitted"
          toJSON (GetByronTransactionResponseBody200StatusEnumIn_ledger) = "in_ledger"
          toJSON (GetByronTransactionResponseBody200StatusEnumExpired) = "expired"
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Status
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "pending" -> GetByronTransactionResponseBody200StatusEnumPending
                                            | val GHC.Classes.== "submitted" -> GetByronTransactionResponseBody200StatusEnumSubmitted
                                            | val GHC.Classes.== "in_ledger" -> GetByronTransactionResponseBody200StatusEnumIn_ledger
                                            | val GHC.Classes.== "expired" -> GetByronTransactionResponseBody200StatusEnumExpired
                                            | GHC.Base.otherwise -> GetByronTransactionResponseBody200StatusOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.validity_interval@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200Validity_interval = GetByronTransactionResponseBody200Validity_interval {
  -- | invalid_before
  getByronTransactionResponseBody200Validity_intervalInvalid_before :: GetByronTransactionResponseBody200Validity_intervalInvalid_before
  -- | invalid_hereafter
  , getByronTransactionResponseBody200Validity_intervalInvalid_hereafter :: GetByronTransactionResponseBody200Validity_intervalInvalid_hereafter
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Validity_interval
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Validity_interval
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Validity_interval" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200Validity_interval GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_before")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_hereafter"))
-- | Create a new 'GetByronTransactionResponseBody200Validity_interval' with all required fields.
mkGetByronTransactionResponseBody200Validity_interval :: GetByronTransactionResponseBody200Validity_intervalInvalid_before -- ^ 'getByronTransactionResponseBody200Validity_intervalInvalid_before'
  -> GetByronTransactionResponseBody200Validity_intervalInvalid_hereafter -- ^ 'getByronTransactionResponseBody200Validity_intervalInvalid_hereafter'
  -> GetByronTransactionResponseBody200Validity_interval
mkGetByronTransactionResponseBody200Validity_interval getByronTransactionResponseBody200Validity_intervalInvalid_before getByronTransactionResponseBody200Validity_intervalInvalid_hereafter = GetByronTransactionResponseBody200Validity_interval{getByronTransactionResponseBody200Validity_intervalInvalid_before = getByronTransactionResponseBody200Validity_intervalInvalid_before,
                                                                                                                                                                                                                                                   getByronTransactionResponseBody200Validity_intervalInvalid_hereafter = getByronTransactionResponseBody200Validity_intervalInvalid_hereafter}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.validity_interval.properties.invalid_before@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200Validity_intervalInvalid_before = GetByronTransactionResponseBody200Validity_intervalInvalid_before {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200Validity_intervalInvalid_beforeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Validity_intervalInvalid_before
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Validity_intervalInvalid_before
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Validity_intervalInvalid_before" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200Validity_intervalInvalid_before GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200Validity_intervalInvalid_before' with all required fields.
mkGetByronTransactionResponseBody200Validity_intervalInvalid_before :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Validity_intervalInvalid_beforeQuantity'
  -> GetByronTransactionResponseBody200Validity_intervalInvalid_before
mkGetByronTransactionResponseBody200Validity_intervalInvalid_before getByronTransactionResponseBody200Validity_intervalInvalid_beforeQuantity = GetByronTransactionResponseBody200Validity_intervalInvalid_before{getByronTransactionResponseBody200Validity_intervalInvalid_beforeQuantity = getByronTransactionResponseBody200Validity_intervalInvalid_beforeQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.validity_interval.properties.invalid_hereafter@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200Validity_intervalInvalid_hereafter = GetByronTransactionResponseBody200Validity_intervalInvalid_hereafter {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200Validity_intervalInvalid_hereafterQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Validity_intervalInvalid_hereafter
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Validity_intervalInvalid_hereafter
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Validity_intervalInvalid_hereafter" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200Validity_intervalInvalid_hereafter GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200Validity_intervalInvalid_hereafter' with all required fields.
mkGetByronTransactionResponseBody200Validity_intervalInvalid_hereafter :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200Validity_intervalInvalid_hereafterQuantity'
  -> GetByronTransactionResponseBody200Validity_intervalInvalid_hereafter
mkGetByronTransactionResponseBody200Validity_intervalInvalid_hereafter getByronTransactionResponseBody200Validity_intervalInvalid_hereafterQuantity = GetByronTransactionResponseBody200Validity_intervalInvalid_hereafter{getByronTransactionResponseBody200Validity_intervalInvalid_hereafterQuantity = getByronTransactionResponseBody200Validity_intervalInvalid_hereafterQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.withdrawals.items@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody200Withdrawals = GetByronTransactionResponseBody200Withdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  getByronTransactionResponseBody200WithdrawalsAmount :: GetByronTransactionResponseBody200WithdrawalsAmount
  -- | stake_address
  , getByronTransactionResponseBody200WithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200Withdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200WithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200WithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200Withdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200Withdrawals" (\obj -> (GHC.Base.pure GetByronTransactionResponseBody200Withdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'GetByronTransactionResponseBody200Withdrawals' with all required fields.
mkGetByronTransactionResponseBody200Withdrawals :: GetByronTransactionResponseBody200WithdrawalsAmount -- ^ 'getByronTransactionResponseBody200WithdrawalsAmount'
  -> Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody200WithdrawalsStake_address'
  -> GetByronTransactionResponseBody200Withdrawals
mkGetByronTransactionResponseBody200Withdrawals getByronTransactionResponseBody200WithdrawalsAmount getByronTransactionResponseBody200WithdrawalsStake_address = GetByronTransactionResponseBody200Withdrawals{getByronTransactionResponseBody200WithdrawalsAmount = getByronTransactionResponseBody200WithdrawalsAmount,
                                                                                                                                                                                                               getByronTransactionResponseBody200WithdrawalsStake_address = getByronTransactionResponseBody200WithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.200.content.application\/json.schema.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data GetByronTransactionResponseBody200WithdrawalsAmount = GetByronTransactionResponseBody200WithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronTransactionResponseBody200WithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody200WithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody200WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody200WithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody200WithdrawalsAmount" (\obj -> GHC.Base.pure GetByronTransactionResponseBody200WithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronTransactionResponseBody200WithdrawalsAmount' with all required fields.
mkGetByronTransactionResponseBody200WithdrawalsAmount :: GHC.Types.Int -- ^ 'getByronTransactionResponseBody200WithdrawalsAmountQuantity'
  -> GetByronTransactionResponseBody200WithdrawalsAmount
mkGetByronTransactionResponseBody200WithdrawalsAmount getByronTransactionResponseBody200WithdrawalsAmountQuantity = GetByronTransactionResponseBody200WithdrawalsAmount{getByronTransactionResponseBody200WithdrawalsAmountQuantity = getByronTransactionResponseBody200WithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.404.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody404OneOf1 = GetByronTransactionResponseBody404OneOf1 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  getByronTransactionResponseBody404OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody404OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody404OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody404OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody404OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody404OneOf1" (\obj -> GHC.Base.pure GetByronTransactionResponseBody404OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetByronTransactionResponseBody404OneOf1' with all required fields.
mkGetByronTransactionResponseBody404OneOf1 :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody404OneOf1Message'
  -> GetByronTransactionResponseBody404OneOf1
mkGetByronTransactionResponseBody404OneOf1 getByronTransactionResponseBody404OneOf1Message = GetByronTransactionResponseBody404OneOf1{getByronTransactionResponseBody404OneOf1Message = getByronTransactionResponseBody404OneOf1Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.404.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody404OneOf2 = GetByronTransactionResponseBody404OneOf2 {
  -- | message: May occur when a given transactionId does not match with any known transactions.
  getByronTransactionResponseBody404OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody404OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody404OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_transaction"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody404OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_transaction"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody404OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody404OneOf2" (\obj -> GHC.Base.pure GetByronTransactionResponseBody404OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetByronTransactionResponseBody404OneOf2' with all required fields.
mkGetByronTransactionResponseBody404OneOf2 :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody404OneOf2Message'
  -> GetByronTransactionResponseBody404OneOf2
mkGetByronTransactionResponseBody404OneOf2 getByronTransactionResponseBody404OneOf2Message = GetByronTransactionResponseBody404OneOf2{getByronTransactionResponseBody404OneOf2Message = getByronTransactionResponseBody404OneOf2Message}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.404.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody404Variants =
   GetByronTransactionResponseBody404Variant1 GetByronTransactionResponseBody404OneOf1
  | GetByronTransactionResponseBody404Variant2 GetByronTransactionResponseBody404OneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody404Variants
    where toJSON (GetByronTransactionResponseBody404Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (GetByronTransactionResponseBody404Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody404Variants
    where parseJSON val = case (GetByronTransactionResponseBody404Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((GetByronTransactionResponseBody404Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions\/{transactionId}.GET.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data GetByronTransactionResponseBody406 = GetByronTransactionResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  getByronTransactionResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronTransactionResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronTransactionResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronTransactionResponseBody406" (\obj -> GHC.Base.pure GetByronTransactionResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetByronTransactionResponseBody406' with all required fields.
mkGetByronTransactionResponseBody406 :: Data.Text.Internal.Text -- ^ 'getByronTransactionResponseBody406Message'
  -> GetByronTransactionResponseBody406
mkGetByronTransactionResponseBody406 getByronTransactionResponseBody406Message = GetByronTransactionResponseBody406{getByronTransactionResponseBody406Message = getByronTransactionResponseBody406Message}
-- | > GET /byron-wallets/{walletId}/transactions/{transactionId}
-- 
-- The same as 'getByronTransaction' but accepts an explicit configuration.
getByronTransactionWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> GetByronTransactionParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response GetByronTransactionResponse) -- ^ Monadic computation which returns the result of the operation
getByronTransactionWithConfiguration config
                                     parameters = GHC.Base.fmap (\response_4 -> GHC.Base.fmap (Data.Either.either GetByronTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetByronTransactionResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                   GetByronTransactionResponseBody200)
                                                                                                                                                                                                | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> GetByronTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                   GetByronTransactionResponseBody404Variants)
                                                                                                                                                                                                | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> GetByronTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                   GetByronTransactionResponseBody406)
                                                                                                                                                                                                | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_4) response_4) (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronTransactionParametersPathWalletId parameters))) GHC.Base.<> ("/transactions/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronTransactionParametersPathTransactionId parameters))) GHC.Base.<> "")))) GHC.Base.mempty)
-- | > GET /byron-wallets/{walletId}/transactions/{transactionId}
-- 
-- The same as 'getByronTransaction' but returns the raw 'Data.ByteString.ByteString'.
getByronTransactionRaw :: forall m . Wallet.Common.MonadHTTP m => GetByronTransactionParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
getByronTransactionRaw parameters = GHC.Base.id (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronTransactionParametersPathWalletId parameters))) GHC.Base.<> ("/transactions/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronTransactionParametersPathTransactionId parameters))) GHC.Base.<> "")))) GHC.Base.mempty)
-- | > GET /byron-wallets/{walletId}/transactions/{transactionId}
-- 
-- The same as 'getByronTransaction' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
getByronTransactionWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> GetByronTransactionParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
getByronTransactionWithConfigurationRaw config
                                        parameters = GHC.Base.id (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronTransactionParametersPathWalletId parameters))) GHC.Base.<> ("/transactions/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (getByronTransactionParametersPathTransactionId parameters))) GHC.Base.<> "")))) GHC.Base.mempty)
