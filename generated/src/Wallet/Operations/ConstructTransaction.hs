-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation constructTransaction
module Wallet.Operations.ConstructTransaction where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /wallets/{walletId}/transactions-construct
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Create a transaction to be signed from the wallet.
constructTransaction :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> ConstructTransactionRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response ConstructTransactionResponse) -- ^ Monadic computation which returns the result of the operation
constructTransaction walletId
                     body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either ConstructTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> ConstructTransactionResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               ConstructTransactionResponseBody202)
                                                                                                                                                                           | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> ConstructTransactionResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               ConstructTransactionResponseBody400Variants)
                                                                                                                                                                           | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> ConstructTransactionResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               ConstructTransactionResponseBody403Variants)
                                                                                                                                                                           | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> ConstructTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               ConstructTransactionResponseBody404)
                                                                                                                                                                           | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ConstructTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               ConstructTransactionResponseBody406)
                                                                                                                                                                           | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> ConstructTransactionResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               ConstructTransactionResponseBody415)
                                                                                                                                                                           | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-construct")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema@ in the specification.
-- 
-- At least one field needs to be chosen
data ConstructTransactionRequestBody = ConstructTransactionRequestBody {
  -- | delegations: \<p>status: \<strong>stable\<\/strong>\<\/p>
  -- 
  -- A list of staking actions (joining, rejoining or leaving from stake pools).
  -- Using \'0H\' stake key index is supported at this moment. This will change with
  -- multi-account support.
  -- Only one delegation action can be used.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  constructTransactionRequestBodyDelegations :: (GHC.Maybe.Maybe ([ConstructTransactionRequestBodyDelegationsVariants]))
  -- | encoding: Encoding of transaction CBOR returned in response (base64 by default).
  , constructTransactionRequestBodyEncoding :: (GHC.Maybe.Maybe ConstructTransactionRequestBodyEncoding)
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  , constructTransactionRequestBodyMetadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | mint_burn: An entry for each unique asset to be minted and\/or burned,
  -- containing helpful information.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , constructTransactionRequestBodyMint_burn :: (GHC.Maybe.Maybe ([ConstructTransactionRequestBodyMint_burn]))
  -- | payments: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , constructTransactionRequestBodyPayments :: (GHC.Maybe.Maybe ([ConstructTransactionRequestBodyPayments]))
  -- | validity_interval: Specify only invalid_before or invalid_hereafter or both.
  -- 
  -- Please note that, if not set, the default values are:
  --   - \`\"invalid_before\": {\"quantity\":0, \"unit\":\"slot\"}\`
  --   - \`\"invalid_hereafter\":{\"quantity\":7200, \"unit\":\"second\"}\`
  -- 
  -- Which translates to 2h transaction TTL.
  , constructTransactionRequestBodyValidity_interval :: (GHC.Maybe.Maybe ConstructTransactionRequestBodyValidity_interval)
  -- | withdrawal: When provided, instruments the server to automatically withdraw rewards from the source wallet when they are deemed
  -- sufficient (i.e. they contribute to the balance for at least as much as they cost).
  -- 
  -- As a consequence, the resulting transaction may or may not have a withdrawal object. Summarizing:
  -- 
  -- withdrawal field | reward balance | result
  -- ---              | ---            | ---
  -- \`null\`           | too small      | ✓ no withdrawals generated
  -- \`null\`           | big enough     | ✓ no withdrawals generated
  -- \`\"self\"\`         | too small      | ✓ no withdrawals generated
  -- \`\"self\"\`         | big enough     | ✓ withdrawal generated
  , constructTransactionRequestBodyWithdrawal :: (GHC.Maybe.Maybe ConstructTransactionRequestBodyWithdrawal)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("delegations" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyDelegations obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("encoding" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyEncoding obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyMetadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint_burn" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyMint_burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("payments" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyPayments obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyValidity_interval obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawal" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyWithdrawal obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("delegations" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyDelegations obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("encoding" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyEncoding obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyMetadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint_burn" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyMint_burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("payments" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyPayments obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyValidity_interval obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawal" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyWithdrawal obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBody" (\obj -> ((((((GHC.Base.pure ConstructTransactionRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "delegations")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "encoding")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mint_burn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "payments")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "validity_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "withdrawal"))
-- | Create a new 'ConstructTransactionRequestBody' with all required fields.
mkConstructTransactionRequestBody :: ConstructTransactionRequestBody
mkConstructTransactionRequestBody = ConstructTransactionRequestBody{constructTransactionRequestBodyDelegations = GHC.Maybe.Nothing,
                                                                    constructTransactionRequestBodyEncoding = GHC.Maybe.Nothing,
                                                                    constructTransactionRequestBodyMetadata = GHC.Maybe.Nothing,
                                                                    constructTransactionRequestBodyMint_burn = GHC.Maybe.Nothing,
                                                                    constructTransactionRequestBodyPayments = GHC.Maybe.Nothing,
                                                                    constructTransactionRequestBodyValidity_interval = GHC.Maybe.Nothing,
                                                                    constructTransactionRequestBodyWithdrawal = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.delegations.items.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyDelegationsOneOf1 = ConstructTransactionRequestBodyDelegationsOneOf1 {
  -- | join
  constructTransactionRequestBodyDelegationsOneOf1Join :: ConstructTransactionRequestBodyDelegationsOneOf1Join
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyDelegationsOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["join" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyDelegationsOneOf1Join obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["join" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyDelegationsOneOf1Join obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyDelegationsOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyDelegationsOneOf1" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyDelegationsOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "join"))
-- | Create a new 'ConstructTransactionRequestBodyDelegationsOneOf1' with all required fields.
mkConstructTransactionRequestBodyDelegationsOneOf1 :: ConstructTransactionRequestBodyDelegationsOneOf1Join -- ^ 'constructTransactionRequestBodyDelegationsOneOf1Join'
  -> ConstructTransactionRequestBodyDelegationsOneOf1
mkConstructTransactionRequestBodyDelegationsOneOf1 constructTransactionRequestBodyDelegationsOneOf1Join = ConstructTransactionRequestBodyDelegationsOneOf1{constructTransactionRequestBodyDelegationsOneOf1Join = constructTransactionRequestBodyDelegationsOneOf1Join}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.delegations.items.oneOf.properties.join@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyDelegationsOneOf1Join = ConstructTransactionRequestBodyDelegationsOneOf1Join {
  -- | pool: A unique identifier for the pool.
  constructTransactionRequestBodyDelegationsOneOf1JoinPool :: Data.Text.Internal.Text
  -- | stake_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , constructTransactionRequestBodyDelegationsOneOf1JoinStake_key_index :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyDelegationsOneOf1Join
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyDelegationsOneOf1JoinPool obj] : ["stake_key_index" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyDelegationsOneOf1JoinStake_key_index obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyDelegationsOneOf1JoinPool obj] : ["stake_key_index" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyDelegationsOneOf1JoinStake_key_index obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyDelegationsOneOf1Join
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyDelegationsOneOf1Join" (\obj -> (GHC.Base.pure ConstructTransactionRequestBodyDelegationsOneOf1Join GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_key_index"))
-- | Create a new 'ConstructTransactionRequestBodyDelegationsOneOf1Join' with all required fields.
mkConstructTransactionRequestBodyDelegationsOneOf1Join :: Data.Text.Internal.Text -- ^ 'constructTransactionRequestBodyDelegationsOneOf1JoinPool'
  -> Data.Text.Internal.Text -- ^ 'constructTransactionRequestBodyDelegationsOneOf1JoinStake_key_index'
  -> ConstructTransactionRequestBodyDelegationsOneOf1Join
mkConstructTransactionRequestBodyDelegationsOneOf1Join constructTransactionRequestBodyDelegationsOneOf1JoinPool constructTransactionRequestBodyDelegationsOneOf1JoinStake_key_index = ConstructTransactionRequestBodyDelegationsOneOf1Join{constructTransactionRequestBodyDelegationsOneOf1JoinPool = constructTransactionRequestBodyDelegationsOneOf1JoinPool,
                                                                                                                                                                                                                                           constructTransactionRequestBodyDelegationsOneOf1JoinStake_key_index = constructTransactionRequestBodyDelegationsOneOf1JoinStake_key_index}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.delegations.items.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyDelegationsOneOf2 = ConstructTransactionRequestBodyDelegationsOneOf2 {
  -- | quit
  constructTransactionRequestBodyDelegationsOneOf2Quit :: ConstructTransactionRequestBodyDelegationsOneOf2Quit
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyDelegationsOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quit" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyDelegationsOneOf2Quit obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quit" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyDelegationsOneOf2Quit obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyDelegationsOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyDelegationsOneOf2" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyDelegationsOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quit"))
-- | Create a new 'ConstructTransactionRequestBodyDelegationsOneOf2' with all required fields.
mkConstructTransactionRequestBodyDelegationsOneOf2 :: ConstructTransactionRequestBodyDelegationsOneOf2Quit -- ^ 'constructTransactionRequestBodyDelegationsOneOf2Quit'
  -> ConstructTransactionRequestBodyDelegationsOneOf2
mkConstructTransactionRequestBodyDelegationsOneOf2 constructTransactionRequestBodyDelegationsOneOf2Quit = ConstructTransactionRequestBodyDelegationsOneOf2{constructTransactionRequestBodyDelegationsOneOf2Quit = constructTransactionRequestBodyDelegationsOneOf2Quit}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.delegations.items.oneOf.properties.quit@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyDelegationsOneOf2Quit = ConstructTransactionRequestBodyDelegationsOneOf2Quit {
  -- | stake_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  constructTransactionRequestBodyDelegationsOneOf2QuitStake_key_index :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyDelegationsOneOf2Quit
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["stake_key_index" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyDelegationsOneOf2QuitStake_key_index obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["stake_key_index" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyDelegationsOneOf2QuitStake_key_index obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyDelegationsOneOf2Quit
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyDelegationsOneOf2Quit" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyDelegationsOneOf2Quit GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_key_index"))
-- | Create a new 'ConstructTransactionRequestBodyDelegationsOneOf2Quit' with all required fields.
mkConstructTransactionRequestBodyDelegationsOneOf2Quit :: Data.Text.Internal.Text -- ^ 'constructTransactionRequestBodyDelegationsOneOf2QuitStake_key_index'
  -> ConstructTransactionRequestBodyDelegationsOneOf2Quit
mkConstructTransactionRequestBodyDelegationsOneOf2Quit constructTransactionRequestBodyDelegationsOneOf2QuitStake_key_index = ConstructTransactionRequestBodyDelegationsOneOf2Quit{constructTransactionRequestBodyDelegationsOneOf2QuitStake_key_index = constructTransactionRequestBodyDelegationsOneOf2QuitStake_key_index}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.delegations.items.oneOf@ in the specification.
-- 
-- A delegation action for a given stake key denoted by its soft index.
-- Pool id is only required for \"join\".
-- Stake key index are required for both actions.
data ConstructTransactionRequestBodyDelegationsVariants =
   ConstructTransactionRequestBodyDelegationsVariant1 ConstructTransactionRequestBodyDelegationsOneOf1
  | ConstructTransactionRequestBodyDelegationsVariant2 ConstructTransactionRequestBodyDelegationsOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyDelegationsVariants
    where toJSON (ConstructTransactionRequestBodyDelegationsVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionRequestBodyDelegationsVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyDelegationsVariants
    where parseJSON val = case (ConstructTransactionRequestBodyDelegationsVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionRequestBodyDelegationsVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.encoding@ in the specification.
-- 
-- Encoding of transaction CBOR returned in response (base64 by default).
data ConstructTransactionRequestBodyEncoding =
   ConstructTransactionRequestBodyEncodingOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ConstructTransactionRequestBodyEncodingTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ConstructTransactionRequestBodyEncodingEnumBase16 -- ^ Represents the JSON value @"base16"@
  | ConstructTransactionRequestBodyEncodingEnumBase64 -- ^ Represents the JSON value @"base64"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyEncoding
    where toJSON (ConstructTransactionRequestBodyEncodingOther val) = val
          toJSON (ConstructTransactionRequestBodyEncodingTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ConstructTransactionRequestBodyEncodingEnumBase16) = "base16"
          toJSON (ConstructTransactionRequestBodyEncodingEnumBase64) = "base64"
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyEncoding
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "base16" -> ConstructTransactionRequestBodyEncodingEnumBase16
                                            | val GHC.Classes.== "base64" -> ConstructTransactionRequestBodyEncodingEnumBase64
                                            | GHC.Base.otherwise -> ConstructTransactionRequestBodyEncodingOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyMint_burn = ConstructTransactionRequestBodyMint_burn {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  constructTransactionRequestBodyMint_burnAsset_name :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | operation
  , constructTransactionRequestBodyMint_burnOperation :: ConstructTransactionRequestBodyMint_burnOperationVariants
  -- | policy_script_template
  , constructTransactionRequestBodyMint_burnPolicy_script_template :: ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyMint_burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("asset_name" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyMint_burnAsset_name obj) : ["operation" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnOperation obj] : ["policy_script_template" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_template obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("asset_name" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyMint_burnAsset_name obj) : ["operation" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnOperation obj] : ["policy_script_template" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_template obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyMint_burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyMint_burn" (\obj -> ((GHC.Base.pure ConstructTransactionRequestBodyMint_burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "operation")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script_template"))
-- | Create a new 'ConstructTransactionRequestBodyMint_burn' with all required fields.
mkConstructTransactionRequestBodyMint_burn :: ConstructTransactionRequestBodyMint_burnOperationVariants -- ^ 'constructTransactionRequestBodyMint_burnOperation'
  -> ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariants -- ^ 'constructTransactionRequestBodyMint_burnPolicy_script_template'
  -> ConstructTransactionRequestBodyMint_burn
mkConstructTransactionRequestBodyMint_burn constructTransactionRequestBodyMint_burnOperation constructTransactionRequestBodyMint_burnPolicy_script_template = ConstructTransactionRequestBodyMint_burn{constructTransactionRequestBodyMint_burnAsset_name = GHC.Maybe.Nothing,
                                                                                                                                                                                                       constructTransactionRequestBodyMint_burnOperation = constructTransactionRequestBodyMint_burnOperation,
                                                                                                                                                                                                       constructTransactionRequestBodyMint_burnPolicy_script_template = constructTransactionRequestBodyMint_burnPolicy_script_template}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.operation.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyMint_burnOperationOneOf1 = ConstructTransactionRequestBodyMint_burnOperationOneOf1 {
  -- | mint
  constructTransactionRequestBodyMint_burnOperationOneOf1Mint :: (GHC.Maybe.Maybe ConstructTransactionRequestBodyMint_burnOperationOneOf1Mint)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyMint_burnOperationOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyMint_burnOperationOneOf1Mint obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyMint_burnOperationOneOf1Mint obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyMint_burnOperationOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyMint_burnOperationOneOf1" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyMint_burnOperationOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mint"))
-- | Create a new 'ConstructTransactionRequestBodyMint_burnOperationOneOf1' with all required fields.
mkConstructTransactionRequestBodyMint_burnOperationOneOf1 :: ConstructTransactionRequestBodyMint_burnOperationOneOf1
mkConstructTransactionRequestBodyMint_burnOperationOneOf1 = ConstructTransactionRequestBodyMint_burnOperationOneOf1{constructTransactionRequestBodyMint_burnOperationOneOf1Mint = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.operation.oneOf.properties.mint@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyMint_burnOperationOneOf1Mint = ConstructTransactionRequestBodyMint_burnOperationOneOf1Mint {
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionRequestBodyMint_burnOperationOneOf1MintQuantity :: GHC.Types.Int
  -- | receiving_address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  , constructTransactionRequestBodyMint_burnOperationOneOf1MintReceiving_address :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyMint_burnOperationOneOf1Mint
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnOperationOneOf1MintQuantity obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("receiving_address" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyMint_burnOperationOneOf1MintReceiving_address obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnOperationOneOf1MintQuantity obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("receiving_address" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyMint_burnOperationOneOf1MintReceiving_address obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyMint_burnOperationOneOf1Mint
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyMint_burnOperationOneOf1Mint" (\obj -> (GHC.Base.pure ConstructTransactionRequestBodyMint_burnOperationOneOf1Mint GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "receiving_address"))
-- | Create a new 'ConstructTransactionRequestBodyMint_burnOperationOneOf1Mint' with all required fields.
mkConstructTransactionRequestBodyMint_burnOperationOneOf1Mint :: GHC.Types.Int -- ^ 'constructTransactionRequestBodyMint_burnOperationOneOf1MintQuantity'
  -> ConstructTransactionRequestBodyMint_burnOperationOneOf1Mint
mkConstructTransactionRequestBodyMint_burnOperationOneOf1Mint constructTransactionRequestBodyMint_burnOperationOneOf1MintQuantity = ConstructTransactionRequestBodyMint_burnOperationOneOf1Mint{constructTransactionRequestBodyMint_burnOperationOneOf1MintQuantity = constructTransactionRequestBodyMint_burnOperationOneOf1MintQuantity,
                                                                                                                                                                                                constructTransactionRequestBodyMint_burnOperationOneOf1MintReceiving_address = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.operation.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyMint_burnOperationOneOf2 = ConstructTransactionRequestBodyMint_burnOperationOneOf2 {
  -- | burn
  constructTransactionRequestBodyMint_burnOperationOneOf2Burn :: (GHC.Maybe.Maybe ConstructTransactionRequestBodyMint_burnOperationOneOf2Burn)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyMint_burnOperationOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyMint_burnOperationOneOf2Burn obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyMint_burnOperationOneOf2Burn obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyMint_burnOperationOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyMint_burnOperationOneOf2" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyMint_burnOperationOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "burn"))
-- | Create a new 'ConstructTransactionRequestBodyMint_burnOperationOneOf2' with all required fields.
mkConstructTransactionRequestBodyMint_burnOperationOneOf2 :: ConstructTransactionRequestBodyMint_burnOperationOneOf2
mkConstructTransactionRequestBodyMint_burnOperationOneOf2 = ConstructTransactionRequestBodyMint_burnOperationOneOf2{constructTransactionRequestBodyMint_burnOperationOneOf2Burn = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.operation.oneOf.properties.burn@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyMint_burnOperationOneOf2Burn = ConstructTransactionRequestBodyMint_burnOperationOneOf2Burn {
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionRequestBodyMint_burnOperationOneOf2BurnQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyMint_burnOperationOneOf2Burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnOperationOneOf2BurnQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnOperationOneOf2BurnQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyMint_burnOperationOneOf2Burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyMint_burnOperationOneOf2Burn" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyMint_burnOperationOneOf2Burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionRequestBodyMint_burnOperationOneOf2Burn' with all required fields.
mkConstructTransactionRequestBodyMint_burnOperationOneOf2Burn :: GHC.Types.Int -- ^ 'constructTransactionRequestBodyMint_burnOperationOneOf2BurnQuantity'
  -> ConstructTransactionRequestBodyMint_burnOperationOneOf2Burn
mkConstructTransactionRequestBodyMint_burnOperationOneOf2Burn constructTransactionRequestBodyMint_burnOperationOneOf2BurnQuantity = ConstructTransactionRequestBodyMint_burnOperationOneOf2Burn{constructTransactionRequestBodyMint_burnOperationOneOf2BurnQuantity = constructTransactionRequestBodyMint_burnOperationOneOf2BurnQuantity}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.operation.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyMint_burnOperationVariants =
   ConstructTransactionRequestBodyMint_burnOperationVariant1 ConstructTransactionRequestBodyMint_burnOperationOneOf1
  | ConstructTransactionRequestBodyMint_burnOperationVariant2 ConstructTransactionRequestBodyMint_burnOperationOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyMint_burnOperationVariants
    where toJSON (ConstructTransactionRequestBodyMint_burnOperationVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionRequestBodyMint_burnOperationVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyMint_burnOperationVariants
    where parseJSON val = case (ConstructTransactionRequestBodyMint_burnOperationVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionRequestBodyMint_burnOperationVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2 = ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list cosigners\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2All :: ([ScriptTemplateValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2' with all required fields.
mkConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2 :: [ScriptTemplateValue] -- ^ 'constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2All'
  -> ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2
mkConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2 constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2All = ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2{constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2All = constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2All}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3 = ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list cosigners\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3Any :: ([ScriptTemplateValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3' with all required fields.
mkConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3 :: [ScriptTemplateValue] -- ^ 'constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3Any'
  -> ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3
mkConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3 constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3Any = ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3{constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3Any = constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3Any}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4 = ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list cosigners\' verification keys are expected to make the script valid.
  constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some :: ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4' with all required fields.
mkConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4 :: ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some -- ^ 'constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some'
  -> ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4
mkConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4 constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some = ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4{constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some = constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.policy_script_template.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list cosigners\' verification keys are expected to make the script valid.
data ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some = ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeFrom :: ([ScriptTemplateValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some" (\obj -> (GHC.Base.pure ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some' with all required fields.
mkConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some :: GHC.Types.Int -- ^ 'constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeAt_least'
  -> [ScriptTemplateValue] -- ^ 'constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeFrom'
  -> ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some
mkConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeAt_least constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeFrom = ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4Some{constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeAt_least = constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                    constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeFrom = constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5 = ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5' with all required fields.
mkConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5 :: GHC.Types.Int -- ^ 'constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5Active_from'
  -> ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5
mkConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5 constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5Active_from = ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5{constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5Active_from = constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5Active_from}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6 = ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6' with all required fields.
mkConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6 :: GHC.Types.Int -- ^ 'constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6Active_until'
  -> ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6
mkConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6 constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6Active_until = ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6{constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6Active_until = constructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.mint_burn.items.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariants =
   ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant1 Data.Text.Internal.Text
  | ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant2 ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf2
  | ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant3 ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf3
  | ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant4 ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf4
  | ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant5 ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf5
  | ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant6 ConstructTransactionRequestBodyMint_burnPolicy_script_templateOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariants
    where toJSON (ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariants
    where parseJSON val = case (ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionRequestBodyMint_burnPolicy_script_templateVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.payments.items@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyPayments = ConstructTransactionRequestBodyPayments {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  constructTransactionRequestBodyPaymentsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructTransactionRequestBodyPaymentsAmount :: ConstructTransactionRequestBodyPaymentsAmount
  -- | assets: A flat list of assets (possibly empty).
  , constructTransactionRequestBodyPaymentsAssets :: (GHC.Maybe.Maybe ([ConstructTransactionRequestBodyPaymentsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyPayments
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyPaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyPaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyPaymentsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyPaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyPaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyPaymentsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyPayments
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyPayments" (\obj -> ((GHC.Base.pure ConstructTransactionRequestBodyPayments GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'ConstructTransactionRequestBodyPayments' with all required fields.
mkConstructTransactionRequestBodyPayments :: Data.Text.Internal.Text -- ^ 'constructTransactionRequestBodyPaymentsAddress'
  -> ConstructTransactionRequestBodyPaymentsAmount -- ^ 'constructTransactionRequestBodyPaymentsAmount'
  -> ConstructTransactionRequestBodyPayments
mkConstructTransactionRequestBodyPayments constructTransactionRequestBodyPaymentsAddress constructTransactionRequestBodyPaymentsAmount = ConstructTransactionRequestBodyPayments{constructTransactionRequestBodyPaymentsAddress = constructTransactionRequestBodyPaymentsAddress,
                                                                                                                                                                                 constructTransactionRequestBodyPaymentsAmount = constructTransactionRequestBodyPaymentsAmount,
                                                                                                                                                                                 constructTransactionRequestBodyPaymentsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.payments.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructTransactionRequestBodyPaymentsAmount = ConstructTransactionRequestBodyPaymentsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionRequestBodyPaymentsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyPaymentsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyPaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyPaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyPaymentsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyPaymentsAmount" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyPaymentsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionRequestBodyPaymentsAmount' with all required fields.
mkConstructTransactionRequestBodyPaymentsAmount :: GHC.Types.Int -- ^ 'constructTransactionRequestBodyPaymentsAmountQuantity'
  -> ConstructTransactionRequestBodyPaymentsAmount
mkConstructTransactionRequestBodyPaymentsAmount constructTransactionRequestBodyPaymentsAmountQuantity = ConstructTransactionRequestBodyPaymentsAmount{constructTransactionRequestBodyPaymentsAmountQuantity = constructTransactionRequestBodyPaymentsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.payments.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ConstructTransactionRequestBodyPaymentsAssets = ConstructTransactionRequestBodyPaymentsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  constructTransactionRequestBodyPaymentsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , constructTransactionRequestBodyPaymentsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , constructTransactionRequestBodyPaymentsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyPaymentsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyPaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyPaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyPaymentsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyPaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyPaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyPaymentsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyPaymentsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyPaymentsAssets" (\obj -> ((GHC.Base.pure ConstructTransactionRequestBodyPaymentsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionRequestBodyPaymentsAssets' with all required fields.
mkConstructTransactionRequestBodyPaymentsAssets :: Data.Text.Internal.Text -- ^ 'constructTransactionRequestBodyPaymentsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'constructTransactionRequestBodyPaymentsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'constructTransactionRequestBodyPaymentsAssetsQuantity'
  -> ConstructTransactionRequestBodyPaymentsAssets
mkConstructTransactionRequestBodyPaymentsAssets constructTransactionRequestBodyPaymentsAssetsAsset_name constructTransactionRequestBodyPaymentsAssetsPolicy_id constructTransactionRequestBodyPaymentsAssetsQuantity = ConstructTransactionRequestBodyPaymentsAssets{constructTransactionRequestBodyPaymentsAssetsAsset_name = constructTransactionRequestBodyPaymentsAssetsAsset_name,
                                                                                                                                                                                                                                                                     constructTransactionRequestBodyPaymentsAssetsPolicy_id = constructTransactionRequestBodyPaymentsAssetsPolicy_id,
                                                                                                                                                                                                                                                                     constructTransactionRequestBodyPaymentsAssetsQuantity = constructTransactionRequestBodyPaymentsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.validity_interval@ in the specification.
-- 
-- Specify only invalid_before or invalid_hereafter or both.
-- 
-- Please note that, if not set, the default values are:
--   - \`\"invalid_before\": {\"quantity\":0, \"unit\":\"slot\"}\`
--   - \`\"invalid_hereafter\":{\"quantity\":7200, \"unit\":\"second\"}\`
-- 
-- Which translates to 2h transaction TTL.
data ConstructTransactionRequestBodyValidity_interval = ConstructTransactionRequestBodyValidity_interval {
  -- | invalid_before
  constructTransactionRequestBodyValidity_intervalInvalid_before :: (GHC.Maybe.Maybe ConstructTransactionRequestBodyValidity_intervalInvalid_beforeVariants)
  -- | invalid_hereafter
  , constructTransactionRequestBodyValidity_intervalInvalid_hereafter :: (GHC.Maybe.Maybe ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterVariants)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyValidity_interval
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invalid_before" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyValidity_intervalInvalid_before obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invalid_hereafter" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyValidity_intervalInvalid_hereafter obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invalid_before" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyValidity_intervalInvalid_before obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("invalid_hereafter" Data.Aeson.Types.ToJSON..=)) (constructTransactionRequestBodyValidity_intervalInvalid_hereafter obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyValidity_interval
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyValidity_interval" (\obj -> (GHC.Base.pure ConstructTransactionRequestBodyValidity_interval GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "invalid_before")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "invalid_hereafter"))
-- | Create a new 'ConstructTransactionRequestBodyValidity_interval' with all required fields.
mkConstructTransactionRequestBodyValidity_interval :: ConstructTransactionRequestBodyValidity_interval
mkConstructTransactionRequestBodyValidity_interval = ConstructTransactionRequestBodyValidity_interval{constructTransactionRequestBodyValidity_intervalInvalid_before = GHC.Maybe.Nothing,
                                                                                                      constructTransactionRequestBodyValidity_intervalInvalid_hereafter = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.validity_interval.properties.invalid_before.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1 = ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1 {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1Quantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "second"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "second"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1' with all required fields.
mkConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1 :: GHC.Types.Double -- ^ 'constructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1Quantity'
  -> ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1
mkConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1 constructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1Quantity = ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1{constructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1Quantity = constructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1Quantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.validity_interval.properties.invalid_before.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2 = ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2 {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2Quantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2' with all required fields.
mkConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2 :: GHC.Types.Int -- ^ 'constructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2Quantity'
  -> ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2
mkConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2 constructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2Quantity = ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2{constructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2Quantity = constructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2Quantity}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.validity_interval.properties.invalid_before.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyValidity_intervalInvalid_beforeVariants =
   ConstructTransactionRequestBodyValidity_intervalInvalid_beforeVariant1 ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf1
  | ConstructTransactionRequestBodyValidity_intervalInvalid_beforeVariant2 ConstructTransactionRequestBodyValidity_intervalInvalid_beforeOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyValidity_intervalInvalid_beforeVariants
    where toJSON (ConstructTransactionRequestBodyValidity_intervalInvalid_beforeVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionRequestBodyValidity_intervalInvalid_beforeVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyValidity_intervalInvalid_beforeVariants
    where parseJSON val = case (ConstructTransactionRequestBodyValidity_intervalInvalid_beforeVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionRequestBodyValidity_intervalInvalid_beforeVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.validity_interval.properties.invalid_hereafter.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1 = ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1 {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1Quantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "second"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "second"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1' with all required fields.
mkConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1 :: GHC.Types.Double -- ^ 'constructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1Quantity'
  -> ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1
mkConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1 constructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1Quantity = ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1{constructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1Quantity = constructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1Quantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.validity_interval.properties.invalid_hereafter.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2 = ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2 {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2Quantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2Quantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2" (\obj -> GHC.Base.pure ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2' with all required fields.
mkConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2 :: GHC.Types.Int -- ^ 'constructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2Quantity'
  -> ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2
mkConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2 constructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2Quantity = ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2{constructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2Quantity = constructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2Quantity}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.validity_interval.properties.invalid_hereafter.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterVariants =
   ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterVariant1 ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf1
  | ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterVariant2 ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterVariants
    where toJSON (ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterVariants
    where parseJSON val = case (ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionRequestBodyValidity_intervalInvalid_hereafterVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.requestBody.content.application\/json.schema.properties.withdrawal@ in the specification.
-- 
-- When provided, instruments the server to automatically withdraw rewards from the source wallet when they are deemed
-- sufficient (i.e. they contribute to the balance for at least as much as they cost).
-- 
-- As a consequence, the resulting transaction may or may not have a withdrawal object. Summarizing:
-- 
-- withdrawal field | reward balance | result
-- ---              | ---            | ---
-- \`null\`           | too small      | ✓ no withdrawals generated
-- \`null\`           | big enough     | ✓ no withdrawals generated
-- \`\"self\"\`         | too small      | ✓ no withdrawals generated
-- \`\"self\"\`         | big enough     | ✓ withdrawal generated
data ConstructTransactionRequestBodyWithdrawal =
   ConstructTransactionRequestBodyWithdrawalOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ConstructTransactionRequestBodyWithdrawalTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ConstructTransactionRequestBodyWithdrawalEnumSelf -- ^ Represents the JSON value @"self"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionRequestBodyWithdrawal
    where toJSON (ConstructTransactionRequestBodyWithdrawalOther val) = val
          toJSON (ConstructTransactionRequestBodyWithdrawalTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ConstructTransactionRequestBodyWithdrawalEnumSelf) = "self"
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionRequestBodyWithdrawal
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "self" -> ConstructTransactionRequestBodyWithdrawalEnumSelf
                                            | GHC.Base.otherwise -> ConstructTransactionRequestBodyWithdrawalOther val)
-- | Represents a response of the operation 'constructTransaction'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'ConstructTransactionResponseError' is used.
data ConstructTransactionResponse =
   ConstructTransactionResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | ConstructTransactionResponse202 ConstructTransactionResponseBody202 -- ^ Accepted
  | ConstructTransactionResponse400 ConstructTransactionResponseBody400Variants -- ^ Bad Request
  | ConstructTransactionResponse403 ConstructTransactionResponseBody403Variants -- ^ Forbidden
  | ConstructTransactionResponse404 ConstructTransactionResponseBody404 -- ^ Not Found
  | ConstructTransactionResponse406 ConstructTransactionResponseBody406 -- ^ Not Acceptable
  | ConstructTransactionResponse415 ConstructTransactionResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody202 = ConstructTransactionResponseBody202 {
  -- | coin_selection
  constructTransactionResponseBody202Coin_selection :: ConstructTransactionResponseBody202Coin_selection
  -- | fee: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructTransactionResponseBody202Fee :: ConstructTransactionResponseBody202Fee
  -- | transaction: The CBOR-encoded transaction, represented in either hex or base64 encoding.
  -- This always includes the transaction body and the witness set, even if the
  -- latter is empty.
  , constructTransactionResponseBody202Transaction :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["coin_selection" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selection obj] : ["fee" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Fee obj] : ["transaction" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Transaction obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["coin_selection" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selection obj] : ["fee" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Fee obj] : ["transaction" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Transaction obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202" (\obj -> ((GHC.Base.pure ConstructTransactionResponseBody202 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "coin_selection")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fee")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "transaction"))
-- | Create a new 'ConstructTransactionResponseBody202' with all required fields.
mkConstructTransactionResponseBody202 :: ConstructTransactionResponseBody202Coin_selection -- ^ 'constructTransactionResponseBody202Coin_selection'
  -> ConstructTransactionResponseBody202Fee -- ^ 'constructTransactionResponseBody202Fee'
  -> Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody202Transaction'
  -> ConstructTransactionResponseBody202
mkConstructTransactionResponseBody202 constructTransactionResponseBody202Coin_selection constructTransactionResponseBody202Fee constructTransactionResponseBody202Transaction = ConstructTransactionResponseBody202{constructTransactionResponseBody202Coin_selection = constructTransactionResponseBody202Coin_selection,
                                                                                                                                                                                                                    constructTransactionResponseBody202Fee = constructTransactionResponseBody202Fee,
                                                                                                                                                                                                                    constructTransactionResponseBody202Transaction = constructTransactionResponseBody202Transaction}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody202Coin_selection = ConstructTransactionResponseBody202Coin_selection {
  -- | certificates
  constructTransactionResponseBody202Coin_selectionCertificates :: (GHC.Maybe.Maybe ([ConstructTransactionResponseBody202Coin_selectionCertificates]))
  -- | change: A list of transaction change outputs.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , constructTransactionResponseBody202Coin_selectionChange :: ([ConstructTransactionResponseBody202Coin_selectionChange])
  -- | collateral: A list of transaction inputs used for collateral
  , constructTransactionResponseBody202Coin_selectionCollateral :: (GHC.Maybe.Maybe ([ConstructTransactionResponseBody202Coin_selectionCollateral]))
  -- | deposits_returned: A list of deposits associated with a transaction.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , constructTransactionResponseBody202Coin_selectionDeposits_returned :: (GHC.Maybe.Maybe ([ConstructTransactionResponseBody202Coin_selectionDeposits_returned]))
  -- | deposits_taken: A list of deposits associated with a transaction.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , constructTransactionResponseBody202Coin_selectionDeposits_taken :: (GHC.Maybe.Maybe ([ConstructTransactionResponseBody202Coin_selectionDeposits_taken]))
  -- | inputs: A list of transaction inputs
  , constructTransactionResponseBody202Coin_selectionInputs :: ([ConstructTransactionResponseBody202Coin_selectionInputs])
  -- | metadata: Transaction metadata, serialized according to the expected on-chain binary format, base64-encoded.
  , constructTransactionResponseBody202Coin_selectionMetadata :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , constructTransactionResponseBody202Coin_selectionOutputs :: ([ConstructTransactionResponseBody202Coin_selectionOutputs])
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , constructTransactionResponseBody202Coin_selectionWithdrawals :: (GHC.Maybe.Maybe ([ConstructTransactionResponseBody202Coin_selectionWithdrawals]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selection
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionCertificates obj) : ["change" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChange obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionCollateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_returned" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionDeposits_returned obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_taken" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionDeposits_taken obj) : ["inputs" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionMetadata obj) : ["outputs" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionOutputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawals" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionWithdrawals obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionCertificates obj) : ["change" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChange obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionCollateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_returned" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionDeposits_returned obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_taken" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionDeposits_taken obj) : ["inputs" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionMetadata obj) : ["outputs" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionOutputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawals" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionWithdrawals obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selection
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selection" (\obj -> ((((((((GHC.Base.pure ConstructTransactionResponseBody202Coin_selection GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "change")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "deposits_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "deposits_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "withdrawals"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selection' with all required fields.
mkConstructTransactionResponseBody202Coin_selection :: [ConstructTransactionResponseBody202Coin_selectionChange] -- ^ 'constructTransactionResponseBody202Coin_selectionChange'
  -> [ConstructTransactionResponseBody202Coin_selectionInputs] -- ^ 'constructTransactionResponseBody202Coin_selectionInputs'
  -> [ConstructTransactionResponseBody202Coin_selectionOutputs] -- ^ 'constructTransactionResponseBody202Coin_selectionOutputs'
  -> ConstructTransactionResponseBody202Coin_selection
mkConstructTransactionResponseBody202Coin_selection constructTransactionResponseBody202Coin_selectionChange constructTransactionResponseBody202Coin_selectionInputs constructTransactionResponseBody202Coin_selectionOutputs = ConstructTransactionResponseBody202Coin_selection{constructTransactionResponseBody202Coin_selectionCertificates = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                 constructTransactionResponseBody202Coin_selectionChange = constructTransactionResponseBody202Coin_selectionChange,
                                                                                                                                                                                                                                                                                 constructTransactionResponseBody202Coin_selectionCollateral = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                 constructTransactionResponseBody202Coin_selectionDeposits_returned = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                 constructTransactionResponseBody202Coin_selectionDeposits_taken = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                 constructTransactionResponseBody202Coin_selectionInputs = constructTransactionResponseBody202Coin_selectionInputs,
                                                                                                                                                                                                                                                                                 constructTransactionResponseBody202Coin_selectionMetadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                 constructTransactionResponseBody202Coin_selectionOutputs = constructTransactionResponseBody202Coin_selectionOutputs,
                                                                                                                                                                                                                                                                                 constructTransactionResponseBody202Coin_selectionWithdrawals = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.certificates.items@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data ConstructTransactionResponseBody202Coin_selectionCertificates = ConstructTransactionResponseBody202Coin_selectionCertificates {
  -- | certificate_type
  constructTransactionResponseBody202Coin_selectionCertificatesCertificate_type :: ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_type
  -- | pool: A unique identifier for the pool.
  , constructTransactionResponseBody202Coin_selectionCertificatesPool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , constructTransactionResponseBody202Coin_selectionCertificatesReward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionCertificates
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCertificatesCertificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionCertificatesPool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCertificatesReward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCertificatesCertificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionCertificatesPool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCertificatesReward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionCertificates
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionCertificates" (\obj -> ((GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionCertificates GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionCertificates' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionCertificates :: ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_type -- ^ 'constructTransactionResponseBody202Coin_selectionCertificatesCertificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'constructTransactionResponseBody202Coin_selectionCertificatesReward_account_path'
  -> ConstructTransactionResponseBody202Coin_selectionCertificates
mkConstructTransactionResponseBody202Coin_selectionCertificates constructTransactionResponseBody202Coin_selectionCertificatesCertificate_type constructTransactionResponseBody202Coin_selectionCertificatesReward_account_path = ConstructTransactionResponseBody202Coin_selectionCertificates{constructTransactionResponseBody202Coin_selectionCertificatesCertificate_type = constructTransactionResponseBody202Coin_selectionCertificatesCertificate_type,
                                                                                                                                                                                                                                                                                               constructTransactionResponseBody202Coin_selectionCertificatesPool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                               constructTransactionResponseBody202Coin_selectionCertificatesReward_account_path = constructTransactionResponseBody202Coin_selectionCertificatesReward_account_path}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.certificates.items.properties.certificate_type@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_type =
   ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_type
    where toJSON (ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_typeOther val) = val
          toJSON (ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumJoin_pool) = "join_pool"
          toJSON (ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> ConstructTransactionResponseBody202Coin_selectionCertificatesCertificate_typeOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.change.items@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody202Coin_selectionChange = ConstructTransactionResponseBody202Coin_selectionChange {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  constructTransactionResponseBody202Coin_selectionChangeAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructTransactionResponseBody202Coin_selectionChangeAmount :: ConstructTransactionResponseBody202Coin_selectionChangeAmount
  -- | assets: A flat list of assets (possibly empty).
  , constructTransactionResponseBody202Coin_selectionChangeAssets :: (GHC.Maybe.Maybe ([ConstructTransactionResponseBody202Coin_selectionChangeAssets]))
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , constructTransactionResponseBody202Coin_selectionChangeDerivation_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionChange
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChangeAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChangeAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionChangeAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChangeDerivation_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChangeAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChangeAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionChangeAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChangeDerivation_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionChange
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionChange" (\obj -> (((GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionChange GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionChange' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionChange :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody202Coin_selectionChangeAddress'
  -> ConstructTransactionResponseBody202Coin_selectionChangeAmount -- ^ 'constructTransactionResponseBody202Coin_selectionChangeAmount'
  -> [Data.Text.Internal.Text] -- ^ 'constructTransactionResponseBody202Coin_selectionChangeDerivation_path'
  -> ConstructTransactionResponseBody202Coin_selectionChange
mkConstructTransactionResponseBody202Coin_selectionChange constructTransactionResponseBody202Coin_selectionChangeAddress constructTransactionResponseBody202Coin_selectionChangeAmount constructTransactionResponseBody202Coin_selectionChangeDerivation_path = ConstructTransactionResponseBody202Coin_selectionChange{constructTransactionResponseBody202Coin_selectionChangeAddress = constructTransactionResponseBody202Coin_selectionChangeAddress,
                                                                                                                                                                                                                                                                                                                        constructTransactionResponseBody202Coin_selectionChangeAmount = constructTransactionResponseBody202Coin_selectionChangeAmount,
                                                                                                                                                                                                                                                                                                                        constructTransactionResponseBody202Coin_selectionChangeAssets = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                        constructTransactionResponseBody202Coin_selectionChangeDerivation_path = constructTransactionResponseBody202Coin_selectionChangeDerivation_path}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.change.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructTransactionResponseBody202Coin_selectionChangeAmount = ConstructTransactionResponseBody202Coin_selectionChangeAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionResponseBody202Coin_selectionChangeAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionChangeAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChangeAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChangeAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionChangeAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionChangeAmount" (\obj -> GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionChangeAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionChangeAmount' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionChangeAmount :: GHC.Types.Int -- ^ 'constructTransactionResponseBody202Coin_selectionChangeAmountQuantity'
  -> ConstructTransactionResponseBody202Coin_selectionChangeAmount
mkConstructTransactionResponseBody202Coin_selectionChangeAmount constructTransactionResponseBody202Coin_selectionChangeAmountQuantity = ConstructTransactionResponseBody202Coin_selectionChangeAmount{constructTransactionResponseBody202Coin_selectionChangeAmountQuantity = constructTransactionResponseBody202Coin_selectionChangeAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.change.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ConstructTransactionResponseBody202Coin_selectionChangeAssets = ConstructTransactionResponseBody202Coin_selectionChangeAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  constructTransactionResponseBody202Coin_selectionChangeAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , constructTransactionResponseBody202Coin_selectionChangeAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , constructTransactionResponseBody202Coin_selectionChangeAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionChangeAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChangeAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChangeAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChangeAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChangeAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChangeAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionChangeAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionChangeAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionChangeAssets" (\obj -> ((GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionChangeAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionChangeAssets' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionChangeAssets :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody202Coin_selectionChangeAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody202Coin_selectionChangeAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'constructTransactionResponseBody202Coin_selectionChangeAssetsQuantity'
  -> ConstructTransactionResponseBody202Coin_selectionChangeAssets
mkConstructTransactionResponseBody202Coin_selectionChangeAssets constructTransactionResponseBody202Coin_selectionChangeAssetsAsset_name constructTransactionResponseBody202Coin_selectionChangeAssetsPolicy_id constructTransactionResponseBody202Coin_selectionChangeAssetsQuantity = ConstructTransactionResponseBody202Coin_selectionChangeAssets{constructTransactionResponseBody202Coin_selectionChangeAssetsAsset_name = constructTransactionResponseBody202Coin_selectionChangeAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                                     constructTransactionResponseBody202Coin_selectionChangeAssetsPolicy_id = constructTransactionResponseBody202Coin_selectionChangeAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                                     constructTransactionResponseBody202Coin_selectionChangeAssetsQuantity = constructTransactionResponseBody202Coin_selectionChangeAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.collateral.items@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody202Coin_selectionCollateral = ConstructTransactionResponseBody202Coin_selectionCollateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  constructTransactionResponseBody202Coin_selectionCollateralAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructTransactionResponseBody202Coin_selectionCollateralAmount :: ConstructTransactionResponseBody202Coin_selectionCollateralAmount
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , constructTransactionResponseBody202Coin_selectionCollateralDerivation_path :: ([Data.Text.Internal.Text])
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , constructTransactionResponseBody202Coin_selectionCollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , constructTransactionResponseBody202Coin_selectionCollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionCollateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCollateralAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCollateralAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCollateralDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCollateralAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCollateralAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCollateralDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionCollateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionCollateral" (\obj -> ((((GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionCollateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionCollateral' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionCollateral :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody202Coin_selectionCollateralAddress'
  -> ConstructTransactionResponseBody202Coin_selectionCollateralAmount -- ^ 'constructTransactionResponseBody202Coin_selectionCollateralAmount'
  -> [Data.Text.Internal.Text] -- ^ 'constructTransactionResponseBody202Coin_selectionCollateralDerivation_path'
  -> Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody202Coin_selectionCollateralId'
  -> GHC.Types.Int -- ^ 'constructTransactionResponseBody202Coin_selectionCollateralIndex'
  -> ConstructTransactionResponseBody202Coin_selectionCollateral
mkConstructTransactionResponseBody202Coin_selectionCollateral constructTransactionResponseBody202Coin_selectionCollateralAddress constructTransactionResponseBody202Coin_selectionCollateralAmount constructTransactionResponseBody202Coin_selectionCollateralDerivation_path constructTransactionResponseBody202Coin_selectionCollateralId constructTransactionResponseBody202Coin_selectionCollateralIndex = ConstructTransactionResponseBody202Coin_selectionCollateral{constructTransactionResponseBody202Coin_selectionCollateralAddress = constructTransactionResponseBody202Coin_selectionCollateralAddress,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           constructTransactionResponseBody202Coin_selectionCollateralAmount = constructTransactionResponseBody202Coin_selectionCollateralAmount,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           constructTransactionResponseBody202Coin_selectionCollateralDerivation_path = constructTransactionResponseBody202Coin_selectionCollateralDerivation_path,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           constructTransactionResponseBody202Coin_selectionCollateralId = constructTransactionResponseBody202Coin_selectionCollateralId,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                           constructTransactionResponseBody202Coin_selectionCollateralIndex = constructTransactionResponseBody202Coin_selectionCollateralIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructTransactionResponseBody202Coin_selectionCollateralAmount = ConstructTransactionResponseBody202Coin_selectionCollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionResponseBody202Coin_selectionCollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionCollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionCollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionCollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionCollateralAmount" (\obj -> GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionCollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionCollateralAmount' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionCollateralAmount :: GHC.Types.Int -- ^ 'constructTransactionResponseBody202Coin_selectionCollateralAmountQuantity'
  -> ConstructTransactionResponseBody202Coin_selectionCollateralAmount
mkConstructTransactionResponseBody202Coin_selectionCollateralAmount constructTransactionResponseBody202Coin_selectionCollateralAmountQuantity = ConstructTransactionResponseBody202Coin_selectionCollateralAmount{constructTransactionResponseBody202Coin_selectionCollateralAmountQuantity = constructTransactionResponseBody202Coin_selectionCollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.deposits_returned.items@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructTransactionResponseBody202Coin_selectionDeposits_returned = ConstructTransactionResponseBody202Coin_selectionDeposits_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionResponseBody202Coin_selectionDeposits_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionDeposits_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionDeposits_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionDeposits_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionDeposits_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionDeposits_returned" (\obj -> GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionDeposits_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionDeposits_returned' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionDeposits_returned :: GHC.Types.Int -- ^ 'constructTransactionResponseBody202Coin_selectionDeposits_returnedQuantity'
  -> ConstructTransactionResponseBody202Coin_selectionDeposits_returned
mkConstructTransactionResponseBody202Coin_selectionDeposits_returned constructTransactionResponseBody202Coin_selectionDeposits_returnedQuantity = ConstructTransactionResponseBody202Coin_selectionDeposits_returned{constructTransactionResponseBody202Coin_selectionDeposits_returnedQuantity = constructTransactionResponseBody202Coin_selectionDeposits_returnedQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.deposits_taken.items@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructTransactionResponseBody202Coin_selectionDeposits_taken = ConstructTransactionResponseBody202Coin_selectionDeposits_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionResponseBody202Coin_selectionDeposits_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionDeposits_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionDeposits_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionDeposits_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionDeposits_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionDeposits_taken" (\obj -> GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionDeposits_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionDeposits_taken' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionDeposits_taken :: GHC.Types.Int -- ^ 'constructTransactionResponseBody202Coin_selectionDeposits_takenQuantity'
  -> ConstructTransactionResponseBody202Coin_selectionDeposits_taken
mkConstructTransactionResponseBody202Coin_selectionDeposits_taken constructTransactionResponseBody202Coin_selectionDeposits_takenQuantity = ConstructTransactionResponseBody202Coin_selectionDeposits_taken{constructTransactionResponseBody202Coin_selectionDeposits_takenQuantity = constructTransactionResponseBody202Coin_selectionDeposits_takenQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.inputs.items@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody202Coin_selectionInputs = ConstructTransactionResponseBody202Coin_selectionInputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  constructTransactionResponseBody202Coin_selectionInputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructTransactionResponseBody202Coin_selectionInputsAmount :: ConstructTransactionResponseBody202Coin_selectionInputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , constructTransactionResponseBody202Coin_selectionInputsAssets :: (GHC.Maybe.Maybe ([ConstructTransactionResponseBody202Coin_selectionInputsAssets]))
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , constructTransactionResponseBody202Coin_selectionInputsDerivation_path :: ([Data.Text.Internal.Text])
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , constructTransactionResponseBody202Coin_selectionInputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , constructTransactionResponseBody202Coin_selectionInputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionInputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionInputsAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsId obj] : ["index" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionInputsAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsId obj] : ["index" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionInputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionInputs" (\obj -> (((((GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionInputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionInputs' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionInputs :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody202Coin_selectionInputsAddress'
  -> ConstructTransactionResponseBody202Coin_selectionInputsAmount -- ^ 'constructTransactionResponseBody202Coin_selectionInputsAmount'
  -> [Data.Text.Internal.Text] -- ^ 'constructTransactionResponseBody202Coin_selectionInputsDerivation_path'
  -> Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody202Coin_selectionInputsId'
  -> GHC.Types.Int -- ^ 'constructTransactionResponseBody202Coin_selectionInputsIndex'
  -> ConstructTransactionResponseBody202Coin_selectionInputs
mkConstructTransactionResponseBody202Coin_selectionInputs constructTransactionResponseBody202Coin_selectionInputsAddress constructTransactionResponseBody202Coin_selectionInputsAmount constructTransactionResponseBody202Coin_selectionInputsDerivation_path constructTransactionResponseBody202Coin_selectionInputsId constructTransactionResponseBody202Coin_selectionInputsIndex = ConstructTransactionResponseBody202Coin_selectionInputs{constructTransactionResponseBody202Coin_selectionInputsAddress = constructTransactionResponseBody202Coin_selectionInputsAddress,
                                                                                                                                                                                                                                                                                                                                                                                                                                               constructTransactionResponseBody202Coin_selectionInputsAmount = constructTransactionResponseBody202Coin_selectionInputsAmount,
                                                                                                                                                                                                                                                                                                                                                                                                                                               constructTransactionResponseBody202Coin_selectionInputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               constructTransactionResponseBody202Coin_selectionInputsDerivation_path = constructTransactionResponseBody202Coin_selectionInputsDerivation_path,
                                                                                                                                                                                                                                                                                                                                                                                                                                               constructTransactionResponseBody202Coin_selectionInputsId = constructTransactionResponseBody202Coin_selectionInputsId,
                                                                                                                                                                                                                                                                                                                                                                                                                                               constructTransactionResponseBody202Coin_selectionInputsIndex = constructTransactionResponseBody202Coin_selectionInputsIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructTransactionResponseBody202Coin_selectionInputsAmount = ConstructTransactionResponseBody202Coin_selectionInputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionResponseBody202Coin_selectionInputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionInputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionInputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionInputsAmount" (\obj -> GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionInputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionInputsAmount' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionInputsAmount :: GHC.Types.Int -- ^ 'constructTransactionResponseBody202Coin_selectionInputsAmountQuantity'
  -> ConstructTransactionResponseBody202Coin_selectionInputsAmount
mkConstructTransactionResponseBody202Coin_selectionInputsAmount constructTransactionResponseBody202Coin_selectionInputsAmountQuantity = ConstructTransactionResponseBody202Coin_selectionInputsAmount{constructTransactionResponseBody202Coin_selectionInputsAmountQuantity = constructTransactionResponseBody202Coin_selectionInputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ConstructTransactionResponseBody202Coin_selectionInputsAssets = ConstructTransactionResponseBody202Coin_selectionInputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  constructTransactionResponseBody202Coin_selectionInputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , constructTransactionResponseBody202Coin_selectionInputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , constructTransactionResponseBody202Coin_selectionInputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionInputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionInputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionInputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionInputsAssets" (\obj -> ((GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionInputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionInputsAssets' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionInputsAssets :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody202Coin_selectionInputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody202Coin_selectionInputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'constructTransactionResponseBody202Coin_selectionInputsAssetsQuantity'
  -> ConstructTransactionResponseBody202Coin_selectionInputsAssets
mkConstructTransactionResponseBody202Coin_selectionInputsAssets constructTransactionResponseBody202Coin_selectionInputsAssetsAsset_name constructTransactionResponseBody202Coin_selectionInputsAssetsPolicy_id constructTransactionResponseBody202Coin_selectionInputsAssetsQuantity = ConstructTransactionResponseBody202Coin_selectionInputsAssets{constructTransactionResponseBody202Coin_selectionInputsAssetsAsset_name = constructTransactionResponseBody202Coin_selectionInputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                                     constructTransactionResponseBody202Coin_selectionInputsAssetsPolicy_id = constructTransactionResponseBody202Coin_selectionInputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                                     constructTransactionResponseBody202Coin_selectionInputsAssetsQuantity = constructTransactionResponseBody202Coin_selectionInputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.outputs.items@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody202Coin_selectionOutputs = ConstructTransactionResponseBody202Coin_selectionOutputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  constructTransactionResponseBody202Coin_selectionOutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructTransactionResponseBody202Coin_selectionOutputsAmount :: ConstructTransactionResponseBody202Coin_selectionOutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , constructTransactionResponseBody202Coin_selectionOutputsAssets :: (GHC.Maybe.Maybe ([ConstructTransactionResponseBody202Coin_selectionOutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionOutputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionOutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionOutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionOutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionOutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionOutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody202Coin_selectionOutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionOutputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionOutputs" (\obj -> ((GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionOutputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionOutputs' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionOutputs :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody202Coin_selectionOutputsAddress'
  -> ConstructTransactionResponseBody202Coin_selectionOutputsAmount -- ^ 'constructTransactionResponseBody202Coin_selectionOutputsAmount'
  -> ConstructTransactionResponseBody202Coin_selectionOutputs
mkConstructTransactionResponseBody202Coin_selectionOutputs constructTransactionResponseBody202Coin_selectionOutputsAddress constructTransactionResponseBody202Coin_selectionOutputsAmount = ConstructTransactionResponseBody202Coin_selectionOutputs{constructTransactionResponseBody202Coin_selectionOutputsAddress = constructTransactionResponseBody202Coin_selectionOutputsAddress,
                                                                                                                                                                                                                                                     constructTransactionResponseBody202Coin_selectionOutputsAmount = constructTransactionResponseBody202Coin_selectionOutputsAmount,
                                                                                                                                                                                                                                                     constructTransactionResponseBody202Coin_selectionOutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructTransactionResponseBody202Coin_selectionOutputsAmount = ConstructTransactionResponseBody202Coin_selectionOutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionResponseBody202Coin_selectionOutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionOutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionOutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionOutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionOutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionOutputsAmount" (\obj -> GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionOutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionOutputsAmount' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionOutputsAmount :: GHC.Types.Int -- ^ 'constructTransactionResponseBody202Coin_selectionOutputsAmountQuantity'
  -> ConstructTransactionResponseBody202Coin_selectionOutputsAmount
mkConstructTransactionResponseBody202Coin_selectionOutputsAmount constructTransactionResponseBody202Coin_selectionOutputsAmountQuantity = ConstructTransactionResponseBody202Coin_selectionOutputsAmount{constructTransactionResponseBody202Coin_selectionOutputsAmountQuantity = constructTransactionResponseBody202Coin_selectionOutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ConstructTransactionResponseBody202Coin_selectionOutputsAssets = ConstructTransactionResponseBody202Coin_selectionOutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  constructTransactionResponseBody202Coin_selectionOutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , constructTransactionResponseBody202Coin_selectionOutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , constructTransactionResponseBody202Coin_selectionOutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionOutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionOutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionOutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionOutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionOutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionOutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionOutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionOutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionOutputsAssets" (\obj -> ((GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionOutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionOutputsAssets' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionOutputsAssets :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody202Coin_selectionOutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody202Coin_selectionOutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'constructTransactionResponseBody202Coin_selectionOutputsAssetsQuantity'
  -> ConstructTransactionResponseBody202Coin_selectionOutputsAssets
mkConstructTransactionResponseBody202Coin_selectionOutputsAssets constructTransactionResponseBody202Coin_selectionOutputsAssetsAsset_name constructTransactionResponseBody202Coin_selectionOutputsAssetsPolicy_id constructTransactionResponseBody202Coin_selectionOutputsAssetsQuantity = ConstructTransactionResponseBody202Coin_selectionOutputsAssets{constructTransactionResponseBody202Coin_selectionOutputsAssetsAsset_name = constructTransactionResponseBody202Coin_selectionOutputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                                          constructTransactionResponseBody202Coin_selectionOutputsAssetsPolicy_id = constructTransactionResponseBody202Coin_selectionOutputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                                          constructTransactionResponseBody202Coin_selectionOutputsAssetsQuantity = constructTransactionResponseBody202Coin_selectionOutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.withdrawals.items@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody202Coin_selectionWithdrawals = ConstructTransactionResponseBody202Coin_selectionWithdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  constructTransactionResponseBody202Coin_selectionWithdrawalsAmount :: ConstructTransactionResponseBody202Coin_selectionWithdrawalsAmount
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , constructTransactionResponseBody202Coin_selectionWithdrawalsDerivation_path :: ([Data.Text.Internal.Text])
  -- | stake_address
  , constructTransactionResponseBody202Coin_selectionWithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionWithdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionWithdrawalsAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionWithdrawalsDerivation_path obj] : ["stake_address" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionWithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionWithdrawalsAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionWithdrawalsDerivation_path obj] : ["stake_address" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionWithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionWithdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionWithdrawals" (\obj -> ((GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionWithdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionWithdrawals' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionWithdrawals :: ConstructTransactionResponseBody202Coin_selectionWithdrawalsAmount -- ^ 'constructTransactionResponseBody202Coin_selectionWithdrawalsAmount'
  -> [Data.Text.Internal.Text] -- ^ 'constructTransactionResponseBody202Coin_selectionWithdrawalsDerivation_path'
  -> Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody202Coin_selectionWithdrawalsStake_address'
  -> ConstructTransactionResponseBody202Coin_selectionWithdrawals
mkConstructTransactionResponseBody202Coin_selectionWithdrawals constructTransactionResponseBody202Coin_selectionWithdrawalsAmount constructTransactionResponseBody202Coin_selectionWithdrawalsDerivation_path constructTransactionResponseBody202Coin_selectionWithdrawalsStake_address = ConstructTransactionResponseBody202Coin_selectionWithdrawals{constructTransactionResponseBody202Coin_selectionWithdrawalsAmount = constructTransactionResponseBody202Coin_selectionWithdrawalsAmount,
                                                                                                                                                                                                                                                                                                                                                       constructTransactionResponseBody202Coin_selectionWithdrawalsDerivation_path = constructTransactionResponseBody202Coin_selectionWithdrawalsDerivation_path,
                                                                                                                                                                                                                                                                                                                                                       constructTransactionResponseBody202Coin_selectionWithdrawalsStake_address = constructTransactionResponseBody202Coin_selectionWithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.coin_selection.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructTransactionResponseBody202Coin_selectionWithdrawalsAmount = ConstructTransactionResponseBody202Coin_selectionWithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionResponseBody202Coin_selectionWithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Coin_selectionWithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionWithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202Coin_selectionWithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Coin_selectionWithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Coin_selectionWithdrawalsAmount" (\obj -> GHC.Base.pure ConstructTransactionResponseBody202Coin_selectionWithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionResponseBody202Coin_selectionWithdrawalsAmount' with all required fields.
mkConstructTransactionResponseBody202Coin_selectionWithdrawalsAmount :: GHC.Types.Int -- ^ 'constructTransactionResponseBody202Coin_selectionWithdrawalsAmountQuantity'
  -> ConstructTransactionResponseBody202Coin_selectionWithdrawalsAmount
mkConstructTransactionResponseBody202Coin_selectionWithdrawalsAmount constructTransactionResponseBody202Coin_selectionWithdrawalsAmountQuantity = ConstructTransactionResponseBody202Coin_selectionWithdrawalsAmount{constructTransactionResponseBody202Coin_selectionWithdrawalsAmountQuantity = constructTransactionResponseBody202Coin_selectionWithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.202.content.application\/json.schema.properties.fee@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructTransactionResponseBody202Fee = ConstructTransactionResponseBody202Fee {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionResponseBody202FeeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody202Fee
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody202Fee
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody202Fee" (\obj -> GHC.Base.pure ConstructTransactionResponseBody202Fee GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionResponseBody202Fee' with all required fields.
mkConstructTransactionResponseBody202Fee :: GHC.Types.Int -- ^ 'constructTransactionResponseBody202FeeQuantity'
  -> ConstructTransactionResponseBody202Fee
mkConstructTransactionResponseBody202Fee constructTransactionResponseBody202FeeQuantity = ConstructTransactionResponseBody202Fee{constructTransactionResponseBody202FeeQuantity = constructTransactionResponseBody202FeeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody400OneOf1 = ConstructTransactionResponseBody400OneOf1 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  constructTransactionResponseBody400OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody400OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody400OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody400OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody400OneOf1" (\obj -> GHC.Base.pure ConstructTransactionResponseBody400OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody400OneOf1' with all required fields.
mkConstructTransactionResponseBody400OneOf1 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody400OneOf1Message'
  -> ConstructTransactionResponseBody400OneOf1
mkConstructTransactionResponseBody400OneOf1 constructTransactionResponseBody400OneOf1Message = ConstructTransactionResponseBody400OneOf1{constructTransactionResponseBody400OneOf1Message = constructTransactionResponseBody400OneOf1Message}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.400.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody400Variants =
   ConstructTransactionResponseBody400Variant1 ConstructTransactionResponseBody400OneOf1
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody400Variants
    where toJSON (ConstructTransactionResponseBody400Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody400Variants
    where parseJSON val = case (ConstructTransactionResponseBody400Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched" of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf1 = ConstructTransactionResponseBody403OneOf1 {
  -- | message: May occur when trying to perform an operation not supported by this type of wallet.
  constructTransactionResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf1" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf1' with all required fields.
mkConstructTransactionResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf1Message'
  -> ConstructTransactionResponseBody403OneOf1
mkConstructTransactionResponseBody403OneOf1 constructTransactionResponseBody403OneOf1Message = ConstructTransactionResponseBody403OneOf1{constructTransactionResponseBody403OneOf1Message = constructTransactionResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf2 = ConstructTransactionResponseBody403OneOf2 {
  -- | message: May occur when submitting a withdrawal while another withdrawal is pending.
  constructTransactionResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf2" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf2' with all required fields.
mkConstructTransactionResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf2Message'
  -> ConstructTransactionResponseBody403OneOf2
mkConstructTransactionResponseBody403OneOf2 constructTransactionResponseBody403OneOf2Message = ConstructTransactionResponseBody403OneOf2{constructTransactionResponseBody403OneOf2Message = constructTransactionResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf3 = ConstructTransactionResponseBody403OneOf3 {
  -- | info
  constructTransactionResponseBody403OneOf3Info :: (GHC.Maybe.Maybe ConstructTransactionResponseBody403OneOf3Info)
  -- | message: Occurs when a requested output has a quantity of lovelace that is below the minimum required by the ledger.
  , constructTransactionResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody403OneOf3Info obj) : ["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (constructTransactionResponseBody403OneOf3Info obj) : ["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf3" (\obj -> (GHC.Base.pure ConstructTransactionResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "info")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf3' with all required fields.
mkConstructTransactionResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf3Message'
  -> ConstructTransactionResponseBody403OneOf3
mkConstructTransactionResponseBody403OneOf3 constructTransactionResponseBody403OneOf3Message = ConstructTransactionResponseBody403OneOf3{constructTransactionResponseBody403OneOf3Info = GHC.Maybe.Nothing,
                                                                                                                                         constructTransactionResponseBody403OneOf3Message = constructTransactionResponseBody403OneOf3Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf.properties.info@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf3Info = ConstructTransactionResponseBody403OneOf3Info {
  -- | tx_output_index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionResponseBody403OneOf3InfoTx_output_index :: GHC.Types.Int
  -- | tx_output_lovelace_required_minimum: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum :: ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
  -- | tx_output_lovelace_specified: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified :: ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf3Info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf3InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf3InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf3Info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf3Info" (\obj -> ((GHC.Base.pure ConstructTransactionResponseBody403OneOf3Info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_index")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_required_minimum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_specified"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf3Info' with all required fields.
mkConstructTransactionResponseBody403OneOf3Info :: GHC.Types.Int -- ^ 'constructTransactionResponseBody403OneOf3InfoTx_output_index'
  -> ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum -- ^ 'constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum'
  -> ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified -- ^ 'constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified'
  -> ConstructTransactionResponseBody403OneOf3Info
mkConstructTransactionResponseBody403OneOf3Info constructTransactionResponseBody403OneOf3InfoTx_output_index constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified = ConstructTransactionResponseBody403OneOf3Info{constructTransactionResponseBody403OneOf3InfoTx_output_index = constructTransactionResponseBody403OneOf3InfoTx_output_index,
                                                                                                                                                                                                                                                                                                                        constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum = constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum,
                                                                                                                                                                                                                                                                                                                        constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified = constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_required_minimum@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum = ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum' with all required fields.
mkConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum :: GHC.Types.Int -- ^ 'constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity'
  -> ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
mkConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity = ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum{constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity = constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_specified@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified = ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified' with all required fields.
mkConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified :: GHC.Types.Int -- ^ 'constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity'
  -> ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
mkConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity = ConstructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified{constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity = constructTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf4 = ConstructTransactionResponseBody403OneOf4 {
  -- | message: May occur when a transaction can\'t be balanced for fees.
  constructTransactionResponseBody403OneOf4Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf4" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf4' with all required fields.
mkConstructTransactionResponseBody403OneOf4 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf4Message'
  -> ConstructTransactionResponseBody403OneOf4
mkConstructTransactionResponseBody403OneOf4 constructTransactionResponseBody403OneOf4Message = ConstructTransactionResponseBody403OneOf4{constructTransactionResponseBody403OneOf4Message = constructTransactionResponseBody403OneOf4Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf5 = ConstructTransactionResponseBody403OneOf5 {
  -- | message: May occur when there\'s not enough money in the wallet to cover a requested payment.
  constructTransactionResponseBody403OneOf5Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf5" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf5' with all required fields.
mkConstructTransactionResponseBody403OneOf5 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf5Message'
  -> ConstructTransactionResponseBody403OneOf5
mkConstructTransactionResponseBody403OneOf5 constructTransactionResponseBody403OneOf5Message = ConstructTransactionResponseBody403OneOf5{constructTransactionResponseBody403OneOf5Message = constructTransactionResponseBody403OneOf5Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf6 = ConstructTransactionResponseBody403OneOf6 {
  -- | message: May occur when the total balance of pure ada UTxOs in the wallet is
  -- insufficient to cover the minimum collateral amount required for a
  -- transaction requiring collateral.
  constructTransactionResponseBody403OneOf6Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf6" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf6' with all required fields.
mkConstructTransactionResponseBody403OneOf6 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf6Message'
  -> ConstructTransactionResponseBody403OneOf6
mkConstructTransactionResponseBody403OneOf6 constructTransactionResponseBody403OneOf6Message = ConstructTransactionResponseBody403OneOf6{constructTransactionResponseBody403OneOf6Message = constructTransactionResponseBody403OneOf6Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf7 = ConstructTransactionResponseBody403OneOf7 {
  -- | message: May occur when the wallet can\'t cover for all requested outputs without making the transaction too large.
  constructTransactionResponseBody403OneOf7Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf7
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_is_too_big"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_is_too_big"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf7
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf7" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf7 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf7' with all required fields.
mkConstructTransactionResponseBody403OneOf7 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf7Message'
  -> ConstructTransactionResponseBody403OneOf7
mkConstructTransactionResponseBody403OneOf7 constructTransactionResponseBody403OneOf7Message = ConstructTransactionResponseBody403OneOf7{constructTransactionResponseBody403OneOf7Message = constructTransactionResponseBody403OneOf7Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf8 = ConstructTransactionResponseBody403OneOf8 {
  -- | message: Occurs when more than 1 delegation action is included in a transaction.
  constructTransactionResponseBody403OneOf8Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf8
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "created_multidelegation_transaction"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "created_multidelegation_transaction"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf8
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf8" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf8 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf8' with all required fields.
mkConstructTransactionResponseBody403OneOf8 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf8Message'
  -> ConstructTransactionResponseBody403OneOf8
mkConstructTransactionResponseBody403OneOf8 constructTransactionResponseBody403OneOf8Message = ConstructTransactionResponseBody403OneOf8{constructTransactionResponseBody403OneOf8Message = constructTransactionResponseBody403OneOf8Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf9 = ConstructTransactionResponseBody403OneOf9 {
  -- | message: Occurs when a delegation action does not use \'0H\' account.
  constructTransactionResponseBody403OneOf9Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf9
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "created_multiaccount_transaction"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "created_multiaccount_transaction"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf9
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf9" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf9 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf9' with all required fields.
mkConstructTransactionResponseBody403OneOf9 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf9Message'
  -> ConstructTransactionResponseBody403OneOf9
mkConstructTransactionResponseBody403OneOf9 constructTransactionResponseBody403OneOf9Message = ConstructTransactionResponseBody403OneOf9{constructTransactionResponseBody403OneOf9Message = constructTransactionResponseBody403OneOf9Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf10 = ConstructTransactionResponseBody403OneOf10 {
  -- | message: Occurs when a policy script template either does not pass validation
  -- or has more than one cosigner.
  constructTransactionResponseBody403OneOf10Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf10
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf10Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "created_wrong_policy_script_template"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf10Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "created_wrong_policy_script_template"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf10
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf10" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf10 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf10' with all required fields.
mkConstructTransactionResponseBody403OneOf10 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf10Message'
  -> ConstructTransactionResponseBody403OneOf10
mkConstructTransactionResponseBody403OneOf10 constructTransactionResponseBody403OneOf10Message = ConstructTransactionResponseBody403OneOf10{constructTransactionResponseBody403OneOf10Message = constructTransactionResponseBody403OneOf10Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf11 = ConstructTransactionResponseBody403OneOf11 {
  -- | message: Occurs when an asset name exceeds 32 bytes in length.
  constructTransactionResponseBody403OneOf11Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf11
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf11Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "asset_name_too_long"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf11Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "asset_name_too_long"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf11
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf11" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf11 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf11' with all required fields.
mkConstructTransactionResponseBody403OneOf11 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf11Message'
  -> ConstructTransactionResponseBody403OneOf11
mkConstructTransactionResponseBody403OneOf11 constructTransactionResponseBody403OneOf11Message = ConstructTransactionResponseBody403OneOf11{constructTransactionResponseBody403OneOf11Message = constructTransactionResponseBody403OneOf11Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf12 = ConstructTransactionResponseBody403OneOf12 {
  -- | message: Occurs when attempting to mint or burn an asset quantity that is not
  -- greater than zero or exceeds 9223372036854775807 (2^63 - 1).
  constructTransactionResponseBody403OneOf12Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf12
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf12Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "mint_or_burn_asset_quantity_out_of_bounds"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf12Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "mint_or_burn_asset_quantity_out_of_bounds"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf12
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf12" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf12 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf12' with all required fields.
mkConstructTransactionResponseBody403OneOf12 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf12Message'
  -> ConstructTransactionResponseBody403OneOf12
mkConstructTransactionResponseBody403OneOf12 constructTransactionResponseBody403OneOf12Message = ConstructTransactionResponseBody403OneOf12{constructTransactionResponseBody403OneOf12Message = constructTransactionResponseBody403OneOf12Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf13 = ConstructTransactionResponseBody403OneOf13 {
  -- | message: Occurs when attempting to create a transaction with invalid validity
  -- bounds. The \'invalid_before\' bound must precede the \'invalid_hereafter\'
  -- bound, and the given time values must not be negative.
  constructTransactionResponseBody403OneOf13Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf13
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf13Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_validity_bounds"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf13Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_validity_bounds"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf13
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf13" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf13 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf13' with all required fields.
mkConstructTransactionResponseBody403OneOf13 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf13Message'
  -> ConstructTransactionResponseBody403OneOf13
mkConstructTransactionResponseBody403OneOf13 constructTransactionResponseBody403OneOf13Message = ConstructTransactionResponseBody403OneOf13{constructTransactionResponseBody403OneOf13Message = constructTransactionResponseBody403OneOf13Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf14 = ConstructTransactionResponseBody403OneOf14 {
  -- | message: Occurs when attempting to create a transaction with a validity interval
  -- that is not a subinterval of an associated script\'s timelock interval.
  constructTransactionResponseBody403OneOf14Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf14
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf14Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "validity_interval_not_inside_script_timelock"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf14Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "validity_interval_not_inside_script_timelock"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf14
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf14" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf14 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf14' with all required fields.
mkConstructTransactionResponseBody403OneOf14 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf14Message'
  -> ConstructTransactionResponseBody403OneOf14
mkConstructTransactionResponseBody403OneOf14 constructTransactionResponseBody403OneOf14Message = ConstructTransactionResponseBody403OneOf14{constructTransactionResponseBody403OneOf14Message = constructTransactionResponseBody403OneOf14Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf15 = ConstructTransactionResponseBody403OneOf15 {
  -- | message: Occurs when attempting to create a transaction for an incomplete shared wallet.
  constructTransactionResponseBody403OneOf15Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf15
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf15Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "shared_wallet_incomplete"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf15Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "shared_wallet_incomplete"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf15
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf15" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf15 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf15' with all required fields.
mkConstructTransactionResponseBody403OneOf15 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf15Message'
  -> ConstructTransactionResponseBody403OneOf15
mkConstructTransactionResponseBody403OneOf15 constructTransactionResponseBody403OneOf15Message = ConstructTransactionResponseBody403OneOf15{constructTransactionResponseBody403OneOf15Message = constructTransactionResponseBody403OneOf15Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403OneOf16 = ConstructTransactionResponseBody403OneOf16 {
  -- | message: Occurs when attempting to create a delegation transaction for a shared wallet
  -- without a delegation script template.
  constructTransactionResponseBody403OneOf16Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403OneOf16
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf16Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "staking_invalid"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody403OneOf16Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "staking_invalid"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403OneOf16
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody403OneOf16" (\obj -> GHC.Base.pure ConstructTransactionResponseBody403OneOf16 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody403OneOf16' with all required fields.
mkConstructTransactionResponseBody403OneOf16 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody403OneOf16Message'
  -> ConstructTransactionResponseBody403OneOf16
mkConstructTransactionResponseBody403OneOf16 constructTransactionResponseBody403OneOf16Message = ConstructTransactionResponseBody403OneOf16{constructTransactionResponseBody403OneOf16Message = constructTransactionResponseBody403OneOf16Message}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody403Variants =
   ConstructTransactionResponseBody403Variant1 ConstructTransactionResponseBody403OneOf1
  | ConstructTransactionResponseBody403Variant2 ConstructTransactionResponseBody403OneOf2
  | ConstructTransactionResponseBody403Variant3 ConstructTransactionResponseBody403OneOf3
  | ConstructTransactionResponseBody403Variant4 ConstructTransactionResponseBody403OneOf4
  | ConstructTransactionResponseBody403Variant5 ConstructTransactionResponseBody403OneOf5
  | ConstructTransactionResponseBody403Variant6 ConstructTransactionResponseBody403OneOf6
  | ConstructTransactionResponseBody403Variant7 ConstructTransactionResponseBody403OneOf7
  | ConstructTransactionResponseBody403Variant8 ConstructTransactionResponseBody403OneOf8
  | ConstructTransactionResponseBody403Variant9 ConstructTransactionResponseBody403OneOf9
  | ConstructTransactionResponseBody403Variant10 ConstructTransactionResponseBody403OneOf10
  | ConstructTransactionResponseBody403Variant11 ConstructTransactionResponseBody403OneOf11
  | ConstructTransactionResponseBody403Variant12 ConstructTransactionResponseBody403OneOf12
  | ConstructTransactionResponseBody403Variant13 ConstructTransactionResponseBody403OneOf13
  | ConstructTransactionResponseBody403Variant14 ConstructTransactionResponseBody403OneOf14
  | ConstructTransactionResponseBody403Variant15 ConstructTransactionResponseBody403OneOf15
  | ConstructTransactionResponseBody403Variant16 ConstructTransactionResponseBody403OneOf16
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody403Variants
    where toJSON (ConstructTransactionResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionResponseBody403Variant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionResponseBody403Variant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionResponseBody403Variant6 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionResponseBody403Variant7 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionResponseBody403Variant8 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionResponseBody403Variant9 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionResponseBody403Variant10 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionResponseBody403Variant11 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionResponseBody403Variant12 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionResponseBody403Variant13 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionResponseBody403Variant14 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionResponseBody403Variant15 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ConstructTransactionResponseBody403Variant16 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody403Variants
    where parseJSON val = case (ConstructTransactionResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionResponseBody403Variant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionResponseBody403Variant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionResponseBody403Variant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionResponseBody403Variant7 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionResponseBody403Variant8 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionResponseBody403Variant9 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionResponseBody403Variant10 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionResponseBody403Variant11 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionResponseBody403Variant12 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionResponseBody403Variant13 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionResponseBody403Variant14 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionResponseBody403Variant15 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ConstructTransactionResponseBody403Variant16 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))))))))))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody404 = ConstructTransactionResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  constructTransactionResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody404" (\obj -> GHC.Base.pure ConstructTransactionResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody404' with all required fields.
mkConstructTransactionResponseBody404 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody404Message'
  -> ConstructTransactionResponseBody404
mkConstructTransactionResponseBody404 constructTransactionResponseBody404Message = ConstructTransactionResponseBody404{constructTransactionResponseBody404Message = constructTransactionResponseBody404Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody406 = ConstructTransactionResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  constructTransactionResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody406" (\obj -> GHC.Base.pure ConstructTransactionResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody406' with all required fields.
mkConstructTransactionResponseBody406 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody406Message'
  -> ConstructTransactionResponseBody406
mkConstructTransactionResponseBody406 constructTransactionResponseBody406Message = ConstructTransactionResponseBody406{constructTransactionResponseBody406Message = constructTransactionResponseBody406Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions-construct.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data ConstructTransactionResponseBody415 = ConstructTransactionResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  constructTransactionResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ConstructTransactionResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= constructTransactionResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ConstructTransactionResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ConstructTransactionResponseBody415" (\obj -> GHC.Base.pure ConstructTransactionResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ConstructTransactionResponseBody415' with all required fields.
mkConstructTransactionResponseBody415 :: Data.Text.Internal.Text -- ^ 'constructTransactionResponseBody415Message'
  -> ConstructTransactionResponseBody415
mkConstructTransactionResponseBody415 constructTransactionResponseBody415Message = ConstructTransactionResponseBody415{constructTransactionResponseBody415Message = constructTransactionResponseBody415Message}
-- | > POST /wallets/{walletId}/transactions-construct
-- 
-- The same as 'constructTransaction' but accepts an explicit configuration.
constructTransactionWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> ConstructTransactionRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response ConstructTransactionResponse) -- ^ Monadic computation which returns the result of the operation
constructTransactionWithConfiguration config
                                      walletId
                                      body = GHC.Base.fmap (\response_7 -> GHC.Base.fmap (Data.Either.either ConstructTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> ConstructTransactionResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                ConstructTransactionResponseBody202)
                                                                                                                                                                                            | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> ConstructTransactionResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                ConstructTransactionResponseBody400Variants)
                                                                                                                                                                                            | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> ConstructTransactionResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ConstructTransactionResponseBody403Variants)
                                                                                                                                                                                            | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> ConstructTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ConstructTransactionResponseBody404)
                                                                                                                                                                                            | (\status_12 -> Network.HTTP.Types.Status.statusCode status_12 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ConstructTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ConstructTransactionResponseBody406)
                                                                                                                                                                                            | (\status_13 -> Network.HTTP.Types.Status.statusCode status_13 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> ConstructTransactionResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                  ConstructTransactionResponseBody415)
                                                                                                                                                                                            | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_7) response_7) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-construct")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/transactions-construct
-- 
-- The same as 'constructTransaction' but returns the raw 'Data.ByteString.ByteString'.
constructTransactionRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> ConstructTransactionRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
constructTransactionRaw walletId
                        body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-construct")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/transactions-construct
-- 
-- The same as 'constructTransaction' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
constructTransactionWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> ConstructTransactionRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
constructTransactionWithConfigurationRaw config
                                         walletId
                                         body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions-construct")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
