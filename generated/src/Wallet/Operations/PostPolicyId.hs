-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation postPolicyId
module Wallet.Operations.PostPolicyId where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /wallets/{walletId}/policy-id
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Create policy id for the wallet and a given mint\/burn script.
postPolicyId :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostPolicyIdRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response PostPolicyIdResponse) -- ^ Monadic computation which returns the result of the operation
postPolicyId walletId
             body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PostPolicyIdResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> PostPolicyIdResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                       PostPolicyIdResponseBody202)
                                                                                                                                                           | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostPolicyIdResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                       PostPolicyIdResponseBody400)
                                                                                                                                                           | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> PostPolicyIdResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                       PostPolicyIdResponseBody403Variants)
                                                                                                                                                           | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostPolicyIdResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                       PostPolicyIdResponseBody406)
                                                                                                                                                           | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostPolicyIdResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                       PostPolicyIdResponseBody415)
                                                                                                                                                           | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/policy-id")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.requestBody.content.application\/json.schema@ in the specification.
-- 
-- 
data PostPolicyIdRequestBody = PostPolicyIdRequestBody {
  -- | policy_script_template
  postPolicyIdRequestBodyPolicy_script_template :: PostPolicyIdRequestBodyPolicy_script_templateVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["policy_script_template" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_template obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["policy_script_template" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_template obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPolicyIdRequestBody" (\obj -> GHC.Base.pure PostPolicyIdRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script_template"))
-- | Create a new 'PostPolicyIdRequestBody' with all required fields.
mkPostPolicyIdRequestBody :: PostPolicyIdRequestBodyPolicy_script_templateVariants -- ^ 'postPolicyIdRequestBodyPolicy_script_template'
  -> PostPolicyIdRequestBody
mkPostPolicyIdRequestBody postPolicyIdRequestBodyPolicy_script_template = PostPolicyIdRequestBody{postPolicyIdRequestBodyPolicy_script_template = postPolicyIdRequestBodyPolicy_script_template}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.requestBody.content.application\/json.schema.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data PostPolicyIdRequestBodyPolicy_script_templateOneOf2 = PostPolicyIdRequestBodyPolicy_script_templateOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list cosigners\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postPolicyIdRequestBodyPolicy_script_templateOneOf2All :: ([ScriptTemplateValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdRequestBodyPolicy_script_templateOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_templateOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_templateOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdRequestBodyPolicy_script_templateOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPolicyIdRequestBodyPolicy_script_templateOneOf2" (\obj -> GHC.Base.pure PostPolicyIdRequestBodyPolicy_script_templateOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'PostPolicyIdRequestBodyPolicy_script_templateOneOf2' with all required fields.
mkPostPolicyIdRequestBodyPolicy_script_templateOneOf2 :: [ScriptTemplateValue] -- ^ 'postPolicyIdRequestBodyPolicy_script_templateOneOf2All'
  -> PostPolicyIdRequestBodyPolicy_script_templateOneOf2
mkPostPolicyIdRequestBodyPolicy_script_templateOneOf2 postPolicyIdRequestBodyPolicy_script_templateOneOf2All = PostPolicyIdRequestBodyPolicy_script_templateOneOf2{postPolicyIdRequestBodyPolicy_script_templateOneOf2All = postPolicyIdRequestBodyPolicy_script_templateOneOf2All}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.requestBody.content.application\/json.schema.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data PostPolicyIdRequestBodyPolicy_script_templateOneOf3 = PostPolicyIdRequestBodyPolicy_script_templateOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list cosigners\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postPolicyIdRequestBodyPolicy_script_templateOneOf3Any :: ([ScriptTemplateValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdRequestBodyPolicy_script_templateOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_templateOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_templateOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdRequestBodyPolicy_script_templateOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPolicyIdRequestBodyPolicy_script_templateOneOf3" (\obj -> GHC.Base.pure PostPolicyIdRequestBodyPolicy_script_templateOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'PostPolicyIdRequestBodyPolicy_script_templateOneOf3' with all required fields.
mkPostPolicyIdRequestBodyPolicy_script_templateOneOf3 :: [ScriptTemplateValue] -- ^ 'postPolicyIdRequestBodyPolicy_script_templateOneOf3Any'
  -> PostPolicyIdRequestBodyPolicy_script_templateOneOf3
mkPostPolicyIdRequestBodyPolicy_script_templateOneOf3 postPolicyIdRequestBodyPolicy_script_templateOneOf3Any = PostPolicyIdRequestBodyPolicy_script_templateOneOf3{postPolicyIdRequestBodyPolicy_script_templateOneOf3Any = postPolicyIdRequestBodyPolicy_script_templateOneOf3Any}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.requestBody.content.application\/json.schema.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data PostPolicyIdRequestBodyPolicy_script_templateOneOf4 = PostPolicyIdRequestBodyPolicy_script_templateOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list cosigners\' verification keys are expected to make the script valid.
  postPolicyIdRequestBodyPolicy_script_templateOneOf4Some :: PostPolicyIdRequestBodyPolicy_script_templateOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdRequestBodyPolicy_script_templateOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_templateOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_templateOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdRequestBodyPolicy_script_templateOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPolicyIdRequestBodyPolicy_script_templateOneOf4" (\obj -> GHC.Base.pure PostPolicyIdRequestBodyPolicy_script_templateOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'PostPolicyIdRequestBodyPolicy_script_templateOneOf4' with all required fields.
mkPostPolicyIdRequestBodyPolicy_script_templateOneOf4 :: PostPolicyIdRequestBodyPolicy_script_templateOneOf4Some -- ^ 'postPolicyIdRequestBodyPolicy_script_templateOneOf4Some'
  -> PostPolicyIdRequestBodyPolicy_script_templateOneOf4
mkPostPolicyIdRequestBodyPolicy_script_templateOneOf4 postPolicyIdRequestBodyPolicy_script_templateOneOf4Some = PostPolicyIdRequestBodyPolicy_script_templateOneOf4{postPolicyIdRequestBodyPolicy_script_templateOneOf4Some = postPolicyIdRequestBodyPolicy_script_templateOneOf4Some}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.requestBody.content.application\/json.schema.properties.policy_script_template.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list cosigners\' verification keys are expected to make the script valid.
data PostPolicyIdRequestBodyPolicy_script_templateOneOf4Some = PostPolicyIdRequestBodyPolicy_script_templateOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  postPolicyIdRequestBodyPolicy_script_templateOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , postPolicyIdRequestBodyPolicy_script_templateOneOf4SomeFrom :: ([ScriptTemplateValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdRequestBodyPolicy_script_templateOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_templateOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_templateOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_templateOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_templateOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdRequestBodyPolicy_script_templateOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPolicyIdRequestBodyPolicy_script_templateOneOf4Some" (\obj -> (GHC.Base.pure PostPolicyIdRequestBodyPolicy_script_templateOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'PostPolicyIdRequestBodyPolicy_script_templateOneOf4Some' with all required fields.
mkPostPolicyIdRequestBodyPolicy_script_templateOneOf4Some :: GHC.Types.Int -- ^ 'postPolicyIdRequestBodyPolicy_script_templateOneOf4SomeAt_least'
  -> [ScriptTemplateValue] -- ^ 'postPolicyIdRequestBodyPolicy_script_templateOneOf4SomeFrom'
  -> PostPolicyIdRequestBodyPolicy_script_templateOneOf4Some
mkPostPolicyIdRequestBodyPolicy_script_templateOneOf4Some postPolicyIdRequestBodyPolicy_script_templateOneOf4SomeAt_least postPolicyIdRequestBodyPolicy_script_templateOneOf4SomeFrom = PostPolicyIdRequestBodyPolicy_script_templateOneOf4Some{postPolicyIdRequestBodyPolicy_script_templateOneOf4SomeAt_least = postPolicyIdRequestBodyPolicy_script_templateOneOf4SomeAt_least,
                                                                                                                                                                                                                                                postPolicyIdRequestBodyPolicy_script_templateOneOf4SomeFrom = postPolicyIdRequestBodyPolicy_script_templateOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.requestBody.content.application\/json.schema.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data PostPolicyIdRequestBodyPolicy_script_templateOneOf5 = PostPolicyIdRequestBodyPolicy_script_templateOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postPolicyIdRequestBodyPolicy_script_templateOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdRequestBodyPolicy_script_templateOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_templateOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_templateOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdRequestBodyPolicy_script_templateOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPolicyIdRequestBodyPolicy_script_templateOneOf5" (\obj -> GHC.Base.pure PostPolicyIdRequestBodyPolicy_script_templateOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'PostPolicyIdRequestBodyPolicy_script_templateOneOf5' with all required fields.
mkPostPolicyIdRequestBodyPolicy_script_templateOneOf5 :: GHC.Types.Int -- ^ 'postPolicyIdRequestBodyPolicy_script_templateOneOf5Active_from'
  -> PostPolicyIdRequestBodyPolicy_script_templateOneOf5
mkPostPolicyIdRequestBodyPolicy_script_templateOneOf5 postPolicyIdRequestBodyPolicy_script_templateOneOf5Active_from = PostPolicyIdRequestBodyPolicy_script_templateOneOf5{postPolicyIdRequestBodyPolicy_script_templateOneOf5Active_from = postPolicyIdRequestBodyPolicy_script_templateOneOf5Active_from}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.requestBody.content.application\/json.schema.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data PostPolicyIdRequestBodyPolicy_script_templateOneOf6 = PostPolicyIdRequestBodyPolicy_script_templateOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postPolicyIdRequestBodyPolicy_script_templateOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdRequestBodyPolicy_script_templateOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_templateOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= postPolicyIdRequestBodyPolicy_script_templateOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdRequestBodyPolicy_script_templateOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPolicyIdRequestBodyPolicy_script_templateOneOf6" (\obj -> GHC.Base.pure PostPolicyIdRequestBodyPolicy_script_templateOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'PostPolicyIdRequestBodyPolicy_script_templateOneOf6' with all required fields.
mkPostPolicyIdRequestBodyPolicy_script_templateOneOf6 :: GHC.Types.Int -- ^ 'postPolicyIdRequestBodyPolicy_script_templateOneOf6Active_until'
  -> PostPolicyIdRequestBodyPolicy_script_templateOneOf6
mkPostPolicyIdRequestBodyPolicy_script_templateOneOf6 postPolicyIdRequestBodyPolicy_script_templateOneOf6Active_until = PostPolicyIdRequestBodyPolicy_script_templateOneOf6{postPolicyIdRequestBodyPolicy_script_templateOneOf6Active_until = postPolicyIdRequestBodyPolicy_script_templateOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.requestBody.content.application\/json.schema.properties.policy_script_template.oneOf@ in the specification.
-- 
-- 
data PostPolicyIdRequestBodyPolicy_script_templateVariants =
   PostPolicyIdRequestBodyPolicy_script_templateVariant1 Data.Text.Internal.Text
  | PostPolicyIdRequestBodyPolicy_script_templateVariant2 PostPolicyIdRequestBodyPolicy_script_templateOneOf2
  | PostPolicyIdRequestBodyPolicy_script_templateVariant3 PostPolicyIdRequestBodyPolicy_script_templateOneOf3
  | PostPolicyIdRequestBodyPolicy_script_templateVariant4 PostPolicyIdRequestBodyPolicy_script_templateOneOf4
  | PostPolicyIdRequestBodyPolicy_script_templateVariant5 PostPolicyIdRequestBodyPolicy_script_templateOneOf5
  | PostPolicyIdRequestBodyPolicy_script_templateVariant6 PostPolicyIdRequestBodyPolicy_script_templateOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdRequestBodyPolicy_script_templateVariants
    where toJSON (PostPolicyIdRequestBodyPolicy_script_templateVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostPolicyIdRequestBodyPolicy_script_templateVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostPolicyIdRequestBodyPolicy_script_templateVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostPolicyIdRequestBodyPolicy_script_templateVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostPolicyIdRequestBodyPolicy_script_templateVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostPolicyIdRequestBodyPolicy_script_templateVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdRequestBodyPolicy_script_templateVariants
    where parseJSON val = case (PostPolicyIdRequestBodyPolicy_script_templateVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostPolicyIdRequestBodyPolicy_script_templateVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostPolicyIdRequestBodyPolicy_script_templateVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostPolicyIdRequestBodyPolicy_script_templateVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostPolicyIdRequestBodyPolicy_script_templateVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostPolicyIdRequestBodyPolicy_script_templateVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Represents a response of the operation 'postPolicyId'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PostPolicyIdResponseError' is used.
data PostPolicyIdResponse =
   PostPolicyIdResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | PostPolicyIdResponse202 PostPolicyIdResponseBody202 -- ^ Accepted
  | PostPolicyIdResponse400 PostPolicyIdResponseBody400 -- ^ Bad Request
  | PostPolicyIdResponse403 PostPolicyIdResponseBody403Variants -- ^ Forbidden
  | PostPolicyIdResponse406 PostPolicyIdResponseBody406 -- ^ Not Acceptable
  | PostPolicyIdResponse415 PostPolicyIdResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.responses.202.content.application\/json.schema@ in the specification.
-- 
-- 
data PostPolicyIdResponseBody202 = PostPolicyIdResponseBody202 {
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  postPolicyIdResponseBody202Policy_id :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdResponseBody202
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["policy_id" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody202Policy_id obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["policy_id" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody202Policy_id obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdResponseBody202
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPolicyIdResponseBody202" (\obj -> GHC.Base.pure PostPolicyIdResponseBody202 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id"))
-- | Create a new 'PostPolicyIdResponseBody202' with all required fields.
mkPostPolicyIdResponseBody202 :: Data.Text.Internal.Text -- ^ 'postPolicyIdResponseBody202Policy_id'
  -> PostPolicyIdResponseBody202
mkPostPolicyIdResponseBody202 postPolicyIdResponseBody202Policy_id = PostPolicyIdResponseBody202{postPolicyIdResponseBody202Policy_id = postPolicyIdResponseBody202Policy_id}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data PostPolicyIdResponseBody400 = PostPolicyIdResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  postPolicyIdResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPolicyIdResponseBody400" (\obj -> GHC.Base.pure PostPolicyIdResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostPolicyIdResponseBody400' with all required fields.
mkPostPolicyIdResponseBody400 :: Data.Text.Internal.Text -- ^ 'postPolicyIdResponseBody400Message'
  -> PostPolicyIdResponseBody400
mkPostPolicyIdResponseBody400 postPolicyIdResponseBody400Message = PostPolicyIdResponseBody400{postPolicyIdResponseBody400Message = postPolicyIdResponseBody400Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostPolicyIdResponseBody403OneOf1 = PostPolicyIdResponseBody403OneOf1 {
  -- | message: May occur when trying to perform an operation not supported by this type of wallet.
  postPolicyIdResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPolicyIdResponseBody403OneOf1" (\obj -> GHC.Base.pure PostPolicyIdResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostPolicyIdResponseBody403OneOf1' with all required fields.
mkPostPolicyIdResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'postPolicyIdResponseBody403OneOf1Message'
  -> PostPolicyIdResponseBody403OneOf1
mkPostPolicyIdResponseBody403OneOf1 postPolicyIdResponseBody403OneOf1Message = PostPolicyIdResponseBody403OneOf1{postPolicyIdResponseBody403OneOf1Message = postPolicyIdResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostPolicyIdResponseBody403OneOf2 = PostPolicyIdResponseBody403OneOf2 {
  -- | message: Occurs when trying to construct with minting\/burning on shelley wallet without policy public key.
  postPolicyIdResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "missing_policy_public_key"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "missing_policy_public_key"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPolicyIdResponseBody403OneOf2" (\obj -> GHC.Base.pure PostPolicyIdResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostPolicyIdResponseBody403OneOf2' with all required fields.
mkPostPolicyIdResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'postPolicyIdResponseBody403OneOf2Message'
  -> PostPolicyIdResponseBody403OneOf2
mkPostPolicyIdResponseBody403OneOf2 postPolicyIdResponseBody403OneOf2Message = PostPolicyIdResponseBody403OneOf2{postPolicyIdResponseBody403OneOf2Message = postPolicyIdResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostPolicyIdResponseBody403OneOf3 = PostPolicyIdResponseBody403OneOf3 {
  -- | message: Occurs when a policy script template either does not pass validation
  -- or has more than one cosigner.
  postPolicyIdResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "created_wrong_policy_script_template"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "created_wrong_policy_script_template"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPolicyIdResponseBody403OneOf3" (\obj -> GHC.Base.pure PostPolicyIdResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostPolicyIdResponseBody403OneOf3' with all required fields.
mkPostPolicyIdResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'postPolicyIdResponseBody403OneOf3Message'
  -> PostPolicyIdResponseBody403OneOf3
mkPostPolicyIdResponseBody403OneOf3 postPolicyIdResponseBody403OneOf3Message = PostPolicyIdResponseBody403OneOf3{postPolicyIdResponseBody403OneOf3Message = postPolicyIdResponseBody403OneOf3Message}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostPolicyIdResponseBody403Variants =
   PostPolicyIdResponseBody403Variant1 PostPolicyIdResponseBody403OneOf1
  | PostPolicyIdResponseBody403Variant2 PostPolicyIdResponseBody403OneOf2
  | PostPolicyIdResponseBody403Variant3 PostPolicyIdResponseBody403OneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdResponseBody403Variants
    where toJSON (PostPolicyIdResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostPolicyIdResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostPolicyIdResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdResponseBody403Variants
    where parseJSON val = case (PostPolicyIdResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostPolicyIdResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostPolicyIdResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data PostPolicyIdResponseBody406 = PostPolicyIdResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  postPolicyIdResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPolicyIdResponseBody406" (\obj -> GHC.Base.pure PostPolicyIdResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostPolicyIdResponseBody406' with all required fields.
mkPostPolicyIdResponseBody406 :: Data.Text.Internal.Text -- ^ 'postPolicyIdResponseBody406Message'
  -> PostPolicyIdResponseBody406
mkPostPolicyIdResponseBody406 postPolicyIdResponseBody406Message = PostPolicyIdResponseBody406{postPolicyIdResponseBody406Message = postPolicyIdResponseBody406Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/policy-id.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data PostPolicyIdResponseBody415 = PostPolicyIdResponseBody415 {
  -- | code: A specific error code for this error, more precise than HTTP ones.
  postPolicyIdResponseBody415Code :: Data.Text.Internal.Text
  -- | message: A descriptive error message.
  , postPolicyIdResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostPolicyIdResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["code" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody415Code obj] : ["message" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody415Message obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["code" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody415Code obj] : ["message" Data.Aeson.Types.ToJSON..= postPolicyIdResponseBody415Message obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostPolicyIdResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostPolicyIdResponseBody415" (\obj -> (GHC.Base.pure PostPolicyIdResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "code")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostPolicyIdResponseBody415' with all required fields.
mkPostPolicyIdResponseBody415 :: Data.Text.Internal.Text -- ^ 'postPolicyIdResponseBody415Code'
  -> Data.Text.Internal.Text -- ^ 'postPolicyIdResponseBody415Message'
  -> PostPolicyIdResponseBody415
mkPostPolicyIdResponseBody415 postPolicyIdResponseBody415Code postPolicyIdResponseBody415Message = PostPolicyIdResponseBody415{postPolicyIdResponseBody415Code = postPolicyIdResponseBody415Code,
                                                                                                                               postPolicyIdResponseBody415Message = postPolicyIdResponseBody415Message}
-- | > POST /wallets/{walletId}/policy-id
-- 
-- The same as 'postPolicyId' but accepts an explicit configuration.
postPolicyIdWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostPolicyIdRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response PostPolicyIdResponse) -- ^ Monadic computation which returns the result of the operation
postPolicyIdWithConfiguration config
                              walletId
                              body = GHC.Base.fmap (\response_6 -> GHC.Base.fmap (Data.Either.either PostPolicyIdResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> PostPolicyIdResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                        PostPolicyIdResponseBody202)
                                                                                                                                                                            | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostPolicyIdResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                        PostPolicyIdResponseBody400)
                                                                                                                                                                            | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> PostPolicyIdResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                        PostPolicyIdResponseBody403Variants)
                                                                                                                                                                            | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostPolicyIdResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                          PostPolicyIdResponseBody406)
                                                                                                                                                                            | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostPolicyIdResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                          PostPolicyIdResponseBody415)
                                                                                                                                                                            | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_6) response_6) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/policy-id")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/policy-id
-- 
-- The same as 'postPolicyId' but returns the raw 'Data.ByteString.ByteString'.
postPolicyIdRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostPolicyIdRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postPolicyIdRaw walletId
                body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/policy-id")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/policy-id
-- 
-- The same as 'postPolicyId' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
postPolicyIdWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostPolicyIdRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postPolicyIdWithConfigurationRaw config
                                 walletId
                                 body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/policy-id")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
