-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation getSharedWalletUtxoSnapshot
module Wallet.Operations.GetSharedWalletUtxoSnapshot where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > GET /shared-wallets/{walletId}/utxo
-- 
-- Generate a snapshot of the wallet\'s UTxO set.
-- 
-- This endpoint is intended for debugging purposes.
getSharedWalletUtxoSnapshot :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response GetSharedWalletUtxoSnapshotResponse) -- ^ Monadic computation which returns the result of the operation
getSharedWalletUtxoSnapshot walletId = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either GetSharedWalletUtxoSnapshotResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetSharedWalletUtxoSnapshotResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                        GetSharedWalletUtxoSnapshotResponseBody200)
                                                                                                                                                                                             | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> GetSharedWalletUtxoSnapshotResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                        GetSharedWalletUtxoSnapshotResponseBody404)
                                                                                                                                                                                             | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> GetSharedWalletUtxoSnapshotResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                        GetSharedWalletUtxoSnapshotResponseBody406)
                                                                                                                                                                                             | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/shared-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/utxo")) GHC.Base.mempty)
-- | Represents a response of the operation 'getSharedWalletUtxoSnapshot'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'GetSharedWalletUtxoSnapshotResponseError' is used.
data GetSharedWalletUtxoSnapshotResponse =
   GetSharedWalletUtxoSnapshotResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | GetSharedWalletUtxoSnapshotResponse200 GetSharedWalletUtxoSnapshotResponseBody200 -- ^ Ok
  | GetSharedWalletUtxoSnapshotResponse404 GetSharedWalletUtxoSnapshotResponseBody404 -- ^ Not Found
  | GetSharedWalletUtxoSnapshotResponse406 GetSharedWalletUtxoSnapshotResponseBody406 -- ^ Not Acceptable
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/utxo.GET.responses.200.content.application\/json.schema@ in the specification.
-- 
-- 
data GetSharedWalletUtxoSnapshotResponseBody200 = GetSharedWalletUtxoSnapshotResponseBody200 {
  -- | entries: The complete set of UTxO entries associated with a wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  getSharedWalletUtxoSnapshotResponseBody200Entries :: ([GetSharedWalletUtxoSnapshotResponseBody200Entries])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetSharedWalletUtxoSnapshotResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["entries" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200Entries obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["entries" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200Entries obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetSharedWalletUtxoSnapshotResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetSharedWalletUtxoSnapshotResponseBody200" (\obj -> GHC.Base.pure GetSharedWalletUtxoSnapshotResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "entries"))
-- | Create a new 'GetSharedWalletUtxoSnapshotResponseBody200' with all required fields.
mkGetSharedWalletUtxoSnapshotResponseBody200 :: [GetSharedWalletUtxoSnapshotResponseBody200Entries] -- ^ 'getSharedWalletUtxoSnapshotResponseBody200Entries'
  -> GetSharedWalletUtxoSnapshotResponseBody200
mkGetSharedWalletUtxoSnapshotResponseBody200 getSharedWalletUtxoSnapshotResponseBody200Entries = GetSharedWalletUtxoSnapshotResponseBody200{getSharedWalletUtxoSnapshotResponseBody200Entries = getSharedWalletUtxoSnapshotResponseBody200Entries}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/utxo.GET.responses.200.content.application\/json.schema.properties.entries.items@ in the specification.
-- 
-- 
data GetSharedWalletUtxoSnapshotResponseBody200Entries = GetSharedWalletUtxoSnapshotResponseBody200Entries {
  -- | ada: The ada quantity associated with this UTxO entry.
  getSharedWalletUtxoSnapshotResponseBody200EntriesAda :: GetSharedWalletUtxoSnapshotResponseBody200EntriesAda
  -- | ada_minimum: The minimum ada quantity permitted by the ledger for this UTxO
  -- entry.
  , getSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum :: GetSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum
  -- | assets: The set of non-ada assets associated with this UTxO entry.
  , getSharedWalletUtxoSnapshotResponseBody200EntriesAssets :: ([GetSharedWalletUtxoSnapshotResponseBody200EntriesAssets])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetSharedWalletUtxoSnapshotResponseBody200Entries
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["ada" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAda obj] : ["ada_minimum" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum obj] : ["assets" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAssets obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["ada" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAda obj] : ["ada_minimum" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum obj] : ["assets" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAssets obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetSharedWalletUtxoSnapshotResponseBody200Entries
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetSharedWalletUtxoSnapshotResponseBody200Entries" (\obj -> ((GHC.Base.pure GetSharedWalletUtxoSnapshotResponseBody200Entries GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ada")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ada_minimum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets"))
-- | Create a new 'GetSharedWalletUtxoSnapshotResponseBody200Entries' with all required fields.
mkGetSharedWalletUtxoSnapshotResponseBody200Entries :: GetSharedWalletUtxoSnapshotResponseBody200EntriesAda -- ^ 'getSharedWalletUtxoSnapshotResponseBody200EntriesAda'
  -> GetSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum -- ^ 'getSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum'
  -> [GetSharedWalletUtxoSnapshotResponseBody200EntriesAssets] -- ^ 'getSharedWalletUtxoSnapshotResponseBody200EntriesAssets'
  -> GetSharedWalletUtxoSnapshotResponseBody200Entries
mkGetSharedWalletUtxoSnapshotResponseBody200Entries getSharedWalletUtxoSnapshotResponseBody200EntriesAda getSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum getSharedWalletUtxoSnapshotResponseBody200EntriesAssets = GetSharedWalletUtxoSnapshotResponseBody200Entries{getSharedWalletUtxoSnapshotResponseBody200EntriesAda = getSharedWalletUtxoSnapshotResponseBody200EntriesAda,
                                                                                                                                                                                                                                                                                  getSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum = getSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum,
                                                                                                                                                                                                                                                                                  getSharedWalletUtxoSnapshotResponseBody200EntriesAssets = getSharedWalletUtxoSnapshotResponseBody200EntriesAssets}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/utxo.GET.responses.200.content.application\/json.schema.properties.entries.items.properties.ada@ in the specification.
-- 
-- The ada quantity associated with this UTxO entry.
data GetSharedWalletUtxoSnapshotResponseBody200EntriesAda = GetSharedWalletUtxoSnapshotResponseBody200EntriesAda {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getSharedWalletUtxoSnapshotResponseBody200EntriesAdaQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetSharedWalletUtxoSnapshotResponseBody200EntriesAda
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAdaQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAdaQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetSharedWalletUtxoSnapshotResponseBody200EntriesAda
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetSharedWalletUtxoSnapshotResponseBody200EntriesAda" (\obj -> GHC.Base.pure GetSharedWalletUtxoSnapshotResponseBody200EntriesAda GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetSharedWalletUtxoSnapshotResponseBody200EntriesAda' with all required fields.
mkGetSharedWalletUtxoSnapshotResponseBody200EntriesAda :: GHC.Types.Int -- ^ 'getSharedWalletUtxoSnapshotResponseBody200EntriesAdaQuantity'
  -> GetSharedWalletUtxoSnapshotResponseBody200EntriesAda
mkGetSharedWalletUtxoSnapshotResponseBody200EntriesAda getSharedWalletUtxoSnapshotResponseBody200EntriesAdaQuantity = GetSharedWalletUtxoSnapshotResponseBody200EntriesAda{getSharedWalletUtxoSnapshotResponseBody200EntriesAdaQuantity = getSharedWalletUtxoSnapshotResponseBody200EntriesAdaQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/utxo.GET.responses.200.content.application\/json.schema.properties.entries.items.properties.ada_minimum@ in the specification.
-- 
-- The minimum ada quantity permitted by the ledger for this UTxO
-- entry.
data GetSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum = GetSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimumQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum" (\obj -> GHC.Base.pure GetSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum' with all required fields.
mkGetSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum :: GHC.Types.Int -- ^ 'getSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimumQuantity'
  -> GetSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum
mkGetSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum getSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimumQuantity = GetSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimum{getSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimumQuantity = getSharedWalletUtxoSnapshotResponseBody200EntriesAda_minimumQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/utxo.GET.responses.200.content.application\/json.schema.properties.entries.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data GetSharedWalletUtxoSnapshotResponseBody200EntriesAssets = GetSharedWalletUtxoSnapshotResponseBody200EntriesAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetSharedWalletUtxoSnapshotResponseBody200EntriesAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetSharedWalletUtxoSnapshotResponseBody200EntriesAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetSharedWalletUtxoSnapshotResponseBody200EntriesAssets" (\obj -> ((GHC.Base.pure GetSharedWalletUtxoSnapshotResponseBody200EntriesAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetSharedWalletUtxoSnapshotResponseBody200EntriesAssets' with all required fields.
mkGetSharedWalletUtxoSnapshotResponseBody200EntriesAssets :: Data.Text.Internal.Text -- ^ 'getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsQuantity'
  -> GetSharedWalletUtxoSnapshotResponseBody200EntriesAssets
mkGetSharedWalletUtxoSnapshotResponseBody200EntriesAssets getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsAsset_name getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsPolicy_id getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsQuantity = GetSharedWalletUtxoSnapshotResponseBody200EntriesAssets{getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsAsset_name = getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                       getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsPolicy_id = getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                       getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsQuantity = getSharedWalletUtxoSnapshotResponseBody200EntriesAssetsQuantity}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/utxo.GET.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data GetSharedWalletUtxoSnapshotResponseBody404 = GetSharedWalletUtxoSnapshotResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  getSharedWalletUtxoSnapshotResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetSharedWalletUtxoSnapshotResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetSharedWalletUtxoSnapshotResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetSharedWalletUtxoSnapshotResponseBody404" (\obj -> GHC.Base.pure GetSharedWalletUtxoSnapshotResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetSharedWalletUtxoSnapshotResponseBody404' with all required fields.
mkGetSharedWalletUtxoSnapshotResponseBody404 :: Data.Text.Internal.Text -- ^ 'getSharedWalletUtxoSnapshotResponseBody404Message'
  -> GetSharedWalletUtxoSnapshotResponseBody404
mkGetSharedWalletUtxoSnapshotResponseBody404 getSharedWalletUtxoSnapshotResponseBody404Message = GetSharedWalletUtxoSnapshotResponseBody404{getSharedWalletUtxoSnapshotResponseBody404Message = getSharedWalletUtxoSnapshotResponseBody404Message}
-- | Defines the object schema located at @paths.\/shared-wallets\/{walletId}\/utxo.GET.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data GetSharedWalletUtxoSnapshotResponseBody406 = GetSharedWalletUtxoSnapshotResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  getSharedWalletUtxoSnapshotResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetSharedWalletUtxoSnapshotResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getSharedWalletUtxoSnapshotResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetSharedWalletUtxoSnapshotResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetSharedWalletUtxoSnapshotResponseBody406" (\obj -> GHC.Base.pure GetSharedWalletUtxoSnapshotResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetSharedWalletUtxoSnapshotResponseBody406' with all required fields.
mkGetSharedWalletUtxoSnapshotResponseBody406 :: Data.Text.Internal.Text -- ^ 'getSharedWalletUtxoSnapshotResponseBody406Message'
  -> GetSharedWalletUtxoSnapshotResponseBody406
mkGetSharedWalletUtxoSnapshotResponseBody406 getSharedWalletUtxoSnapshotResponseBody406Message = GetSharedWalletUtxoSnapshotResponseBody406{getSharedWalletUtxoSnapshotResponseBody406Message = getSharedWalletUtxoSnapshotResponseBody406Message}
-- | > GET /shared-wallets/{walletId}/utxo
-- 
-- The same as 'getSharedWalletUtxoSnapshot' but accepts an explicit configuration.
getSharedWalletUtxoSnapshotWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> m (Network.HTTP.Client.Types.Response GetSharedWalletUtxoSnapshotResponse) -- ^ Monadic computation which returns the result of the operation
getSharedWalletUtxoSnapshotWithConfiguration config
                                             walletId = GHC.Base.fmap (\response_4 -> GHC.Base.fmap (Data.Either.either GetSharedWalletUtxoSnapshotResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetSharedWalletUtxoSnapshotResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GetSharedWalletUtxoSnapshotResponseBody200)
                                                                                                                                                                                                              | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> GetSharedWalletUtxoSnapshotResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GetSharedWalletUtxoSnapshotResponseBody404)
                                                                                                                                                                                                              | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> GetSharedWalletUtxoSnapshotResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                         GetSharedWalletUtxoSnapshotResponseBody406)
                                                                                                                                                                                                              | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_4) response_4) (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/shared-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/utxo")) GHC.Base.mempty)
-- | > GET /shared-wallets/{walletId}/utxo
-- 
-- The same as 'getSharedWalletUtxoSnapshot' but returns the raw 'Data.ByteString.ByteString'.
getSharedWalletUtxoSnapshotRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
getSharedWalletUtxoSnapshotRaw walletId = GHC.Base.id (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/shared-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/utxo")) GHC.Base.mempty)
-- | > GET /shared-wallets/{walletId}/utxo
-- 
-- The same as 'getSharedWalletUtxoSnapshot' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
getSharedWalletUtxoSnapshotWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
getSharedWalletUtxoSnapshotWithConfigurationRaw config
                                                walletId = GHC.Base.id (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/shared-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/utxo")) GHC.Base.mempty)
