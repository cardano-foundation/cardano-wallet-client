-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation byronSelectCoins
module Wallet.Operations.ByronSelectCoins where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /byron-wallets/{walletId}/coin-selections/random
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Select coins to cover the given set of payments.
-- 
-- Uses the \<a href=\"https:\/\/iohk.io\/blog\/self-organisation-in-coin-selection\/\">
-- Random-Improve coin selection algorithm\<\/a>.
-- 
-- \<b>Note: \<\/b> Not supported for Byron random wallets.
byronSelectCoins :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> ByronSelectCoinsRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response ByronSelectCoinsResponse) -- ^ Monadic computation which returns the result of the operation
byronSelectCoins walletId
                 body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either ByronSelectCoinsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ByronSelectCoinsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                   ByronSelectCoinsResponseBody200)
                                                                                                                                                                   | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> ByronSelectCoinsResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                   ByronSelectCoinsResponseBody400)
                                                                                                                                                                   | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> ByronSelectCoinsResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                   ByronSelectCoinsResponseBody403Variants)
                                                                                                                                                                   | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> ByronSelectCoinsResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                   ByronSelectCoinsResponseBody404)
                                                                                                                                                                   | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ByronSelectCoinsResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                   ByronSelectCoinsResponseBody406)
                                                                                                                                                                   | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> ByronSelectCoinsResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                   ByronSelectCoinsResponseBody415)
                                                                                                                                                                   | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/coin-selections/random")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema@ in the specification.
-- 
-- 
data ByronSelectCoinsRequestBody = ByronSelectCoinsRequestBody {
  -- | payments: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  byronSelectCoinsRequestBodyPayments :: ([ByronSelectCoinsRequestBodyPayments])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["payments" Data.Aeson.Types.ToJSON..= byronSelectCoinsRequestBodyPayments obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["payments" Data.Aeson.Types.ToJSON..= byronSelectCoinsRequestBodyPayments obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsRequestBody" (\obj -> GHC.Base.pure ByronSelectCoinsRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "payments"))
-- | Create a new 'ByronSelectCoinsRequestBody' with all required fields.
mkByronSelectCoinsRequestBody :: [ByronSelectCoinsRequestBodyPayments] -- ^ 'byronSelectCoinsRequestBodyPayments'
  -> ByronSelectCoinsRequestBody
mkByronSelectCoinsRequestBody byronSelectCoinsRequestBodyPayments = ByronSelectCoinsRequestBody{byronSelectCoinsRequestBodyPayments = byronSelectCoinsRequestBodyPayments}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.properties.payments.items@ in the specification.
-- 
-- 
data ByronSelectCoinsRequestBodyPayments = ByronSelectCoinsRequestBodyPayments {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  byronSelectCoinsRequestBodyPaymentsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , byronSelectCoinsRequestBodyPaymentsAmount :: ByronSelectCoinsRequestBodyPaymentsAmount
  -- | assets: A flat list of assets (possibly empty).
  , byronSelectCoinsRequestBodyPaymentsAssets :: (GHC.Maybe.Maybe ([ByronSelectCoinsRequestBodyPaymentsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsRequestBodyPayments
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= byronSelectCoinsRequestBodyPaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= byronSelectCoinsRequestBodyPaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsRequestBodyPaymentsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= byronSelectCoinsRequestBodyPaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= byronSelectCoinsRequestBodyPaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsRequestBodyPaymentsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsRequestBodyPayments
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsRequestBodyPayments" (\obj -> ((GHC.Base.pure ByronSelectCoinsRequestBodyPayments GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'ByronSelectCoinsRequestBodyPayments' with all required fields.
mkByronSelectCoinsRequestBodyPayments :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsRequestBodyPaymentsAddress'
  -> ByronSelectCoinsRequestBodyPaymentsAmount -- ^ 'byronSelectCoinsRequestBodyPaymentsAmount'
  -> ByronSelectCoinsRequestBodyPayments
mkByronSelectCoinsRequestBodyPayments byronSelectCoinsRequestBodyPaymentsAddress byronSelectCoinsRequestBodyPaymentsAmount = ByronSelectCoinsRequestBodyPayments{byronSelectCoinsRequestBodyPaymentsAddress = byronSelectCoinsRequestBodyPaymentsAddress,
                                                                                                                                                                 byronSelectCoinsRequestBodyPaymentsAmount = byronSelectCoinsRequestBodyPaymentsAmount,
                                                                                                                                                                 byronSelectCoinsRequestBodyPaymentsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.properties.payments.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ByronSelectCoinsRequestBodyPaymentsAmount = ByronSelectCoinsRequestBodyPaymentsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  byronSelectCoinsRequestBodyPaymentsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsRequestBodyPaymentsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsRequestBodyPaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsRequestBodyPaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsRequestBodyPaymentsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsRequestBodyPaymentsAmount" (\obj -> GHC.Base.pure ByronSelectCoinsRequestBodyPaymentsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ByronSelectCoinsRequestBodyPaymentsAmount' with all required fields.
mkByronSelectCoinsRequestBodyPaymentsAmount :: GHC.Types.Int -- ^ 'byronSelectCoinsRequestBodyPaymentsAmountQuantity'
  -> ByronSelectCoinsRequestBodyPaymentsAmount
mkByronSelectCoinsRequestBodyPaymentsAmount byronSelectCoinsRequestBodyPaymentsAmountQuantity = ByronSelectCoinsRequestBodyPaymentsAmount{byronSelectCoinsRequestBodyPaymentsAmountQuantity = byronSelectCoinsRequestBodyPaymentsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.requestBody.content.application\/json.schema.properties.payments.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ByronSelectCoinsRequestBodyPaymentsAssets = ByronSelectCoinsRequestBodyPaymentsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  byronSelectCoinsRequestBodyPaymentsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , byronSelectCoinsRequestBodyPaymentsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , byronSelectCoinsRequestBodyPaymentsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsRequestBodyPaymentsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= byronSelectCoinsRequestBodyPaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= byronSelectCoinsRequestBodyPaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsRequestBodyPaymentsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= byronSelectCoinsRequestBodyPaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= byronSelectCoinsRequestBodyPaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsRequestBodyPaymentsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsRequestBodyPaymentsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsRequestBodyPaymentsAssets" (\obj -> ((GHC.Base.pure ByronSelectCoinsRequestBodyPaymentsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ByronSelectCoinsRequestBodyPaymentsAssets' with all required fields.
mkByronSelectCoinsRequestBodyPaymentsAssets :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsRequestBodyPaymentsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'byronSelectCoinsRequestBodyPaymentsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'byronSelectCoinsRequestBodyPaymentsAssetsQuantity'
  -> ByronSelectCoinsRequestBodyPaymentsAssets
mkByronSelectCoinsRequestBodyPaymentsAssets byronSelectCoinsRequestBodyPaymentsAssetsAsset_name byronSelectCoinsRequestBodyPaymentsAssetsPolicy_id byronSelectCoinsRequestBodyPaymentsAssetsQuantity = ByronSelectCoinsRequestBodyPaymentsAssets{byronSelectCoinsRequestBodyPaymentsAssetsAsset_name = byronSelectCoinsRequestBodyPaymentsAssetsAsset_name,
                                                                                                                                                                                                                                                 byronSelectCoinsRequestBodyPaymentsAssetsPolicy_id = byronSelectCoinsRequestBodyPaymentsAssetsPolicy_id,
                                                                                                                                                                                                                                                 byronSelectCoinsRequestBodyPaymentsAssetsQuantity = byronSelectCoinsRequestBodyPaymentsAssetsQuantity}
-- | Represents a response of the operation 'byronSelectCoins'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'ByronSelectCoinsResponseError' is used.
data ByronSelectCoinsResponse =
   ByronSelectCoinsResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | ByronSelectCoinsResponse200 ByronSelectCoinsResponseBody200 -- ^ OK
  | ByronSelectCoinsResponse400 ByronSelectCoinsResponseBody400 -- ^ Bad Request
  | ByronSelectCoinsResponse403 ByronSelectCoinsResponseBody403Variants -- ^ Forbidden
  | ByronSelectCoinsResponse404 ByronSelectCoinsResponseBody404 -- ^ Not Found
  | ByronSelectCoinsResponse406 ByronSelectCoinsResponseBody406 -- ^ Not Acceptable
  | ByronSelectCoinsResponse415 ByronSelectCoinsResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody200 = ByronSelectCoinsResponseBody200 {
  -- | certificates
  byronSelectCoinsResponseBody200Certificates :: (GHC.Maybe.Maybe ([ByronSelectCoinsResponseBody200Certificates]))
  -- | change: A list of transaction change outputs.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , byronSelectCoinsResponseBody200Change :: ([ByronSelectCoinsResponseBody200Change])
  -- | collateral: A list of transaction inputs used for collateral
  , byronSelectCoinsResponseBody200Collateral :: (GHC.Maybe.Maybe ([ByronSelectCoinsResponseBody200Collateral]))
  -- | deposits_returned: A list of deposits associated with a transaction.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , byronSelectCoinsResponseBody200Deposits_returned :: (GHC.Maybe.Maybe ([ByronSelectCoinsResponseBody200Deposits_returned]))
  -- | deposits_taken: A list of deposits associated with a transaction.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , byronSelectCoinsResponseBody200Deposits_taken :: (GHC.Maybe.Maybe ([ByronSelectCoinsResponseBody200Deposits_taken]))
  -- | inputs: A list of transaction inputs
  , byronSelectCoinsResponseBody200Inputs :: ([ByronSelectCoinsResponseBody200Inputs])
  -- | metadata: Transaction metadata, serialized according to the expected on-chain binary format, base64-encoded.
  , byronSelectCoinsResponseBody200Metadata :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , byronSelectCoinsResponseBody200Outputs :: ([ByronSelectCoinsResponseBody200Outputs])
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , byronSelectCoinsResponseBody200Withdrawals :: (GHC.Maybe.Maybe ([ByronSelectCoinsResponseBody200Withdrawals]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200Certificates obj) : ["change" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200Change obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_returned" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200Deposits_returned obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_taken" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200Deposits_taken obj) : ["inputs" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200Metadata obj) : ["outputs" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawals" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200Withdrawals obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200Certificates obj) : ["change" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200Change obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_returned" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200Deposits_returned obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_taken" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200Deposits_taken obj) : ["inputs" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200Metadata obj) : ["outputs" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawals" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200Withdrawals obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200" (\obj -> ((((((((GHC.Base.pure ByronSelectCoinsResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "change")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "deposits_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "deposits_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "withdrawals"))
-- | Create a new 'ByronSelectCoinsResponseBody200' with all required fields.
mkByronSelectCoinsResponseBody200 :: [ByronSelectCoinsResponseBody200Change] -- ^ 'byronSelectCoinsResponseBody200Change'
  -> [ByronSelectCoinsResponseBody200Inputs] -- ^ 'byronSelectCoinsResponseBody200Inputs'
  -> [ByronSelectCoinsResponseBody200Outputs] -- ^ 'byronSelectCoinsResponseBody200Outputs'
  -> ByronSelectCoinsResponseBody200
mkByronSelectCoinsResponseBody200 byronSelectCoinsResponseBody200Change byronSelectCoinsResponseBody200Inputs byronSelectCoinsResponseBody200Outputs = ByronSelectCoinsResponseBody200{byronSelectCoinsResponseBody200Certificates = GHC.Maybe.Nothing,
                                                                                                                                                                                       byronSelectCoinsResponseBody200Change = byronSelectCoinsResponseBody200Change,
                                                                                                                                                                                       byronSelectCoinsResponseBody200Collateral = GHC.Maybe.Nothing,
                                                                                                                                                                                       byronSelectCoinsResponseBody200Deposits_returned = GHC.Maybe.Nothing,
                                                                                                                                                                                       byronSelectCoinsResponseBody200Deposits_taken = GHC.Maybe.Nothing,
                                                                                                                                                                                       byronSelectCoinsResponseBody200Inputs = byronSelectCoinsResponseBody200Inputs,
                                                                                                                                                                                       byronSelectCoinsResponseBody200Metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                       byronSelectCoinsResponseBody200Outputs = byronSelectCoinsResponseBody200Outputs,
                                                                                                                                                                                       byronSelectCoinsResponseBody200Withdrawals = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.certificates.items@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data ByronSelectCoinsResponseBody200Certificates = ByronSelectCoinsResponseBody200Certificates {
  -- | certificate_type
  byronSelectCoinsResponseBody200CertificatesCertificate_type :: ByronSelectCoinsResponseBody200CertificatesCertificate_type
  -- | pool: A unique identifier for the pool.
  , byronSelectCoinsResponseBody200CertificatesPool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , byronSelectCoinsResponseBody200CertificatesReward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200Certificates
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CertificatesCertificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200CertificatesPool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CertificatesReward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CertificatesCertificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200CertificatesPool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CertificatesReward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200Certificates
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200Certificates" (\obj -> ((GHC.Base.pure ByronSelectCoinsResponseBody200Certificates GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'ByronSelectCoinsResponseBody200Certificates' with all required fields.
mkByronSelectCoinsResponseBody200Certificates :: ByronSelectCoinsResponseBody200CertificatesCertificate_type -- ^ 'byronSelectCoinsResponseBody200CertificatesCertificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'byronSelectCoinsResponseBody200CertificatesReward_account_path'
  -> ByronSelectCoinsResponseBody200Certificates
mkByronSelectCoinsResponseBody200Certificates byronSelectCoinsResponseBody200CertificatesCertificate_type byronSelectCoinsResponseBody200CertificatesReward_account_path = ByronSelectCoinsResponseBody200Certificates{byronSelectCoinsResponseBody200CertificatesCertificate_type = byronSelectCoinsResponseBody200CertificatesCertificate_type,
                                                                                                                                                                                                                       byronSelectCoinsResponseBody200CertificatesPool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                       byronSelectCoinsResponseBody200CertificatesReward_account_path = byronSelectCoinsResponseBody200CertificatesReward_account_path}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.certificates.items.properties.certificate_type@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody200CertificatesCertificate_type =
   ByronSelectCoinsResponseBody200CertificatesCertificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ByronSelectCoinsResponseBody200CertificatesCertificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ByronSelectCoinsResponseBody200CertificatesCertificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | ByronSelectCoinsResponseBody200CertificatesCertificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | ByronSelectCoinsResponseBody200CertificatesCertificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200CertificatesCertificate_type
    where toJSON (ByronSelectCoinsResponseBody200CertificatesCertificate_typeOther val) = val
          toJSON (ByronSelectCoinsResponseBody200CertificatesCertificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ByronSelectCoinsResponseBody200CertificatesCertificate_typeEnumJoin_pool) = "join_pool"
          toJSON (ByronSelectCoinsResponseBody200CertificatesCertificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (ByronSelectCoinsResponseBody200CertificatesCertificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200CertificatesCertificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> ByronSelectCoinsResponseBody200CertificatesCertificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> ByronSelectCoinsResponseBody200CertificatesCertificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> ByronSelectCoinsResponseBody200CertificatesCertificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> ByronSelectCoinsResponseBody200CertificatesCertificate_typeOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.change.items@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody200Change = ByronSelectCoinsResponseBody200Change {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  byronSelectCoinsResponseBody200ChangeAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , byronSelectCoinsResponseBody200ChangeAmount :: ByronSelectCoinsResponseBody200ChangeAmount
  -- | assets: A flat list of assets (possibly empty).
  , byronSelectCoinsResponseBody200ChangeAssets :: (GHC.Maybe.Maybe ([ByronSelectCoinsResponseBody200ChangeAssets]))
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , byronSelectCoinsResponseBody200ChangeDerivation_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200Change
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200ChangeAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200ChangeAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200ChangeAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200ChangeDerivation_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200ChangeAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200ChangeAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200ChangeAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200ChangeDerivation_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200Change
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200Change" (\obj -> (((GHC.Base.pure ByronSelectCoinsResponseBody200Change GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path"))
-- | Create a new 'ByronSelectCoinsResponseBody200Change' with all required fields.
mkByronSelectCoinsResponseBody200Change :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody200ChangeAddress'
  -> ByronSelectCoinsResponseBody200ChangeAmount -- ^ 'byronSelectCoinsResponseBody200ChangeAmount'
  -> [Data.Text.Internal.Text] -- ^ 'byronSelectCoinsResponseBody200ChangeDerivation_path'
  -> ByronSelectCoinsResponseBody200Change
mkByronSelectCoinsResponseBody200Change byronSelectCoinsResponseBody200ChangeAddress byronSelectCoinsResponseBody200ChangeAmount byronSelectCoinsResponseBody200ChangeDerivation_path = ByronSelectCoinsResponseBody200Change{byronSelectCoinsResponseBody200ChangeAddress = byronSelectCoinsResponseBody200ChangeAddress,
                                                                                                                                                                                                                              byronSelectCoinsResponseBody200ChangeAmount = byronSelectCoinsResponseBody200ChangeAmount,
                                                                                                                                                                                                                              byronSelectCoinsResponseBody200ChangeAssets = GHC.Maybe.Nothing,
                                                                                                                                                                                                                              byronSelectCoinsResponseBody200ChangeDerivation_path = byronSelectCoinsResponseBody200ChangeDerivation_path}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.change.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ByronSelectCoinsResponseBody200ChangeAmount = ByronSelectCoinsResponseBody200ChangeAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  byronSelectCoinsResponseBody200ChangeAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200ChangeAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200ChangeAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200ChangeAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200ChangeAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200ChangeAmount" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody200ChangeAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ByronSelectCoinsResponseBody200ChangeAmount' with all required fields.
mkByronSelectCoinsResponseBody200ChangeAmount :: GHC.Types.Int -- ^ 'byronSelectCoinsResponseBody200ChangeAmountQuantity'
  -> ByronSelectCoinsResponseBody200ChangeAmount
mkByronSelectCoinsResponseBody200ChangeAmount byronSelectCoinsResponseBody200ChangeAmountQuantity = ByronSelectCoinsResponseBody200ChangeAmount{byronSelectCoinsResponseBody200ChangeAmountQuantity = byronSelectCoinsResponseBody200ChangeAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.change.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ByronSelectCoinsResponseBody200ChangeAssets = ByronSelectCoinsResponseBody200ChangeAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  byronSelectCoinsResponseBody200ChangeAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , byronSelectCoinsResponseBody200ChangeAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , byronSelectCoinsResponseBody200ChangeAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200ChangeAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200ChangeAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200ChangeAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200ChangeAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200ChangeAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200ChangeAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200ChangeAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200ChangeAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200ChangeAssets" (\obj -> ((GHC.Base.pure ByronSelectCoinsResponseBody200ChangeAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ByronSelectCoinsResponseBody200ChangeAssets' with all required fields.
mkByronSelectCoinsResponseBody200ChangeAssets :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody200ChangeAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody200ChangeAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'byronSelectCoinsResponseBody200ChangeAssetsQuantity'
  -> ByronSelectCoinsResponseBody200ChangeAssets
mkByronSelectCoinsResponseBody200ChangeAssets byronSelectCoinsResponseBody200ChangeAssetsAsset_name byronSelectCoinsResponseBody200ChangeAssetsPolicy_id byronSelectCoinsResponseBody200ChangeAssetsQuantity = ByronSelectCoinsResponseBody200ChangeAssets{byronSelectCoinsResponseBody200ChangeAssetsAsset_name = byronSelectCoinsResponseBody200ChangeAssetsAsset_name,
                                                                                                                                                                                                                                                           byronSelectCoinsResponseBody200ChangeAssetsPolicy_id = byronSelectCoinsResponseBody200ChangeAssetsPolicy_id,
                                                                                                                                                                                                                                                           byronSelectCoinsResponseBody200ChangeAssetsQuantity = byronSelectCoinsResponseBody200ChangeAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.collateral.items@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody200Collateral = ByronSelectCoinsResponseBody200Collateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  byronSelectCoinsResponseBody200CollateralAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , byronSelectCoinsResponseBody200CollateralAmount :: ByronSelectCoinsResponseBody200CollateralAmount
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , byronSelectCoinsResponseBody200CollateralDerivation_path :: ([Data.Text.Internal.Text])
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , byronSelectCoinsResponseBody200CollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , byronSelectCoinsResponseBody200CollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200Collateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CollateralAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CollateralAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CollateralDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CollateralAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CollateralAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CollateralDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200Collateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200Collateral" (\obj -> ((((GHC.Base.pure ByronSelectCoinsResponseBody200Collateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ByronSelectCoinsResponseBody200Collateral' with all required fields.
mkByronSelectCoinsResponseBody200Collateral :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody200CollateralAddress'
  -> ByronSelectCoinsResponseBody200CollateralAmount -- ^ 'byronSelectCoinsResponseBody200CollateralAmount'
  -> [Data.Text.Internal.Text] -- ^ 'byronSelectCoinsResponseBody200CollateralDerivation_path'
  -> Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody200CollateralId'
  -> GHC.Types.Int -- ^ 'byronSelectCoinsResponseBody200CollateralIndex'
  -> ByronSelectCoinsResponseBody200Collateral
mkByronSelectCoinsResponseBody200Collateral byronSelectCoinsResponseBody200CollateralAddress byronSelectCoinsResponseBody200CollateralAmount byronSelectCoinsResponseBody200CollateralDerivation_path byronSelectCoinsResponseBody200CollateralId byronSelectCoinsResponseBody200CollateralIndex = ByronSelectCoinsResponseBody200Collateral{byronSelectCoinsResponseBody200CollateralAddress = byronSelectCoinsResponseBody200CollateralAddress,
                                                                                                                                                                                                                                                                                                                                             byronSelectCoinsResponseBody200CollateralAmount = byronSelectCoinsResponseBody200CollateralAmount,
                                                                                                                                                                                                                                                                                                                                             byronSelectCoinsResponseBody200CollateralDerivation_path = byronSelectCoinsResponseBody200CollateralDerivation_path,
                                                                                                                                                                                                                                                                                                                                             byronSelectCoinsResponseBody200CollateralId = byronSelectCoinsResponseBody200CollateralId,
                                                                                                                                                                                                                                                                                                                                             byronSelectCoinsResponseBody200CollateralIndex = byronSelectCoinsResponseBody200CollateralIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ByronSelectCoinsResponseBody200CollateralAmount = ByronSelectCoinsResponseBody200CollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  byronSelectCoinsResponseBody200CollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200CollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200CollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200CollateralAmount" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody200CollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ByronSelectCoinsResponseBody200CollateralAmount' with all required fields.
mkByronSelectCoinsResponseBody200CollateralAmount :: GHC.Types.Int -- ^ 'byronSelectCoinsResponseBody200CollateralAmountQuantity'
  -> ByronSelectCoinsResponseBody200CollateralAmount
mkByronSelectCoinsResponseBody200CollateralAmount byronSelectCoinsResponseBody200CollateralAmountQuantity = ByronSelectCoinsResponseBody200CollateralAmount{byronSelectCoinsResponseBody200CollateralAmountQuantity = byronSelectCoinsResponseBody200CollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.deposits_returned.items@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ByronSelectCoinsResponseBody200Deposits_returned = ByronSelectCoinsResponseBody200Deposits_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  byronSelectCoinsResponseBody200Deposits_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200Deposits_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200Deposits_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200Deposits_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200Deposits_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200Deposits_returned" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody200Deposits_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ByronSelectCoinsResponseBody200Deposits_returned' with all required fields.
mkByronSelectCoinsResponseBody200Deposits_returned :: GHC.Types.Int -- ^ 'byronSelectCoinsResponseBody200Deposits_returnedQuantity'
  -> ByronSelectCoinsResponseBody200Deposits_returned
mkByronSelectCoinsResponseBody200Deposits_returned byronSelectCoinsResponseBody200Deposits_returnedQuantity = ByronSelectCoinsResponseBody200Deposits_returned{byronSelectCoinsResponseBody200Deposits_returnedQuantity = byronSelectCoinsResponseBody200Deposits_returnedQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.deposits_taken.items@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ByronSelectCoinsResponseBody200Deposits_taken = ByronSelectCoinsResponseBody200Deposits_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  byronSelectCoinsResponseBody200Deposits_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200Deposits_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200Deposits_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200Deposits_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200Deposits_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200Deposits_taken" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody200Deposits_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ByronSelectCoinsResponseBody200Deposits_taken' with all required fields.
mkByronSelectCoinsResponseBody200Deposits_taken :: GHC.Types.Int -- ^ 'byronSelectCoinsResponseBody200Deposits_takenQuantity'
  -> ByronSelectCoinsResponseBody200Deposits_taken
mkByronSelectCoinsResponseBody200Deposits_taken byronSelectCoinsResponseBody200Deposits_takenQuantity = ByronSelectCoinsResponseBody200Deposits_taken{byronSelectCoinsResponseBody200Deposits_takenQuantity = byronSelectCoinsResponseBody200Deposits_takenQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.inputs.items@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody200Inputs = ByronSelectCoinsResponseBody200Inputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  byronSelectCoinsResponseBody200InputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , byronSelectCoinsResponseBody200InputsAmount :: ByronSelectCoinsResponseBody200InputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , byronSelectCoinsResponseBody200InputsAssets :: (GHC.Maybe.Maybe ([ByronSelectCoinsResponseBody200InputsAssets]))
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , byronSelectCoinsResponseBody200InputsDerivation_path :: ([Data.Text.Internal.Text])
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , byronSelectCoinsResponseBody200InputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , byronSelectCoinsResponseBody200InputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200Inputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200InputsAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200InputsAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200Inputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200Inputs" (\obj -> (((((GHC.Base.pure ByronSelectCoinsResponseBody200Inputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'ByronSelectCoinsResponseBody200Inputs' with all required fields.
mkByronSelectCoinsResponseBody200Inputs :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody200InputsAddress'
  -> ByronSelectCoinsResponseBody200InputsAmount -- ^ 'byronSelectCoinsResponseBody200InputsAmount'
  -> [Data.Text.Internal.Text] -- ^ 'byronSelectCoinsResponseBody200InputsDerivation_path'
  -> Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody200InputsId'
  -> GHC.Types.Int -- ^ 'byronSelectCoinsResponseBody200InputsIndex'
  -> ByronSelectCoinsResponseBody200Inputs
mkByronSelectCoinsResponseBody200Inputs byronSelectCoinsResponseBody200InputsAddress byronSelectCoinsResponseBody200InputsAmount byronSelectCoinsResponseBody200InputsDerivation_path byronSelectCoinsResponseBody200InputsId byronSelectCoinsResponseBody200InputsIndex = ByronSelectCoinsResponseBody200Inputs{byronSelectCoinsResponseBody200InputsAddress = byronSelectCoinsResponseBody200InputsAddress,
                                                                                                                                                                                                                                                                                                                 byronSelectCoinsResponseBody200InputsAmount = byronSelectCoinsResponseBody200InputsAmount,
                                                                                                                                                                                                                                                                                                                 byronSelectCoinsResponseBody200InputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                 byronSelectCoinsResponseBody200InputsDerivation_path = byronSelectCoinsResponseBody200InputsDerivation_path,
                                                                                                                                                                                                                                                                                                                 byronSelectCoinsResponseBody200InputsId = byronSelectCoinsResponseBody200InputsId,
                                                                                                                                                                                                                                                                                                                 byronSelectCoinsResponseBody200InputsIndex = byronSelectCoinsResponseBody200InputsIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ByronSelectCoinsResponseBody200InputsAmount = ByronSelectCoinsResponseBody200InputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  byronSelectCoinsResponseBody200InputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200InputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200InputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200InputsAmount" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody200InputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ByronSelectCoinsResponseBody200InputsAmount' with all required fields.
mkByronSelectCoinsResponseBody200InputsAmount :: GHC.Types.Int -- ^ 'byronSelectCoinsResponseBody200InputsAmountQuantity'
  -> ByronSelectCoinsResponseBody200InputsAmount
mkByronSelectCoinsResponseBody200InputsAmount byronSelectCoinsResponseBody200InputsAmountQuantity = ByronSelectCoinsResponseBody200InputsAmount{byronSelectCoinsResponseBody200InputsAmountQuantity = byronSelectCoinsResponseBody200InputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ByronSelectCoinsResponseBody200InputsAssets = ByronSelectCoinsResponseBody200InputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  byronSelectCoinsResponseBody200InputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , byronSelectCoinsResponseBody200InputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , byronSelectCoinsResponseBody200InputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200InputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200InputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200InputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200InputsAssets" (\obj -> ((GHC.Base.pure ByronSelectCoinsResponseBody200InputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ByronSelectCoinsResponseBody200InputsAssets' with all required fields.
mkByronSelectCoinsResponseBody200InputsAssets :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody200InputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody200InputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'byronSelectCoinsResponseBody200InputsAssetsQuantity'
  -> ByronSelectCoinsResponseBody200InputsAssets
mkByronSelectCoinsResponseBody200InputsAssets byronSelectCoinsResponseBody200InputsAssetsAsset_name byronSelectCoinsResponseBody200InputsAssetsPolicy_id byronSelectCoinsResponseBody200InputsAssetsQuantity = ByronSelectCoinsResponseBody200InputsAssets{byronSelectCoinsResponseBody200InputsAssetsAsset_name = byronSelectCoinsResponseBody200InputsAssetsAsset_name,
                                                                                                                                                                                                                                                           byronSelectCoinsResponseBody200InputsAssetsPolicy_id = byronSelectCoinsResponseBody200InputsAssetsPolicy_id,
                                                                                                                                                                                                                                                           byronSelectCoinsResponseBody200InputsAssetsQuantity = byronSelectCoinsResponseBody200InputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.outputs.items@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody200Outputs = ByronSelectCoinsResponseBody200Outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  byronSelectCoinsResponseBody200OutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , byronSelectCoinsResponseBody200OutputsAmount :: ByronSelectCoinsResponseBody200OutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , byronSelectCoinsResponseBody200OutputsAssets :: (GHC.Maybe.Maybe ([ByronSelectCoinsResponseBody200OutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200Outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200OutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody200OutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200Outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200Outputs" (\obj -> ((GHC.Base.pure ByronSelectCoinsResponseBody200Outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'ByronSelectCoinsResponseBody200Outputs' with all required fields.
mkByronSelectCoinsResponseBody200Outputs :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody200OutputsAddress'
  -> ByronSelectCoinsResponseBody200OutputsAmount -- ^ 'byronSelectCoinsResponseBody200OutputsAmount'
  -> ByronSelectCoinsResponseBody200Outputs
mkByronSelectCoinsResponseBody200Outputs byronSelectCoinsResponseBody200OutputsAddress byronSelectCoinsResponseBody200OutputsAmount = ByronSelectCoinsResponseBody200Outputs{byronSelectCoinsResponseBody200OutputsAddress = byronSelectCoinsResponseBody200OutputsAddress,
                                                                                                                                                                             byronSelectCoinsResponseBody200OutputsAmount = byronSelectCoinsResponseBody200OutputsAmount,
                                                                                                                                                                             byronSelectCoinsResponseBody200OutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ByronSelectCoinsResponseBody200OutputsAmount = ByronSelectCoinsResponseBody200OutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  byronSelectCoinsResponseBody200OutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200OutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200OutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200OutputsAmount" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody200OutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ByronSelectCoinsResponseBody200OutputsAmount' with all required fields.
mkByronSelectCoinsResponseBody200OutputsAmount :: GHC.Types.Int -- ^ 'byronSelectCoinsResponseBody200OutputsAmountQuantity'
  -> ByronSelectCoinsResponseBody200OutputsAmount
mkByronSelectCoinsResponseBody200OutputsAmount byronSelectCoinsResponseBody200OutputsAmountQuantity = ByronSelectCoinsResponseBody200OutputsAmount{byronSelectCoinsResponseBody200OutputsAmountQuantity = byronSelectCoinsResponseBody200OutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ByronSelectCoinsResponseBody200OutputsAssets = ByronSelectCoinsResponseBody200OutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  byronSelectCoinsResponseBody200OutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , byronSelectCoinsResponseBody200OutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , byronSelectCoinsResponseBody200OutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200OutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200OutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200OutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200OutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200OutputsAssets" (\obj -> ((GHC.Base.pure ByronSelectCoinsResponseBody200OutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ByronSelectCoinsResponseBody200OutputsAssets' with all required fields.
mkByronSelectCoinsResponseBody200OutputsAssets :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody200OutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody200OutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'byronSelectCoinsResponseBody200OutputsAssetsQuantity'
  -> ByronSelectCoinsResponseBody200OutputsAssets
mkByronSelectCoinsResponseBody200OutputsAssets byronSelectCoinsResponseBody200OutputsAssetsAsset_name byronSelectCoinsResponseBody200OutputsAssetsPolicy_id byronSelectCoinsResponseBody200OutputsAssetsQuantity = ByronSelectCoinsResponseBody200OutputsAssets{byronSelectCoinsResponseBody200OutputsAssetsAsset_name = byronSelectCoinsResponseBody200OutputsAssetsAsset_name,
                                                                                                                                                                                                                                                                byronSelectCoinsResponseBody200OutputsAssetsPolicy_id = byronSelectCoinsResponseBody200OutputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                byronSelectCoinsResponseBody200OutputsAssetsQuantity = byronSelectCoinsResponseBody200OutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.withdrawals.items@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody200Withdrawals = ByronSelectCoinsResponseBody200Withdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  byronSelectCoinsResponseBody200WithdrawalsAmount :: ByronSelectCoinsResponseBody200WithdrawalsAmount
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , byronSelectCoinsResponseBody200WithdrawalsDerivation_path :: ([Data.Text.Internal.Text])
  -- | stake_address
  , byronSelectCoinsResponseBody200WithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200Withdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200WithdrawalsAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200WithdrawalsDerivation_path obj] : ["stake_address" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200WithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200WithdrawalsAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200WithdrawalsDerivation_path obj] : ["stake_address" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200WithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200Withdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200Withdrawals" (\obj -> ((GHC.Base.pure ByronSelectCoinsResponseBody200Withdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'ByronSelectCoinsResponseBody200Withdrawals' with all required fields.
mkByronSelectCoinsResponseBody200Withdrawals :: ByronSelectCoinsResponseBody200WithdrawalsAmount -- ^ 'byronSelectCoinsResponseBody200WithdrawalsAmount'
  -> [Data.Text.Internal.Text] -- ^ 'byronSelectCoinsResponseBody200WithdrawalsDerivation_path'
  -> Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody200WithdrawalsStake_address'
  -> ByronSelectCoinsResponseBody200Withdrawals
mkByronSelectCoinsResponseBody200Withdrawals byronSelectCoinsResponseBody200WithdrawalsAmount byronSelectCoinsResponseBody200WithdrawalsDerivation_path byronSelectCoinsResponseBody200WithdrawalsStake_address = ByronSelectCoinsResponseBody200Withdrawals{byronSelectCoinsResponseBody200WithdrawalsAmount = byronSelectCoinsResponseBody200WithdrawalsAmount,
                                                                                                                                                                                                                                                             byronSelectCoinsResponseBody200WithdrawalsDerivation_path = byronSelectCoinsResponseBody200WithdrawalsDerivation_path,
                                                                                                                                                                                                                                                             byronSelectCoinsResponseBody200WithdrawalsStake_address = byronSelectCoinsResponseBody200WithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.200.content.application\/json.schema.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ByronSelectCoinsResponseBody200WithdrawalsAmount = ByronSelectCoinsResponseBody200WithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  byronSelectCoinsResponseBody200WithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody200WithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody200WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody200WithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody200WithdrawalsAmount" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody200WithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ByronSelectCoinsResponseBody200WithdrawalsAmount' with all required fields.
mkByronSelectCoinsResponseBody200WithdrawalsAmount :: GHC.Types.Int -- ^ 'byronSelectCoinsResponseBody200WithdrawalsAmountQuantity'
  -> ByronSelectCoinsResponseBody200WithdrawalsAmount
mkByronSelectCoinsResponseBody200WithdrawalsAmount byronSelectCoinsResponseBody200WithdrawalsAmountQuantity = ByronSelectCoinsResponseBody200WithdrawalsAmount{byronSelectCoinsResponseBody200WithdrawalsAmountQuantity = byronSelectCoinsResponseBody200WithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody400 = ByronSelectCoinsResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  byronSelectCoinsResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody400" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ByronSelectCoinsResponseBody400' with all required fields.
mkByronSelectCoinsResponseBody400 :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody400Message'
  -> ByronSelectCoinsResponseBody400
mkByronSelectCoinsResponseBody400 byronSelectCoinsResponseBody400Message = ByronSelectCoinsResponseBody400{byronSelectCoinsResponseBody400Message = byronSelectCoinsResponseBody400Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody403OneOf1 = ByronSelectCoinsResponseBody403OneOf1 {
  -- | message: May occur when submitting a withdrawal while another withdrawal is pending.
  byronSelectCoinsResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody403OneOf1" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ByronSelectCoinsResponseBody403OneOf1' with all required fields.
mkByronSelectCoinsResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody403OneOf1Message'
  -> ByronSelectCoinsResponseBody403OneOf1
mkByronSelectCoinsResponseBody403OneOf1 byronSelectCoinsResponseBody403OneOf1Message = ByronSelectCoinsResponseBody403OneOf1{byronSelectCoinsResponseBody403OneOf1Message = byronSelectCoinsResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody403OneOf2 = ByronSelectCoinsResponseBody403OneOf2 {
  -- | info
  byronSelectCoinsResponseBody403OneOf2Info :: (GHC.Maybe.Maybe ByronSelectCoinsResponseBody403OneOf2Info)
  -- | message: Occurs when a requested output has a quantity of lovelace that is below the minimum required by the ledger.
  , byronSelectCoinsResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody403OneOf2Info obj) : ["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (byronSelectCoinsResponseBody403OneOf2Info obj) : ["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody403OneOf2" (\obj -> (GHC.Base.pure ByronSelectCoinsResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "info")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ByronSelectCoinsResponseBody403OneOf2' with all required fields.
mkByronSelectCoinsResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody403OneOf2Message'
  -> ByronSelectCoinsResponseBody403OneOf2
mkByronSelectCoinsResponseBody403OneOf2 byronSelectCoinsResponseBody403OneOf2Message = ByronSelectCoinsResponseBody403OneOf2{byronSelectCoinsResponseBody403OneOf2Info = GHC.Maybe.Nothing,
                                                                                                                             byronSelectCoinsResponseBody403OneOf2Message = byronSelectCoinsResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf.properties.info@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody403OneOf2Info = ByronSelectCoinsResponseBody403OneOf2Info {
  -- | tx_output_index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  byronSelectCoinsResponseBody403OneOf2InfoTx_output_index :: GHC.Types.Int
  -- | tx_output_lovelace_required_minimum: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum :: ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum
  -- | tx_output_lovelace_specified: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified :: ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody403OneOf2Info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf2InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf2InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody403OneOf2Info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody403OneOf2Info" (\obj -> ((GHC.Base.pure ByronSelectCoinsResponseBody403OneOf2Info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_index")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_required_minimum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_specified"))
-- | Create a new 'ByronSelectCoinsResponseBody403OneOf2Info' with all required fields.
mkByronSelectCoinsResponseBody403OneOf2Info :: GHC.Types.Int -- ^ 'byronSelectCoinsResponseBody403OneOf2InfoTx_output_index'
  -> ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum -- ^ 'byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum'
  -> ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified -- ^ 'byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified'
  -> ByronSelectCoinsResponseBody403OneOf2Info
mkByronSelectCoinsResponseBody403OneOf2Info byronSelectCoinsResponseBody403OneOf2InfoTx_output_index byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified = ByronSelectCoinsResponseBody403OneOf2Info{byronSelectCoinsResponseBody403OneOf2InfoTx_output_index = byronSelectCoinsResponseBody403OneOf2InfoTx_output_index,
                                                                                                                                                                                                                                                                                                    byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum = byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum,
                                                                                                                                                                                                                                                                                                    byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified = byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_required_minimum@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum = ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimumQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum' with all required fields.
mkByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum :: GHC.Types.Int -- ^ 'byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimumQuantity'
  -> ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum
mkByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimumQuantity = ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimum{byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimumQuantity = byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_required_minimumQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_specified@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified = ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specifiedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified' with all required fields.
mkByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified :: GHC.Types.Int -- ^ 'byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specifiedQuantity'
  -> ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified
mkByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specifiedQuantity = ByronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specified{byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specifiedQuantity = byronSelectCoinsResponseBody403OneOf2InfoTx_output_lovelace_specifiedQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody403OneOf3 = ByronSelectCoinsResponseBody403OneOf3 {
  -- | message: May occur when there\'s not enough money in the wallet to cover a requested payment.
  byronSelectCoinsResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody403OneOf3" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ByronSelectCoinsResponseBody403OneOf3' with all required fields.
mkByronSelectCoinsResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody403OneOf3Message'
  -> ByronSelectCoinsResponseBody403OneOf3
mkByronSelectCoinsResponseBody403OneOf3 byronSelectCoinsResponseBody403OneOf3Message = ByronSelectCoinsResponseBody403OneOf3{byronSelectCoinsResponseBody403OneOf3Message = byronSelectCoinsResponseBody403OneOf3Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody403OneOf4 = ByronSelectCoinsResponseBody403OneOf4 {
  -- | message: May occur when the total balance of pure ada UTxOs in the wallet is
  -- insufficient to cover the minimum collateral amount required for a
  -- transaction requiring collateral.
  byronSelectCoinsResponseBody403OneOf4Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody403OneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody403OneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody403OneOf4" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody403OneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ByronSelectCoinsResponseBody403OneOf4' with all required fields.
mkByronSelectCoinsResponseBody403OneOf4 :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody403OneOf4Message'
  -> ByronSelectCoinsResponseBody403OneOf4
mkByronSelectCoinsResponseBody403OneOf4 byronSelectCoinsResponseBody403OneOf4Message = ByronSelectCoinsResponseBody403OneOf4{byronSelectCoinsResponseBody403OneOf4Message = byronSelectCoinsResponseBody403OneOf4Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody403OneOf5 = ByronSelectCoinsResponseBody403OneOf5 {
  -- | message: May occur when a transaction can\'t be balanced for fees.
  byronSelectCoinsResponseBody403OneOf5Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody403OneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody403OneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody403OneOf5" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody403OneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ByronSelectCoinsResponseBody403OneOf5' with all required fields.
mkByronSelectCoinsResponseBody403OneOf5 :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody403OneOf5Message'
  -> ByronSelectCoinsResponseBody403OneOf5
mkByronSelectCoinsResponseBody403OneOf5 byronSelectCoinsResponseBody403OneOf5Message = ByronSelectCoinsResponseBody403OneOf5{byronSelectCoinsResponseBody403OneOf5Message = byronSelectCoinsResponseBody403OneOf5Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody403OneOf6 = ByronSelectCoinsResponseBody403OneOf6 {
  -- | message: May occur when there\'s enough money to pay for a payment, but not enough UTxO to allow for paying each output independently.
  byronSelectCoinsResponseBody403OneOf6Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody403OneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "inputs_depleted"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "inputs_depleted"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody403OneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody403OneOf6" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody403OneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ByronSelectCoinsResponseBody403OneOf6' with all required fields.
mkByronSelectCoinsResponseBody403OneOf6 :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody403OneOf6Message'
  -> ByronSelectCoinsResponseBody403OneOf6
mkByronSelectCoinsResponseBody403OneOf6 byronSelectCoinsResponseBody403OneOf6Message = ByronSelectCoinsResponseBody403OneOf6{byronSelectCoinsResponseBody403OneOf6Message = byronSelectCoinsResponseBody403OneOf6Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody403OneOf7 = ByronSelectCoinsResponseBody403OneOf7 {
  -- | message: Should never happen unless the server screwed up with the creation of a coin selection.
  byronSelectCoinsResponseBody403OneOf7Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody403OneOf7
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_coin_selection"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_coin_selection"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody403OneOf7
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody403OneOf7" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody403OneOf7 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ByronSelectCoinsResponseBody403OneOf7' with all required fields.
mkByronSelectCoinsResponseBody403OneOf7 :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody403OneOf7Message'
  -> ByronSelectCoinsResponseBody403OneOf7
mkByronSelectCoinsResponseBody403OneOf7 byronSelectCoinsResponseBody403OneOf7Message = ByronSelectCoinsResponseBody403OneOf7{byronSelectCoinsResponseBody403OneOf7Message = byronSelectCoinsResponseBody403OneOf7Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody403OneOf8 = ByronSelectCoinsResponseBody403OneOf8 {
  -- | message: Returned when a user-specified transaction output contains, for some
  -- asset, a token quantity that exceeds the limit supported by the
  -- protocol.
  byronSelectCoinsResponseBody403OneOf8Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody403OneOf8
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_quantity_exceeds_limit"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_quantity_exceeds_limit"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody403OneOf8
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody403OneOf8" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody403OneOf8 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ByronSelectCoinsResponseBody403OneOf8' with all required fields.
mkByronSelectCoinsResponseBody403OneOf8 :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody403OneOf8Message'
  -> ByronSelectCoinsResponseBody403OneOf8
mkByronSelectCoinsResponseBody403OneOf8 byronSelectCoinsResponseBody403OneOf8Message = ByronSelectCoinsResponseBody403OneOf8{byronSelectCoinsResponseBody403OneOf8Message = byronSelectCoinsResponseBody403OneOf8Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody403OneOf9 = ByronSelectCoinsResponseBody403OneOf9 {
  -- | message: Returned when a user-specified transaction output contains a token
  -- bundle whose serialized length exceeds the limit supported by the
  -- protocol.
  byronSelectCoinsResponseBody403OneOf9Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody403OneOf9
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_bundle_size_exceeds_limit"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "output_token_bundle_size_exceeds_limit"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody403OneOf9
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody403OneOf9" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody403OneOf9 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ByronSelectCoinsResponseBody403OneOf9' with all required fields.
mkByronSelectCoinsResponseBody403OneOf9 :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody403OneOf9Message'
  -> ByronSelectCoinsResponseBody403OneOf9
mkByronSelectCoinsResponseBody403OneOf9 byronSelectCoinsResponseBody403OneOf9Message = ByronSelectCoinsResponseBody403OneOf9{byronSelectCoinsResponseBody403OneOf9Message = byronSelectCoinsResponseBody403OneOf9Message}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody403Variants =
   ByronSelectCoinsResponseBody403Variant1 ByronSelectCoinsResponseBody403OneOf1
  | ByronSelectCoinsResponseBody403Variant2 ByronSelectCoinsResponseBody403OneOf2
  | ByronSelectCoinsResponseBody403Variant3 ByronSelectCoinsResponseBody403OneOf3
  | ByronSelectCoinsResponseBody403Variant4 ByronSelectCoinsResponseBody403OneOf4
  | ByronSelectCoinsResponseBody403Variant5 ByronSelectCoinsResponseBody403OneOf5
  | ByronSelectCoinsResponseBody403Variant6 ByronSelectCoinsResponseBody403OneOf6
  | ByronSelectCoinsResponseBody403Variant7 ByronSelectCoinsResponseBody403OneOf7
  | ByronSelectCoinsResponseBody403Variant8 ByronSelectCoinsResponseBody403OneOf8
  | ByronSelectCoinsResponseBody403Variant9 ByronSelectCoinsResponseBody403OneOf9
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody403Variants
    where toJSON (ByronSelectCoinsResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ByronSelectCoinsResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ByronSelectCoinsResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ByronSelectCoinsResponseBody403Variant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ByronSelectCoinsResponseBody403Variant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ByronSelectCoinsResponseBody403Variant6 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ByronSelectCoinsResponseBody403Variant7 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ByronSelectCoinsResponseBody403Variant8 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (ByronSelectCoinsResponseBody403Variant9 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody403Variants
    where parseJSON val = case (ByronSelectCoinsResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ByronSelectCoinsResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ByronSelectCoinsResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ByronSelectCoinsResponseBody403Variant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ByronSelectCoinsResponseBody403Variant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ByronSelectCoinsResponseBody403Variant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ByronSelectCoinsResponseBody403Variant7 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ByronSelectCoinsResponseBody403Variant8 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((ByronSelectCoinsResponseBody403Variant9 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody404 = ByronSelectCoinsResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  byronSelectCoinsResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody404" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ByronSelectCoinsResponseBody404' with all required fields.
mkByronSelectCoinsResponseBody404 :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody404Message'
  -> ByronSelectCoinsResponseBody404
mkByronSelectCoinsResponseBody404 byronSelectCoinsResponseBody404Message = ByronSelectCoinsResponseBody404{byronSelectCoinsResponseBody404Message = byronSelectCoinsResponseBody404Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody406 = ByronSelectCoinsResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  byronSelectCoinsResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody406" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ByronSelectCoinsResponseBody406' with all required fields.
mkByronSelectCoinsResponseBody406 :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody406Message'
  -> ByronSelectCoinsResponseBody406
mkByronSelectCoinsResponseBody406 byronSelectCoinsResponseBody406Message = ByronSelectCoinsResponseBody406{byronSelectCoinsResponseBody406Message = byronSelectCoinsResponseBody406Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/coin-selections\/random.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data ByronSelectCoinsResponseBody415 = ByronSelectCoinsResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  byronSelectCoinsResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ByronSelectCoinsResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= byronSelectCoinsResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ByronSelectCoinsResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ByronSelectCoinsResponseBody415" (\obj -> GHC.Base.pure ByronSelectCoinsResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ByronSelectCoinsResponseBody415' with all required fields.
mkByronSelectCoinsResponseBody415 :: Data.Text.Internal.Text -- ^ 'byronSelectCoinsResponseBody415Message'
  -> ByronSelectCoinsResponseBody415
mkByronSelectCoinsResponseBody415 byronSelectCoinsResponseBody415Message = ByronSelectCoinsResponseBody415{byronSelectCoinsResponseBody415Message = byronSelectCoinsResponseBody415Message}
-- | > POST /byron-wallets/{walletId}/coin-selections/random
-- 
-- The same as 'byronSelectCoins' but accepts an explicit configuration.
byronSelectCoinsWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> ByronSelectCoinsRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response ByronSelectCoinsResponse) -- ^ Monadic computation which returns the result of the operation
byronSelectCoinsWithConfiguration config
                                  walletId
                                  body = GHC.Base.fmap (\response_7 -> GHC.Base.fmap (Data.Either.either ByronSelectCoinsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ByronSelectCoinsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                    ByronSelectCoinsResponseBody200)
                                                                                                                                                                                    | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> ByronSelectCoinsResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                    ByronSelectCoinsResponseBody400)
                                                                                                                                                                                    | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> ByronSelectCoinsResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                      ByronSelectCoinsResponseBody403Variants)
                                                                                                                                                                                    | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> ByronSelectCoinsResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                      ByronSelectCoinsResponseBody404)
                                                                                                                                                                                    | (\status_12 -> Network.HTTP.Types.Status.statusCode status_12 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ByronSelectCoinsResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                      ByronSelectCoinsResponseBody406)
                                                                                                                                                                                    | (\status_13 -> Network.HTTP.Types.Status.statusCode status_13 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> ByronSelectCoinsResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                      ByronSelectCoinsResponseBody415)
                                                                                                                                                                                    | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_7) response_7) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/coin-selections/random")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /byron-wallets/{walletId}/coin-selections/random
-- 
-- The same as 'byronSelectCoins' but returns the raw 'Data.ByteString.ByteString'.
byronSelectCoinsRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> ByronSelectCoinsRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
byronSelectCoinsRaw walletId
                    body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/coin-selections/random")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /byron-wallets/{walletId}/coin-selections/random
-- 
-- The same as 'byronSelectCoins' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
byronSelectCoinsWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> ByronSelectCoinsRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
byronSelectCoinsWithConfigurationRaw config
                                     walletId
                                     body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/coin-selections/random")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
