-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation postTransaction
module Wallet.Operations.PostTransaction where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /wallets/{walletId}/transactions
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Create and send transaction from the wallet.
postTransaction :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostTransactionRequestBodyVariants -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response PostTransactionResponse) -- ^ Monadic computation which returns the result of the operation
postTransaction walletId
                body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PostTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                PostTransactionResponseBody202)
                                                                                                                                                                 | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                PostTransactionResponseBody400)
                                                                                                                                                                 | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                PostTransactionResponseBody403Variants)
                                                                                                                                                                 | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                PostTransactionResponseBody404)
                                                                                                                                                                 | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                PostTransactionResponseBody406)
                                                                                                                                                                 | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                PostTransactionResponseBody415)
                                                                                                                                                                 | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 425) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionResponse425 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                PostTransactionResponseBody425)
                                                                                                                                                                 | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionRequestBodyOneOf1 = PostTransactionRequestBodyOneOf1 {
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  postTransactionRequestBodyOneOf1Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | passphrase: The wallet\'s master passphrase.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 0
  , postTransactionRequestBodyOneOf1Passphrase :: Data.Text.Internal.Text
  -- | payments: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postTransactionRequestBodyOneOf1Payments :: ([PostTransactionRequestBodyOneOf1Payments])
  -- | time_to_live: The TTL (time to live) is the time period in which the transaction
  -- will be accepted into node mempools.
  -- 
  -- After the TTL has lapsed, the transaction is considered
  -- expired. At this point, nodes will give up on broadcasting the
  -- transaction, and the wallet will release the funds allocated to
  -- the transaction so they can be used for other payments.
  -- 
  -- The TTL should be long enough that the transaction has time to be
  -- propagated through the network and confirmed, but short enough so
  -- that - in the event of failures - UTxO are returned to the wallet
  -- in a timely manner.
  -- 
  -- The TTL value is given in seconds. It will be converted to a slot
  -- number internally.
  -- 
  -- If the TTL is not provided for a payment, a reasonable default
  -- value will be used.
  , postTransactionRequestBodyOneOf1Time_to_live :: (GHC.Maybe.Maybe PostTransactionRequestBodyOneOf1Time_to_live)
  -- | withdrawal: When provided, instruments the server to automatically withdraw rewards from the source wallet when they are deemed
  -- sufficient (i.e. they contribute to the balance for at least as much as they cost).
  -- 
  -- As a consequence, the resulting transaction may or may not have a withdrawal object. Summarizing:
  -- 
  -- withdrawal field | reward balance | result
  -- ---              | ---            | ---
  -- \`null\`           | too small      | ✓ no withdrawals generated
  -- \`null\`           | big enough     | ✓ no withdrawals generated
  -- \`\"self\"\`         | too small      | ✓ no withdrawals generated
  -- \`\"self\"\`         | big enough     | ✓ withdrawal generated
  , postTransactionRequestBodyOneOf1Withdrawal :: (GHC.Maybe.Maybe PostTransactionRequestBodyOneOf1Withdrawal)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionRequestBodyOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (postTransactionRequestBodyOneOf1Metadata obj) : ["passphrase" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1Passphrase obj] : ["payments" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1Payments obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("time_to_live" Data.Aeson.Types.ToJSON..=)) (postTransactionRequestBodyOneOf1Time_to_live obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawal" Data.Aeson.Types.ToJSON..=)) (postTransactionRequestBodyOneOf1Withdrawal obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (postTransactionRequestBodyOneOf1Metadata obj) : ["passphrase" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1Passphrase obj] : ["payments" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1Payments obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("time_to_live" Data.Aeson.Types.ToJSON..=)) (postTransactionRequestBodyOneOf1Time_to_live obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawal" Data.Aeson.Types.ToJSON..=)) (postTransactionRequestBodyOneOf1Withdrawal obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionRequestBodyOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionRequestBodyOneOf1" (\obj -> ((((GHC.Base.pure PostTransactionRequestBodyOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "payments")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "time_to_live")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "withdrawal"))
-- | Create a new 'PostTransactionRequestBodyOneOf1' with all required fields.
mkPostTransactionRequestBodyOneOf1 :: Data.Text.Internal.Text -- ^ 'postTransactionRequestBodyOneOf1Passphrase'
  -> [PostTransactionRequestBodyOneOf1Payments] -- ^ 'postTransactionRequestBodyOneOf1Payments'
  -> PostTransactionRequestBodyOneOf1
mkPostTransactionRequestBodyOneOf1 postTransactionRequestBodyOneOf1Passphrase postTransactionRequestBodyOneOf1Payments = PostTransactionRequestBodyOneOf1{postTransactionRequestBodyOneOf1Metadata = GHC.Maybe.Nothing,
                                                                                                                                                          postTransactionRequestBodyOneOf1Passphrase = postTransactionRequestBodyOneOf1Passphrase,
                                                                                                                                                          postTransactionRequestBodyOneOf1Payments = postTransactionRequestBodyOneOf1Payments,
                                                                                                                                                          postTransactionRequestBodyOneOf1Time_to_live = GHC.Maybe.Nothing,
                                                                                                                                                          postTransactionRequestBodyOneOf1Withdrawal = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items@ in the specification.
-- 
-- 
data PostTransactionRequestBodyOneOf1Payments = PostTransactionRequestBodyOneOf1Payments {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  postTransactionRequestBodyOneOf1PaymentsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionRequestBodyOneOf1PaymentsAmount :: PostTransactionRequestBodyOneOf1PaymentsAmount
  -- | assets: A flat list of assets (possibly empty).
  , postTransactionRequestBodyOneOf1PaymentsAssets :: (GHC.Maybe.Maybe ([PostTransactionRequestBodyOneOf1PaymentsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionRequestBodyOneOf1Payments
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1PaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1PaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postTransactionRequestBodyOneOf1PaymentsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1PaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1PaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postTransactionRequestBodyOneOf1PaymentsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionRequestBodyOneOf1Payments
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionRequestBodyOneOf1Payments" (\obj -> ((GHC.Base.pure PostTransactionRequestBodyOneOf1Payments GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'PostTransactionRequestBodyOneOf1Payments' with all required fields.
mkPostTransactionRequestBodyOneOf1Payments :: Data.Text.Internal.Text -- ^ 'postTransactionRequestBodyOneOf1PaymentsAddress'
  -> PostTransactionRequestBodyOneOf1PaymentsAmount -- ^ 'postTransactionRequestBodyOneOf1PaymentsAmount'
  -> PostTransactionRequestBodyOneOf1Payments
mkPostTransactionRequestBodyOneOf1Payments postTransactionRequestBodyOneOf1PaymentsAddress postTransactionRequestBodyOneOf1PaymentsAmount = PostTransactionRequestBodyOneOf1Payments{postTransactionRequestBodyOneOf1PaymentsAddress = postTransactionRequestBodyOneOf1PaymentsAddress,
                                                                                                                                                                                     postTransactionRequestBodyOneOf1PaymentsAmount = postTransactionRequestBodyOneOf1PaymentsAmount,
                                                                                                                                                                                     postTransactionRequestBodyOneOf1PaymentsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionRequestBodyOneOf1PaymentsAmount = PostTransactionRequestBodyOneOf1PaymentsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionRequestBodyOneOf1PaymentsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionRequestBodyOneOf1PaymentsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1PaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1PaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionRequestBodyOneOf1PaymentsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionRequestBodyOneOf1PaymentsAmount" (\obj -> GHC.Base.pure PostTransactionRequestBodyOneOf1PaymentsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionRequestBodyOneOf1PaymentsAmount' with all required fields.
mkPostTransactionRequestBodyOneOf1PaymentsAmount :: GHC.Types.Int -- ^ 'postTransactionRequestBodyOneOf1PaymentsAmountQuantity'
  -> PostTransactionRequestBodyOneOf1PaymentsAmount
mkPostTransactionRequestBodyOneOf1PaymentsAmount postTransactionRequestBodyOneOf1PaymentsAmountQuantity = PostTransactionRequestBodyOneOf1PaymentsAmount{postTransactionRequestBodyOneOf1PaymentsAmountQuantity = postTransactionRequestBodyOneOf1PaymentsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostTransactionRequestBodyOneOf1PaymentsAssets = PostTransactionRequestBodyOneOf1PaymentsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postTransactionRequestBodyOneOf1PaymentsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postTransactionRequestBodyOneOf1PaymentsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionRequestBodyOneOf1PaymentsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionRequestBodyOneOf1PaymentsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1PaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1PaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1PaymentsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1PaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1PaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1PaymentsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionRequestBodyOneOf1PaymentsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionRequestBodyOneOf1PaymentsAssets" (\obj -> ((GHC.Base.pure PostTransactionRequestBodyOneOf1PaymentsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionRequestBodyOneOf1PaymentsAssets' with all required fields.
mkPostTransactionRequestBodyOneOf1PaymentsAssets :: Data.Text.Internal.Text -- ^ 'postTransactionRequestBodyOneOf1PaymentsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postTransactionRequestBodyOneOf1PaymentsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'postTransactionRequestBodyOneOf1PaymentsAssetsQuantity'
  -> PostTransactionRequestBodyOneOf1PaymentsAssets
mkPostTransactionRequestBodyOneOf1PaymentsAssets postTransactionRequestBodyOneOf1PaymentsAssetsAsset_name postTransactionRequestBodyOneOf1PaymentsAssetsPolicy_id postTransactionRequestBodyOneOf1PaymentsAssetsQuantity = PostTransactionRequestBodyOneOf1PaymentsAssets{postTransactionRequestBodyOneOf1PaymentsAssetsAsset_name = postTransactionRequestBodyOneOf1PaymentsAssetsAsset_name,
                                                                                                                                                                                                                                                                          postTransactionRequestBodyOneOf1PaymentsAssetsPolicy_id = postTransactionRequestBodyOneOf1PaymentsAssetsPolicy_id,
                                                                                                                                                                                                                                                                          postTransactionRequestBodyOneOf1PaymentsAssetsQuantity = postTransactionRequestBodyOneOf1PaymentsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.requestBody.content.application\/json.schema.oneOf.properties.time_to_live@ in the specification.
-- 
-- The TTL (time to live) is the time period in which the transaction
-- will be accepted into node mempools.
-- 
-- After the TTL has lapsed, the transaction is considered
-- expired. At this point, nodes will give up on broadcasting the
-- transaction, and the wallet will release the funds allocated to
-- the transaction so they can be used for other payments.
-- 
-- The TTL should be long enough that the transaction has time to be
-- propagated through the network and confirmed, but short enough so
-- that - in the event of failures - UTxO are returned to the wallet
-- in a timely manner.
-- 
-- The TTL value is given in seconds. It will be converted to a slot
-- number internally.
-- 
-- If the TTL is not provided for a payment, a reasonable default
-- value will be used.
data PostTransactionRequestBodyOneOf1Time_to_live = PostTransactionRequestBodyOneOf1Time_to_live {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionRequestBodyOneOf1Time_to_liveQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionRequestBodyOneOf1Time_to_live
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1Time_to_liveQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "second"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf1Time_to_liveQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "second"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionRequestBodyOneOf1Time_to_live
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionRequestBodyOneOf1Time_to_live" (\obj -> GHC.Base.pure PostTransactionRequestBodyOneOf1Time_to_live GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionRequestBodyOneOf1Time_to_live' with all required fields.
mkPostTransactionRequestBodyOneOf1Time_to_live :: GHC.Types.Double -- ^ 'postTransactionRequestBodyOneOf1Time_to_liveQuantity'
  -> PostTransactionRequestBodyOneOf1Time_to_live
mkPostTransactionRequestBodyOneOf1Time_to_live postTransactionRequestBodyOneOf1Time_to_liveQuantity = PostTransactionRequestBodyOneOf1Time_to_live{postTransactionRequestBodyOneOf1Time_to_liveQuantity = postTransactionRequestBodyOneOf1Time_to_liveQuantity}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.POST.requestBody.content.application\/json.schema.oneOf.properties.withdrawal@ in the specification.
-- 
-- When provided, instruments the server to automatically withdraw rewards from the source wallet when they are deemed
-- sufficient (i.e. they contribute to the balance for at least as much as they cost).
-- 
-- As a consequence, the resulting transaction may or may not have a withdrawal object. Summarizing:
-- 
-- withdrawal field | reward balance | result
-- ---              | ---            | ---
-- \`null\`           | too small      | ✓ no withdrawals generated
-- \`null\`           | big enough     | ✓ no withdrawals generated
-- \`\"self\"\`         | too small      | ✓ no withdrawals generated
-- \`\"self\"\`         | big enough     | ✓ withdrawal generated
data PostTransactionRequestBodyOneOf1Withdrawal =
   PostTransactionRequestBodyOneOf1WithdrawalOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostTransactionRequestBodyOneOf1WithdrawalTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostTransactionRequestBodyOneOf1WithdrawalEnumSelf -- ^ Represents the JSON value @"self"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionRequestBodyOneOf1Withdrawal
    where toJSON (PostTransactionRequestBodyOneOf1WithdrawalOther val) = val
          toJSON (PostTransactionRequestBodyOneOf1WithdrawalTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostTransactionRequestBodyOneOf1WithdrawalEnumSelf) = "self"
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionRequestBodyOneOf1Withdrawal
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "self" -> PostTransactionRequestBodyOneOf1WithdrawalEnumSelf
                                            | GHC.Base.otherwise -> PostTransactionRequestBodyOneOf1WithdrawalOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionRequestBodyOneOf2 = PostTransactionRequestBodyOneOf2 {
  -- | passphrase: The wallet\'s master passphrase.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 0
  postTransactionRequestBodyOneOf2Passphrase :: Data.Text.Internal.Text
  -- | payments: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postTransactionRequestBodyOneOf2Payments :: ([PostTransactionRequestBodyOneOf2Payments])
  -- | withdrawal: When provided, attempts to withdraw rewards from the default stake address
  -- corresponding to the given mnemonic.
  -- 
  -- Should the rewards be null or too small to be worth withdrawing (i.e. the
  -- cost of adding them into the transaction is more than their own intrinsic
  -- value), the server will reject the request with a
  -- \`withdrawal_not_beneficial\` error.
  -- 
  -- withdrawal field    | reward balance | result
  -- ---                 | ---            | ---
  -- any recovery phrase | too small      | x Error 403 \`withdrawal_not_beneficial\`
  -- any recovery phrase | big enough     | ✓ withdrawal generated
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 24 items
  -- * Must have a minimum of 15 items
  , postTransactionRequestBodyOneOf2Withdrawal :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionRequestBodyOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["passphrase" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2Passphrase obj] : ["payments" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2Payments obj] : ["withdrawal" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2Withdrawal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["passphrase" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2Passphrase obj] : ["payments" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2Payments obj] : ["withdrawal" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2Withdrawal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionRequestBodyOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionRequestBodyOneOf2" (\obj -> ((GHC.Base.pure PostTransactionRequestBodyOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "payments")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "withdrawal"))
-- | Create a new 'PostTransactionRequestBodyOneOf2' with all required fields.
mkPostTransactionRequestBodyOneOf2 :: Data.Text.Internal.Text -- ^ 'postTransactionRequestBodyOneOf2Passphrase'
  -> [PostTransactionRequestBodyOneOf2Payments] -- ^ 'postTransactionRequestBodyOneOf2Payments'
  -> [Data.Text.Internal.Text] -- ^ 'postTransactionRequestBodyOneOf2Withdrawal'
  -> PostTransactionRequestBodyOneOf2
mkPostTransactionRequestBodyOneOf2 postTransactionRequestBodyOneOf2Passphrase postTransactionRequestBodyOneOf2Payments postTransactionRequestBodyOneOf2Withdrawal = PostTransactionRequestBodyOneOf2{postTransactionRequestBodyOneOf2Passphrase = postTransactionRequestBodyOneOf2Passphrase,
                                                                                                                                                                                                     postTransactionRequestBodyOneOf2Payments = postTransactionRequestBodyOneOf2Payments,
                                                                                                                                                                                                     postTransactionRequestBodyOneOf2Withdrawal = postTransactionRequestBodyOneOf2Withdrawal}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items@ in the specification.
-- 
-- 
data PostTransactionRequestBodyOneOf2Payments = PostTransactionRequestBodyOneOf2Payments {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  postTransactionRequestBodyOneOf2PaymentsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionRequestBodyOneOf2PaymentsAmount :: PostTransactionRequestBodyOneOf2PaymentsAmount
  -- | assets: A flat list of assets (possibly empty).
  , postTransactionRequestBodyOneOf2PaymentsAssets :: (GHC.Maybe.Maybe ([PostTransactionRequestBodyOneOf2PaymentsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionRequestBodyOneOf2Payments
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2PaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2PaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postTransactionRequestBodyOneOf2PaymentsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2PaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2PaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postTransactionRequestBodyOneOf2PaymentsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionRequestBodyOneOf2Payments
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionRequestBodyOneOf2Payments" (\obj -> ((GHC.Base.pure PostTransactionRequestBodyOneOf2Payments GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'PostTransactionRequestBodyOneOf2Payments' with all required fields.
mkPostTransactionRequestBodyOneOf2Payments :: Data.Text.Internal.Text -- ^ 'postTransactionRequestBodyOneOf2PaymentsAddress'
  -> PostTransactionRequestBodyOneOf2PaymentsAmount -- ^ 'postTransactionRequestBodyOneOf2PaymentsAmount'
  -> PostTransactionRequestBodyOneOf2Payments
mkPostTransactionRequestBodyOneOf2Payments postTransactionRequestBodyOneOf2PaymentsAddress postTransactionRequestBodyOneOf2PaymentsAmount = PostTransactionRequestBodyOneOf2Payments{postTransactionRequestBodyOneOf2PaymentsAddress = postTransactionRequestBodyOneOf2PaymentsAddress,
                                                                                                                                                                                     postTransactionRequestBodyOneOf2PaymentsAmount = postTransactionRequestBodyOneOf2PaymentsAmount,
                                                                                                                                                                                     postTransactionRequestBodyOneOf2PaymentsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionRequestBodyOneOf2PaymentsAmount = PostTransactionRequestBodyOneOf2PaymentsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionRequestBodyOneOf2PaymentsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionRequestBodyOneOf2PaymentsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2PaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2PaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionRequestBodyOneOf2PaymentsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionRequestBodyOneOf2PaymentsAmount" (\obj -> GHC.Base.pure PostTransactionRequestBodyOneOf2PaymentsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionRequestBodyOneOf2PaymentsAmount' with all required fields.
mkPostTransactionRequestBodyOneOf2PaymentsAmount :: GHC.Types.Int -- ^ 'postTransactionRequestBodyOneOf2PaymentsAmountQuantity'
  -> PostTransactionRequestBodyOneOf2PaymentsAmount
mkPostTransactionRequestBodyOneOf2PaymentsAmount postTransactionRequestBodyOneOf2PaymentsAmountQuantity = PostTransactionRequestBodyOneOf2PaymentsAmount{postTransactionRequestBodyOneOf2PaymentsAmountQuantity = postTransactionRequestBodyOneOf2PaymentsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.requestBody.content.application\/json.schema.oneOf.properties.payments.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostTransactionRequestBodyOneOf2PaymentsAssets = PostTransactionRequestBodyOneOf2PaymentsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postTransactionRequestBodyOneOf2PaymentsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postTransactionRequestBodyOneOf2PaymentsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionRequestBodyOneOf2PaymentsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionRequestBodyOneOf2PaymentsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2PaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2PaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2PaymentsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2PaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2PaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionRequestBodyOneOf2PaymentsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionRequestBodyOneOf2PaymentsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionRequestBodyOneOf2PaymentsAssets" (\obj -> ((GHC.Base.pure PostTransactionRequestBodyOneOf2PaymentsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionRequestBodyOneOf2PaymentsAssets' with all required fields.
mkPostTransactionRequestBodyOneOf2PaymentsAssets :: Data.Text.Internal.Text -- ^ 'postTransactionRequestBodyOneOf2PaymentsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postTransactionRequestBodyOneOf2PaymentsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'postTransactionRequestBodyOneOf2PaymentsAssetsQuantity'
  -> PostTransactionRequestBodyOneOf2PaymentsAssets
mkPostTransactionRequestBodyOneOf2PaymentsAssets postTransactionRequestBodyOneOf2PaymentsAssetsAsset_name postTransactionRequestBodyOneOf2PaymentsAssetsPolicy_id postTransactionRequestBodyOneOf2PaymentsAssetsQuantity = PostTransactionRequestBodyOneOf2PaymentsAssets{postTransactionRequestBodyOneOf2PaymentsAssetsAsset_name = postTransactionRequestBodyOneOf2PaymentsAssetsAsset_name,
                                                                                                                                                                                                                                                                          postTransactionRequestBodyOneOf2PaymentsAssetsPolicy_id = postTransactionRequestBodyOneOf2PaymentsAssetsPolicy_id,
                                                                                                                                                                                                                                                                          postTransactionRequestBodyOneOf2PaymentsAssetsQuantity = postTransactionRequestBodyOneOf2PaymentsAssetsQuantity}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionRequestBodyVariants =
   PostTransactionRequestBodyVariant1 PostTransactionRequestBodyOneOf1
  | PostTransactionRequestBodyVariant2 PostTransactionRequestBodyOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionRequestBodyVariants
    where toJSON (PostTransactionRequestBodyVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionRequestBodyVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionRequestBodyVariants
    where parseJSON val = case (PostTransactionRequestBodyVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionRequestBodyVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Represents a response of the operation 'postTransaction'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PostTransactionResponseError' is used.
data PostTransactionResponse =
   PostTransactionResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | PostTransactionResponse202 PostTransactionResponseBody202 -- ^ Accepted
  | PostTransactionResponse400 PostTransactionResponseBody400 -- ^ Bad Request
  | PostTransactionResponse403 PostTransactionResponseBody403Variants -- ^ Forbidden
  | PostTransactionResponse404 PostTransactionResponseBody404 -- ^ Not Found
  | PostTransactionResponse406 PostTransactionResponseBody406 -- ^ Not Acceptable
  | PostTransactionResponse415 PostTransactionResponseBody415 -- ^ Unsupported Media Type
  | PostTransactionResponse425 PostTransactionResponseBody425 -- ^ Mempool is Full
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema@ in the specification.
-- 
-- 
data PostTransactionResponseBody202 = PostTransactionResponseBody202 {
  -- | amount: An amount of Ada spent or received, from the perspective of the wallet.
  -- 
  -- That is, for outgoing transaction, it represents the amount of Ada consumed
  -- as inputs including the amount of Ada spent as fees or deposits.
  -- 
  -- For incoming transaction, it represents the total amount of Ada received to
  -- addresses that belong to the wallet.
  postTransactionResponseBody202Amount :: PostTransactionResponseBody202Amount
  -- | burn
  , postTransactionResponseBody202Burn :: (GHC.Maybe.Maybe PostTransactionResponseBody202Burn)
  -- | certificates
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postTransactionResponseBody202Certificates :: (GHC.Maybe.Maybe ([PostTransactionResponseBody202CertificatesVariants]))
  -- | collateral: A list of transaction inputs used for collateral.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postTransactionResponseBody202Collateral :: (GHC.Maybe.Maybe ([PostTransactionResponseBody202Collateral]))
  -- | collateral_outputs: A list of collateral return outputs with amounts specified.
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 1 items
  -- * Must have a minimum of 0 items
  , postTransactionResponseBody202Collateral_outputs :: (GHC.Maybe.Maybe ([PostTransactionResponseBody202Collateral_outputs]))
  -- | deposit_returned: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionResponseBody202Deposit_returned :: PostTransactionResponseBody202Deposit_returned
  -- | deposit_taken: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionResponseBody202Deposit_taken :: PostTransactionResponseBody202Deposit_taken
  -- | depth: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Current depth of the transaction in the local chain
  , postTransactionResponseBody202Depth :: (GHC.Maybe.Maybe PostTransactionResponseBody202Depth)
  -- | direction
  , postTransactionResponseBody202Direction :: PostTransactionResponseBody202Direction
  -- | expires_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending OR status == expired
  -- \<\/span>\<br\/>
  -- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
  , postTransactionResponseBody202Expires_at :: (GHC.Maybe.Maybe PostTransactionResponseBody202Expires_at)
  -- | extra_signatures
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postTransactionResponseBody202Extra_signatures :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | fee: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionResponseBody202Fee :: PostTransactionResponseBody202Fee
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , postTransactionResponseBody202Id :: Data.Text.Internal.Text
  -- | inputs: A list of transaction inputs.
  -- 
  -- \`assets\` and \`address\` are always present for \`outgoing\`
  -- transactions but generally absent for \`incoming\`
  -- transactions. This information is present on the Cardano explorer,
  -- but is not tracked by the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postTransactionResponseBody202Inputs :: ([PostTransactionResponseBody202Inputs])
  -- | inserted_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Absolute time at which the transaction was inserted in a block.
  , postTransactionResponseBody202Inserted_at :: (GHC.Maybe.Maybe PostTransactionResponseBody202Inserted_at)
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  , postTransactionResponseBody202Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | mint
  , postTransactionResponseBody202Mint :: (GHC.Maybe.Maybe PostTransactionResponseBody202Mint)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postTransactionResponseBody202Outputs :: ([PostTransactionResponseBody202Outputs])
  -- | pending_since: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending
  -- \<\/span>\<br\/>
  -- The point in time at which a transaction became pending.
  , postTransactionResponseBody202Pending_since :: (GHC.Maybe.Maybe PostTransactionResponseBody202Pending_since)
  -- | script_integrity: A script data integrity hash - 32 bytes
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^(script_data)1[0-9a-z]*\$\'
  , postTransactionResponseBody202Script_integrity :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | script_validity: Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
  -- used in the transaction validated or not. Validity may be null if this
  -- transaction was from an era that doesn\'t support phase-2 monetary policy
  -- scripts, or is a pending transaction (we don\'t know if validation passed or
  -- failed until the transaction hits the ledger).
  , postTransactionResponseBody202Script_validity :: (GHC.Maybe.Maybe (Wallet.Common.Nullable PostTransactionResponseBody202Script_validityNonNullable))
  -- | status: Current transaction status.
  -- 
  --   \`\`\`
  --        *-----------*
  --   ---> |  PENDING  |----------------*
  --        *-----------*                |
  --              |                      |
  --              V                      V
  --        *-----------*          *-----------*
  --        |           |---------->  EXPIRED  |
  --        |           |  (ttl)   *-----------*
  --        | SUBMITTED |
  --        |           \<----------------*
  --        |           |                |
  --        *-----------*           (rollback)
  --               |                     |
  --          (in ledger)          *-----------*
  --               |               |           |
  --               *---------------> IN_LEDGER |
  --                               |           |
  --                               *-----------*
  --   \`\`\`
  , postTransactionResponseBody202Status :: PostTransactionResponseBody202Status
  -- | validity_interval
  , postTransactionResponseBody202Validity_interval :: (GHC.Maybe.Maybe PostTransactionResponseBody202Validity_interval)
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postTransactionResponseBody202Withdrawals :: ([PostTransactionResponseBody202Withdrawals])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Fee obj] : ["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Withdrawals obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Fee obj] : ["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Withdrawals obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202" (\obj -> (((((((((((((((((((((((GHC.Base.pure PostTransactionResponseBody202 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "burn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral_outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "depth")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "direction")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "expires_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "extra_signatures")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fee")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "inserted_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pending_since")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_integrity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_validity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "validity_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "withdrawals"))
-- | Create a new 'PostTransactionResponseBody202' with all required fields.
mkPostTransactionResponseBody202 :: PostTransactionResponseBody202Amount -- ^ 'postTransactionResponseBody202Amount'
  -> PostTransactionResponseBody202Deposit_returned -- ^ 'postTransactionResponseBody202Deposit_returned'
  -> PostTransactionResponseBody202Deposit_taken -- ^ 'postTransactionResponseBody202Deposit_taken'
  -> PostTransactionResponseBody202Direction -- ^ 'postTransactionResponseBody202Direction'
  -> PostTransactionResponseBody202Fee -- ^ 'postTransactionResponseBody202Fee'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202Id'
  -> [PostTransactionResponseBody202Inputs] -- ^ 'postTransactionResponseBody202Inputs'
  -> [PostTransactionResponseBody202Outputs] -- ^ 'postTransactionResponseBody202Outputs'
  -> PostTransactionResponseBody202Status -- ^ 'postTransactionResponseBody202Status'
  -> [PostTransactionResponseBody202Withdrawals] -- ^ 'postTransactionResponseBody202Withdrawals'
  -> PostTransactionResponseBody202
mkPostTransactionResponseBody202 postTransactionResponseBody202Amount postTransactionResponseBody202Deposit_returned postTransactionResponseBody202Deposit_taken postTransactionResponseBody202Direction postTransactionResponseBody202Fee postTransactionResponseBody202Id postTransactionResponseBody202Inputs postTransactionResponseBody202Outputs postTransactionResponseBody202Status postTransactionResponseBody202Withdrawals = PostTransactionResponseBody202{postTransactionResponseBody202Amount = postTransactionResponseBody202Amount,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Burn = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Certificates = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Collateral = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Collateral_outputs = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Deposit_returned = postTransactionResponseBody202Deposit_returned,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Deposit_taken = postTransactionResponseBody202Deposit_taken,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Depth = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Direction = postTransactionResponseBody202Direction,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Expires_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Extra_signatures = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Fee = postTransactionResponseBody202Fee,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Id = postTransactionResponseBody202Id,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Inputs = postTransactionResponseBody202Inputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Inserted_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Mint = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Outputs = postTransactionResponseBody202Outputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Pending_since = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Script_integrity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Script_validity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Status = postTransactionResponseBody202Status,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Validity_interval = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                       postTransactionResponseBody202Withdrawals = postTransactionResponseBody202Withdrawals}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.amount@ in the specification.
-- 
-- An amount of Ada spent or received, from the perspective of the wallet.
-- 
-- That is, for outgoing transaction, it represents the amount of Ada consumed
-- as inputs including the amount of Ada spent as fees or deposits.
-- 
-- For incoming transaction, it represents the total amount of Ada received to
-- addresses that belong to the wallet.
data PostTransactionResponseBody202Amount = PostTransactionResponseBody202Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Amount" (\obj -> GHC.Base.pure PostTransactionResponseBody202Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202Amount' with all required fields.
mkPostTransactionResponseBody202Amount :: GHC.Types.Int -- ^ 'postTransactionResponseBody202AmountQuantity'
  -> PostTransactionResponseBody202Amount
mkPostTransactionResponseBody202Amount postTransactionResponseBody202AmountQuantity = PostTransactionResponseBody202Amount{postTransactionResponseBody202AmountQuantity = postTransactionResponseBody202AmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn@ in the specification.
-- 
-- 
data PostTransactionResponseBody202Burn = PostTransactionResponseBody202Burn {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  postTransactionResponseBody202BurnTokens :: ([PostTransactionResponseBody202BurnTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , postTransactionResponseBody202BurnWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , postTransactionResponseBody202BurnWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202BurnWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202BurnWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Burn" (\obj -> ((GHC.Base.pure PostTransactionResponseBody202Burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'PostTransactionResponseBody202Burn' with all required fields.
mkPostTransactionResponseBody202Burn :: [PostTransactionResponseBody202BurnTokens] -- ^ 'postTransactionResponseBody202BurnTokens'
  -> PostTransactionResponseBody202Burn
mkPostTransactionResponseBody202Burn postTransactionResponseBody202BurnTokens = PostTransactionResponseBody202Burn{postTransactionResponseBody202BurnTokens = postTransactionResponseBody202BurnTokens,
                                                                                                                   postTransactionResponseBody202BurnWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                   postTransactionResponseBody202BurnWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items@ in the specification.
-- 
-- 
data PostTransactionResponseBody202BurnTokens = PostTransactionResponseBody202BurnTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postTransactionResponseBody202BurnTokensAssets :: ([PostTransactionResponseBody202BurnTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postTransactionResponseBody202BurnTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , postTransactionResponseBody202BurnTokensPolicy_script :: PostTransactionResponseBody202BurnTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202BurnTokens" (\obj -> ((GHC.Base.pure PostTransactionResponseBody202BurnTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'PostTransactionResponseBody202BurnTokens' with all required fields.
mkPostTransactionResponseBody202BurnTokens :: [PostTransactionResponseBody202BurnTokensAssets] -- ^ 'postTransactionResponseBody202BurnTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202BurnTokensPolicy_id'
  -> PostTransactionResponseBody202BurnTokensPolicy_scriptVariants -- ^ 'postTransactionResponseBody202BurnTokensPolicy_script'
  -> PostTransactionResponseBody202BurnTokens
mkPostTransactionResponseBody202BurnTokens postTransactionResponseBody202BurnTokensAssets postTransactionResponseBody202BurnTokensPolicy_id postTransactionResponseBody202BurnTokensPolicy_script = PostTransactionResponseBody202BurnTokens{postTransactionResponseBody202BurnTokensAssets = postTransactionResponseBody202BurnTokensAssets,
                                                                                                                                                                                                                                             postTransactionResponseBody202BurnTokensPolicy_id = postTransactionResponseBody202BurnTokensPolicy_id,
                                                                                                                                                                                                                                             postTransactionResponseBody202BurnTokensPolicy_script = postTransactionResponseBody202BurnTokensPolicy_script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data PostTransactionResponseBody202BurnTokensAssets = PostTransactionResponseBody202BurnTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postTransactionResponseBody202BurnTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , postTransactionResponseBody202BurnTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202BurnTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202BurnTokensAssets" (\obj -> ((GHC.Base.pure PostTransactionResponseBody202BurnTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202BurnTokensAssets' with all required fields.
mkPostTransactionResponseBody202BurnTokensAssets :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202BurnTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202BurnTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202BurnTokensAssetsQuantity'
  -> PostTransactionResponseBody202BurnTokensAssets
mkPostTransactionResponseBody202BurnTokensAssets postTransactionResponseBody202BurnTokensAssetsAsset_name postTransactionResponseBody202BurnTokensAssetsFingerprint postTransactionResponseBody202BurnTokensAssetsQuantity = PostTransactionResponseBody202BurnTokensAssets{postTransactionResponseBody202BurnTokensAssetsAsset_name = postTransactionResponseBody202BurnTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                            postTransactionResponseBody202BurnTokensAssetsFingerprint = postTransactionResponseBody202BurnTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                            postTransactionResponseBody202BurnTokensAssetsQuantity = postTransactionResponseBody202BurnTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1 = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference)
  -- | script
  , postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script :: PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1' with all required fields.
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1 :: PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script'
  -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1 postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1{postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                              postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference' with all required fields.
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex'
  -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference{postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                               postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2{postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3{postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 :: PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4{postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some{postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5{postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6{postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants =
   PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
  | PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
  | PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
  | PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
  | PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2 = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info :: PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2' with all required fields.
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2 :: PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info'
  -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2 postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2{postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                   postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference' with all required fields.
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex'
  -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference{postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                               postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version :: PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info :: PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info{postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                           postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3 = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References :: ([PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3' with all required fields.
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3 :: [PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References] -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash'
  -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3 postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3{postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                         postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References' with all required fields.
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex'
  -> PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References
mkPostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex = PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References{postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                   postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex = postTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202BurnTokensPolicy_scriptVariants =
   PostTransactionResponseBody202BurnTokensPolicy_scriptVariant1 PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf1
  | PostTransactionResponseBody202BurnTokensPolicy_scriptVariant2 PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf2
  | PostTransactionResponseBody202BurnTokensPolicy_scriptVariant3 PostTransactionResponseBody202BurnTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202BurnTokensPolicy_scriptVariants
    where toJSON (PostTransactionResponseBody202BurnTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202BurnTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202BurnTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202BurnTokensPolicy_scriptVariants
    where parseJSON val = case (PostTransactionResponseBody202BurnTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202BurnTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202BurnTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data PostTransactionResponseBody202CertificatesOneOf1 = PostTransactionResponseBody202CertificatesOneOf1 {
  -- | certificate_type
  postTransactionResponseBody202CertificatesOneOf1Certificate_type :: PostTransactionResponseBody202CertificatesOneOf1Certificate_type
  -- | pool: A unique identifier for the pool.
  , postTransactionResponseBody202CertificatesOneOf1Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , postTransactionResponseBody202CertificatesOneOf1Reward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202CertificatesOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202CertificatesOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202CertificatesOneOf1" (\obj -> ((GHC.Base.pure PostTransactionResponseBody202CertificatesOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'PostTransactionResponseBody202CertificatesOneOf1' with all required fields.
mkPostTransactionResponseBody202CertificatesOneOf1 :: PostTransactionResponseBody202CertificatesOneOf1Certificate_type -- ^ 'postTransactionResponseBody202CertificatesOneOf1Certificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'postTransactionResponseBody202CertificatesOneOf1Reward_account_path'
  -> PostTransactionResponseBody202CertificatesOneOf1
mkPostTransactionResponseBody202CertificatesOneOf1 postTransactionResponseBody202CertificatesOneOf1Certificate_type postTransactionResponseBody202CertificatesOneOf1Reward_account_path = PostTransactionResponseBody202CertificatesOneOf1{postTransactionResponseBody202CertificatesOneOf1Certificate_type = postTransactionResponseBody202CertificatesOneOf1Certificate_type,
                                                                                                                                                                                                                                           postTransactionResponseBody202CertificatesOneOf1Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                           postTransactionResponseBody202CertificatesOneOf1Reward_account_path = postTransactionResponseBody202CertificatesOneOf1Reward_account_path}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data PostTransactionResponseBody202CertificatesOneOf1Certificate_type =
   PostTransactionResponseBody202CertificatesOneOf1Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostTransactionResponseBody202CertificatesOneOf1Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | PostTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | PostTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202CertificatesOneOf1Certificate_type
    where toJSON (PostTransactionResponseBody202CertificatesOneOf1Certificate_typeOther val) = val
          toJSON (PostTransactionResponseBody202CertificatesOneOf1Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool) = "join_pool"
          toJSON (PostTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (PostTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202CertificatesOneOf1Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> PostTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> PostTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> PostTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> PostTransactionResponseBody202CertificatesOneOf1Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate not belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data PostTransactionResponseBody202CertificatesOneOf2 = PostTransactionResponseBody202CertificatesOneOf2 {
  -- | certificate_type
  postTransactionResponseBody202CertificatesOneOf2Certificate_type :: PostTransactionResponseBody202CertificatesOneOf2Certificate_type
  -- | pool: A unique identifier for the pool.
  , postTransactionResponseBody202CertificatesOneOf2Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account
  , postTransactionResponseBody202CertificatesOneOf2Reward_account :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202CertificatesOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf2Reward_account obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf2Reward_account obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202CertificatesOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202CertificatesOneOf2" (\obj -> ((GHC.Base.pure PostTransactionResponseBody202CertificatesOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account"))
-- | Create a new 'PostTransactionResponseBody202CertificatesOneOf2' with all required fields.
mkPostTransactionResponseBody202CertificatesOneOf2 :: PostTransactionResponseBody202CertificatesOneOf2Certificate_type -- ^ 'postTransactionResponseBody202CertificatesOneOf2Certificate_type'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202CertificatesOneOf2Reward_account'
  -> PostTransactionResponseBody202CertificatesOneOf2
mkPostTransactionResponseBody202CertificatesOneOf2 postTransactionResponseBody202CertificatesOneOf2Certificate_type postTransactionResponseBody202CertificatesOneOf2Reward_account = PostTransactionResponseBody202CertificatesOneOf2{postTransactionResponseBody202CertificatesOneOf2Certificate_type = postTransactionResponseBody202CertificatesOneOf2Certificate_type,
                                                                                                                                                                                                                                      postTransactionResponseBody202CertificatesOneOf2Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                      postTransactionResponseBody202CertificatesOneOf2Reward_account = postTransactionResponseBody202CertificatesOneOf2Reward_account}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data PostTransactionResponseBody202CertificatesOneOf2Certificate_type =
   PostTransactionResponseBody202CertificatesOneOf2Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostTransactionResponseBody202CertificatesOneOf2Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external -- ^ Represents the JSON value @"join_pool_external"@
  | PostTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external -- ^ Represents the JSON value @"quit_pool_external"@
  | PostTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external -- ^ Represents the JSON value @"register_reward_account_external"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202CertificatesOneOf2Certificate_type
    where toJSON (PostTransactionResponseBody202CertificatesOneOf2Certificate_typeOther val) = val
          toJSON (PostTransactionResponseBody202CertificatesOneOf2Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external) = "join_pool_external"
          toJSON (PostTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external) = "quit_pool_external"
          toJSON (PostTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external) = "register_reward_account_external"
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202CertificatesOneOf2Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool_external" -> PostTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external
                                            | val GHC.Classes.== "quit_pool_external" -> PostTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external
                                            | val GHC.Classes.== "register_reward_account_external" -> PostTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external
                                            | GHC.Base.otherwise -> PostTransactionResponseBody202CertificatesOneOf2Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202CertificatesOneOf3 = PostTransactionResponseBody202CertificatesOneOf3 {
  -- | pool_cost: Estimated cost set by the pool operator when registering his pool.
  -- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  postTransactionResponseBody202CertificatesOneOf3Pool_cost :: PostTransactionResponseBody202CertificatesOneOf3Pool_cost
  -- | pool_id: A unique identifier for the pool.
  , postTransactionResponseBody202CertificatesOneOf3Pool_id :: Data.Text.Internal.Text
  -- | pool_margin: Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , postTransactionResponseBody202CertificatesOneOf3Pool_margin :: PostTransactionResponseBody202CertificatesOneOf3Pool_margin
  -- | pool_metadata
  , postTransactionResponseBody202CertificatesOneOf3Pool_metadata :: (GHC.Maybe.Maybe PostTransactionResponseBody202CertificatesOneOf3Pool_metadata)
  -- | pool_owners
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postTransactionResponseBody202CertificatesOneOf3Pool_owners :: ([Data.Text.Internal.Text])
  -- | pool_pledge: Minimal stake amount that a stake pool is willing to honor.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , postTransactionResponseBody202CertificatesOneOf3Pool_pledge :: PostTransactionResponseBody202CertificatesOneOf3Pool_pledge
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202CertificatesOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202CertificatesOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202CertificatesOneOf3" (\obj -> (((((GHC.Base.pure PostTransactionResponseBody202CertificatesOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_cost")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_margin")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool_metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_owners")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_pledge"))
-- | Create a new 'PostTransactionResponseBody202CertificatesOneOf3' with all required fields.
mkPostTransactionResponseBody202CertificatesOneOf3 :: PostTransactionResponseBody202CertificatesOneOf3Pool_cost -- ^ 'postTransactionResponseBody202CertificatesOneOf3Pool_cost'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202CertificatesOneOf3Pool_id'
  -> PostTransactionResponseBody202CertificatesOneOf3Pool_margin -- ^ 'postTransactionResponseBody202CertificatesOneOf3Pool_margin'
  -> [Data.Text.Internal.Text] -- ^ 'postTransactionResponseBody202CertificatesOneOf3Pool_owners'
  -> PostTransactionResponseBody202CertificatesOneOf3Pool_pledge -- ^ 'postTransactionResponseBody202CertificatesOneOf3Pool_pledge'
  -> PostTransactionResponseBody202CertificatesOneOf3
mkPostTransactionResponseBody202CertificatesOneOf3 postTransactionResponseBody202CertificatesOneOf3Pool_cost postTransactionResponseBody202CertificatesOneOf3Pool_id postTransactionResponseBody202CertificatesOneOf3Pool_margin postTransactionResponseBody202CertificatesOneOf3Pool_owners postTransactionResponseBody202CertificatesOneOf3Pool_pledge = PostTransactionResponseBody202CertificatesOneOf3{postTransactionResponseBody202CertificatesOneOf3Pool_cost = postTransactionResponseBody202CertificatesOneOf3Pool_cost,
                                                                                                                                                                                                                                                                                                                                                                                                            postTransactionResponseBody202CertificatesOneOf3Pool_id = postTransactionResponseBody202CertificatesOneOf3Pool_id,
                                                                                                                                                                                                                                                                                                                                                                                                            postTransactionResponseBody202CertificatesOneOf3Pool_margin = postTransactionResponseBody202CertificatesOneOf3Pool_margin,
                                                                                                                                                                                                                                                                                                                                                                                                            postTransactionResponseBody202CertificatesOneOf3Pool_metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                            postTransactionResponseBody202CertificatesOneOf3Pool_owners = postTransactionResponseBody202CertificatesOneOf3Pool_owners,
                                                                                                                                                                                                                                                                                                                                                                                                            postTransactionResponseBody202CertificatesOneOf3Pool_pledge = postTransactionResponseBody202CertificatesOneOf3Pool_pledge}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_cost@ in the specification.
-- 
-- Estimated cost set by the pool operator when registering his pool.
-- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data PostTransactionResponseBody202CertificatesOneOf3Pool_cost = PostTransactionResponseBody202CertificatesOneOf3Pool_cost {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202CertificatesOneOf3Pool_costQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202CertificatesOneOf3Pool_cost
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202CertificatesOneOf3Pool_cost
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202CertificatesOneOf3Pool_cost" (\obj -> GHC.Base.pure PostTransactionResponseBody202CertificatesOneOf3Pool_cost GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202CertificatesOneOf3Pool_cost' with all required fields.
mkPostTransactionResponseBody202CertificatesOneOf3Pool_cost :: GHC.Types.Int -- ^ 'postTransactionResponseBody202CertificatesOneOf3Pool_costQuantity'
  -> PostTransactionResponseBody202CertificatesOneOf3Pool_cost
mkPostTransactionResponseBody202CertificatesOneOf3Pool_cost postTransactionResponseBody202CertificatesOneOf3Pool_costQuantity = PostTransactionResponseBody202CertificatesOneOf3Pool_cost{postTransactionResponseBody202CertificatesOneOf3Pool_costQuantity = postTransactionResponseBody202CertificatesOneOf3Pool_costQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_margin@ in the specification.
-- 
-- Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data PostTransactionResponseBody202CertificatesOneOf3Pool_margin = PostTransactionResponseBody202CertificatesOneOf3Pool_margin {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  postTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202CertificatesOneOf3Pool_margin
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202CertificatesOneOf3Pool_margin
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202CertificatesOneOf3Pool_margin" (\obj -> GHC.Base.pure PostTransactionResponseBody202CertificatesOneOf3Pool_margin GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202CertificatesOneOf3Pool_margin' with all required fields.
mkPostTransactionResponseBody202CertificatesOneOf3Pool_margin :: GHC.Types.Double -- ^ 'postTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity'
  -> PostTransactionResponseBody202CertificatesOneOf3Pool_margin
mkPostTransactionResponseBody202CertificatesOneOf3Pool_margin postTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity = PostTransactionResponseBody202CertificatesOneOf3Pool_margin{postTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity = postTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_metadata@ in the specification.
-- 
-- 
data PostTransactionResponseBody202CertificatesOneOf3Pool_metadata = PostTransactionResponseBody202CertificatesOneOf3Pool_metadata {
  -- | hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  postTransactionResponseBody202CertificatesOneOf3Pool_metadataHash :: Data.Text.Internal.Text
  -- | url: A URL to the stake pool\'s website.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 250
  -- * Must match pattern \'^https:\/\/.+\'
  , postTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202CertificatesOneOf3Pool_metadata
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202CertificatesOneOf3Pool_metadata
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202CertificatesOneOf3Pool_metadata" (\obj -> (GHC.Base.pure PostTransactionResponseBody202CertificatesOneOf3Pool_metadata GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))
-- | Create a new 'PostTransactionResponseBody202CertificatesOneOf3Pool_metadata' with all required fields.
mkPostTransactionResponseBody202CertificatesOneOf3Pool_metadata :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202CertificatesOneOf3Pool_metadataHash'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl'
  -> PostTransactionResponseBody202CertificatesOneOf3Pool_metadata
mkPostTransactionResponseBody202CertificatesOneOf3Pool_metadata postTransactionResponseBody202CertificatesOneOf3Pool_metadataHash postTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl = PostTransactionResponseBody202CertificatesOneOf3Pool_metadata{postTransactionResponseBody202CertificatesOneOf3Pool_metadataHash = postTransactionResponseBody202CertificatesOneOf3Pool_metadataHash,
                                                                                                                                                                                                                                                                   postTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl = postTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_pledge@ in the specification.
-- 
-- Minimal stake amount that a stake pool is willing to honor.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data PostTransactionResponseBody202CertificatesOneOf3Pool_pledge = PostTransactionResponseBody202CertificatesOneOf3Pool_pledge {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202CertificatesOneOf3Pool_pledge
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202CertificatesOneOf3Pool_pledge
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202CertificatesOneOf3Pool_pledge" (\obj -> GHC.Base.pure PostTransactionResponseBody202CertificatesOneOf3Pool_pledge GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202CertificatesOneOf3Pool_pledge' with all required fields.
mkPostTransactionResponseBody202CertificatesOneOf3Pool_pledge :: GHC.Types.Int -- ^ 'postTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity'
  -> PostTransactionResponseBody202CertificatesOneOf3Pool_pledge
mkPostTransactionResponseBody202CertificatesOneOf3Pool_pledge postTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity = PostTransactionResponseBody202CertificatesOneOf3Pool_pledge{postTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity = postTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202CertificatesOneOf4 = PostTransactionResponseBody202CertificatesOneOf4 {
  -- | pool_id: A unique identifier for the pool.
  postTransactionResponseBody202CertificatesOneOf4Pool_id :: Data.Text.Internal.Text
  -- | retirement_epoch: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202CertificatesOneOf4Retirement_epoch :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202CertificatesOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202CertificatesOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202CertificatesOneOf4" (\obj -> (GHC.Base.pure PostTransactionResponseBody202CertificatesOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "retirement_epoch"))
-- | Create a new 'PostTransactionResponseBody202CertificatesOneOf4' with all required fields.
mkPostTransactionResponseBody202CertificatesOneOf4 :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202CertificatesOneOf4Pool_id'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202CertificatesOneOf4Retirement_epoch'
  -> PostTransactionResponseBody202CertificatesOneOf4
mkPostTransactionResponseBody202CertificatesOneOf4 postTransactionResponseBody202CertificatesOneOf4Pool_id postTransactionResponseBody202CertificatesOneOf4Retirement_epoch = PostTransactionResponseBody202CertificatesOneOf4{postTransactionResponseBody202CertificatesOneOf4Pool_id = postTransactionResponseBody202CertificatesOneOf4Pool_id,
                                                                                                                                                                                                                               postTransactionResponseBody202CertificatesOneOf4Retirement_epoch = postTransactionResponseBody202CertificatesOneOf4Retirement_epoch}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202CertificatesOneOf5 = PostTransactionResponseBody202CertificatesOneOf5 {
  -- | certificate_type
  postTransactionResponseBody202CertificatesOneOf5Certificate_type :: PostTransactionResponseBody202CertificatesOneOf5Certificate_type
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202CertificatesOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202CertificatesOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202CertificatesOneOf5" (\obj -> GHC.Base.pure PostTransactionResponseBody202CertificatesOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type"))
-- | Create a new 'PostTransactionResponseBody202CertificatesOneOf5' with all required fields.
mkPostTransactionResponseBody202CertificatesOneOf5 :: PostTransactionResponseBody202CertificatesOneOf5Certificate_type -- ^ 'postTransactionResponseBody202CertificatesOneOf5Certificate_type'
  -> PostTransactionResponseBody202CertificatesOneOf5
mkPostTransactionResponseBody202CertificatesOneOf5 postTransactionResponseBody202CertificatesOneOf5Certificate_type = PostTransactionResponseBody202CertificatesOneOf5{postTransactionResponseBody202CertificatesOneOf5Certificate_type = postTransactionResponseBody202CertificatesOneOf5Certificate_type}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data PostTransactionResponseBody202CertificatesOneOf5Certificate_type =
   PostTransactionResponseBody202CertificatesOneOf5Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostTransactionResponseBody202CertificatesOneOf5Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumMir -- ^ Represents the JSON value @"mir"@
  | PostTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis -- ^ Represents the JSON value @"genesis"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202CertificatesOneOf5Certificate_type
    where toJSON (PostTransactionResponseBody202CertificatesOneOf5Certificate_typeOther val) = val
          toJSON (PostTransactionResponseBody202CertificatesOneOf5Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumMir) = "mir"
          toJSON (PostTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis) = "genesis"
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202CertificatesOneOf5Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "mir" -> PostTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumMir
                                            | val GHC.Classes.== "genesis" -> PostTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis
                                            | GHC.Base.otherwise -> PostTransactionResponseBody202CertificatesOneOf5Certificate_typeOther val)
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- Any certificate that could occur in an arbitrary transaction:
-- might be related to delegation, pool activities, genesis or MIR.
data PostTransactionResponseBody202CertificatesVariants =
   PostTransactionResponseBody202CertificatesVariant1 PostTransactionResponseBody202CertificatesOneOf1
  | PostTransactionResponseBody202CertificatesVariant2 PostTransactionResponseBody202CertificatesOneOf2
  | PostTransactionResponseBody202CertificatesVariant3 PostTransactionResponseBody202CertificatesOneOf3
  | PostTransactionResponseBody202CertificatesVariant4 PostTransactionResponseBody202CertificatesOneOf4
  | PostTransactionResponseBody202CertificatesVariant5 PostTransactionResponseBody202CertificatesOneOf5
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202CertificatesVariants
    where toJSON (PostTransactionResponseBody202CertificatesVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202CertificatesVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202CertificatesVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202CertificatesVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202CertificatesVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202CertificatesVariants
    where parseJSON val = case (PostTransactionResponseBody202CertificatesVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202CertificatesVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202CertificatesVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202CertificatesVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202CertificatesVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.collateral.items@ in the specification.
-- 
-- 
data PostTransactionResponseBody202Collateral = PostTransactionResponseBody202Collateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  postTransactionResponseBody202CollateralAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionResponseBody202CollateralAmount :: (GHC.Maybe.Maybe PostTransactionResponseBody202CollateralAmount)
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , postTransactionResponseBody202CollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202CollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Collateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Collateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Collateral" (\obj -> (((GHC.Base.pure PostTransactionResponseBody202Collateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostTransactionResponseBody202Collateral' with all required fields.
mkPostTransactionResponseBody202Collateral :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202CollateralId'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202CollateralIndex'
  -> PostTransactionResponseBody202Collateral
mkPostTransactionResponseBody202Collateral postTransactionResponseBody202CollateralId postTransactionResponseBody202CollateralIndex = PostTransactionResponseBody202Collateral{postTransactionResponseBody202CollateralAddress = GHC.Maybe.Nothing,
                                                                                                                                                                               postTransactionResponseBody202CollateralAmount = GHC.Maybe.Nothing,
                                                                                                                                                                               postTransactionResponseBody202CollateralId = postTransactionResponseBody202CollateralId,
                                                                                                                                                                               postTransactionResponseBody202CollateralIndex = postTransactionResponseBody202CollateralIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionResponseBody202CollateralAmount = PostTransactionResponseBody202CollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202CollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202CollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202CollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202CollateralAmount" (\obj -> GHC.Base.pure PostTransactionResponseBody202CollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202CollateralAmount' with all required fields.
mkPostTransactionResponseBody202CollateralAmount :: GHC.Types.Int -- ^ 'postTransactionResponseBody202CollateralAmountQuantity'
  -> PostTransactionResponseBody202CollateralAmount
mkPostTransactionResponseBody202CollateralAmount postTransactionResponseBody202CollateralAmountQuantity = PostTransactionResponseBody202CollateralAmount{postTransactionResponseBody202CollateralAmountQuantity = postTransactionResponseBody202CollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.collateral_outputs.items@ in the specification.
-- 
-- 
data PostTransactionResponseBody202Collateral_outputs = PostTransactionResponseBody202Collateral_outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  postTransactionResponseBody202Collateral_outputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionResponseBody202Collateral_outputsAmount :: PostTransactionResponseBody202Collateral_outputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , postTransactionResponseBody202Collateral_outputsAssets :: (GHC.Maybe.Maybe ([PostTransactionResponseBody202Collateral_outputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Collateral_outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Collateral_outputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202Collateral_outputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Collateral_outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Collateral_outputs" (\obj -> ((GHC.Base.pure PostTransactionResponseBody202Collateral_outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'PostTransactionResponseBody202Collateral_outputs' with all required fields.
mkPostTransactionResponseBody202Collateral_outputs :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202Collateral_outputsAddress'
  -> PostTransactionResponseBody202Collateral_outputsAmount -- ^ 'postTransactionResponseBody202Collateral_outputsAmount'
  -> PostTransactionResponseBody202Collateral_outputs
mkPostTransactionResponseBody202Collateral_outputs postTransactionResponseBody202Collateral_outputsAddress postTransactionResponseBody202Collateral_outputsAmount = PostTransactionResponseBody202Collateral_outputs{postTransactionResponseBody202Collateral_outputsAddress = postTransactionResponseBody202Collateral_outputsAddress,
                                                                                                                                                                                                                     postTransactionResponseBody202Collateral_outputsAmount = postTransactionResponseBody202Collateral_outputsAmount,
                                                                                                                                                                                                                     postTransactionResponseBody202Collateral_outputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.collateral_outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionResponseBody202Collateral_outputsAmount = PostTransactionResponseBody202Collateral_outputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202Collateral_outputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Collateral_outputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Collateral_outputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Collateral_outputsAmount" (\obj -> GHC.Base.pure PostTransactionResponseBody202Collateral_outputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202Collateral_outputsAmount' with all required fields.
mkPostTransactionResponseBody202Collateral_outputsAmount :: GHC.Types.Int -- ^ 'postTransactionResponseBody202Collateral_outputsAmountQuantity'
  -> PostTransactionResponseBody202Collateral_outputsAmount
mkPostTransactionResponseBody202Collateral_outputsAmount postTransactionResponseBody202Collateral_outputsAmountQuantity = PostTransactionResponseBody202Collateral_outputsAmount{postTransactionResponseBody202Collateral_outputsAmountQuantity = postTransactionResponseBody202Collateral_outputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.collateral_outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostTransactionResponseBody202Collateral_outputsAssets = PostTransactionResponseBody202Collateral_outputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postTransactionResponseBody202Collateral_outputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postTransactionResponseBody202Collateral_outputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202Collateral_outputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Collateral_outputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Collateral_outputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Collateral_outputsAssets" (\obj -> ((GHC.Base.pure PostTransactionResponseBody202Collateral_outputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202Collateral_outputsAssets' with all required fields.
mkPostTransactionResponseBody202Collateral_outputsAssets :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202Collateral_outputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202Collateral_outputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202Collateral_outputsAssetsQuantity'
  -> PostTransactionResponseBody202Collateral_outputsAssets
mkPostTransactionResponseBody202Collateral_outputsAssets postTransactionResponseBody202Collateral_outputsAssetsAsset_name postTransactionResponseBody202Collateral_outputsAssetsPolicy_id postTransactionResponseBody202Collateral_outputsAssetsQuantity = PostTransactionResponseBody202Collateral_outputsAssets{postTransactionResponseBody202Collateral_outputsAssetsAsset_name = postTransactionResponseBody202Collateral_outputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                  postTransactionResponseBody202Collateral_outputsAssetsPolicy_id = postTransactionResponseBody202Collateral_outputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                  postTransactionResponseBody202Collateral_outputsAssetsQuantity = postTransactionResponseBody202Collateral_outputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.deposit_returned@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionResponseBody202Deposit_returned = PostTransactionResponseBody202Deposit_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202Deposit_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Deposit_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Deposit_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Deposit_returned" (\obj -> GHC.Base.pure PostTransactionResponseBody202Deposit_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202Deposit_returned' with all required fields.
mkPostTransactionResponseBody202Deposit_returned :: GHC.Types.Int -- ^ 'postTransactionResponseBody202Deposit_returnedQuantity'
  -> PostTransactionResponseBody202Deposit_returned
mkPostTransactionResponseBody202Deposit_returned postTransactionResponseBody202Deposit_returnedQuantity = PostTransactionResponseBody202Deposit_returned{postTransactionResponseBody202Deposit_returnedQuantity = postTransactionResponseBody202Deposit_returnedQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.deposit_taken@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionResponseBody202Deposit_taken = PostTransactionResponseBody202Deposit_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202Deposit_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Deposit_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Deposit_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Deposit_taken" (\obj -> GHC.Base.pure PostTransactionResponseBody202Deposit_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202Deposit_taken' with all required fields.
mkPostTransactionResponseBody202Deposit_taken :: GHC.Types.Int -- ^ 'postTransactionResponseBody202Deposit_takenQuantity'
  -> PostTransactionResponseBody202Deposit_taken
mkPostTransactionResponseBody202Deposit_taken postTransactionResponseBody202Deposit_takenQuantity = PostTransactionResponseBody202Deposit_taken{postTransactionResponseBody202Deposit_takenQuantity = postTransactionResponseBody202Deposit_takenQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.depth@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Current depth of the transaction in the local chain
data PostTransactionResponseBody202Depth = PostTransactionResponseBody202Depth {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202DepthQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Depth
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Depth
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Depth" (\obj -> GHC.Base.pure PostTransactionResponseBody202Depth GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202Depth' with all required fields.
mkPostTransactionResponseBody202Depth :: GHC.Types.Int -- ^ 'postTransactionResponseBody202DepthQuantity'
  -> PostTransactionResponseBody202Depth
mkPostTransactionResponseBody202Depth postTransactionResponseBody202DepthQuantity = PostTransactionResponseBody202Depth{postTransactionResponseBody202DepthQuantity = postTransactionResponseBody202DepthQuantity}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.direction@ in the specification.
-- 
-- 
data PostTransactionResponseBody202Direction =
   PostTransactionResponseBody202DirectionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostTransactionResponseBody202DirectionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostTransactionResponseBody202DirectionEnumOutgoing -- ^ Represents the JSON value @"outgoing"@
  | PostTransactionResponseBody202DirectionEnumIncoming -- ^ Represents the JSON value @"incoming"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Direction
    where toJSON (PostTransactionResponseBody202DirectionOther val) = val
          toJSON (PostTransactionResponseBody202DirectionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostTransactionResponseBody202DirectionEnumOutgoing) = "outgoing"
          toJSON (PostTransactionResponseBody202DirectionEnumIncoming) = "incoming"
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Direction
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "outgoing" -> PostTransactionResponseBody202DirectionEnumOutgoing
                                            | val GHC.Classes.== "incoming" -> PostTransactionResponseBody202DirectionEnumIncoming
                                            | GHC.Base.otherwise -> PostTransactionResponseBody202DirectionOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.expires_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending OR status == expired
-- \<\/span>\<br\/>
-- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
data PostTransactionResponseBody202Expires_at = PostTransactionResponseBody202Expires_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202Expires_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202Expires_atEpoch_number :: GHC.Types.Int
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202Expires_atSlot_number :: GHC.Types.Int
  -- | time
  , postTransactionResponseBody202Expires_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Expires_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Expires_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Expires_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Expires_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Expires_at" (\obj -> (((GHC.Base.pure PostTransactionResponseBody202Expires_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'PostTransactionResponseBody202Expires_at' with all required fields.
mkPostTransactionResponseBody202Expires_at :: GHC.Types.Int -- ^ 'postTransactionResponseBody202Expires_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202Expires_atEpoch_number'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202Expires_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202Expires_atTime'
  -> PostTransactionResponseBody202Expires_at
mkPostTransactionResponseBody202Expires_at postTransactionResponseBody202Expires_atAbsolute_slot_number postTransactionResponseBody202Expires_atEpoch_number postTransactionResponseBody202Expires_atSlot_number postTransactionResponseBody202Expires_atTime = PostTransactionResponseBody202Expires_at{postTransactionResponseBody202Expires_atAbsolute_slot_number = postTransactionResponseBody202Expires_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                         postTransactionResponseBody202Expires_atEpoch_number = postTransactionResponseBody202Expires_atEpoch_number,
                                                                                                                                                                                                                                                                                                         postTransactionResponseBody202Expires_atSlot_number = postTransactionResponseBody202Expires_atSlot_number,
                                                                                                                                                                                                                                                                                                         postTransactionResponseBody202Expires_atTime = postTransactionResponseBody202Expires_atTime}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.fee@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionResponseBody202Fee = PostTransactionResponseBody202Fee {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202FeeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Fee
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Fee
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Fee" (\obj -> GHC.Base.pure PostTransactionResponseBody202Fee GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202Fee' with all required fields.
mkPostTransactionResponseBody202Fee :: GHC.Types.Int -- ^ 'postTransactionResponseBody202FeeQuantity'
  -> PostTransactionResponseBody202Fee
mkPostTransactionResponseBody202Fee postTransactionResponseBody202FeeQuantity = PostTransactionResponseBody202Fee{postTransactionResponseBody202FeeQuantity = postTransactionResponseBody202FeeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.inputs.items@ in the specification.
-- 
-- 
data PostTransactionResponseBody202Inputs = PostTransactionResponseBody202Inputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  postTransactionResponseBody202InputsAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionResponseBody202InputsAmount :: (GHC.Maybe.Maybe PostTransactionResponseBody202InputsAmount)
  -- | assets: A flat list of assets (possibly empty).
  , postTransactionResponseBody202InputsAssets :: (GHC.Maybe.Maybe ([PostTransactionResponseBody202InputsAssets]))
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , postTransactionResponseBody202InputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202InputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Inputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202InputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202InputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Inputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Inputs" (\obj -> ((((GHC.Base.pure PostTransactionResponseBody202Inputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostTransactionResponseBody202Inputs' with all required fields.
mkPostTransactionResponseBody202Inputs :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202InputsId'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202InputsIndex'
  -> PostTransactionResponseBody202Inputs
mkPostTransactionResponseBody202Inputs postTransactionResponseBody202InputsId postTransactionResponseBody202InputsIndex = PostTransactionResponseBody202Inputs{postTransactionResponseBody202InputsAddress = GHC.Maybe.Nothing,
                                                                                                                                                               postTransactionResponseBody202InputsAmount = GHC.Maybe.Nothing,
                                                                                                                                                               postTransactionResponseBody202InputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                               postTransactionResponseBody202InputsId = postTransactionResponseBody202InputsId,
                                                                                                                                                               postTransactionResponseBody202InputsIndex = postTransactionResponseBody202InputsIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionResponseBody202InputsAmount = PostTransactionResponseBody202InputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202InputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202InputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202InputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202InputsAmount" (\obj -> GHC.Base.pure PostTransactionResponseBody202InputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202InputsAmount' with all required fields.
mkPostTransactionResponseBody202InputsAmount :: GHC.Types.Int -- ^ 'postTransactionResponseBody202InputsAmountQuantity'
  -> PostTransactionResponseBody202InputsAmount
mkPostTransactionResponseBody202InputsAmount postTransactionResponseBody202InputsAmountQuantity = PostTransactionResponseBody202InputsAmount{postTransactionResponseBody202InputsAmountQuantity = postTransactionResponseBody202InputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostTransactionResponseBody202InputsAssets = PostTransactionResponseBody202InputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postTransactionResponseBody202InputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postTransactionResponseBody202InputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202InputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202InputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202InputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202InputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202InputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202InputsAssets" (\obj -> ((GHC.Base.pure PostTransactionResponseBody202InputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202InputsAssets' with all required fields.
mkPostTransactionResponseBody202InputsAssets :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202InputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202InputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202InputsAssetsQuantity'
  -> PostTransactionResponseBody202InputsAssets
mkPostTransactionResponseBody202InputsAssets postTransactionResponseBody202InputsAssetsAsset_name postTransactionResponseBody202InputsAssetsPolicy_id postTransactionResponseBody202InputsAssetsQuantity = PostTransactionResponseBody202InputsAssets{postTransactionResponseBody202InputsAssetsAsset_name = postTransactionResponseBody202InputsAssetsAsset_name,
                                                                                                                                                                                                                                                      postTransactionResponseBody202InputsAssetsPolicy_id = postTransactionResponseBody202InputsAssetsPolicy_id,
                                                                                                                                                                                                                                                      postTransactionResponseBody202InputsAssetsQuantity = postTransactionResponseBody202InputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.inserted_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Absolute time at which the transaction was inserted in a block.
data PostTransactionResponseBody202Inserted_at = PostTransactionResponseBody202Inserted_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202Inserted_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202Inserted_atEpoch_number :: GHC.Types.Int
  -- | height
  , postTransactionResponseBody202Inserted_atHeight :: PostTransactionResponseBody202Inserted_atHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202Inserted_atSlot_number :: GHC.Types.Int
  -- | time
  , postTransactionResponseBody202Inserted_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Inserted_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Inserted_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Inserted_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Inserted_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Inserted_at" (\obj -> ((((GHC.Base.pure PostTransactionResponseBody202Inserted_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'PostTransactionResponseBody202Inserted_at' with all required fields.
mkPostTransactionResponseBody202Inserted_at :: GHC.Types.Int -- ^ 'postTransactionResponseBody202Inserted_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202Inserted_atEpoch_number'
  -> PostTransactionResponseBody202Inserted_atHeight -- ^ 'postTransactionResponseBody202Inserted_atHeight'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202Inserted_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202Inserted_atTime'
  -> PostTransactionResponseBody202Inserted_at
mkPostTransactionResponseBody202Inserted_at postTransactionResponseBody202Inserted_atAbsolute_slot_number postTransactionResponseBody202Inserted_atEpoch_number postTransactionResponseBody202Inserted_atHeight postTransactionResponseBody202Inserted_atSlot_number postTransactionResponseBody202Inserted_atTime = PostTransactionResponseBody202Inserted_at{postTransactionResponseBody202Inserted_atAbsolute_slot_number = postTransactionResponseBody202Inserted_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                               postTransactionResponseBody202Inserted_atEpoch_number = postTransactionResponseBody202Inserted_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                                               postTransactionResponseBody202Inserted_atHeight = postTransactionResponseBody202Inserted_atHeight,
                                                                                                                                                                                                                                                                                                                                                               postTransactionResponseBody202Inserted_atSlot_number = postTransactionResponseBody202Inserted_atSlot_number,
                                                                                                                                                                                                                                                                                                                                                               postTransactionResponseBody202Inserted_atTime = postTransactionResponseBody202Inserted_atTime}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.inserted_at.properties.height@ in the specification.
-- 
-- 
data PostTransactionResponseBody202Inserted_atHeight = PostTransactionResponseBody202Inserted_atHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202Inserted_atHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Inserted_atHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Inserted_atHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Inserted_atHeight" (\obj -> GHC.Base.pure PostTransactionResponseBody202Inserted_atHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202Inserted_atHeight' with all required fields.
mkPostTransactionResponseBody202Inserted_atHeight :: GHC.Types.Int -- ^ 'postTransactionResponseBody202Inserted_atHeightQuantity'
  -> PostTransactionResponseBody202Inserted_atHeight
mkPostTransactionResponseBody202Inserted_atHeight postTransactionResponseBody202Inserted_atHeightQuantity = PostTransactionResponseBody202Inserted_atHeight{postTransactionResponseBody202Inserted_atHeightQuantity = postTransactionResponseBody202Inserted_atHeightQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint@ in the specification.
-- 
-- 
data PostTransactionResponseBody202Mint = PostTransactionResponseBody202Mint {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  postTransactionResponseBody202MintTokens :: ([PostTransactionResponseBody202MintTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , postTransactionResponseBody202MintWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , postTransactionResponseBody202MintWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Mint
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202MintWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202MintWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Mint
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Mint" (\obj -> ((GHC.Base.pure PostTransactionResponseBody202Mint GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'PostTransactionResponseBody202Mint' with all required fields.
mkPostTransactionResponseBody202Mint :: [PostTransactionResponseBody202MintTokens] -- ^ 'postTransactionResponseBody202MintTokens'
  -> PostTransactionResponseBody202Mint
mkPostTransactionResponseBody202Mint postTransactionResponseBody202MintTokens = PostTransactionResponseBody202Mint{postTransactionResponseBody202MintTokens = postTransactionResponseBody202MintTokens,
                                                                                                                   postTransactionResponseBody202MintWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                   postTransactionResponseBody202MintWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items@ in the specification.
-- 
-- 
data PostTransactionResponseBody202MintTokens = PostTransactionResponseBody202MintTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postTransactionResponseBody202MintTokensAssets :: ([PostTransactionResponseBody202MintTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postTransactionResponseBody202MintTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , postTransactionResponseBody202MintTokensPolicy_script :: PostTransactionResponseBody202MintTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202MintTokens" (\obj -> ((GHC.Base.pure PostTransactionResponseBody202MintTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'PostTransactionResponseBody202MintTokens' with all required fields.
mkPostTransactionResponseBody202MintTokens :: [PostTransactionResponseBody202MintTokensAssets] -- ^ 'postTransactionResponseBody202MintTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202MintTokensPolicy_id'
  -> PostTransactionResponseBody202MintTokensPolicy_scriptVariants -- ^ 'postTransactionResponseBody202MintTokensPolicy_script'
  -> PostTransactionResponseBody202MintTokens
mkPostTransactionResponseBody202MintTokens postTransactionResponseBody202MintTokensAssets postTransactionResponseBody202MintTokensPolicy_id postTransactionResponseBody202MintTokensPolicy_script = PostTransactionResponseBody202MintTokens{postTransactionResponseBody202MintTokensAssets = postTransactionResponseBody202MintTokensAssets,
                                                                                                                                                                                                                                             postTransactionResponseBody202MintTokensPolicy_id = postTransactionResponseBody202MintTokensPolicy_id,
                                                                                                                                                                                                                                             postTransactionResponseBody202MintTokensPolicy_script = postTransactionResponseBody202MintTokensPolicy_script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data PostTransactionResponseBody202MintTokensAssets = PostTransactionResponseBody202MintTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postTransactionResponseBody202MintTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , postTransactionResponseBody202MintTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202MintTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202MintTokensAssets" (\obj -> ((GHC.Base.pure PostTransactionResponseBody202MintTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202MintTokensAssets' with all required fields.
mkPostTransactionResponseBody202MintTokensAssets :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202MintTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202MintTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202MintTokensAssetsQuantity'
  -> PostTransactionResponseBody202MintTokensAssets
mkPostTransactionResponseBody202MintTokensAssets postTransactionResponseBody202MintTokensAssetsAsset_name postTransactionResponseBody202MintTokensAssetsFingerprint postTransactionResponseBody202MintTokensAssetsQuantity = PostTransactionResponseBody202MintTokensAssets{postTransactionResponseBody202MintTokensAssetsAsset_name = postTransactionResponseBody202MintTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                            postTransactionResponseBody202MintTokensAssetsFingerprint = postTransactionResponseBody202MintTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                            postTransactionResponseBody202MintTokensAssetsQuantity = postTransactionResponseBody202MintTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1 = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  postTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference)
  -- | script
  , postTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script :: PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1' with all required fields.
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1 :: PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script'
  -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1 postTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1{postTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                              postTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script = postTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference' with all required fields.
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex'
  -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference{postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId = postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                               postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex = postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2{postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All = postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3{postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 :: PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4{postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some{postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5{postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6{postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = postTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants =
   PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
  | PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
  | PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
  | PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
  | PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2 = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info :: PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2' with all required fields.
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf2 :: PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info'
  -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf2 postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2{postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                   postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info = postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  postTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference' with all required fields.
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex'
  -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference postTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId postTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference{postTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId = postTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                               postTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex = postTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version :: PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info :: PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info{postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version = postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                           postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash = postTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3 = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postTransactionResponseBody202MintTokensPolicy_scriptOneOf3References :: ([PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3' with all required fields.
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf3 :: [PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3References] -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash'
  -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf3 postTransactionResponseBody202MintTokensPolicy_scriptOneOf3References postTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3{postTransactionResponseBody202MintTokensPolicy_scriptOneOf3References = postTransactionResponseBody202MintTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                         postTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash = postTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3References = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  postTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3References' with all required fields.
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex'
  -> PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3References
mkPostTransactionResponseBody202MintTokensPolicy_scriptOneOf3References postTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId postTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex = PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3References{postTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId = postTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                   postTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex = postTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody202MintTokensPolicy_scriptVariants =
   PostTransactionResponseBody202MintTokensPolicy_scriptVariant1 PostTransactionResponseBody202MintTokensPolicy_scriptOneOf1
  | PostTransactionResponseBody202MintTokensPolicy_scriptVariant2 PostTransactionResponseBody202MintTokensPolicy_scriptOneOf2
  | PostTransactionResponseBody202MintTokensPolicy_scriptVariant3 PostTransactionResponseBody202MintTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202MintTokensPolicy_scriptVariants
    where toJSON (PostTransactionResponseBody202MintTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202MintTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody202MintTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202MintTokensPolicy_scriptVariants
    where parseJSON val = case (PostTransactionResponseBody202MintTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202MintTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody202MintTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.outputs.items@ in the specification.
-- 
-- 
data PostTransactionResponseBody202Outputs = PostTransactionResponseBody202Outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  postTransactionResponseBody202OutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionResponseBody202OutputsAmount :: PostTransactionResponseBody202OutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , postTransactionResponseBody202OutputsAssets :: (GHC.Maybe.Maybe ([PostTransactionResponseBody202OutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202OutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody202OutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Outputs" (\obj -> ((GHC.Base.pure PostTransactionResponseBody202Outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'PostTransactionResponseBody202Outputs' with all required fields.
mkPostTransactionResponseBody202Outputs :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202OutputsAddress'
  -> PostTransactionResponseBody202OutputsAmount -- ^ 'postTransactionResponseBody202OutputsAmount'
  -> PostTransactionResponseBody202Outputs
mkPostTransactionResponseBody202Outputs postTransactionResponseBody202OutputsAddress postTransactionResponseBody202OutputsAmount = PostTransactionResponseBody202Outputs{postTransactionResponseBody202OutputsAddress = postTransactionResponseBody202OutputsAddress,
                                                                                                                                                                         postTransactionResponseBody202OutputsAmount = postTransactionResponseBody202OutputsAmount,
                                                                                                                                                                         postTransactionResponseBody202OutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionResponseBody202OutputsAmount = PostTransactionResponseBody202OutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202OutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202OutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202OutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202OutputsAmount" (\obj -> GHC.Base.pure PostTransactionResponseBody202OutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202OutputsAmount' with all required fields.
mkPostTransactionResponseBody202OutputsAmount :: GHC.Types.Int -- ^ 'postTransactionResponseBody202OutputsAmountQuantity'
  -> PostTransactionResponseBody202OutputsAmount
mkPostTransactionResponseBody202OutputsAmount postTransactionResponseBody202OutputsAmountQuantity = PostTransactionResponseBody202OutputsAmount{postTransactionResponseBody202OutputsAmountQuantity = postTransactionResponseBody202OutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostTransactionResponseBody202OutputsAssets = PostTransactionResponseBody202OutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postTransactionResponseBody202OutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postTransactionResponseBody202OutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202OutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202OutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202OutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202OutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202OutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202OutputsAssets" (\obj -> ((GHC.Base.pure PostTransactionResponseBody202OutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202OutputsAssets' with all required fields.
mkPostTransactionResponseBody202OutputsAssets :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202OutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202OutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202OutputsAssetsQuantity'
  -> PostTransactionResponseBody202OutputsAssets
mkPostTransactionResponseBody202OutputsAssets postTransactionResponseBody202OutputsAssetsAsset_name postTransactionResponseBody202OutputsAssetsPolicy_id postTransactionResponseBody202OutputsAssetsQuantity = PostTransactionResponseBody202OutputsAssets{postTransactionResponseBody202OutputsAssetsAsset_name = postTransactionResponseBody202OutputsAssetsAsset_name,
                                                                                                                                                                                                                                                           postTransactionResponseBody202OutputsAssetsPolicy_id = postTransactionResponseBody202OutputsAssetsPolicy_id,
                                                                                                                                                                                                                                                           postTransactionResponseBody202OutputsAssetsQuantity = postTransactionResponseBody202OutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.pending_since@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending
-- \<\/span>\<br\/>
-- The point in time at which a transaction became pending.
data PostTransactionResponseBody202Pending_since = PostTransactionResponseBody202Pending_since {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202Pending_sinceAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202Pending_sinceEpoch_number :: GHC.Types.Int
  -- | height
  , postTransactionResponseBody202Pending_sinceHeight :: PostTransactionResponseBody202Pending_sinceHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postTransactionResponseBody202Pending_sinceSlot_number :: GHC.Types.Int
  -- | time
  , postTransactionResponseBody202Pending_sinceTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Pending_since
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Pending_sinceTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Pending_sinceTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Pending_since
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Pending_since" (\obj -> ((((GHC.Base.pure PostTransactionResponseBody202Pending_since GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'PostTransactionResponseBody202Pending_since' with all required fields.
mkPostTransactionResponseBody202Pending_since :: GHC.Types.Int -- ^ 'postTransactionResponseBody202Pending_sinceAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202Pending_sinceEpoch_number'
  -> PostTransactionResponseBody202Pending_sinceHeight -- ^ 'postTransactionResponseBody202Pending_sinceHeight'
  -> GHC.Types.Int -- ^ 'postTransactionResponseBody202Pending_sinceSlot_number'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202Pending_sinceTime'
  -> PostTransactionResponseBody202Pending_since
mkPostTransactionResponseBody202Pending_since postTransactionResponseBody202Pending_sinceAbsolute_slot_number postTransactionResponseBody202Pending_sinceEpoch_number postTransactionResponseBody202Pending_sinceHeight postTransactionResponseBody202Pending_sinceSlot_number postTransactionResponseBody202Pending_sinceTime = PostTransactionResponseBody202Pending_since{postTransactionResponseBody202Pending_sinceAbsolute_slot_number = postTransactionResponseBody202Pending_sinceAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                             postTransactionResponseBody202Pending_sinceEpoch_number = postTransactionResponseBody202Pending_sinceEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                             postTransactionResponseBody202Pending_sinceHeight = postTransactionResponseBody202Pending_sinceHeight,
                                                                                                                                                                                                                                                                                                                                                                             postTransactionResponseBody202Pending_sinceSlot_number = postTransactionResponseBody202Pending_sinceSlot_number,
                                                                                                                                                                                                                                                                                                                                                                             postTransactionResponseBody202Pending_sinceTime = postTransactionResponseBody202Pending_sinceTime}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.pending_since.properties.height@ in the specification.
-- 
-- 
data PostTransactionResponseBody202Pending_sinceHeight = PostTransactionResponseBody202Pending_sinceHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202Pending_sinceHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Pending_sinceHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Pending_sinceHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Pending_sinceHeight" (\obj -> GHC.Base.pure PostTransactionResponseBody202Pending_sinceHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202Pending_sinceHeight' with all required fields.
mkPostTransactionResponseBody202Pending_sinceHeight :: GHC.Types.Int -- ^ 'postTransactionResponseBody202Pending_sinceHeightQuantity'
  -> PostTransactionResponseBody202Pending_sinceHeight
mkPostTransactionResponseBody202Pending_sinceHeight postTransactionResponseBody202Pending_sinceHeightQuantity = PostTransactionResponseBody202Pending_sinceHeight{postTransactionResponseBody202Pending_sinceHeightQuantity = postTransactionResponseBody202Pending_sinceHeightQuantity}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.script_validity@ in the specification.
-- 
-- Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
-- used in the transaction validated or not. Validity may be null if this
-- transaction was from an era that doesn\'t support phase-2 monetary policy
-- scripts, or is a pending transaction (we don\'t know if validation passed or
-- failed until the transaction hits the ledger).
data PostTransactionResponseBody202Script_validityNonNullable =
   PostTransactionResponseBody202Script_validityNonNullableOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostTransactionResponseBody202Script_validityNonNullableTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostTransactionResponseBody202Script_validityNonNullableEnumValid -- ^ Represents the JSON value @"valid"@
  | PostTransactionResponseBody202Script_validityNonNullableEnumInvalid -- ^ Represents the JSON value @"invalid"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Script_validityNonNullable
    where toJSON (PostTransactionResponseBody202Script_validityNonNullableOther val) = val
          toJSON (PostTransactionResponseBody202Script_validityNonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostTransactionResponseBody202Script_validityNonNullableEnumValid) = "valid"
          toJSON (PostTransactionResponseBody202Script_validityNonNullableEnumInvalid) = "invalid"
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Script_validityNonNullable
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "valid" -> PostTransactionResponseBody202Script_validityNonNullableEnumValid
                                            | val GHC.Classes.== "invalid" -> PostTransactionResponseBody202Script_validityNonNullableEnumInvalid
                                            | GHC.Base.otherwise -> PostTransactionResponseBody202Script_validityNonNullableOther val)
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.status@ in the specification.
-- 
-- Current transaction status.
-- 
--   \`\`\`
--        *-----------*
--   ---> |  PENDING  |----------------*
--        *-----------*                |
--              |                      |
--              V                      V
--        *-----------*          *-----------*
--        |           |---------->  EXPIRED  |
--        |           |  (ttl)   *-----------*
--        | SUBMITTED |
--        |           \<----------------*
--        |           |                |
--        *-----------*           (rollback)
--               |                     |
--          (in ledger)          *-----------*
--               |               |           |
--               *---------------> IN_LEDGER |
--                               |           |
--                               *-----------*
--   \`\`\`
data PostTransactionResponseBody202Status =
   PostTransactionResponseBody202StatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostTransactionResponseBody202StatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostTransactionResponseBody202StatusEnumPending -- ^ Represents the JSON value @"pending"@
  | PostTransactionResponseBody202StatusEnumSubmitted -- ^ Represents the JSON value @"submitted"@
  | PostTransactionResponseBody202StatusEnumIn_ledger -- ^ Represents the JSON value @"in_ledger"@
  | PostTransactionResponseBody202StatusEnumExpired -- ^ Represents the JSON value @"expired"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Status
    where toJSON (PostTransactionResponseBody202StatusOther val) = val
          toJSON (PostTransactionResponseBody202StatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostTransactionResponseBody202StatusEnumPending) = "pending"
          toJSON (PostTransactionResponseBody202StatusEnumSubmitted) = "submitted"
          toJSON (PostTransactionResponseBody202StatusEnumIn_ledger) = "in_ledger"
          toJSON (PostTransactionResponseBody202StatusEnumExpired) = "expired"
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Status
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "pending" -> PostTransactionResponseBody202StatusEnumPending
                                            | val GHC.Classes.== "submitted" -> PostTransactionResponseBody202StatusEnumSubmitted
                                            | val GHC.Classes.== "in_ledger" -> PostTransactionResponseBody202StatusEnumIn_ledger
                                            | val GHC.Classes.== "expired" -> PostTransactionResponseBody202StatusEnumExpired
                                            | GHC.Base.otherwise -> PostTransactionResponseBody202StatusOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.validity_interval@ in the specification.
-- 
-- 
data PostTransactionResponseBody202Validity_interval = PostTransactionResponseBody202Validity_interval {
  -- | invalid_before
  postTransactionResponseBody202Validity_intervalInvalid_before :: PostTransactionResponseBody202Validity_intervalInvalid_before
  -- | invalid_hereafter
  , postTransactionResponseBody202Validity_intervalInvalid_hereafter :: PostTransactionResponseBody202Validity_intervalInvalid_hereafter
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Validity_interval
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Validity_interval
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Validity_interval" (\obj -> (GHC.Base.pure PostTransactionResponseBody202Validity_interval GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_before")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_hereafter"))
-- | Create a new 'PostTransactionResponseBody202Validity_interval' with all required fields.
mkPostTransactionResponseBody202Validity_interval :: PostTransactionResponseBody202Validity_intervalInvalid_before -- ^ 'postTransactionResponseBody202Validity_intervalInvalid_before'
  -> PostTransactionResponseBody202Validity_intervalInvalid_hereafter -- ^ 'postTransactionResponseBody202Validity_intervalInvalid_hereafter'
  -> PostTransactionResponseBody202Validity_interval
mkPostTransactionResponseBody202Validity_interval postTransactionResponseBody202Validity_intervalInvalid_before postTransactionResponseBody202Validity_intervalInvalid_hereafter = PostTransactionResponseBody202Validity_interval{postTransactionResponseBody202Validity_intervalInvalid_before = postTransactionResponseBody202Validity_intervalInvalid_before,
                                                                                                                                                                                                                                   postTransactionResponseBody202Validity_intervalInvalid_hereafter = postTransactionResponseBody202Validity_intervalInvalid_hereafter}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.validity_interval.properties.invalid_before@ in the specification.
-- 
-- 
data PostTransactionResponseBody202Validity_intervalInvalid_before = PostTransactionResponseBody202Validity_intervalInvalid_before {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202Validity_intervalInvalid_beforeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Validity_intervalInvalid_before
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Validity_intervalInvalid_before
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Validity_intervalInvalid_before" (\obj -> GHC.Base.pure PostTransactionResponseBody202Validity_intervalInvalid_before GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202Validity_intervalInvalid_before' with all required fields.
mkPostTransactionResponseBody202Validity_intervalInvalid_before :: GHC.Types.Int -- ^ 'postTransactionResponseBody202Validity_intervalInvalid_beforeQuantity'
  -> PostTransactionResponseBody202Validity_intervalInvalid_before
mkPostTransactionResponseBody202Validity_intervalInvalid_before postTransactionResponseBody202Validity_intervalInvalid_beforeQuantity = PostTransactionResponseBody202Validity_intervalInvalid_before{postTransactionResponseBody202Validity_intervalInvalid_beforeQuantity = postTransactionResponseBody202Validity_intervalInvalid_beforeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.validity_interval.properties.invalid_hereafter@ in the specification.
-- 
-- 
data PostTransactionResponseBody202Validity_intervalInvalid_hereafter = PostTransactionResponseBody202Validity_intervalInvalid_hereafter {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Validity_intervalInvalid_hereafter
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Validity_intervalInvalid_hereafter
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Validity_intervalInvalid_hereafter" (\obj -> GHC.Base.pure PostTransactionResponseBody202Validity_intervalInvalid_hereafter GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202Validity_intervalInvalid_hereafter' with all required fields.
mkPostTransactionResponseBody202Validity_intervalInvalid_hereafter :: GHC.Types.Int -- ^ 'postTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity'
  -> PostTransactionResponseBody202Validity_intervalInvalid_hereafter
mkPostTransactionResponseBody202Validity_intervalInvalid_hereafter postTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity = PostTransactionResponseBody202Validity_intervalInvalid_hereafter{postTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity = postTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.withdrawals.items@ in the specification.
-- 
-- 
data PostTransactionResponseBody202Withdrawals = PostTransactionResponseBody202Withdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  postTransactionResponseBody202WithdrawalsAmount :: PostTransactionResponseBody202WithdrawalsAmount
  -- | stake_address
  , postTransactionResponseBody202WithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202Withdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202WithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202WithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202Withdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202Withdrawals" (\obj -> (GHC.Base.pure PostTransactionResponseBody202Withdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'PostTransactionResponseBody202Withdrawals' with all required fields.
mkPostTransactionResponseBody202Withdrawals :: PostTransactionResponseBody202WithdrawalsAmount -- ^ 'postTransactionResponseBody202WithdrawalsAmount'
  -> Data.Text.Internal.Text -- ^ 'postTransactionResponseBody202WithdrawalsStake_address'
  -> PostTransactionResponseBody202Withdrawals
mkPostTransactionResponseBody202Withdrawals postTransactionResponseBody202WithdrawalsAmount postTransactionResponseBody202WithdrawalsStake_address = PostTransactionResponseBody202Withdrawals{postTransactionResponseBody202WithdrawalsAmount = postTransactionResponseBody202WithdrawalsAmount,
                                                                                                                                                                                               postTransactionResponseBody202WithdrawalsStake_address = postTransactionResponseBody202WithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionResponseBody202WithdrawalsAmount = PostTransactionResponseBody202WithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody202WithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody202WithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody202WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody202WithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody202WithdrawalsAmount" (\obj -> GHC.Base.pure PostTransactionResponseBody202WithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody202WithdrawalsAmount' with all required fields.
mkPostTransactionResponseBody202WithdrawalsAmount :: GHC.Types.Int -- ^ 'postTransactionResponseBody202WithdrawalsAmountQuantity'
  -> PostTransactionResponseBody202WithdrawalsAmount
mkPostTransactionResponseBody202WithdrawalsAmount postTransactionResponseBody202WithdrawalsAmountQuantity = PostTransactionResponseBody202WithdrawalsAmount{postTransactionResponseBody202WithdrawalsAmountQuantity = postTransactionResponseBody202WithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data PostTransactionResponseBody400 = PostTransactionResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  postTransactionResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody400" (\obj -> GHC.Base.pure PostTransactionResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionResponseBody400' with all required fields.
mkPostTransactionResponseBody400 :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody400Message'
  -> PostTransactionResponseBody400
mkPostTransactionResponseBody400 postTransactionResponseBody400Message = PostTransactionResponseBody400{postTransactionResponseBody400Message = postTransactionResponseBody400Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody403OneOf1 = PostTransactionResponseBody403OneOf1 {
  -- | message: May occur when trying to perform an operation not supported by this type of wallet.
  postTransactionResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody403OneOf1" (\obj -> GHC.Base.pure PostTransactionResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionResponseBody403OneOf1' with all required fields.
mkPostTransactionResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody403OneOf1Message'
  -> PostTransactionResponseBody403OneOf1
mkPostTransactionResponseBody403OneOf1 postTransactionResponseBody403OneOf1Message = PostTransactionResponseBody403OneOf1{postTransactionResponseBody403OneOf1Message = postTransactionResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody403OneOf2 = PostTransactionResponseBody403OneOf2 {
  -- | message: May occur when submitting a withdrawal while another withdrawal is pending.
  postTransactionResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody403OneOf2" (\obj -> GHC.Base.pure PostTransactionResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionResponseBody403OneOf2' with all required fields.
mkPostTransactionResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody403OneOf2Message'
  -> PostTransactionResponseBody403OneOf2
mkPostTransactionResponseBody403OneOf2 postTransactionResponseBody403OneOf2Message = PostTransactionResponseBody403OneOf2{postTransactionResponseBody403OneOf2Message = postTransactionResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody403OneOf3 = PostTransactionResponseBody403OneOf3 {
  -- | info
  postTransactionResponseBody403OneOf3Info :: (GHC.Maybe.Maybe PostTransactionResponseBody403OneOf3Info)
  -- | message: Occurs when a requested output has a quantity of lovelace that is below the minimum required by the ledger.
  , postTransactionResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody403OneOf3Info obj) : ["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (postTransactionResponseBody403OneOf3Info obj) : ["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody403OneOf3" (\obj -> (GHC.Base.pure PostTransactionResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "info")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionResponseBody403OneOf3' with all required fields.
mkPostTransactionResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody403OneOf3Message'
  -> PostTransactionResponseBody403OneOf3
mkPostTransactionResponseBody403OneOf3 postTransactionResponseBody403OneOf3Message = PostTransactionResponseBody403OneOf3{postTransactionResponseBody403OneOf3Info = GHC.Maybe.Nothing,
                                                                                                                          postTransactionResponseBody403OneOf3Message = postTransactionResponseBody403OneOf3Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf.properties.info@ in the specification.
-- 
-- 
data PostTransactionResponseBody403OneOf3Info = PostTransactionResponseBody403OneOf3Info {
  -- | tx_output_index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody403OneOf3InfoTx_output_index :: GHC.Types.Int
  -- | tx_output_lovelace_required_minimum: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum :: PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
  -- | tx_output_lovelace_specified: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified :: PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody403OneOf3Info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf3InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf3InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody403OneOf3Info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody403OneOf3Info" (\obj -> ((GHC.Base.pure PostTransactionResponseBody403OneOf3Info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_index")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_required_minimum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_specified"))
-- | Create a new 'PostTransactionResponseBody403OneOf3Info' with all required fields.
mkPostTransactionResponseBody403OneOf3Info :: GHC.Types.Int -- ^ 'postTransactionResponseBody403OneOf3InfoTx_output_index'
  -> PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum -- ^ 'postTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum'
  -> PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified -- ^ 'postTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified'
  -> PostTransactionResponseBody403OneOf3Info
mkPostTransactionResponseBody403OneOf3Info postTransactionResponseBody403OneOf3InfoTx_output_index postTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum postTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified = PostTransactionResponseBody403OneOf3Info{postTransactionResponseBody403OneOf3InfoTx_output_index = postTransactionResponseBody403OneOf3InfoTx_output_index,
                                                                                                                                                                                                                                                                                               postTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum = postTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum,
                                                                                                                                                                                                                                                                                               postTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified = postTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_required_minimum@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum = PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum" (\obj -> GHC.Base.pure PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum' with all required fields.
mkPostTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum :: GHC.Types.Int -- ^ 'postTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity'
  -> PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
mkPostTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum postTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity = PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum{postTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity = postTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_specified@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified = PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified" (\obj -> GHC.Base.pure PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified' with all required fields.
mkPostTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified :: GHC.Types.Int -- ^ 'postTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity'
  -> PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
mkPostTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified postTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity = PostTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified{postTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity = postTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody403OneOf4 = PostTransactionResponseBody403OneOf4 {
  -- | message: May occur when a transaction can\'t be balanced for fees.
  postTransactionResponseBody403OneOf4Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody403OneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody403OneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody403OneOf4" (\obj -> GHC.Base.pure PostTransactionResponseBody403OneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionResponseBody403OneOf4' with all required fields.
mkPostTransactionResponseBody403OneOf4 :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody403OneOf4Message'
  -> PostTransactionResponseBody403OneOf4
mkPostTransactionResponseBody403OneOf4 postTransactionResponseBody403OneOf4Message = PostTransactionResponseBody403OneOf4{postTransactionResponseBody403OneOf4Message = postTransactionResponseBody403OneOf4Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody403OneOf5 = PostTransactionResponseBody403OneOf5 {
  -- | message: May occur when there\'s not enough money in the wallet to cover a requested payment.
  postTransactionResponseBody403OneOf5Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody403OneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody403OneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody403OneOf5" (\obj -> GHC.Base.pure PostTransactionResponseBody403OneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionResponseBody403OneOf5' with all required fields.
mkPostTransactionResponseBody403OneOf5 :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody403OneOf5Message'
  -> PostTransactionResponseBody403OneOf5
mkPostTransactionResponseBody403OneOf5 postTransactionResponseBody403OneOf5Message = PostTransactionResponseBody403OneOf5{postTransactionResponseBody403OneOf5Message = postTransactionResponseBody403OneOf5Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody403OneOf6 = PostTransactionResponseBody403OneOf6 {
  -- | message: May occur when the total balance of pure ada UTxOs in the wallet is
  -- insufficient to cover the minimum collateral amount required for a
  -- transaction requiring collateral.
  postTransactionResponseBody403OneOf6Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody403OneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody403OneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody403OneOf6" (\obj -> GHC.Base.pure PostTransactionResponseBody403OneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionResponseBody403OneOf6' with all required fields.
mkPostTransactionResponseBody403OneOf6 :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody403OneOf6Message'
  -> PostTransactionResponseBody403OneOf6
mkPostTransactionResponseBody403OneOf6 postTransactionResponseBody403OneOf6Message = PostTransactionResponseBody403OneOf6{postTransactionResponseBody403OneOf6Message = postTransactionResponseBody403OneOf6Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody403OneOf7 = PostTransactionResponseBody403OneOf7 {
  -- | message: May occur when the wallet can\'t cover for all requested outputs without making the transaction too large.
  postTransactionResponseBody403OneOf7Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody403OneOf7
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_is_too_big"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_is_too_big"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody403OneOf7
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody403OneOf7" (\obj -> GHC.Base.pure PostTransactionResponseBody403OneOf7 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionResponseBody403OneOf7' with all required fields.
mkPostTransactionResponseBody403OneOf7 :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody403OneOf7Message'
  -> PostTransactionResponseBody403OneOf7
mkPostTransactionResponseBody403OneOf7 postTransactionResponseBody403OneOf7Message = PostTransactionResponseBody403OneOf7{postTransactionResponseBody403OneOf7Message = postTransactionResponseBody403OneOf7Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody403OneOf8 = PostTransactionResponseBody403OneOf8 {
  -- | message: May occur when an action require a signing key but the wallet has only access to verification keys.
  postTransactionResponseBody403OneOf8Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody403OneOf8
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody403OneOf8
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody403OneOf8" (\obj -> GHC.Base.pure PostTransactionResponseBody403OneOf8 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionResponseBody403OneOf8' with all required fields.
mkPostTransactionResponseBody403OneOf8 :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody403OneOf8Message'
  -> PostTransactionResponseBody403OneOf8
mkPostTransactionResponseBody403OneOf8 postTransactionResponseBody403OneOf8Message = PostTransactionResponseBody403OneOf8{postTransactionResponseBody403OneOf8Message = postTransactionResponseBody403OneOf8Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody403OneOf9 = PostTransactionResponseBody403OneOf9 {
  -- | message: May occur when the given spending passphrase is wrong.
  postTransactionResponseBody403OneOf9Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody403OneOf9
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody403OneOf9
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody403OneOf9" (\obj -> GHC.Base.pure PostTransactionResponseBody403OneOf9 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionResponseBody403OneOf9' with all required fields.
mkPostTransactionResponseBody403OneOf9 :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody403OneOf9Message'
  -> PostTransactionResponseBody403OneOf9
mkPostTransactionResponseBody403OneOf9 postTransactionResponseBody403OneOf9Message = PostTransactionResponseBody403OneOf9{postTransactionResponseBody403OneOf9Message = postTransactionResponseBody403OneOf9Message}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostTransactionResponseBody403Variants =
   PostTransactionResponseBody403Variant1 PostTransactionResponseBody403OneOf1
  | PostTransactionResponseBody403Variant2 PostTransactionResponseBody403OneOf2
  | PostTransactionResponseBody403Variant3 PostTransactionResponseBody403OneOf3
  | PostTransactionResponseBody403Variant4 PostTransactionResponseBody403OneOf4
  | PostTransactionResponseBody403Variant5 PostTransactionResponseBody403OneOf5
  | PostTransactionResponseBody403Variant6 PostTransactionResponseBody403OneOf6
  | PostTransactionResponseBody403Variant7 PostTransactionResponseBody403OneOf7
  | PostTransactionResponseBody403Variant8 PostTransactionResponseBody403OneOf8
  | PostTransactionResponseBody403Variant9 PostTransactionResponseBody403OneOf9
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody403Variants
    where toJSON (PostTransactionResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody403Variant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody403Variant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody403Variant6 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody403Variant7 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody403Variant8 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostTransactionResponseBody403Variant9 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody403Variants
    where parseJSON val = case (PostTransactionResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody403Variant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody403Variant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody403Variant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody403Variant7 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody403Variant8 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostTransactionResponseBody403Variant9 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data PostTransactionResponseBody404 = PostTransactionResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  postTransactionResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody404" (\obj -> GHC.Base.pure PostTransactionResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionResponseBody404' with all required fields.
mkPostTransactionResponseBody404 :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody404Message'
  -> PostTransactionResponseBody404
mkPostTransactionResponseBody404 postTransactionResponseBody404Message = PostTransactionResponseBody404{postTransactionResponseBody404Message = postTransactionResponseBody404Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data PostTransactionResponseBody406 = PostTransactionResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  postTransactionResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody406" (\obj -> GHC.Base.pure PostTransactionResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionResponseBody406' with all required fields.
mkPostTransactionResponseBody406 :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody406Message'
  -> PostTransactionResponseBody406
mkPostTransactionResponseBody406 postTransactionResponseBody406Message = PostTransactionResponseBody406{postTransactionResponseBody406Message = postTransactionResponseBody406Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data PostTransactionResponseBody415 = PostTransactionResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  postTransactionResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody415" (\obj -> GHC.Base.pure PostTransactionResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionResponseBody415' with all required fields.
mkPostTransactionResponseBody415 :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody415Message'
  -> PostTransactionResponseBody415
mkPostTransactionResponseBody415 postTransactionResponseBody415Message = PostTransactionResponseBody415{postTransactionResponseBody415Message = postTransactionResponseBody415Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/transactions.POST.responses.425.content.application\/json.schema@ in the specification.
-- 
-- 
data PostTransactionResponseBody425 = PostTransactionResponseBody425 {
  -- | message: May occur when submitting a serialized transaction to a node with full mempool.
  postTransactionResponseBody425Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostTransactionResponseBody425
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody425Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "mempool_is_full"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postTransactionResponseBody425Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "mempool_is_full"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostTransactionResponseBody425
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostTransactionResponseBody425" (\obj -> GHC.Base.pure PostTransactionResponseBody425 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostTransactionResponseBody425' with all required fields.
mkPostTransactionResponseBody425 :: Data.Text.Internal.Text -- ^ 'postTransactionResponseBody425Message'
  -> PostTransactionResponseBody425
mkPostTransactionResponseBody425 postTransactionResponseBody425Message = PostTransactionResponseBody425{postTransactionResponseBody425Message = postTransactionResponseBody425Message}
-- | > POST /wallets/{walletId}/transactions
-- 
-- The same as 'postTransaction' but accepts an explicit configuration.
postTransactionWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostTransactionRequestBodyVariants -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response PostTransactionResponse) -- ^ Monadic computation which returns the result of the operation
postTransactionWithConfiguration config
                                 walletId
                                 body = GHC.Base.fmap (\response_8 -> GHC.Base.fmap (Data.Either.either PostTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                 PostTransactionResponseBody202)
                                                                                                                                                                                  | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                   PostTransactionResponseBody400)
                                                                                                                                                                                  | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                   PostTransactionResponseBody403Variants)
                                                                                                                                                                                  | (\status_12 -> Network.HTTP.Types.Status.statusCode status_12 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                   PostTransactionResponseBody404)
                                                                                                                                                                                  | (\status_13 -> Network.HTTP.Types.Status.statusCode status_13 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                   PostTransactionResponseBody406)
                                                                                                                                                                                  | (\status_14 -> Network.HTTP.Types.Status.statusCode status_14 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                   PostTransactionResponseBody415)
                                                                                                                                                                                  | (\status_15 -> Network.HTTP.Types.Status.statusCode status_15 GHC.Classes.== 425) (Network.HTTP.Client.Types.responseStatus response) -> PostTransactionResponse425 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                   PostTransactionResponseBody425)
                                                                                                                                                                                  | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_8) response_8) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/transactions
-- 
-- The same as 'postTransaction' but returns the raw 'Data.ByteString.ByteString'.
postTransactionRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostTransactionRequestBodyVariants -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postTransactionRaw walletId
                   body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/transactions
-- 
-- The same as 'postTransaction' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
postTransactionWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostTransactionRequestBodyVariants -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postTransactionWithConfigurationRaw config
                                    walletId
                                    body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
