-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation postByronWallet
module Wallet.Operations.PostByronWallet where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /byron-wallets
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Restore a Byron wallet from a mnemonic sentence or encrypted root private key (deprecated).
-- 
--   **⚠️ WARNING ⚠️**
-- 
--   The construction of random wallet in itself is **deprecated**, in particular the restoration from an encrypted root private key.
--   These endpoints exist to ease migrations from legacy software such as \`cardano-sl\` but should be avoided by new applications.
postByronWallet :: forall m . Wallet.Common.MonadHTTP m => PostByronWalletRequestBodyVariants -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response PostByronWalletResponse) -- ^ Monadic computation which returns the result of the operation
postByronWallet body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PostByronWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 201) (Network.HTTP.Client.Types.responseStatus response) -> PostByronWalletResponse201 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                PostByronWalletResponseBody201)
                                                                                                                                                                 | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostByronWalletResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                PostByronWalletResponseBody400)
                                                                                                                                                                 | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostByronWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                PostByronWalletResponseBody406)
                                                                                                                                                                 | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 409) (Network.HTTP.Client.Types.responseStatus response) -> PostByronWalletResponse409 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                PostByronWalletResponseBody409)
                                                                                                                                                                 | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostByronWalletResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                PostByronWalletResponseBody415)
                                                                                                                                                                 | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") "/byron-wallets" GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/byron-wallets.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronWalletRequestBodyOneOf1 = PostByronWalletRequestBodyOneOf1 {
  -- | mnemonic_sentence: A list of mnemonic words
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 24 items
  -- * Must have a minimum of 12 items
  postByronWalletRequestBodyOneOf1Mnemonic_sentence :: ([Data.Text.Internal.Text])
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , postByronWalletRequestBodyOneOf1Name :: Data.Text.Internal.Text
  -- | passphrase: A master passphrase to lock and protect the wallet for sensitive operation (e.g. sending funds)
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 10
  , postByronWalletRequestBodyOneOf1Passphrase :: Data.Text.Internal.Text
  -- | style
  , postByronWalletRequestBodyOneOf1Style :: (GHC.Maybe.Maybe PostByronWalletRequestBodyOneOf1Style)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletRequestBodyOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["mnemonic_sentence" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf1Mnemonic_sentence obj] : ["name" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf1Name obj] : ["passphrase" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf1Passphrase obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("style" Data.Aeson.Types.ToJSON..=)) (postByronWalletRequestBodyOneOf1Style obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["mnemonic_sentence" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf1Mnemonic_sentence obj] : ["name" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf1Name obj] : ["passphrase" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf1Passphrase obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("style" Data.Aeson.Types.ToJSON..=)) (postByronWalletRequestBodyOneOf1Style obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletRequestBodyOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletRequestBodyOneOf1" (\obj -> (((GHC.Base.pure PostByronWalletRequestBodyOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "mnemonic_sentence")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "style"))
-- | Create a new 'PostByronWalletRequestBodyOneOf1' with all required fields.
mkPostByronWalletRequestBodyOneOf1 :: [Data.Text.Internal.Text] -- ^ 'postByronWalletRequestBodyOneOf1Mnemonic_sentence'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletRequestBodyOneOf1Name'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletRequestBodyOneOf1Passphrase'
  -> PostByronWalletRequestBodyOneOf1
mkPostByronWalletRequestBodyOneOf1 postByronWalletRequestBodyOneOf1Mnemonic_sentence postByronWalletRequestBodyOneOf1Name postByronWalletRequestBodyOneOf1Passphrase = PostByronWalletRequestBodyOneOf1{postByronWalletRequestBodyOneOf1Mnemonic_sentence = postByronWalletRequestBodyOneOf1Mnemonic_sentence,
                                                                                                                                                                                                        postByronWalletRequestBodyOneOf1Name = postByronWalletRequestBodyOneOf1Name,
                                                                                                                                                                                                        postByronWalletRequestBodyOneOf1Passphrase = postByronWalletRequestBodyOneOf1Passphrase,
                                                                                                                                                                                                        postByronWalletRequestBodyOneOf1Style = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/byron-wallets.POST.requestBody.content.application\/json.schema.oneOf.properties.style@ in the specification.
-- 
-- 
data PostByronWalletRequestBodyOneOf1Style =
   PostByronWalletRequestBodyOneOf1StyleOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostByronWalletRequestBodyOneOf1StyleTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostByronWalletRequestBodyOneOf1StyleEnumRandom -- ^ Represents the JSON value @"random"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletRequestBodyOneOf1Style
    where toJSON (PostByronWalletRequestBodyOneOf1StyleOther val) = val
          toJSON (PostByronWalletRequestBodyOneOf1StyleTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostByronWalletRequestBodyOneOf1StyleEnumRandom) = "random"
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletRequestBodyOneOf1Style
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "random" -> PostByronWalletRequestBodyOneOf1StyleEnumRandom
                                            | GHC.Base.otherwise -> PostByronWalletRequestBodyOneOf1StyleOther val)
-- | Defines the object schema located at @paths.\/byron-wallets.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronWalletRequestBodyOneOf2 = PostByronWalletRequestBodyOneOf2 {
  -- | mnemonic_sentence: A list of mnemonic words
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 24 items
  -- * Must have a minimum of 12 items
  postByronWalletRequestBodyOneOf2Mnemonic_sentence :: ([Data.Text.Internal.Text])
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , postByronWalletRequestBodyOneOf2Name :: Data.Text.Internal.Text
  -- | passphrase: A master passphrase to lock and protect the wallet for sensitive operation (e.g. sending funds)
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 10
  , postByronWalletRequestBodyOneOf2Passphrase :: Data.Text.Internal.Text
  -- | style
  , postByronWalletRequestBodyOneOf2Style :: (GHC.Maybe.Maybe PostByronWalletRequestBodyOneOf2Style)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletRequestBodyOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["mnemonic_sentence" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf2Mnemonic_sentence obj] : ["name" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf2Name obj] : ["passphrase" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf2Passphrase obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("style" Data.Aeson.Types.ToJSON..=)) (postByronWalletRequestBodyOneOf2Style obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["mnemonic_sentence" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf2Mnemonic_sentence obj] : ["name" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf2Name obj] : ["passphrase" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf2Passphrase obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("style" Data.Aeson.Types.ToJSON..=)) (postByronWalletRequestBodyOneOf2Style obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletRequestBodyOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletRequestBodyOneOf2" (\obj -> (((GHC.Base.pure PostByronWalletRequestBodyOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "mnemonic_sentence")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "style"))
-- | Create a new 'PostByronWalletRequestBodyOneOf2' with all required fields.
mkPostByronWalletRequestBodyOneOf2 :: [Data.Text.Internal.Text] -- ^ 'postByronWalletRequestBodyOneOf2Mnemonic_sentence'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletRequestBodyOneOf2Name'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletRequestBodyOneOf2Passphrase'
  -> PostByronWalletRequestBodyOneOf2
mkPostByronWalletRequestBodyOneOf2 postByronWalletRequestBodyOneOf2Mnemonic_sentence postByronWalletRequestBodyOneOf2Name postByronWalletRequestBodyOneOf2Passphrase = PostByronWalletRequestBodyOneOf2{postByronWalletRequestBodyOneOf2Mnemonic_sentence = postByronWalletRequestBodyOneOf2Mnemonic_sentence,
                                                                                                                                                                                                        postByronWalletRequestBodyOneOf2Name = postByronWalletRequestBodyOneOf2Name,
                                                                                                                                                                                                        postByronWalletRequestBodyOneOf2Passphrase = postByronWalletRequestBodyOneOf2Passphrase,
                                                                                                                                                                                                        postByronWalletRequestBodyOneOf2Style = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/byron-wallets.POST.requestBody.content.application\/json.schema.oneOf.properties.style@ in the specification.
-- 
-- 
data PostByronWalletRequestBodyOneOf2Style =
   PostByronWalletRequestBodyOneOf2StyleOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostByronWalletRequestBodyOneOf2StyleTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostByronWalletRequestBodyOneOf2StyleEnumIcarus -- ^ Represents the JSON value @"icarus"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletRequestBodyOneOf2Style
    where toJSON (PostByronWalletRequestBodyOneOf2StyleOther val) = val
          toJSON (PostByronWalletRequestBodyOneOf2StyleTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostByronWalletRequestBodyOneOf2StyleEnumIcarus) = "icarus"
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletRequestBodyOneOf2Style
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "icarus" -> PostByronWalletRequestBodyOneOf2StyleEnumIcarus
                                            | GHC.Base.otherwise -> PostByronWalletRequestBodyOneOf2StyleOther val)
-- | Defines the object schema located at @paths.\/byron-wallets.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronWalletRequestBodyOneOf3 = PostByronWalletRequestBodyOneOf3 {
  -- | mnemonic_sentence: A list of mnemonic words
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 24 items
  -- * Must have a minimum of 12 items
  postByronWalletRequestBodyOneOf3Mnemonic_sentence :: ([Data.Text.Internal.Text])
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , postByronWalletRequestBodyOneOf3Name :: Data.Text.Internal.Text
  -- | passphrase: A master passphrase to lock and protect the wallet for sensitive operation (e.g. sending funds)
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 10
  , postByronWalletRequestBodyOneOf3Passphrase :: Data.Text.Internal.Text
  -- | style
  , postByronWalletRequestBodyOneOf3Style :: (GHC.Maybe.Maybe PostByronWalletRequestBodyOneOf3Style)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletRequestBodyOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["mnemonic_sentence" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf3Mnemonic_sentence obj] : ["name" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf3Name obj] : ["passphrase" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf3Passphrase obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("style" Data.Aeson.Types.ToJSON..=)) (postByronWalletRequestBodyOneOf3Style obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["mnemonic_sentence" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf3Mnemonic_sentence obj] : ["name" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf3Name obj] : ["passphrase" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf3Passphrase obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("style" Data.Aeson.Types.ToJSON..=)) (postByronWalletRequestBodyOneOf3Style obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletRequestBodyOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletRequestBodyOneOf3" (\obj -> (((GHC.Base.pure PostByronWalletRequestBodyOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "mnemonic_sentence")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "style"))
-- | Create a new 'PostByronWalletRequestBodyOneOf3' with all required fields.
mkPostByronWalletRequestBodyOneOf3 :: [Data.Text.Internal.Text] -- ^ 'postByronWalletRequestBodyOneOf3Mnemonic_sentence'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletRequestBodyOneOf3Name'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletRequestBodyOneOf3Passphrase'
  -> PostByronWalletRequestBodyOneOf3
mkPostByronWalletRequestBodyOneOf3 postByronWalletRequestBodyOneOf3Mnemonic_sentence postByronWalletRequestBodyOneOf3Name postByronWalletRequestBodyOneOf3Passphrase = PostByronWalletRequestBodyOneOf3{postByronWalletRequestBodyOneOf3Mnemonic_sentence = postByronWalletRequestBodyOneOf3Mnemonic_sentence,
                                                                                                                                                                                                        postByronWalletRequestBodyOneOf3Name = postByronWalletRequestBodyOneOf3Name,
                                                                                                                                                                                                        postByronWalletRequestBodyOneOf3Passphrase = postByronWalletRequestBodyOneOf3Passphrase,
                                                                                                                                                                                                        postByronWalletRequestBodyOneOf3Style = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/byron-wallets.POST.requestBody.content.application\/json.schema.oneOf.properties.style@ in the specification.
-- 
-- 
data PostByronWalletRequestBodyOneOf3Style =
   PostByronWalletRequestBodyOneOf3StyleOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostByronWalletRequestBodyOneOf3StyleTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostByronWalletRequestBodyOneOf3StyleEnumTrezor -- ^ Represents the JSON value @"trezor"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletRequestBodyOneOf3Style
    where toJSON (PostByronWalletRequestBodyOneOf3StyleOther val) = val
          toJSON (PostByronWalletRequestBodyOneOf3StyleTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostByronWalletRequestBodyOneOf3StyleEnumTrezor) = "trezor"
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletRequestBodyOneOf3Style
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "trezor" -> PostByronWalletRequestBodyOneOf3StyleEnumTrezor
                                            | GHC.Base.otherwise -> PostByronWalletRequestBodyOneOf3StyleOther val)
-- | Defines the object schema located at @paths.\/byron-wallets.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronWalletRequestBodyOneOf4 = PostByronWalletRequestBodyOneOf4 {
  -- | mnemonic_sentence: A list of mnemonic words
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 24 items
  -- * Must have a minimum of 12 items
  postByronWalletRequestBodyOneOf4Mnemonic_sentence :: ([Data.Text.Internal.Text])
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , postByronWalletRequestBodyOneOf4Name :: Data.Text.Internal.Text
  -- | passphrase: A master passphrase to lock and protect the wallet for sensitive operation (e.g. sending funds)
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 10
  , postByronWalletRequestBodyOneOf4Passphrase :: Data.Text.Internal.Text
  -- | style
  , postByronWalletRequestBodyOneOf4Style :: (GHC.Maybe.Maybe PostByronWalletRequestBodyOneOf4Style)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletRequestBodyOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["mnemonic_sentence" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf4Mnemonic_sentence obj] : ["name" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf4Name obj] : ["passphrase" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf4Passphrase obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("style" Data.Aeson.Types.ToJSON..=)) (postByronWalletRequestBodyOneOf4Style obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["mnemonic_sentence" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf4Mnemonic_sentence obj] : ["name" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf4Name obj] : ["passphrase" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf4Passphrase obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("style" Data.Aeson.Types.ToJSON..=)) (postByronWalletRequestBodyOneOf4Style obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletRequestBodyOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletRequestBodyOneOf4" (\obj -> (((GHC.Base.pure PostByronWalletRequestBodyOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "mnemonic_sentence")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "style"))
-- | Create a new 'PostByronWalletRequestBodyOneOf4' with all required fields.
mkPostByronWalletRequestBodyOneOf4 :: [Data.Text.Internal.Text] -- ^ 'postByronWalletRequestBodyOneOf4Mnemonic_sentence'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletRequestBodyOneOf4Name'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletRequestBodyOneOf4Passphrase'
  -> PostByronWalletRequestBodyOneOf4
mkPostByronWalletRequestBodyOneOf4 postByronWalletRequestBodyOneOf4Mnemonic_sentence postByronWalletRequestBodyOneOf4Name postByronWalletRequestBodyOneOf4Passphrase = PostByronWalletRequestBodyOneOf4{postByronWalletRequestBodyOneOf4Mnemonic_sentence = postByronWalletRequestBodyOneOf4Mnemonic_sentence,
                                                                                                                                                                                                        postByronWalletRequestBodyOneOf4Name = postByronWalletRequestBodyOneOf4Name,
                                                                                                                                                                                                        postByronWalletRequestBodyOneOf4Passphrase = postByronWalletRequestBodyOneOf4Passphrase,
                                                                                                                                                                                                        postByronWalletRequestBodyOneOf4Style = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/byron-wallets.POST.requestBody.content.application\/json.schema.oneOf.properties.style@ in the specification.
-- 
-- 
data PostByronWalletRequestBodyOneOf4Style =
   PostByronWalletRequestBodyOneOf4StyleOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostByronWalletRequestBodyOneOf4StyleTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostByronWalletRequestBodyOneOf4StyleEnumLedger -- ^ Represents the JSON value @"ledger"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletRequestBodyOneOf4Style
    where toJSON (PostByronWalletRequestBodyOneOf4StyleOther val) = val
          toJSON (PostByronWalletRequestBodyOneOf4StyleTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostByronWalletRequestBodyOneOf4StyleEnumLedger) = "ledger"
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletRequestBodyOneOf4Style
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "ledger" -> PostByronWalletRequestBodyOneOf4StyleEnumLedger
                                            | GHC.Base.otherwise -> PostByronWalletRequestBodyOneOf4StyleOther val)
-- | Defines the object schema located at @paths.\/byron-wallets.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- Restore from account public key
data PostByronWalletRequestBodyOneOf5 = PostByronWalletRequestBodyOneOf5 {
  -- | account_public_key: An extended account public key (public key + chain code)
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 128
  -- * Minimum length of 128
  postByronWalletRequestBodyOneOf5Account_public_key :: Data.Text.Internal.Text
  -- | address_pool_gap: Number of consecutive unused addresses allowed.
  -- 
  -- **IMPORTANT DISCLAIMER:** Using values other than \`20\` automatically makes your wallet invalid with regards to BIP-44 address discovery. It means that you **will not** be able to fully restore
  -- your wallet in a different software which is strictly following BIP-44.
  -- 
  -- Beside, using large gaps is **not recommended** as it may induce important performance degradations. Use at your own risks.
  -- 
  -- **IMPORTANT DISCLAIMER 2:** There is no way to \`import\` addresses generated outside (e.g. using cardano-addresses) into the wallet.
  -- Wallet only discovers transactions on its used and unused addresses that are within its currently seen \`address_pool_gap\`.
  -- Transactions on addresses that \"belong\" to the wallet but happen to be beyond its \`address_pool_gap\` will not be visible to the wallet.
  -- This is a technical limitation of the industry standard [BIP-44](https:\/\/github.com\/bitcoin\/bips\/blob\/master\/bip-0044.mediawiki). See also [CIP-1852](https:\/\/github.com\/cardano-foundation\/CIPs\/blob\/master\/CIP-1852\/CIP-1852.md).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100000.0
  -- * Minimum  of 10.0
  , postByronWalletRequestBodyOneOf5Address_pool_gap :: (GHC.Maybe.Maybe GHC.Types.Int)
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , postByronWalletRequestBodyOneOf5Name :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletRequestBodyOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["account_public_key" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf5Account_public_key obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address_pool_gap" Data.Aeson.Types.ToJSON..=)) (postByronWalletRequestBodyOneOf5Address_pool_gap obj) : ["name" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf5Name obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["account_public_key" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf5Account_public_key obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address_pool_gap" Data.Aeson.Types.ToJSON..=)) (postByronWalletRequestBodyOneOf5Address_pool_gap obj) : ["name" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf5Name obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletRequestBodyOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletRequestBodyOneOf5" (\obj -> ((GHC.Base.pure PostByronWalletRequestBodyOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "account_public_key")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address_pool_gap")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name"))
-- | Create a new 'PostByronWalletRequestBodyOneOf5' with all required fields.
mkPostByronWalletRequestBodyOneOf5 :: Data.Text.Internal.Text -- ^ 'postByronWalletRequestBodyOneOf5Account_public_key'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletRequestBodyOneOf5Name'
  -> PostByronWalletRequestBodyOneOf5
mkPostByronWalletRequestBodyOneOf5 postByronWalletRequestBodyOneOf5Account_public_key postByronWalletRequestBodyOneOf5Name = PostByronWalletRequestBodyOneOf5{postByronWalletRequestBodyOneOf5Account_public_key = postByronWalletRequestBodyOneOf5Account_public_key,
                                                                                                                                                              postByronWalletRequestBodyOneOf5Address_pool_gap = GHC.Maybe.Nothing,
                                                                                                                                                              postByronWalletRequestBodyOneOf5Name = postByronWalletRequestBodyOneOf5Name}
-- | Defines the object schema located at @paths.\/byron-wallets.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- patate
data PostByronWalletRequestBodyOneOf6 = PostByronWalletRequestBodyOneOf6 {
  -- | encrypted_root_private_key: A root private key, encrypted using a given passphrase. The underlying key should contain:
  -- - A private key
  -- - A chain code
  -- - A public key
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 256
  -- * Minimum length of 256
  postByronWalletRequestBodyOneOf6Encrypted_root_private_key :: Data.Text.Internal.Text
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , postByronWalletRequestBodyOneOf6Name :: Data.Text.Internal.Text
  -- | passphrase_hash: A hash of master passphrase. The hash should be an output of a Scrypt function with the following parameters:
  -- - logN = 14
  -- - r = 8
  -- - p = 1
  , postByronWalletRequestBodyOneOf6Passphrase_hash :: Data.Text.Internal.Text
  -- | style
  , postByronWalletRequestBodyOneOf6Style :: (GHC.Maybe.Maybe PostByronWalletRequestBodyOneOf6Style)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletRequestBodyOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["encrypted_root_private_key" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf6Encrypted_root_private_key obj] : ["name" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf6Name obj] : ["passphrase_hash" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf6Passphrase_hash obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("style" Data.Aeson.Types.ToJSON..=)) (postByronWalletRequestBodyOneOf6Style obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["encrypted_root_private_key" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf6Encrypted_root_private_key obj] : ["name" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf6Name obj] : ["passphrase_hash" Data.Aeson.Types.ToJSON..= postByronWalletRequestBodyOneOf6Passphrase_hash obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("style" Data.Aeson.Types.ToJSON..=)) (postByronWalletRequestBodyOneOf6Style obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletRequestBodyOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletRequestBodyOneOf6" (\obj -> (((GHC.Base.pure PostByronWalletRequestBodyOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "encrypted_root_private_key")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "passphrase_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "style"))
-- | Create a new 'PostByronWalletRequestBodyOneOf6' with all required fields.
mkPostByronWalletRequestBodyOneOf6 :: Data.Text.Internal.Text -- ^ 'postByronWalletRequestBodyOneOf6Encrypted_root_private_key'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletRequestBodyOneOf6Name'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletRequestBodyOneOf6Passphrase_hash'
  -> PostByronWalletRequestBodyOneOf6
mkPostByronWalletRequestBodyOneOf6 postByronWalletRequestBodyOneOf6Encrypted_root_private_key postByronWalletRequestBodyOneOf6Name postByronWalletRequestBodyOneOf6Passphrase_hash = PostByronWalletRequestBodyOneOf6{postByronWalletRequestBodyOneOf6Encrypted_root_private_key = postByronWalletRequestBodyOneOf6Encrypted_root_private_key,
                                                                                                                                                                                                                      postByronWalletRequestBodyOneOf6Name = postByronWalletRequestBodyOneOf6Name,
                                                                                                                                                                                                                      postByronWalletRequestBodyOneOf6Passphrase_hash = postByronWalletRequestBodyOneOf6Passphrase_hash,
                                                                                                                                                                                                                      postByronWalletRequestBodyOneOf6Style = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/byron-wallets.POST.requestBody.content.application\/json.schema.oneOf.properties.style@ in the specification.
-- 
-- 
data PostByronWalletRequestBodyOneOf6Style =
   PostByronWalletRequestBodyOneOf6StyleOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostByronWalletRequestBodyOneOf6StyleTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostByronWalletRequestBodyOneOf6StyleEnumRandom -- ^ Represents the JSON value @"random"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletRequestBodyOneOf6Style
    where toJSON (PostByronWalletRequestBodyOneOf6StyleOther val) = val
          toJSON (PostByronWalletRequestBodyOneOf6StyleTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostByronWalletRequestBodyOneOf6StyleEnumRandom) = "random"
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletRequestBodyOneOf6Style
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "random" -> PostByronWalletRequestBodyOneOf6StyleEnumRandom
                                            | GHC.Base.otherwise -> PostByronWalletRequestBodyOneOf6StyleOther val)
-- | Defines the oneOf schema located at @paths.\/byron-wallets.POST.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronWalletRequestBodyVariants =
   PostByronWalletRequestBodyVariant1 PostByronWalletRequestBodyOneOf1
  | PostByronWalletRequestBodyVariant2 PostByronWalletRequestBodyOneOf2
  | PostByronWalletRequestBodyVariant3 PostByronWalletRequestBodyOneOf3
  | PostByronWalletRequestBodyVariant4 PostByronWalletRequestBodyOneOf4
  | PostByronWalletRequestBodyVariant5 PostByronWalletRequestBodyOneOf5
  | PostByronWalletRequestBodyVariant6 PostByronWalletRequestBodyOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletRequestBodyVariants
    where toJSON (PostByronWalletRequestBodyVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronWalletRequestBodyVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronWalletRequestBodyVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronWalletRequestBodyVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronWalletRequestBodyVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronWalletRequestBodyVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletRequestBodyVariants
    where parseJSON val = case (PostByronWalletRequestBodyVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronWalletRequestBodyVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronWalletRequestBodyVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronWalletRequestBodyVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronWalletRequestBodyVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronWalletRequestBodyVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Represents a response of the operation 'postByronWallet'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PostByronWalletResponseError' is used.
data PostByronWalletResponse =
   PostByronWalletResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | PostByronWalletResponse201 PostByronWalletResponseBody201 -- ^ Created
  | PostByronWalletResponse400 PostByronWalletResponseBody400 -- ^ Bad Request
  | PostByronWalletResponse406 PostByronWalletResponseBody406 -- ^ Not Acceptable
  | PostByronWalletResponse409 PostByronWalletResponseBody409 -- ^ Conflict
  | PostByronWalletResponse415 PostByronWalletResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.201.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronWalletResponseBody201 = PostByronWalletResponseBody201 {
  -- | assets: Current non-Ada asset holdings of the wallet.
  -- 
  -- The amount of assets available to spend may be less than the total
  -- unspent assets due to transaction change amounts which are yet to
  -- be fully confirmed (pending).
  postByronWalletResponseBody201Assets :: PostByronWalletResponseBody201Assets
  -- | balance: Byron wallet\'s current balance(s)
  , postByronWalletResponseBody201Balance :: PostByronWalletResponseBody201Balance
  -- | discovery: Mechanism used for discovering addresses.
  , postByronWalletResponseBody201Discovery :: PostByronWalletResponseBody201Discovery
  -- | id: A unique identifier for the wallet
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  , postByronWalletResponseBody201Id :: Data.Text.Internal.Text
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , postByronWalletResponseBody201Name :: Data.Text.Internal.Text
  -- | passphrase: Information about the wallet\'s passphrase
  , postByronWalletResponseBody201Passphrase :: (GHC.Maybe.Maybe PostByronWalletResponseBody201Passphrase)
  -- | state: Whether a wallet is ready to use or still syncing
  , postByronWalletResponseBody201State :: PostByronWalletResponseBody201State
  -- | tip: A reference to a particular time slot, and the block height at that point.
  , postByronWalletResponseBody201Tip :: PostByronWalletResponseBody201Tip
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody201
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201Balance obj] : ["discovery" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201Discovery obj] : ["id" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201Id obj] : ["name" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (postByronWalletResponseBody201Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201State obj] : ["tip" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201Tip obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201Balance obj] : ["discovery" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201Discovery obj] : ["id" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201Id obj] : ["name" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (postByronWalletResponseBody201Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201State obj] : ["tip" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201Tip obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody201
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody201" (\obj -> (((((((GHC.Base.pure PostByronWalletResponseBody201 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "balance")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "discovery")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "state")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tip"))
-- | Create a new 'PostByronWalletResponseBody201' with all required fields.
mkPostByronWalletResponseBody201 :: PostByronWalletResponseBody201Assets -- ^ 'postByronWalletResponseBody201Assets'
  -> PostByronWalletResponseBody201Balance -- ^ 'postByronWalletResponseBody201Balance'
  -> PostByronWalletResponseBody201Discovery -- ^ 'postByronWalletResponseBody201Discovery'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletResponseBody201Id'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletResponseBody201Name'
  -> PostByronWalletResponseBody201State -- ^ 'postByronWalletResponseBody201State'
  -> PostByronWalletResponseBody201Tip -- ^ 'postByronWalletResponseBody201Tip'
  -> PostByronWalletResponseBody201
mkPostByronWalletResponseBody201 postByronWalletResponseBody201Assets postByronWalletResponseBody201Balance postByronWalletResponseBody201Discovery postByronWalletResponseBody201Id postByronWalletResponseBody201Name postByronWalletResponseBody201State postByronWalletResponseBody201Tip = PostByronWalletResponseBody201{postByronWalletResponseBody201Assets = postByronWalletResponseBody201Assets,
                                                                                                                                                                                                                                                                                                                               postByronWalletResponseBody201Balance = postByronWalletResponseBody201Balance,
                                                                                                                                                                                                                                                                                                                               postByronWalletResponseBody201Discovery = postByronWalletResponseBody201Discovery,
                                                                                                                                                                                                                                                                                                                               postByronWalletResponseBody201Id = postByronWalletResponseBody201Id,
                                                                                                                                                                                                                                                                                                                               postByronWalletResponseBody201Name = postByronWalletResponseBody201Name,
                                                                                                                                                                                                                                                                                                                               postByronWalletResponseBody201Passphrase = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                               postByronWalletResponseBody201State = postByronWalletResponseBody201State,
                                                                                                                                                                                                                                                                                                                               postByronWalletResponseBody201Tip = postByronWalletResponseBody201Tip}
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.201.content.application\/json.schema.properties.assets@ in the specification.
-- 
-- Current non-Ada asset holdings of the wallet.
-- 
-- The amount of assets available to spend may be less than the total
-- unspent assets due to transaction change amounts which are yet to
-- be fully confirmed (pending).
data PostByronWalletResponseBody201Assets = PostByronWalletResponseBody201Assets {
  -- | available: Available UTxO asset balances (funds that can be spent without
  -- condition).
  postByronWalletResponseBody201AssetsAvailable :: ([PostByronWalletResponseBody201AssetsAvailable])
  -- | total: Total asset balances (available balances plus pending change balances).
  , postByronWalletResponseBody201AssetsTotal :: ([PostByronWalletResponseBody201AssetsTotal])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody201Assets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody201Assets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody201Assets" (\obj -> (GHC.Base.pure PostByronWalletResponseBody201Assets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'PostByronWalletResponseBody201Assets' with all required fields.
mkPostByronWalletResponseBody201Assets :: [PostByronWalletResponseBody201AssetsAvailable] -- ^ 'postByronWalletResponseBody201AssetsAvailable'
  -> [PostByronWalletResponseBody201AssetsTotal] -- ^ 'postByronWalletResponseBody201AssetsTotal'
  -> PostByronWalletResponseBody201Assets
mkPostByronWalletResponseBody201Assets postByronWalletResponseBody201AssetsAvailable postByronWalletResponseBody201AssetsTotal = PostByronWalletResponseBody201Assets{postByronWalletResponseBody201AssetsAvailable = postByronWalletResponseBody201AssetsAvailable,
                                                                                                                                                                      postByronWalletResponseBody201AssetsTotal = postByronWalletResponseBody201AssetsTotal}
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.201.content.application\/json.schema.properties.assets.properties.available.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostByronWalletResponseBody201AssetsAvailable = PostByronWalletResponseBody201AssetsAvailable {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postByronWalletResponseBody201AssetsAvailableAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postByronWalletResponseBody201AssetsAvailablePolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronWalletResponseBody201AssetsAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody201AssetsAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsAvailableQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsAvailableQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody201AssetsAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody201AssetsAvailable" (\obj -> ((GHC.Base.pure PostByronWalletResponseBody201AssetsAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronWalletResponseBody201AssetsAvailable' with all required fields.
mkPostByronWalletResponseBody201AssetsAvailable :: Data.Text.Internal.Text -- ^ 'postByronWalletResponseBody201AssetsAvailableAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletResponseBody201AssetsAvailablePolicy_id'
  -> GHC.Types.Int -- ^ 'postByronWalletResponseBody201AssetsAvailableQuantity'
  -> PostByronWalletResponseBody201AssetsAvailable
mkPostByronWalletResponseBody201AssetsAvailable postByronWalletResponseBody201AssetsAvailableAsset_name postByronWalletResponseBody201AssetsAvailablePolicy_id postByronWalletResponseBody201AssetsAvailableQuantity = PostByronWalletResponseBody201AssetsAvailable{postByronWalletResponseBody201AssetsAvailableAsset_name = postByronWalletResponseBody201AssetsAvailableAsset_name,
                                                                                                                                                                                                                                                                     postByronWalletResponseBody201AssetsAvailablePolicy_id = postByronWalletResponseBody201AssetsAvailablePolicy_id,
                                                                                                                                                                                                                                                                     postByronWalletResponseBody201AssetsAvailableQuantity = postByronWalletResponseBody201AssetsAvailableQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.201.content.application\/json.schema.properties.assets.properties.total.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostByronWalletResponseBody201AssetsTotal = PostByronWalletResponseBody201AssetsTotal {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postByronWalletResponseBody201AssetsTotalAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postByronWalletResponseBody201AssetsTotalPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronWalletResponseBody201AssetsTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody201AssetsTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsTotalQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201AssetsTotalQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody201AssetsTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody201AssetsTotal" (\obj -> ((GHC.Base.pure PostByronWalletResponseBody201AssetsTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronWalletResponseBody201AssetsTotal' with all required fields.
mkPostByronWalletResponseBody201AssetsTotal :: Data.Text.Internal.Text -- ^ 'postByronWalletResponseBody201AssetsTotalAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletResponseBody201AssetsTotalPolicy_id'
  -> GHC.Types.Int -- ^ 'postByronWalletResponseBody201AssetsTotalQuantity'
  -> PostByronWalletResponseBody201AssetsTotal
mkPostByronWalletResponseBody201AssetsTotal postByronWalletResponseBody201AssetsTotalAsset_name postByronWalletResponseBody201AssetsTotalPolicy_id postByronWalletResponseBody201AssetsTotalQuantity = PostByronWalletResponseBody201AssetsTotal{postByronWalletResponseBody201AssetsTotalAsset_name = postByronWalletResponseBody201AssetsTotalAsset_name,
                                                                                                                                                                                                                                                 postByronWalletResponseBody201AssetsTotalPolicy_id = postByronWalletResponseBody201AssetsTotalPolicy_id,
                                                                                                                                                                                                                                                 postByronWalletResponseBody201AssetsTotalQuantity = postByronWalletResponseBody201AssetsTotalQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.201.content.application\/json.schema.properties.balance@ in the specification.
-- 
-- Byron wallet\'s current balance(s)
data PostByronWalletResponseBody201Balance = PostByronWalletResponseBody201Balance {
  -- | available: Available balance (funds that can be spent)
  postByronWalletResponseBody201BalanceAvailable :: PostByronWalletResponseBody201BalanceAvailable
  -- | total: Total balance (available balance plus pending change)
  , postByronWalletResponseBody201BalanceTotal :: PostByronWalletResponseBody201BalanceTotal
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody201Balance
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201BalanceAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201BalanceTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201BalanceAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201BalanceTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody201Balance
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody201Balance" (\obj -> (GHC.Base.pure PostByronWalletResponseBody201Balance GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'PostByronWalletResponseBody201Balance' with all required fields.
mkPostByronWalletResponseBody201Balance :: PostByronWalletResponseBody201BalanceAvailable -- ^ 'postByronWalletResponseBody201BalanceAvailable'
  -> PostByronWalletResponseBody201BalanceTotal -- ^ 'postByronWalletResponseBody201BalanceTotal'
  -> PostByronWalletResponseBody201Balance
mkPostByronWalletResponseBody201Balance postByronWalletResponseBody201BalanceAvailable postByronWalletResponseBody201BalanceTotal = PostByronWalletResponseBody201Balance{postByronWalletResponseBody201BalanceAvailable = postByronWalletResponseBody201BalanceAvailable,
                                                                                                                                                                          postByronWalletResponseBody201BalanceTotal = postByronWalletResponseBody201BalanceTotal}
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.201.content.application\/json.schema.properties.balance.properties.available@ in the specification.
-- 
-- Available balance (funds that can be spent)
data PostByronWalletResponseBody201BalanceAvailable = PostByronWalletResponseBody201BalanceAvailable {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronWalletResponseBody201BalanceAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody201BalanceAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody201BalanceAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody201BalanceAvailable" (\obj -> GHC.Base.pure PostByronWalletResponseBody201BalanceAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronWalletResponseBody201BalanceAvailable' with all required fields.
mkPostByronWalletResponseBody201BalanceAvailable :: GHC.Types.Int -- ^ 'postByronWalletResponseBody201BalanceAvailableQuantity'
  -> PostByronWalletResponseBody201BalanceAvailable
mkPostByronWalletResponseBody201BalanceAvailable postByronWalletResponseBody201BalanceAvailableQuantity = PostByronWalletResponseBody201BalanceAvailable{postByronWalletResponseBody201BalanceAvailableQuantity = postByronWalletResponseBody201BalanceAvailableQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.201.content.application\/json.schema.properties.balance.properties.total@ in the specification.
-- 
-- Total balance (available balance plus pending change)
data PostByronWalletResponseBody201BalanceTotal = PostByronWalletResponseBody201BalanceTotal {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronWalletResponseBody201BalanceTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody201BalanceTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody201BalanceTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody201BalanceTotal" (\obj -> GHC.Base.pure PostByronWalletResponseBody201BalanceTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronWalletResponseBody201BalanceTotal' with all required fields.
mkPostByronWalletResponseBody201BalanceTotal :: GHC.Types.Int -- ^ 'postByronWalletResponseBody201BalanceTotalQuantity'
  -> PostByronWalletResponseBody201BalanceTotal
mkPostByronWalletResponseBody201BalanceTotal postByronWalletResponseBody201BalanceTotalQuantity = PostByronWalletResponseBody201BalanceTotal{postByronWalletResponseBody201BalanceTotalQuantity = postByronWalletResponseBody201BalanceTotalQuantity}
-- | Defines the enum schema located at @paths.\/byron-wallets.POST.responses.201.content.application\/json.schema.properties.discovery@ in the specification.
-- 
-- Mechanism used for discovering addresses.
data PostByronWalletResponseBody201Discovery =
   PostByronWalletResponseBody201DiscoveryOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostByronWalletResponseBody201DiscoveryTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostByronWalletResponseBody201DiscoveryEnumRandom -- ^ Represents the JSON value @"random"@
  | PostByronWalletResponseBody201DiscoveryEnumSequential -- ^ Represents the JSON value @"sequential"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody201Discovery
    where toJSON (PostByronWalletResponseBody201DiscoveryOther val) = val
          toJSON (PostByronWalletResponseBody201DiscoveryTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostByronWalletResponseBody201DiscoveryEnumRandom) = "random"
          toJSON (PostByronWalletResponseBody201DiscoveryEnumSequential) = "sequential"
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody201Discovery
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "random" -> PostByronWalletResponseBody201DiscoveryEnumRandom
                                            | val GHC.Classes.== "sequential" -> PostByronWalletResponseBody201DiscoveryEnumSequential
                                            | GHC.Base.otherwise -> PostByronWalletResponseBody201DiscoveryOther val)
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.201.content.application\/json.schema.properties.passphrase@ in the specification.
-- 
-- Information about the wallet\'s passphrase
data PostByronWalletResponseBody201Passphrase = PostByronWalletResponseBody201Passphrase {
  -- | last_updated_at
  postByronWalletResponseBody201PassphraseLast_updated_at :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody201Passphrase
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201PassphraseLast_updated_at obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201PassphraseLast_updated_at obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody201Passphrase
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody201Passphrase" (\obj -> GHC.Base.pure PostByronWalletResponseBody201Passphrase GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "last_updated_at"))
-- | Create a new 'PostByronWalletResponseBody201Passphrase' with all required fields.
mkPostByronWalletResponseBody201Passphrase :: Data.Text.Internal.Text -- ^ 'postByronWalletResponseBody201PassphraseLast_updated_at'
  -> PostByronWalletResponseBody201Passphrase
mkPostByronWalletResponseBody201Passphrase postByronWalletResponseBody201PassphraseLast_updated_at = PostByronWalletResponseBody201Passphrase{postByronWalletResponseBody201PassphraseLast_updated_at = postByronWalletResponseBody201PassphraseLast_updated_at}
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.201.content.application\/json.schema.properties.state@ in the specification.
-- 
-- Whether a wallet is ready to use or still syncing
data PostByronWalletResponseBody201State = PostByronWalletResponseBody201State {
  -- | progress: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == syncing
  -- \<\/span>\<br\/>
  postByronWalletResponseBody201StateProgress :: (GHC.Maybe.Maybe PostByronWalletResponseBody201StateProgress)
  -- | status
  , postByronWalletResponseBody201StateStatus :: PostByronWalletResponseBody201StateStatus
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody201State
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (postByronWalletResponseBody201StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201StateStatus obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (postByronWalletResponseBody201StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201StateStatus obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody201State
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody201State" (\obj -> (GHC.Base.pure PostByronWalletResponseBody201State GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "progress")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status"))
-- | Create a new 'PostByronWalletResponseBody201State' with all required fields.
mkPostByronWalletResponseBody201State :: PostByronWalletResponseBody201StateStatus -- ^ 'postByronWalletResponseBody201StateStatus'
  -> PostByronWalletResponseBody201State
mkPostByronWalletResponseBody201State postByronWalletResponseBody201StateStatus = PostByronWalletResponseBody201State{postByronWalletResponseBody201StateProgress = GHC.Maybe.Nothing,
                                                                                                                      postByronWalletResponseBody201StateStatus = postByronWalletResponseBody201StateStatus}
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.201.content.application\/json.schema.properties.state.properties.progress@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == syncing
-- \<\/span>\<br\/>
data PostByronWalletResponseBody201StateProgress = PostByronWalletResponseBody201StateProgress {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  postByronWalletResponseBody201StateProgressQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody201StateProgress
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody201StateProgress
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody201StateProgress" (\obj -> GHC.Base.pure PostByronWalletResponseBody201StateProgress GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronWalletResponseBody201StateProgress' with all required fields.
mkPostByronWalletResponseBody201StateProgress :: GHC.Types.Double -- ^ 'postByronWalletResponseBody201StateProgressQuantity'
  -> PostByronWalletResponseBody201StateProgress
mkPostByronWalletResponseBody201StateProgress postByronWalletResponseBody201StateProgressQuantity = PostByronWalletResponseBody201StateProgress{postByronWalletResponseBody201StateProgressQuantity = postByronWalletResponseBody201StateProgressQuantity}
-- | Defines the enum schema located at @paths.\/byron-wallets.POST.responses.201.content.application\/json.schema.properties.state.properties.status@ in the specification.
-- 
-- 
data PostByronWalletResponseBody201StateStatus =
   PostByronWalletResponseBody201StateStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostByronWalletResponseBody201StateStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostByronWalletResponseBody201StateStatusEnumReady -- ^ Represents the JSON value @"ready"@
  | PostByronWalletResponseBody201StateStatusEnumSyncing -- ^ Represents the JSON value @"syncing"@
  | PostByronWalletResponseBody201StateStatusEnumNot_responding -- ^ Represents the JSON value @"not_responding"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody201StateStatus
    where toJSON (PostByronWalletResponseBody201StateStatusOther val) = val
          toJSON (PostByronWalletResponseBody201StateStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostByronWalletResponseBody201StateStatusEnumReady) = "ready"
          toJSON (PostByronWalletResponseBody201StateStatusEnumSyncing) = "syncing"
          toJSON (PostByronWalletResponseBody201StateStatusEnumNot_responding) = "not_responding"
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody201StateStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "ready" -> PostByronWalletResponseBody201StateStatusEnumReady
                                            | val GHC.Classes.== "syncing" -> PostByronWalletResponseBody201StateStatusEnumSyncing
                                            | val GHC.Classes.== "not_responding" -> PostByronWalletResponseBody201StateStatusEnumNot_responding
                                            | GHC.Base.otherwise -> PostByronWalletResponseBody201StateStatusOther val)
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.201.content.application\/json.schema.properties.tip@ in the specification.
-- 
-- A reference to a particular time slot, and the block height at that point.
data PostByronWalletResponseBody201Tip = PostByronWalletResponseBody201Tip {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronWalletResponseBody201TipAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronWalletResponseBody201TipEpoch_number :: GHC.Types.Int
  -- | height
  , postByronWalletResponseBody201TipHeight :: PostByronWalletResponseBody201TipHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronWalletResponseBody201TipSlot_number :: GHC.Types.Int
  -- | time
  , postByronWalletResponseBody201TipTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody201Tip
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201TipTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201TipTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody201Tip
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody201Tip" (\obj -> ((((GHC.Base.pure PostByronWalletResponseBody201Tip GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'PostByronWalletResponseBody201Tip' with all required fields.
mkPostByronWalletResponseBody201Tip :: GHC.Types.Int -- ^ 'postByronWalletResponseBody201TipAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'postByronWalletResponseBody201TipEpoch_number'
  -> PostByronWalletResponseBody201TipHeight -- ^ 'postByronWalletResponseBody201TipHeight'
  -> GHC.Types.Int -- ^ 'postByronWalletResponseBody201TipSlot_number'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletResponseBody201TipTime'
  -> PostByronWalletResponseBody201Tip
mkPostByronWalletResponseBody201Tip postByronWalletResponseBody201TipAbsolute_slot_number postByronWalletResponseBody201TipEpoch_number postByronWalletResponseBody201TipHeight postByronWalletResponseBody201TipSlot_number postByronWalletResponseBody201TipTime = PostByronWalletResponseBody201Tip{postByronWalletResponseBody201TipAbsolute_slot_number = postByronWalletResponseBody201TipAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                       postByronWalletResponseBody201TipEpoch_number = postByronWalletResponseBody201TipEpoch_number,
                                                                                                                                                                                                                                                                                                       postByronWalletResponseBody201TipHeight = postByronWalletResponseBody201TipHeight,
                                                                                                                                                                                                                                                                                                       postByronWalletResponseBody201TipSlot_number = postByronWalletResponseBody201TipSlot_number,
                                                                                                                                                                                                                                                                                                       postByronWalletResponseBody201TipTime = postByronWalletResponseBody201TipTime}
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.201.content.application\/json.schema.properties.tip.properties.height@ in the specification.
-- 
-- 
data PostByronWalletResponseBody201TipHeight = PostByronWalletResponseBody201TipHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronWalletResponseBody201TipHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody201TipHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody201TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody201TipHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody201TipHeight" (\obj -> GHC.Base.pure PostByronWalletResponseBody201TipHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronWalletResponseBody201TipHeight' with all required fields.
mkPostByronWalletResponseBody201TipHeight :: GHC.Types.Int -- ^ 'postByronWalletResponseBody201TipHeightQuantity'
  -> PostByronWalletResponseBody201TipHeight
mkPostByronWalletResponseBody201TipHeight postByronWalletResponseBody201TipHeightQuantity = PostByronWalletResponseBody201TipHeight{postByronWalletResponseBody201TipHeightQuantity = postByronWalletResponseBody201TipHeightQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronWalletResponseBody400 = PostByronWalletResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  postByronWalletResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody400" (\obj -> GHC.Base.pure PostByronWalletResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronWalletResponseBody400' with all required fields.
mkPostByronWalletResponseBody400 :: Data.Text.Internal.Text -- ^ 'postByronWalletResponseBody400Message'
  -> PostByronWalletResponseBody400
mkPostByronWalletResponseBody400 postByronWalletResponseBody400Message = PostByronWalletResponseBody400{postByronWalletResponseBody400Message = postByronWalletResponseBody400Message}
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronWalletResponseBody406 = PostByronWalletResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  postByronWalletResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody406" (\obj -> GHC.Base.pure PostByronWalletResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronWalletResponseBody406' with all required fields.
mkPostByronWalletResponseBody406 :: Data.Text.Internal.Text -- ^ 'postByronWalletResponseBody406Message'
  -> PostByronWalletResponseBody406
mkPostByronWalletResponseBody406 postByronWalletResponseBody406Message = PostByronWalletResponseBody406{postByronWalletResponseBody406Message = postByronWalletResponseBody406Message}
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.409.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronWalletResponseBody409 = PostByronWalletResponseBody409 {
  -- | code: A specific error code for this error, more precise than HTTP ones.
  postByronWalletResponseBody409Code :: Data.Text.Internal.Text
  -- | message: A descriptive error message.
  , postByronWalletResponseBody409Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody409
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["code" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody409Code obj] : ["message" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody409Message obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["code" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody409Code obj] : ["message" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody409Message obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody409
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody409" (\obj -> (GHC.Base.pure PostByronWalletResponseBody409 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "code")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronWalletResponseBody409' with all required fields.
mkPostByronWalletResponseBody409 :: Data.Text.Internal.Text -- ^ 'postByronWalletResponseBody409Code'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletResponseBody409Message'
  -> PostByronWalletResponseBody409
mkPostByronWalletResponseBody409 postByronWalletResponseBody409Code postByronWalletResponseBody409Message = PostByronWalletResponseBody409{postByronWalletResponseBody409Code = postByronWalletResponseBody409Code,
                                                                                                                                           postByronWalletResponseBody409Message = postByronWalletResponseBody409Message}
-- | Defines the object schema located at @paths.\/byron-wallets.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronWalletResponseBody415 = PostByronWalletResponseBody415 {
  -- | code: A specific error code for this error, more precise than HTTP ones.
  postByronWalletResponseBody415Code :: Data.Text.Internal.Text
  -- | message: A descriptive error message.
  , postByronWalletResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronWalletResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["code" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody415Code obj] : ["message" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody415Message obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["code" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody415Code obj] : ["message" Data.Aeson.Types.ToJSON..= postByronWalletResponseBody415Message obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronWalletResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronWalletResponseBody415" (\obj -> (GHC.Base.pure PostByronWalletResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "code")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronWalletResponseBody415' with all required fields.
mkPostByronWalletResponseBody415 :: Data.Text.Internal.Text -- ^ 'postByronWalletResponseBody415Code'
  -> Data.Text.Internal.Text -- ^ 'postByronWalletResponseBody415Message'
  -> PostByronWalletResponseBody415
mkPostByronWalletResponseBody415 postByronWalletResponseBody415Code postByronWalletResponseBody415Message = PostByronWalletResponseBody415{postByronWalletResponseBody415Code = postByronWalletResponseBody415Code,
                                                                                                                                           postByronWalletResponseBody415Message = postByronWalletResponseBody415Message}
-- | > POST /byron-wallets
-- 
-- The same as 'postByronWallet' but accepts an explicit configuration.
postByronWalletWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> PostByronWalletRequestBodyVariants -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response PostByronWalletResponse) -- ^ Monadic computation which returns the result of the operation
postByronWalletWithConfiguration config
                                 body = GHC.Base.fmap (\response_6 -> GHC.Base.fmap (Data.Either.either PostByronWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 201) (Network.HTTP.Client.Types.responseStatus response) -> PostByronWalletResponse201 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                 PostByronWalletResponseBody201)
                                                                                                                                                                                  | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostByronWalletResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                 PostByronWalletResponseBody400)
                                                                                                                                                                                  | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostByronWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                 PostByronWalletResponseBody406)
                                                                                                                                                                                  | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 409) (Network.HTTP.Client.Types.responseStatus response) -> PostByronWalletResponse409 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                   PostByronWalletResponseBody409)
                                                                                                                                                                                  | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostByronWalletResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                   PostByronWalletResponseBody415)
                                                                                                                                                                                  | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_6) response_6) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") "/byron-wallets" GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /byron-wallets
-- 
-- The same as 'postByronWallet' but returns the raw 'Data.ByteString.ByteString'.
postByronWalletRaw :: forall m . Wallet.Common.MonadHTTP m => PostByronWalletRequestBodyVariants -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postByronWalletRaw body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") "/byron-wallets" GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /byron-wallets
-- 
-- The same as 'postByronWallet' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
postByronWalletWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> PostByronWalletRequestBodyVariants -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postByronWalletWithConfigurationRaw config
                                    body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") "/byron-wallets" GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
