-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation getByronWalletUtxoSnapshot
module Wallet.Operations.GetByronWalletUtxoSnapshot where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > GET /byron-wallets/{walletId}/utxo
-- 
-- Generate a snapshot of the wallet\'s UTxO set.
-- 
-- This endpoint is intended for debugging purposes.
getByronWalletUtxoSnapshot :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response GetByronWalletUtxoSnapshotResponse) -- ^ Monadic computation which returns the result of the operation
getByronWalletUtxoSnapshot walletId = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either GetByronWalletUtxoSnapshotResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetByronWalletUtxoSnapshotResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                     GetByronWalletUtxoSnapshotResponseBody200)
                                                                                                                                                                                           | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> GetByronWalletUtxoSnapshotResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                     GetByronWalletUtxoSnapshotResponseBody404)
                                                                                                                                                                                           | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> GetByronWalletUtxoSnapshotResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                     GetByronWalletUtxoSnapshotResponseBody406)
                                                                                                                                                                                           | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/utxo")) GHC.Base.mempty)
-- | Represents a response of the operation 'getByronWalletUtxoSnapshot'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'GetByronWalletUtxoSnapshotResponseError' is used.
data GetByronWalletUtxoSnapshotResponse =
   GetByronWalletUtxoSnapshotResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | GetByronWalletUtxoSnapshotResponse200 GetByronWalletUtxoSnapshotResponseBody200 -- ^ Ok
  | GetByronWalletUtxoSnapshotResponse404 GetByronWalletUtxoSnapshotResponseBody404 -- ^ Not Found
  | GetByronWalletUtxoSnapshotResponse406 GetByronWalletUtxoSnapshotResponseBody406 -- ^ Not Acceptable
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/utxo.GET.responses.200.content.application\/json.schema@ in the specification.
-- 
-- 
data GetByronWalletUtxoSnapshotResponseBody200 = GetByronWalletUtxoSnapshotResponseBody200 {
  -- | entries: The complete set of UTxO entries associated with a wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  getByronWalletUtxoSnapshotResponseBody200Entries :: ([GetByronWalletUtxoSnapshotResponseBody200Entries])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletUtxoSnapshotResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["entries" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200Entries obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["entries" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200Entries obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletUtxoSnapshotResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletUtxoSnapshotResponseBody200" (\obj -> GHC.Base.pure GetByronWalletUtxoSnapshotResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "entries"))
-- | Create a new 'GetByronWalletUtxoSnapshotResponseBody200' with all required fields.
mkGetByronWalletUtxoSnapshotResponseBody200 :: [GetByronWalletUtxoSnapshotResponseBody200Entries] -- ^ 'getByronWalletUtxoSnapshotResponseBody200Entries'
  -> GetByronWalletUtxoSnapshotResponseBody200
mkGetByronWalletUtxoSnapshotResponseBody200 getByronWalletUtxoSnapshotResponseBody200Entries = GetByronWalletUtxoSnapshotResponseBody200{getByronWalletUtxoSnapshotResponseBody200Entries = getByronWalletUtxoSnapshotResponseBody200Entries}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/utxo.GET.responses.200.content.application\/json.schema.properties.entries.items@ in the specification.
-- 
-- 
data GetByronWalletUtxoSnapshotResponseBody200Entries = GetByronWalletUtxoSnapshotResponseBody200Entries {
  -- | ada: The ada quantity associated with this UTxO entry.
  getByronWalletUtxoSnapshotResponseBody200EntriesAda :: GetByronWalletUtxoSnapshotResponseBody200EntriesAda
  -- | ada_minimum: The minimum ada quantity permitted by the ledger for this UTxO
  -- entry.
  , getByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum :: GetByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum
  -- | assets: The set of non-ada assets associated with this UTxO entry.
  , getByronWalletUtxoSnapshotResponseBody200EntriesAssets :: ([GetByronWalletUtxoSnapshotResponseBody200EntriesAssets])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletUtxoSnapshotResponseBody200Entries
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["ada" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAda obj] : ["ada_minimum" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum obj] : ["assets" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAssets obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["ada" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAda obj] : ["ada_minimum" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum obj] : ["assets" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAssets obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletUtxoSnapshotResponseBody200Entries
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletUtxoSnapshotResponseBody200Entries" (\obj -> ((GHC.Base.pure GetByronWalletUtxoSnapshotResponseBody200Entries GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ada")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ada_minimum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets"))
-- | Create a new 'GetByronWalletUtxoSnapshotResponseBody200Entries' with all required fields.
mkGetByronWalletUtxoSnapshotResponseBody200Entries :: GetByronWalletUtxoSnapshotResponseBody200EntriesAda -- ^ 'getByronWalletUtxoSnapshotResponseBody200EntriesAda'
  -> GetByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum -- ^ 'getByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum'
  -> [GetByronWalletUtxoSnapshotResponseBody200EntriesAssets] -- ^ 'getByronWalletUtxoSnapshotResponseBody200EntriesAssets'
  -> GetByronWalletUtxoSnapshotResponseBody200Entries
mkGetByronWalletUtxoSnapshotResponseBody200Entries getByronWalletUtxoSnapshotResponseBody200EntriesAda getByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum getByronWalletUtxoSnapshotResponseBody200EntriesAssets = GetByronWalletUtxoSnapshotResponseBody200Entries{getByronWalletUtxoSnapshotResponseBody200EntriesAda = getByronWalletUtxoSnapshotResponseBody200EntriesAda,
                                                                                                                                                                                                                                                                             getByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum = getByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum,
                                                                                                                                                                                                                                                                             getByronWalletUtxoSnapshotResponseBody200EntriesAssets = getByronWalletUtxoSnapshotResponseBody200EntriesAssets}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/utxo.GET.responses.200.content.application\/json.schema.properties.entries.items.properties.ada@ in the specification.
-- 
-- The ada quantity associated with this UTxO entry.
data GetByronWalletUtxoSnapshotResponseBody200EntriesAda = GetByronWalletUtxoSnapshotResponseBody200EntriesAda {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronWalletUtxoSnapshotResponseBody200EntriesAdaQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletUtxoSnapshotResponseBody200EntriesAda
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAdaQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAdaQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletUtxoSnapshotResponseBody200EntriesAda
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletUtxoSnapshotResponseBody200EntriesAda" (\obj -> GHC.Base.pure GetByronWalletUtxoSnapshotResponseBody200EntriesAda GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronWalletUtxoSnapshotResponseBody200EntriesAda' with all required fields.
mkGetByronWalletUtxoSnapshotResponseBody200EntriesAda :: GHC.Types.Int -- ^ 'getByronWalletUtxoSnapshotResponseBody200EntriesAdaQuantity'
  -> GetByronWalletUtxoSnapshotResponseBody200EntriesAda
mkGetByronWalletUtxoSnapshotResponseBody200EntriesAda getByronWalletUtxoSnapshotResponseBody200EntriesAdaQuantity = GetByronWalletUtxoSnapshotResponseBody200EntriesAda{getByronWalletUtxoSnapshotResponseBody200EntriesAdaQuantity = getByronWalletUtxoSnapshotResponseBody200EntriesAdaQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/utxo.GET.responses.200.content.application\/json.schema.properties.entries.items.properties.ada_minimum@ in the specification.
-- 
-- The minimum ada quantity permitted by the ledger for this UTxO
-- entry.
data GetByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum = GetByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  getByronWalletUtxoSnapshotResponseBody200EntriesAda_minimumQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAda_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAda_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum" (\obj -> GHC.Base.pure GetByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum' with all required fields.
mkGetByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum :: GHC.Types.Int -- ^ 'getByronWalletUtxoSnapshotResponseBody200EntriesAda_minimumQuantity'
  -> GetByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum
mkGetByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum getByronWalletUtxoSnapshotResponseBody200EntriesAda_minimumQuantity = GetByronWalletUtxoSnapshotResponseBody200EntriesAda_minimum{getByronWalletUtxoSnapshotResponseBody200EntriesAda_minimumQuantity = getByronWalletUtxoSnapshotResponseBody200EntriesAda_minimumQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/utxo.GET.responses.200.content.application\/json.schema.properties.entries.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data GetByronWalletUtxoSnapshotResponseBody200EntriesAssets = GetByronWalletUtxoSnapshotResponseBody200EntriesAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  getByronWalletUtxoSnapshotResponseBody200EntriesAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , getByronWalletUtxoSnapshotResponseBody200EntriesAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , getByronWalletUtxoSnapshotResponseBody200EntriesAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletUtxoSnapshotResponseBody200EntriesAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody200EntriesAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletUtxoSnapshotResponseBody200EntriesAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletUtxoSnapshotResponseBody200EntriesAssets" (\obj -> ((GHC.Base.pure GetByronWalletUtxoSnapshotResponseBody200EntriesAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'GetByronWalletUtxoSnapshotResponseBody200EntriesAssets' with all required fields.
mkGetByronWalletUtxoSnapshotResponseBody200EntriesAssets :: Data.Text.Internal.Text -- ^ 'getByronWalletUtxoSnapshotResponseBody200EntriesAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'getByronWalletUtxoSnapshotResponseBody200EntriesAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'getByronWalletUtxoSnapshotResponseBody200EntriesAssetsQuantity'
  -> GetByronWalletUtxoSnapshotResponseBody200EntriesAssets
mkGetByronWalletUtxoSnapshotResponseBody200EntriesAssets getByronWalletUtxoSnapshotResponseBody200EntriesAssetsAsset_name getByronWalletUtxoSnapshotResponseBody200EntriesAssetsPolicy_id getByronWalletUtxoSnapshotResponseBody200EntriesAssetsQuantity = GetByronWalletUtxoSnapshotResponseBody200EntriesAssets{getByronWalletUtxoSnapshotResponseBody200EntriesAssetsAsset_name = getByronWalletUtxoSnapshotResponseBody200EntriesAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                  getByronWalletUtxoSnapshotResponseBody200EntriesAssetsPolicy_id = getByronWalletUtxoSnapshotResponseBody200EntriesAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                  getByronWalletUtxoSnapshotResponseBody200EntriesAssetsQuantity = getByronWalletUtxoSnapshotResponseBody200EntriesAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/utxo.GET.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data GetByronWalletUtxoSnapshotResponseBody404 = GetByronWalletUtxoSnapshotResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  getByronWalletUtxoSnapshotResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletUtxoSnapshotResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletUtxoSnapshotResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletUtxoSnapshotResponseBody404" (\obj -> GHC.Base.pure GetByronWalletUtxoSnapshotResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetByronWalletUtxoSnapshotResponseBody404' with all required fields.
mkGetByronWalletUtxoSnapshotResponseBody404 :: Data.Text.Internal.Text -- ^ 'getByronWalletUtxoSnapshotResponseBody404Message'
  -> GetByronWalletUtxoSnapshotResponseBody404
mkGetByronWalletUtxoSnapshotResponseBody404 getByronWalletUtxoSnapshotResponseBody404Message = GetByronWalletUtxoSnapshotResponseBody404{getByronWalletUtxoSnapshotResponseBody404Message = getByronWalletUtxoSnapshotResponseBody404Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/utxo.GET.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data GetByronWalletUtxoSnapshotResponseBody406 = GetByronWalletUtxoSnapshotResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  getByronWalletUtxoSnapshotResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON GetByronWalletUtxoSnapshotResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= getByronWalletUtxoSnapshotResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON GetByronWalletUtxoSnapshotResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "GetByronWalletUtxoSnapshotResponseBody406" (\obj -> GHC.Base.pure GetByronWalletUtxoSnapshotResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'GetByronWalletUtxoSnapshotResponseBody406' with all required fields.
mkGetByronWalletUtxoSnapshotResponseBody406 :: Data.Text.Internal.Text -- ^ 'getByronWalletUtxoSnapshotResponseBody406Message'
  -> GetByronWalletUtxoSnapshotResponseBody406
mkGetByronWalletUtxoSnapshotResponseBody406 getByronWalletUtxoSnapshotResponseBody406Message = GetByronWalletUtxoSnapshotResponseBody406{getByronWalletUtxoSnapshotResponseBody406Message = getByronWalletUtxoSnapshotResponseBody406Message}
-- | > GET /byron-wallets/{walletId}/utxo
-- 
-- The same as 'getByronWalletUtxoSnapshot' but accepts an explicit configuration.
getByronWalletUtxoSnapshotWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> m (Network.HTTP.Client.Types.Response GetByronWalletUtxoSnapshotResponse) -- ^ Monadic computation which returns the result of the operation
getByronWalletUtxoSnapshotWithConfiguration config
                                            walletId = GHC.Base.fmap (\response_4 -> GHC.Base.fmap (Data.Either.either GetByronWalletUtxoSnapshotResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> GetByronWalletUtxoSnapshotResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      GetByronWalletUtxoSnapshotResponseBody200)
                                                                                                                                                                                                            | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> GetByronWalletUtxoSnapshotResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      GetByronWalletUtxoSnapshotResponseBody404)
                                                                                                                                                                                                            | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> GetByronWalletUtxoSnapshotResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                      GetByronWalletUtxoSnapshotResponseBody406)
                                                                                                                                                                                                            | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_4) response_4) (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/utxo")) GHC.Base.mempty)
-- | > GET /byron-wallets/{walletId}/utxo
-- 
-- The same as 'getByronWalletUtxoSnapshot' but returns the raw 'Data.ByteString.ByteString'.
getByronWalletUtxoSnapshotRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
getByronWalletUtxoSnapshotRaw walletId = GHC.Base.id (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/utxo")) GHC.Base.mempty)
-- | > GET /byron-wallets/{walletId}/utxo
-- 
-- The same as 'getByronWalletUtxoSnapshot' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
getByronWalletUtxoSnapshotWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
getByronWalletUtxoSnapshotWithConfigurationRaw config
                                               walletId = GHC.Base.id (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/utxo")) GHC.Base.mempty)
