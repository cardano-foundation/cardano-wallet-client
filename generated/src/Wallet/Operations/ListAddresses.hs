-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation listAddresses
module Wallet.Operations.ListAddresses where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > GET /wallets/{walletId}/addresses
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Return a list of known addresses, ordered from newest to oldest
listAddresses :: forall m . Wallet.Common.MonadHTTP m => ListAddressesParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response ListAddressesResponse) -- ^ Monadic computation which returns the result of the operation
listAddresses parameters = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either ListAddressesResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ListAddressesResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                ([ListAddressesResponseBody200]))
                                                                                                                                                                   | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> ListAddressesResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                ListAddressesResponseBody400)
                                                                                                                                                                   | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> ListAddressesResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                ListAddressesResponseBody404)
                                                                                                                                                                   | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ListAddressesResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                ListAddressesResponseBody406)
                                                                                                                                                                   | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listAddressesParametersPathWalletId parameters))) GHC.Base.<> "/addresses")) [Wallet.Common.QueryParameter (Data.Text.pack "state") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listAddressesParametersQueryState parameters) (Data.Text.pack "form") GHC.Types.False])
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/addresses.GET.parameters@ in the specification.
-- 
-- 
data ListAddressesParameters = ListAddressesParameters {
  -- | pathWalletId: Represents the parameter named \'walletId\'
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  listAddressesParametersPathWalletId :: Data.Text.Internal.Text
  -- | queryState: Represents the parameter named \'state\'
  -- 
  -- An optional filter on the address state.
  , listAddressesParametersQueryState :: (GHC.Maybe.Maybe ListAddressesParametersQueryState)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListAddressesParameters
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pathWalletId" Data.Aeson.Types.ToJSON..= listAddressesParametersPathWalletId obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryState" Data.Aeson.Types.ToJSON..=)) (listAddressesParametersQueryState obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pathWalletId" Data.Aeson.Types.ToJSON..= listAddressesParametersPathWalletId obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("queryState" Data.Aeson.Types.ToJSON..=)) (listAddressesParametersQueryState obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListAddressesParameters
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListAddressesParameters" (\obj -> (GHC.Base.pure ListAddressesParameters GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pathWalletId")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "queryState"))
-- | Create a new 'ListAddressesParameters' with all required fields.
mkListAddressesParameters :: Data.Text.Internal.Text -- ^ 'listAddressesParametersPathWalletId'
  -> ListAddressesParameters
mkListAddressesParameters listAddressesParametersPathWalletId = ListAddressesParameters{listAddressesParametersPathWalletId = listAddressesParametersPathWalletId,
                                                                                        listAddressesParametersQueryState = GHC.Maybe.Nothing}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/addresses.GET.parameters.properties.queryState@ in the specification.
-- 
-- Represents the parameter named \'state\'
-- 
-- An optional filter on the address state.
data ListAddressesParametersQueryState =
   ListAddressesParametersQueryStateOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListAddressesParametersQueryStateTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListAddressesParametersQueryStateEnumUsed -- ^ Represents the JSON value @"used"@
  | ListAddressesParametersQueryStateEnumUnused -- ^ Represents the JSON value @"unused"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListAddressesParametersQueryState
    where toJSON (ListAddressesParametersQueryStateOther val) = val
          toJSON (ListAddressesParametersQueryStateTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListAddressesParametersQueryStateEnumUsed) = "used"
          toJSON (ListAddressesParametersQueryStateEnumUnused) = "unused"
instance Data.Aeson.Types.FromJSON.FromJSON ListAddressesParametersQueryState
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "used" -> ListAddressesParametersQueryStateEnumUsed
                                            | val GHC.Classes.== "unused" -> ListAddressesParametersQueryStateEnumUnused
                                            | GHC.Base.otherwise -> ListAddressesParametersQueryStateOther val)
-- | Represents a response of the operation 'listAddresses'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'ListAddressesResponseError' is used.
data ListAddressesResponse =
   ListAddressesResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | ListAddressesResponse200 ([ListAddressesResponseBody200]) -- ^ Ok
  | ListAddressesResponse400 ListAddressesResponseBody400 -- ^ Bad Request
  | ListAddressesResponse404 ListAddressesResponseBody404 -- ^ Not Found
  | ListAddressesResponse406 ListAddressesResponseBody406 -- ^ Not Acceptable
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/addresses.GET.responses.200.content.application\/json.schema.items@ in the specification.
-- 
-- 
data ListAddressesResponseBody200 = ListAddressesResponseBody200 {
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  listAddressesResponseBody200Derivation_path :: ([Data.Text.Internal.Text])
  -- | id: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  , listAddressesResponseBody200Id :: Data.Text.Internal.Text
  -- | state
  , listAddressesResponseBody200State :: ListAddressesResponseBody200State
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListAddressesResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["derivation_path" Data.Aeson.Types.ToJSON..= listAddressesResponseBody200Derivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= listAddressesResponseBody200Id obj] : ["state" Data.Aeson.Types.ToJSON..= listAddressesResponseBody200State obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["derivation_path" Data.Aeson.Types.ToJSON..= listAddressesResponseBody200Derivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= listAddressesResponseBody200Id obj] : ["state" Data.Aeson.Types.ToJSON..= listAddressesResponseBody200State obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListAddressesResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListAddressesResponseBody200" (\obj -> ((GHC.Base.pure ListAddressesResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "state"))
-- | Create a new 'ListAddressesResponseBody200' with all required fields.
mkListAddressesResponseBody200 :: [Data.Text.Internal.Text] -- ^ 'listAddressesResponseBody200Derivation_path'
  -> Data.Text.Internal.Text -- ^ 'listAddressesResponseBody200Id'
  -> ListAddressesResponseBody200State -- ^ 'listAddressesResponseBody200State'
  -> ListAddressesResponseBody200
mkListAddressesResponseBody200 listAddressesResponseBody200Derivation_path listAddressesResponseBody200Id listAddressesResponseBody200State = ListAddressesResponseBody200{listAddressesResponseBody200Derivation_path = listAddressesResponseBody200Derivation_path,
                                                                                                                                                                           listAddressesResponseBody200Id = listAddressesResponseBody200Id,
                                                                                                                                                                           listAddressesResponseBody200State = listAddressesResponseBody200State}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/addresses.GET.responses.200.content.application\/json.schema.items.properties.state@ in the specification.
-- 
-- 
data ListAddressesResponseBody200State =
   ListAddressesResponseBody200StateOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListAddressesResponseBody200StateTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListAddressesResponseBody200StateEnumUsed -- ^ Represents the JSON value @"used"@
  | ListAddressesResponseBody200StateEnumUnused -- ^ Represents the JSON value @"unused"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListAddressesResponseBody200State
    where toJSON (ListAddressesResponseBody200StateOther val) = val
          toJSON (ListAddressesResponseBody200StateTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListAddressesResponseBody200StateEnumUsed) = "used"
          toJSON (ListAddressesResponseBody200StateEnumUnused) = "unused"
instance Data.Aeson.Types.FromJSON.FromJSON ListAddressesResponseBody200State
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "used" -> ListAddressesResponseBody200StateEnumUsed
                                            | val GHC.Classes.== "unused" -> ListAddressesResponseBody200StateEnumUnused
                                            | GHC.Base.otherwise -> ListAddressesResponseBody200StateOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/addresses.GET.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data ListAddressesResponseBody400 = ListAddressesResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  listAddressesResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListAddressesResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listAddressesResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listAddressesResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListAddressesResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListAddressesResponseBody400" (\obj -> GHC.Base.pure ListAddressesResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListAddressesResponseBody400' with all required fields.
mkListAddressesResponseBody400 :: Data.Text.Internal.Text -- ^ 'listAddressesResponseBody400Message'
  -> ListAddressesResponseBody400
mkListAddressesResponseBody400 listAddressesResponseBody400Message = ListAddressesResponseBody400{listAddressesResponseBody400Message = listAddressesResponseBody400Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/addresses.GET.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data ListAddressesResponseBody404 = ListAddressesResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  listAddressesResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListAddressesResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listAddressesResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listAddressesResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListAddressesResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListAddressesResponseBody404" (\obj -> GHC.Base.pure ListAddressesResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListAddressesResponseBody404' with all required fields.
mkListAddressesResponseBody404 :: Data.Text.Internal.Text -- ^ 'listAddressesResponseBody404Message'
  -> ListAddressesResponseBody404
mkListAddressesResponseBody404 listAddressesResponseBody404Message = ListAddressesResponseBody404{listAddressesResponseBody404Message = listAddressesResponseBody404Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/addresses.GET.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data ListAddressesResponseBody406 = ListAddressesResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  listAddressesResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListAddressesResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listAddressesResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listAddressesResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListAddressesResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListAddressesResponseBody406" (\obj -> GHC.Base.pure ListAddressesResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListAddressesResponseBody406' with all required fields.
mkListAddressesResponseBody406 :: Data.Text.Internal.Text -- ^ 'listAddressesResponseBody406Message'
  -> ListAddressesResponseBody406
mkListAddressesResponseBody406 listAddressesResponseBody406Message = ListAddressesResponseBody406{listAddressesResponseBody406Message = listAddressesResponseBody406Message}
-- | > GET /wallets/{walletId}/addresses
-- 
-- The same as 'listAddresses' but accepts an explicit configuration.
listAddressesWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> ListAddressesParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response ListAddressesResponse) -- ^ Monadic computation which returns the result of the operation
listAddressesWithConfiguration config
                               parameters = GHC.Base.fmap (\response_5 -> GHC.Base.fmap (Data.Either.either ListAddressesResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ListAddressesResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                 ([ListAddressesResponseBody200]))
                                                                                                                                                                                    | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> ListAddressesResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                 ListAddressesResponseBody400)
                                                                                                                                                                                    | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> ListAddressesResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                 ListAddressesResponseBody404)
                                                                                                                                                                                    | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ListAddressesResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                 ListAddressesResponseBody406)
                                                                                                                                                                                    | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_5) response_5) (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listAddressesParametersPathWalletId parameters))) GHC.Base.<> "/addresses")) [Wallet.Common.QueryParameter (Data.Text.pack "state") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listAddressesParametersQueryState parameters) (Data.Text.pack "form") GHC.Types.False])
-- | > GET /wallets/{walletId}/addresses
-- 
-- The same as 'listAddresses' but returns the raw 'Data.ByteString.ByteString'.
listAddressesRaw :: forall m . Wallet.Common.MonadHTTP m => ListAddressesParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
listAddressesRaw parameters = GHC.Base.id (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listAddressesParametersPathWalletId parameters))) GHC.Base.<> "/addresses")) [Wallet.Common.QueryParameter (Data.Text.pack "state") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listAddressesParametersQueryState parameters) (Data.Text.pack "form") GHC.Types.False])
-- | > GET /wallets/{walletId}/addresses
-- 
-- The same as 'listAddresses' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
listAddressesWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> ListAddressesParameters -- ^ Contains all available parameters of this operation (query and path parameters)
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
listAddressesWithConfigurationRaw config
                                  parameters = GHC.Base.id (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel (listAddressesParametersPathWalletId parameters))) GHC.Base.<> "/addresses")) [Wallet.Common.QueryParameter (Data.Text.pack "state") (Data.Aeson.Types.ToJSON.toJSON Data.Functor.<$> listAddressesParametersQueryState parameters) (Data.Text.pack "form") GHC.Types.False])
