-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation listByronWallets
module Wallet.Operations.ListByronWallets where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > GET /byron-wallets
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Return a list of known Byron wallets, ordered from oldest to newest.
listByronWallets :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response ListByronWalletsResponse) -- ^ Monadic computation which returns the result of the operation
listByronWallets = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either ListByronWalletsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ListByronWalletsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                              ([ListByronWalletsResponseBody200]))
                                                                                                                                                              | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ListByronWalletsResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                              ListByronWalletsResponseBody406)
                                                                                                                                                              | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") "/byron-wallets" GHC.Base.mempty)
-- | Represents a response of the operation 'listByronWallets'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'ListByronWalletsResponseError' is used.
data ListByronWalletsResponse =
   ListByronWalletsResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | ListByronWalletsResponse200 ([ListByronWalletsResponseBody200]) -- ^ Ok
  | ListByronWalletsResponse406 ListByronWalletsResponseBody406 -- ^ Not Acceptable
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/byron-wallets.GET.responses.200.content.application\/json.schema.items@ in the specification.
-- 
-- 
data ListByronWalletsResponseBody200 = ListByronWalletsResponseBody200 {
  -- | assets: Current non-Ada asset holdings of the wallet.
  -- 
  -- The amount of assets available to spend may be less than the total
  -- unspent assets due to transaction change amounts which are yet to
  -- be fully confirmed (pending).
  listByronWalletsResponseBody200Assets :: ListByronWalletsResponseBody200Assets
  -- | balance: Byron wallet\'s current balance(s)
  , listByronWalletsResponseBody200Balance :: ListByronWalletsResponseBody200Balance
  -- | discovery: Mechanism used for discovering addresses.
  , listByronWalletsResponseBody200Discovery :: ListByronWalletsResponseBody200Discovery
  -- | id: A unique identifier for the wallet
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 40
  -- * Minimum length of 40
  , listByronWalletsResponseBody200Id :: Data.Text.Internal.Text
  -- | name
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 1
  , listByronWalletsResponseBody200Name :: Data.Text.Internal.Text
  -- | passphrase: Information about the wallet\'s passphrase
  , listByronWalletsResponseBody200Passphrase :: (GHC.Maybe.Maybe ListByronWalletsResponseBody200Passphrase)
  -- | state: Whether a wallet is ready to use or still syncing
  , listByronWalletsResponseBody200State :: ListByronWalletsResponseBody200State
  -- | tip: A reference to a particular time slot, and the block height at that point.
  , listByronWalletsResponseBody200Tip :: ListByronWalletsResponseBody200Tip
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronWalletsResponseBody200
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200Balance obj] : ["discovery" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200Discovery obj] : ["id" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200Id obj] : ["name" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (listByronWalletsResponseBody200Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200State obj] : ["tip" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200Tip obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200Assets obj] : ["balance" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200Balance obj] : ["discovery" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200Discovery obj] : ["id" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200Id obj] : ["name" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200Name obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("passphrase" Data.Aeson.Types.ToJSON..=)) (listByronWalletsResponseBody200Passphrase obj) : ["state" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200State obj] : ["tip" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200Tip obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronWalletsResponseBody200
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronWalletsResponseBody200" (\obj -> (((((((GHC.Base.pure ListByronWalletsResponseBody200 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "balance")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "discovery")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "state")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tip"))
-- | Create a new 'ListByronWalletsResponseBody200' with all required fields.
mkListByronWalletsResponseBody200 :: ListByronWalletsResponseBody200Assets -- ^ 'listByronWalletsResponseBody200Assets'
  -> ListByronWalletsResponseBody200Balance -- ^ 'listByronWalletsResponseBody200Balance'
  -> ListByronWalletsResponseBody200Discovery -- ^ 'listByronWalletsResponseBody200Discovery'
  -> Data.Text.Internal.Text -- ^ 'listByronWalletsResponseBody200Id'
  -> Data.Text.Internal.Text -- ^ 'listByronWalletsResponseBody200Name'
  -> ListByronWalletsResponseBody200State -- ^ 'listByronWalletsResponseBody200State'
  -> ListByronWalletsResponseBody200Tip -- ^ 'listByronWalletsResponseBody200Tip'
  -> ListByronWalletsResponseBody200
mkListByronWalletsResponseBody200 listByronWalletsResponseBody200Assets listByronWalletsResponseBody200Balance listByronWalletsResponseBody200Discovery listByronWalletsResponseBody200Id listByronWalletsResponseBody200Name listByronWalletsResponseBody200State listByronWalletsResponseBody200Tip = ListByronWalletsResponseBody200{listByronWalletsResponseBody200Assets = listByronWalletsResponseBody200Assets,
                                                                                                                                                                                                                                                                                                                                        listByronWalletsResponseBody200Balance = listByronWalletsResponseBody200Balance,
                                                                                                                                                                                                                                                                                                                                        listByronWalletsResponseBody200Discovery = listByronWalletsResponseBody200Discovery,
                                                                                                                                                                                                                                                                                                                                        listByronWalletsResponseBody200Id = listByronWalletsResponseBody200Id,
                                                                                                                                                                                                                                                                                                                                        listByronWalletsResponseBody200Name = listByronWalletsResponseBody200Name,
                                                                                                                                                                                                                                                                                                                                        listByronWalletsResponseBody200Passphrase = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                        listByronWalletsResponseBody200State = listByronWalletsResponseBody200State,
                                                                                                                                                                                                                                                                                                                                        listByronWalletsResponseBody200Tip = listByronWalletsResponseBody200Tip}
-- | Defines the object schema located at @paths.\/byron-wallets.GET.responses.200.content.application\/json.schema.items.properties.assets@ in the specification.
-- 
-- Current non-Ada asset holdings of the wallet.
-- 
-- The amount of assets available to spend may be less than the total
-- unspent assets due to transaction change amounts which are yet to
-- be fully confirmed (pending).
data ListByronWalletsResponseBody200Assets = ListByronWalletsResponseBody200Assets {
  -- | available: Available UTxO asset balances (funds that can be spent without
  -- condition).
  listByronWalletsResponseBody200AssetsAvailable :: ([ListByronWalletsResponseBody200AssetsAvailable])
  -- | total: Total asset balances (available balances plus pending change balances).
  , listByronWalletsResponseBody200AssetsTotal :: ([ListByronWalletsResponseBody200AssetsTotal])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronWalletsResponseBody200Assets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronWalletsResponseBody200Assets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronWalletsResponseBody200Assets" (\obj -> (GHC.Base.pure ListByronWalletsResponseBody200Assets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'ListByronWalletsResponseBody200Assets' with all required fields.
mkListByronWalletsResponseBody200Assets :: [ListByronWalletsResponseBody200AssetsAvailable] -- ^ 'listByronWalletsResponseBody200AssetsAvailable'
  -> [ListByronWalletsResponseBody200AssetsTotal] -- ^ 'listByronWalletsResponseBody200AssetsTotal'
  -> ListByronWalletsResponseBody200Assets
mkListByronWalletsResponseBody200Assets listByronWalletsResponseBody200AssetsAvailable listByronWalletsResponseBody200AssetsTotal = ListByronWalletsResponseBody200Assets{listByronWalletsResponseBody200AssetsAvailable = listByronWalletsResponseBody200AssetsAvailable,
                                                                                                                                                                          listByronWalletsResponseBody200AssetsTotal = listByronWalletsResponseBody200AssetsTotal}
-- | Defines the object schema located at @paths.\/byron-wallets.GET.responses.200.content.application\/json.schema.items.properties.assets.properties.available.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ListByronWalletsResponseBody200AssetsAvailable = ListByronWalletsResponseBody200AssetsAvailable {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listByronWalletsResponseBody200AssetsAvailableAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listByronWalletsResponseBody200AssetsAvailablePolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronWalletsResponseBody200AssetsAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronWalletsResponseBody200AssetsAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsAvailableQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsAvailableAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsAvailablePolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsAvailableQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronWalletsResponseBody200AssetsAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronWalletsResponseBody200AssetsAvailable" (\obj -> ((GHC.Base.pure ListByronWalletsResponseBody200AssetsAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronWalletsResponseBody200AssetsAvailable' with all required fields.
mkListByronWalletsResponseBody200AssetsAvailable :: Data.Text.Internal.Text -- ^ 'listByronWalletsResponseBody200AssetsAvailableAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listByronWalletsResponseBody200AssetsAvailablePolicy_id'
  -> GHC.Types.Int -- ^ 'listByronWalletsResponseBody200AssetsAvailableQuantity'
  -> ListByronWalletsResponseBody200AssetsAvailable
mkListByronWalletsResponseBody200AssetsAvailable listByronWalletsResponseBody200AssetsAvailableAsset_name listByronWalletsResponseBody200AssetsAvailablePolicy_id listByronWalletsResponseBody200AssetsAvailableQuantity = ListByronWalletsResponseBody200AssetsAvailable{listByronWalletsResponseBody200AssetsAvailableAsset_name = listByronWalletsResponseBody200AssetsAvailableAsset_name,
                                                                                                                                                                                                                                                                          listByronWalletsResponseBody200AssetsAvailablePolicy_id = listByronWalletsResponseBody200AssetsAvailablePolicy_id,
                                                                                                                                                                                                                                                                          listByronWalletsResponseBody200AssetsAvailableQuantity = listByronWalletsResponseBody200AssetsAvailableQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets.GET.responses.200.content.application\/json.schema.items.properties.assets.properties.total.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data ListByronWalletsResponseBody200AssetsTotal = ListByronWalletsResponseBody200AssetsTotal {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  listByronWalletsResponseBody200AssetsTotalAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , listByronWalletsResponseBody200AssetsTotalPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronWalletsResponseBody200AssetsTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronWalletsResponseBody200AssetsTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsTotalQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsTotalAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsTotalPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200AssetsTotalQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronWalletsResponseBody200AssetsTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronWalletsResponseBody200AssetsTotal" (\obj -> ((GHC.Base.pure ListByronWalletsResponseBody200AssetsTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronWalletsResponseBody200AssetsTotal' with all required fields.
mkListByronWalletsResponseBody200AssetsTotal :: Data.Text.Internal.Text -- ^ 'listByronWalletsResponseBody200AssetsTotalAsset_name'
  -> Data.Text.Internal.Text -- ^ 'listByronWalletsResponseBody200AssetsTotalPolicy_id'
  -> GHC.Types.Int -- ^ 'listByronWalletsResponseBody200AssetsTotalQuantity'
  -> ListByronWalletsResponseBody200AssetsTotal
mkListByronWalletsResponseBody200AssetsTotal listByronWalletsResponseBody200AssetsTotalAsset_name listByronWalletsResponseBody200AssetsTotalPolicy_id listByronWalletsResponseBody200AssetsTotalQuantity = ListByronWalletsResponseBody200AssetsTotal{listByronWalletsResponseBody200AssetsTotalAsset_name = listByronWalletsResponseBody200AssetsTotalAsset_name,
                                                                                                                                                                                                                                                      listByronWalletsResponseBody200AssetsTotalPolicy_id = listByronWalletsResponseBody200AssetsTotalPolicy_id,
                                                                                                                                                                                                                                                      listByronWalletsResponseBody200AssetsTotalQuantity = listByronWalletsResponseBody200AssetsTotalQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets.GET.responses.200.content.application\/json.schema.items.properties.balance@ in the specification.
-- 
-- Byron wallet\'s current balance(s)
data ListByronWalletsResponseBody200Balance = ListByronWalletsResponseBody200Balance {
  -- | available: Available balance (funds that can be spent)
  listByronWalletsResponseBody200BalanceAvailable :: ListByronWalletsResponseBody200BalanceAvailable
  -- | total: Total balance (available balance plus pending change)
  , listByronWalletsResponseBody200BalanceTotal :: ListByronWalletsResponseBody200BalanceTotal
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronWalletsResponseBody200Balance
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200BalanceAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200BalanceTotal obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["available" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200BalanceAvailable obj] : ["total" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200BalanceTotal obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronWalletsResponseBody200Balance
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronWalletsResponseBody200Balance" (\obj -> (GHC.Base.pure ListByronWalletsResponseBody200Balance GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "available")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total"))
-- | Create a new 'ListByronWalletsResponseBody200Balance' with all required fields.
mkListByronWalletsResponseBody200Balance :: ListByronWalletsResponseBody200BalanceAvailable -- ^ 'listByronWalletsResponseBody200BalanceAvailable'
  -> ListByronWalletsResponseBody200BalanceTotal -- ^ 'listByronWalletsResponseBody200BalanceTotal'
  -> ListByronWalletsResponseBody200Balance
mkListByronWalletsResponseBody200Balance listByronWalletsResponseBody200BalanceAvailable listByronWalletsResponseBody200BalanceTotal = ListByronWalletsResponseBody200Balance{listByronWalletsResponseBody200BalanceAvailable = listByronWalletsResponseBody200BalanceAvailable,
                                                                                                                                                                              listByronWalletsResponseBody200BalanceTotal = listByronWalletsResponseBody200BalanceTotal}
-- | Defines the object schema located at @paths.\/byron-wallets.GET.responses.200.content.application\/json.schema.items.properties.balance.properties.available@ in the specification.
-- 
-- Available balance (funds that can be spent)
data ListByronWalletsResponseBody200BalanceAvailable = ListByronWalletsResponseBody200BalanceAvailable {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronWalletsResponseBody200BalanceAvailableQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronWalletsResponseBody200BalanceAvailable
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200BalanceAvailableQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronWalletsResponseBody200BalanceAvailable
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronWalletsResponseBody200BalanceAvailable" (\obj -> GHC.Base.pure ListByronWalletsResponseBody200BalanceAvailable GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronWalletsResponseBody200BalanceAvailable' with all required fields.
mkListByronWalletsResponseBody200BalanceAvailable :: GHC.Types.Int -- ^ 'listByronWalletsResponseBody200BalanceAvailableQuantity'
  -> ListByronWalletsResponseBody200BalanceAvailable
mkListByronWalletsResponseBody200BalanceAvailable listByronWalletsResponseBody200BalanceAvailableQuantity = ListByronWalletsResponseBody200BalanceAvailable{listByronWalletsResponseBody200BalanceAvailableQuantity = listByronWalletsResponseBody200BalanceAvailableQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets.GET.responses.200.content.application\/json.schema.items.properties.balance.properties.total@ in the specification.
-- 
-- Total balance (available balance plus pending change)
data ListByronWalletsResponseBody200BalanceTotal = ListByronWalletsResponseBody200BalanceTotal {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronWalletsResponseBody200BalanceTotalQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronWalletsResponseBody200BalanceTotal
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200BalanceTotalQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronWalletsResponseBody200BalanceTotal
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronWalletsResponseBody200BalanceTotal" (\obj -> GHC.Base.pure ListByronWalletsResponseBody200BalanceTotal GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronWalletsResponseBody200BalanceTotal' with all required fields.
mkListByronWalletsResponseBody200BalanceTotal :: GHC.Types.Int -- ^ 'listByronWalletsResponseBody200BalanceTotalQuantity'
  -> ListByronWalletsResponseBody200BalanceTotal
mkListByronWalletsResponseBody200BalanceTotal listByronWalletsResponseBody200BalanceTotalQuantity = ListByronWalletsResponseBody200BalanceTotal{listByronWalletsResponseBody200BalanceTotalQuantity = listByronWalletsResponseBody200BalanceTotalQuantity}
-- | Defines the enum schema located at @paths.\/byron-wallets.GET.responses.200.content.application\/json.schema.items.properties.discovery@ in the specification.
-- 
-- Mechanism used for discovering addresses.
data ListByronWalletsResponseBody200Discovery =
   ListByronWalletsResponseBody200DiscoveryOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListByronWalletsResponseBody200DiscoveryTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListByronWalletsResponseBody200DiscoveryEnumRandom -- ^ Represents the JSON value @"random"@
  | ListByronWalletsResponseBody200DiscoveryEnumSequential -- ^ Represents the JSON value @"sequential"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronWalletsResponseBody200Discovery
    where toJSON (ListByronWalletsResponseBody200DiscoveryOther val) = val
          toJSON (ListByronWalletsResponseBody200DiscoveryTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListByronWalletsResponseBody200DiscoveryEnumRandom) = "random"
          toJSON (ListByronWalletsResponseBody200DiscoveryEnumSequential) = "sequential"
instance Data.Aeson.Types.FromJSON.FromJSON ListByronWalletsResponseBody200Discovery
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "random" -> ListByronWalletsResponseBody200DiscoveryEnumRandom
                                            | val GHC.Classes.== "sequential" -> ListByronWalletsResponseBody200DiscoveryEnumSequential
                                            | GHC.Base.otherwise -> ListByronWalletsResponseBody200DiscoveryOther val)
-- | Defines the object schema located at @paths.\/byron-wallets.GET.responses.200.content.application\/json.schema.items.properties.passphrase@ in the specification.
-- 
-- Information about the wallet\'s passphrase
data ListByronWalletsResponseBody200Passphrase = ListByronWalletsResponseBody200Passphrase {
  -- | last_updated_at
  listByronWalletsResponseBody200PassphraseLast_updated_at :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronWalletsResponseBody200Passphrase
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200PassphraseLast_updated_at obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["last_updated_at" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200PassphraseLast_updated_at obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronWalletsResponseBody200Passphrase
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronWalletsResponseBody200Passphrase" (\obj -> GHC.Base.pure ListByronWalletsResponseBody200Passphrase GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "last_updated_at"))
-- | Create a new 'ListByronWalletsResponseBody200Passphrase' with all required fields.
mkListByronWalletsResponseBody200Passphrase :: Data.Text.Internal.Text -- ^ 'listByronWalletsResponseBody200PassphraseLast_updated_at'
  -> ListByronWalletsResponseBody200Passphrase
mkListByronWalletsResponseBody200Passphrase listByronWalletsResponseBody200PassphraseLast_updated_at = ListByronWalletsResponseBody200Passphrase{listByronWalletsResponseBody200PassphraseLast_updated_at = listByronWalletsResponseBody200PassphraseLast_updated_at}
-- | Defines the object schema located at @paths.\/byron-wallets.GET.responses.200.content.application\/json.schema.items.properties.state@ in the specification.
-- 
-- Whether a wallet is ready to use or still syncing
data ListByronWalletsResponseBody200State = ListByronWalletsResponseBody200State {
  -- | progress: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == syncing
  -- \<\/span>\<br\/>
  listByronWalletsResponseBody200StateProgress :: (GHC.Maybe.Maybe ListByronWalletsResponseBody200StateProgress)
  -- | status
  , listByronWalletsResponseBody200StateStatus :: ListByronWalletsResponseBody200StateStatus
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronWalletsResponseBody200State
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (listByronWalletsResponseBody200StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200StateStatus obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("progress" Data.Aeson.Types.ToJSON..=)) (listByronWalletsResponseBody200StateProgress obj) : ["status" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200StateStatus obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronWalletsResponseBody200State
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronWalletsResponseBody200State" (\obj -> (GHC.Base.pure ListByronWalletsResponseBody200State GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "progress")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status"))
-- | Create a new 'ListByronWalletsResponseBody200State' with all required fields.
mkListByronWalletsResponseBody200State :: ListByronWalletsResponseBody200StateStatus -- ^ 'listByronWalletsResponseBody200StateStatus'
  -> ListByronWalletsResponseBody200State
mkListByronWalletsResponseBody200State listByronWalletsResponseBody200StateStatus = ListByronWalletsResponseBody200State{listByronWalletsResponseBody200StateProgress = GHC.Maybe.Nothing,
                                                                                                                         listByronWalletsResponseBody200StateStatus = listByronWalletsResponseBody200StateStatus}
-- | Defines the object schema located at @paths.\/byron-wallets.GET.responses.200.content.application\/json.schema.items.properties.state.properties.progress@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == syncing
-- \<\/span>\<br\/>
data ListByronWalletsResponseBody200StateProgress = ListByronWalletsResponseBody200StateProgress {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  listByronWalletsResponseBody200StateProgressQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronWalletsResponseBody200StateProgress
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200StateProgressQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronWalletsResponseBody200StateProgress
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronWalletsResponseBody200StateProgress" (\obj -> GHC.Base.pure ListByronWalletsResponseBody200StateProgress GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronWalletsResponseBody200StateProgress' with all required fields.
mkListByronWalletsResponseBody200StateProgress :: GHC.Types.Double -- ^ 'listByronWalletsResponseBody200StateProgressQuantity'
  -> ListByronWalletsResponseBody200StateProgress
mkListByronWalletsResponseBody200StateProgress listByronWalletsResponseBody200StateProgressQuantity = ListByronWalletsResponseBody200StateProgress{listByronWalletsResponseBody200StateProgressQuantity = listByronWalletsResponseBody200StateProgressQuantity}
-- | Defines the enum schema located at @paths.\/byron-wallets.GET.responses.200.content.application\/json.schema.items.properties.state.properties.status@ in the specification.
-- 
-- 
data ListByronWalletsResponseBody200StateStatus =
   ListByronWalletsResponseBody200StateStatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | ListByronWalletsResponseBody200StateStatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | ListByronWalletsResponseBody200StateStatusEnumReady -- ^ Represents the JSON value @"ready"@
  | ListByronWalletsResponseBody200StateStatusEnumSyncing -- ^ Represents the JSON value @"syncing"@
  | ListByronWalletsResponseBody200StateStatusEnumNot_responding -- ^ Represents the JSON value @"not_responding"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronWalletsResponseBody200StateStatus
    where toJSON (ListByronWalletsResponseBody200StateStatusOther val) = val
          toJSON (ListByronWalletsResponseBody200StateStatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (ListByronWalletsResponseBody200StateStatusEnumReady) = "ready"
          toJSON (ListByronWalletsResponseBody200StateStatusEnumSyncing) = "syncing"
          toJSON (ListByronWalletsResponseBody200StateStatusEnumNot_responding) = "not_responding"
instance Data.Aeson.Types.FromJSON.FromJSON ListByronWalletsResponseBody200StateStatus
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "ready" -> ListByronWalletsResponseBody200StateStatusEnumReady
                                            | val GHC.Classes.== "syncing" -> ListByronWalletsResponseBody200StateStatusEnumSyncing
                                            | val GHC.Classes.== "not_responding" -> ListByronWalletsResponseBody200StateStatusEnumNot_responding
                                            | GHC.Base.otherwise -> ListByronWalletsResponseBody200StateStatusOther val)
-- | Defines the object schema located at @paths.\/byron-wallets.GET.responses.200.content.application\/json.schema.items.properties.tip@ in the specification.
-- 
-- A reference to a particular time slot, and the block height at that point.
data ListByronWalletsResponseBody200Tip = ListByronWalletsResponseBody200Tip {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronWalletsResponseBody200TipAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronWalletsResponseBody200TipEpoch_number :: GHC.Types.Int
  -- | height
  , listByronWalletsResponseBody200TipHeight :: ListByronWalletsResponseBody200TipHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , listByronWalletsResponseBody200TipSlot_number :: GHC.Types.Int
  -- | time
  , listByronWalletsResponseBody200TipTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronWalletsResponseBody200Tip
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200TipTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200TipAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200TipEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200TipHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200TipSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200TipTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronWalletsResponseBody200Tip
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronWalletsResponseBody200Tip" (\obj -> ((((GHC.Base.pure ListByronWalletsResponseBody200Tip GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'ListByronWalletsResponseBody200Tip' with all required fields.
mkListByronWalletsResponseBody200Tip :: GHC.Types.Int -- ^ 'listByronWalletsResponseBody200TipAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'listByronWalletsResponseBody200TipEpoch_number'
  -> ListByronWalletsResponseBody200TipHeight -- ^ 'listByronWalletsResponseBody200TipHeight'
  -> GHC.Types.Int -- ^ 'listByronWalletsResponseBody200TipSlot_number'
  -> Data.Text.Internal.Text -- ^ 'listByronWalletsResponseBody200TipTime'
  -> ListByronWalletsResponseBody200Tip
mkListByronWalletsResponseBody200Tip listByronWalletsResponseBody200TipAbsolute_slot_number listByronWalletsResponseBody200TipEpoch_number listByronWalletsResponseBody200TipHeight listByronWalletsResponseBody200TipSlot_number listByronWalletsResponseBody200TipTime = ListByronWalletsResponseBody200Tip{listByronWalletsResponseBody200TipAbsolute_slot_number = listByronWalletsResponseBody200TipAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                              listByronWalletsResponseBody200TipEpoch_number = listByronWalletsResponseBody200TipEpoch_number,
                                                                                                                                                                                                                                                                                                              listByronWalletsResponseBody200TipHeight = listByronWalletsResponseBody200TipHeight,
                                                                                                                                                                                                                                                                                                              listByronWalletsResponseBody200TipSlot_number = listByronWalletsResponseBody200TipSlot_number,
                                                                                                                                                                                                                                                                                                              listByronWalletsResponseBody200TipTime = listByronWalletsResponseBody200TipTime}
-- | Defines the object schema located at @paths.\/byron-wallets.GET.responses.200.content.application\/json.schema.items.properties.tip.properties.height@ in the specification.
-- 
-- 
data ListByronWalletsResponseBody200TipHeight = ListByronWalletsResponseBody200TipHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  listByronWalletsResponseBody200TipHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronWalletsResponseBody200TipHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody200TipHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronWalletsResponseBody200TipHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronWalletsResponseBody200TipHeight" (\obj -> GHC.Base.pure ListByronWalletsResponseBody200TipHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'ListByronWalletsResponseBody200TipHeight' with all required fields.
mkListByronWalletsResponseBody200TipHeight :: GHC.Types.Int -- ^ 'listByronWalletsResponseBody200TipHeightQuantity'
  -> ListByronWalletsResponseBody200TipHeight
mkListByronWalletsResponseBody200TipHeight listByronWalletsResponseBody200TipHeightQuantity = ListByronWalletsResponseBody200TipHeight{listByronWalletsResponseBody200TipHeightQuantity = listByronWalletsResponseBody200TipHeightQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets.GET.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data ListByronWalletsResponseBody406 = ListByronWalletsResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  listByronWalletsResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON ListByronWalletsResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= listByronWalletsResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON ListByronWalletsResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "ListByronWalletsResponseBody406" (\obj -> GHC.Base.pure ListByronWalletsResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'ListByronWalletsResponseBody406' with all required fields.
mkListByronWalletsResponseBody406 :: Data.Text.Internal.Text -- ^ 'listByronWalletsResponseBody406Message'
  -> ListByronWalletsResponseBody406
mkListByronWalletsResponseBody406 listByronWalletsResponseBody406Message = ListByronWalletsResponseBody406{listByronWalletsResponseBody406Message = listByronWalletsResponseBody406Message}
-- | > GET /byron-wallets
-- 
-- The same as 'listByronWallets' but accepts an explicit configuration.
listByronWalletsWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> m (Network.HTTP.Client.Types.Response ListByronWalletsResponse) -- ^ Monadic computation which returns the result of the operation
listByronWalletsWithConfiguration config = GHC.Base.fmap (\response_3 -> GHC.Base.fmap (Data.Either.either ListByronWalletsResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 200) (Network.HTTP.Client.Types.responseStatus response) -> ListByronWalletsResponse200 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                      ([ListByronWalletsResponseBody200]))
                                                                                                                                                                                      | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> ListByronWalletsResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                      ListByronWalletsResponseBody406)
                                                                                                                                                                                      | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_3) response_3) (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") "/byron-wallets" GHC.Base.mempty)
-- | > GET /byron-wallets
-- 
-- The same as 'listByronWallets' but returns the raw 'Data.ByteString.ByteString'.
listByronWalletsRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
listByronWalletsRaw = GHC.Base.id (Wallet.Common.doCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") "/byron-wallets" GHC.Base.mempty)
-- | > GET /byron-wallets
-- 
-- The same as 'listByronWallets' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
listByronWalletsWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
listByronWalletsWithConfigurationRaw config = GHC.Base.id (Wallet.Common.doCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "GET") "/byron-wallets" GHC.Base.mempty)
