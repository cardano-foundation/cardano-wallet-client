-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation postByronTransaction
module Wallet.Operations.PostByronTransaction where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /byron-wallets/{walletId}/transactions
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
-- 
-- Create and send transaction from the wallet.
postByronTransaction :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostByronTransactionRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response PostByronTransactionResponse) -- ^ Monadic computation which returns the result of the operation
postByronTransaction walletId
                     body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PostByronTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               PostByronTransactionResponseBody202)
                                                                                                                                                                           | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               PostByronTransactionResponseBody400)
                                                                                                                                                                           | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               PostByronTransactionResponseBody403Variants)
                                                                                                                                                                           | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               PostByronTransactionResponseBody404)
                                                                                                                                                                           | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               PostByronTransactionResponseBody406)
                                                                                                                                                                           | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               PostByronTransactionResponseBody415)
                                                                                                                                                                           | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 425) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionResponse425 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               PostByronTransactionResponseBody425)
                                                                                                                                                                           | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.requestBody.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronTransactionRequestBody = PostByronTransactionRequestBody {
  -- | passphrase: The wallet\'s master passphrase.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 0
  postByronTransactionRequestBodyPassphrase :: Data.Text.Internal.Text
  -- | payments: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postByronTransactionRequestBodyPayments :: ([PostByronTransactionRequestBodyPayments])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["passphrase" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPassphrase obj] : ["payments" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPayments obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["passphrase" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPassphrase obj] : ["payments" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPayments obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionRequestBody" (\obj -> (GHC.Base.pure PostByronTransactionRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "payments"))
-- | Create a new 'PostByronTransactionRequestBody' with all required fields.
mkPostByronTransactionRequestBody :: Data.Text.Internal.Text -- ^ 'postByronTransactionRequestBodyPassphrase'
  -> [PostByronTransactionRequestBodyPayments] -- ^ 'postByronTransactionRequestBodyPayments'
  -> PostByronTransactionRequestBody
mkPostByronTransactionRequestBody postByronTransactionRequestBodyPassphrase postByronTransactionRequestBodyPayments = PostByronTransactionRequestBody{postByronTransactionRequestBodyPassphrase = postByronTransactionRequestBodyPassphrase,
                                                                                                                                                      postByronTransactionRequestBodyPayments = postByronTransactionRequestBodyPayments}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.requestBody.content.application\/json.schema.properties.payments.items@ in the specification.
-- 
-- 
data PostByronTransactionRequestBodyPayments = PostByronTransactionRequestBodyPayments {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  postByronTransactionRequestBodyPaymentsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postByronTransactionRequestBodyPaymentsAmount :: PostByronTransactionRequestBodyPaymentsAmount
  -- | assets: A flat list of assets (possibly empty).
  , postByronTransactionRequestBodyPaymentsAssets :: (GHC.Maybe.Maybe ([PostByronTransactionRequestBodyPaymentsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionRequestBodyPayments
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postByronTransactionRequestBodyPaymentsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPaymentsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPaymentsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postByronTransactionRequestBodyPaymentsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionRequestBodyPayments
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionRequestBodyPayments" (\obj -> ((GHC.Base.pure PostByronTransactionRequestBodyPayments GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'PostByronTransactionRequestBodyPayments' with all required fields.
mkPostByronTransactionRequestBodyPayments :: Data.Text.Internal.Text -- ^ 'postByronTransactionRequestBodyPaymentsAddress'
  -> PostByronTransactionRequestBodyPaymentsAmount -- ^ 'postByronTransactionRequestBodyPaymentsAmount'
  -> PostByronTransactionRequestBodyPayments
mkPostByronTransactionRequestBodyPayments postByronTransactionRequestBodyPaymentsAddress postByronTransactionRequestBodyPaymentsAmount = PostByronTransactionRequestBodyPayments{postByronTransactionRequestBodyPaymentsAddress = postByronTransactionRequestBodyPaymentsAddress,
                                                                                                                                                                                 postByronTransactionRequestBodyPaymentsAmount = postByronTransactionRequestBodyPaymentsAmount,
                                                                                                                                                                                 postByronTransactionRequestBodyPaymentsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.requestBody.content.application\/json.schema.properties.payments.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionRequestBodyPaymentsAmount = PostByronTransactionRequestBodyPaymentsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionRequestBodyPaymentsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionRequestBodyPaymentsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPaymentsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionRequestBodyPaymentsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionRequestBodyPaymentsAmount" (\obj -> GHC.Base.pure PostByronTransactionRequestBodyPaymentsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionRequestBodyPaymentsAmount' with all required fields.
mkPostByronTransactionRequestBodyPaymentsAmount :: GHC.Types.Int -- ^ 'postByronTransactionRequestBodyPaymentsAmountQuantity'
  -> PostByronTransactionRequestBodyPaymentsAmount
mkPostByronTransactionRequestBodyPaymentsAmount postByronTransactionRequestBodyPaymentsAmountQuantity = PostByronTransactionRequestBodyPaymentsAmount{postByronTransactionRequestBodyPaymentsAmountQuantity = postByronTransactionRequestBodyPaymentsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.requestBody.content.application\/json.schema.properties.payments.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostByronTransactionRequestBodyPaymentsAssets = PostByronTransactionRequestBodyPaymentsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postByronTransactionRequestBodyPaymentsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postByronTransactionRequestBodyPaymentsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionRequestBodyPaymentsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionRequestBodyPaymentsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPaymentsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPaymentsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPaymentsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionRequestBodyPaymentsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionRequestBodyPaymentsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionRequestBodyPaymentsAssets" (\obj -> ((GHC.Base.pure PostByronTransactionRequestBodyPaymentsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionRequestBodyPaymentsAssets' with all required fields.
mkPostByronTransactionRequestBodyPaymentsAssets :: Data.Text.Internal.Text -- ^ 'postByronTransactionRequestBodyPaymentsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionRequestBodyPaymentsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'postByronTransactionRequestBodyPaymentsAssetsQuantity'
  -> PostByronTransactionRequestBodyPaymentsAssets
mkPostByronTransactionRequestBodyPaymentsAssets postByronTransactionRequestBodyPaymentsAssetsAsset_name postByronTransactionRequestBodyPaymentsAssetsPolicy_id postByronTransactionRequestBodyPaymentsAssetsQuantity = PostByronTransactionRequestBodyPaymentsAssets{postByronTransactionRequestBodyPaymentsAssetsAsset_name = postByronTransactionRequestBodyPaymentsAssetsAsset_name,
                                                                                                                                                                                                                                                                     postByronTransactionRequestBodyPaymentsAssetsPolicy_id = postByronTransactionRequestBodyPaymentsAssetsPolicy_id,
                                                                                                                                                                                                                                                                     postByronTransactionRequestBodyPaymentsAssetsQuantity = postByronTransactionRequestBodyPaymentsAssetsQuantity}
-- | Represents a response of the operation 'postByronTransaction'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PostByronTransactionResponseError' is used.
data PostByronTransactionResponse =
   PostByronTransactionResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | PostByronTransactionResponse202 PostByronTransactionResponseBody202 -- ^ Accepted
  | PostByronTransactionResponse400 PostByronTransactionResponseBody400 -- ^ Bad Request
  | PostByronTransactionResponse403 PostByronTransactionResponseBody403Variants -- ^ Forbidden
  | PostByronTransactionResponse404 PostByronTransactionResponseBody404 -- ^ Not Found
  | PostByronTransactionResponse406 PostByronTransactionResponseBody406 -- ^ Not Acceptable
  | PostByronTransactionResponse415 PostByronTransactionResponseBody415 -- ^ Unsupported Media Type
  | PostByronTransactionResponse425 PostByronTransactionResponseBody425 -- ^ Mempool is Full
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202 = PostByronTransactionResponseBody202 {
  -- | amount: An amount of Ada spent or received, from the perspective of the wallet.
  -- 
  -- That is, for outgoing transaction, it represents the amount of Ada consumed
  -- as inputs including the amount of Ada spent as fees or deposits.
  -- 
  -- For incoming transaction, it represents the total amount of Ada received to
  -- addresses that belong to the wallet.
  postByronTransactionResponseBody202Amount :: PostByronTransactionResponseBody202Amount
  -- | burn
  , postByronTransactionResponseBody202Burn :: (GHC.Maybe.Maybe PostByronTransactionResponseBody202Burn)
  -- | certificates
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postByronTransactionResponseBody202Certificates :: (GHC.Maybe.Maybe ([PostByronTransactionResponseBody202CertificatesVariants]))
  -- | collateral: A list of transaction inputs used for collateral.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postByronTransactionResponseBody202Collateral :: (GHC.Maybe.Maybe ([PostByronTransactionResponseBody202Collateral]))
  -- | collateral_outputs: A list of collateral return outputs with amounts specified.
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 1 items
  -- * Must have a minimum of 0 items
  , postByronTransactionResponseBody202Collateral_outputs :: (GHC.Maybe.Maybe ([PostByronTransactionResponseBody202Collateral_outputs]))
  -- | deposit_returned: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postByronTransactionResponseBody202Deposit_returned :: PostByronTransactionResponseBody202Deposit_returned
  -- | deposit_taken: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postByronTransactionResponseBody202Deposit_taken :: PostByronTransactionResponseBody202Deposit_taken
  -- | depth: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Current depth of the transaction in the local chain
  , postByronTransactionResponseBody202Depth :: (GHC.Maybe.Maybe PostByronTransactionResponseBody202Depth)
  -- | direction
  , postByronTransactionResponseBody202Direction :: PostByronTransactionResponseBody202Direction
  -- | expires_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending OR status == expired
  -- \<\/span>\<br\/>
  -- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
  , postByronTransactionResponseBody202Expires_at :: (GHC.Maybe.Maybe PostByronTransactionResponseBody202Expires_at)
  -- | extra_signatures
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postByronTransactionResponseBody202Extra_signatures :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | fee: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postByronTransactionResponseBody202Fee :: PostByronTransactionResponseBody202Fee
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , postByronTransactionResponseBody202Id :: Data.Text.Internal.Text
  -- | inputs: A list of transaction inputs.
  -- 
  -- \`assets\` and \`address\` are always present for \`outgoing\`
  -- transactions but generally absent for \`incoming\`
  -- transactions. This information is present on the Cardano explorer,
  -- but is not tracked by the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postByronTransactionResponseBody202Inputs :: ([PostByronTransactionResponseBody202Inputs])
  -- | inserted_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Absolute time at which the transaction was inserted in a block.
  , postByronTransactionResponseBody202Inserted_at :: (GHC.Maybe.Maybe PostByronTransactionResponseBody202Inserted_at)
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  , postByronTransactionResponseBody202Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | mint
  , postByronTransactionResponseBody202Mint :: (GHC.Maybe.Maybe PostByronTransactionResponseBody202Mint)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postByronTransactionResponseBody202Outputs :: ([PostByronTransactionResponseBody202Outputs])
  -- | pending_since: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending
  -- \<\/span>\<br\/>
  -- The point in time at which a transaction became pending.
  , postByronTransactionResponseBody202Pending_since :: (GHC.Maybe.Maybe PostByronTransactionResponseBody202Pending_since)
  -- | script_integrity: A script data integrity hash - 32 bytes
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^(script_data)1[0-9a-z]*\$\'
  , postByronTransactionResponseBody202Script_integrity :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | script_validity: Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
  -- used in the transaction validated or not. Validity may be null if this
  -- transaction was from an era that doesn\'t support phase-2 monetary policy
  -- scripts, or is a pending transaction (we don\'t know if validation passed or
  -- failed until the transaction hits the ledger).
  , postByronTransactionResponseBody202Script_validity :: (GHC.Maybe.Maybe (Wallet.Common.Nullable PostByronTransactionResponseBody202Script_validityNonNullable))
  -- | status: Current transaction status.
  -- 
  --   \`\`\`
  --        *-----------*
  --   ---> |  PENDING  |----------------*
  --        *-----------*                |
  --              |                      |
  --              V                      V
  --        *-----------*          *-----------*
  --        |           |---------->  EXPIRED  |
  --        |           |  (ttl)   *-----------*
  --        | SUBMITTED |
  --        |           \<----------------*
  --        |           |                |
  --        *-----------*           (rollback)
  --               |                     |
  --          (in ledger)          *-----------*
  --               |               |           |
  --               *---------------> IN_LEDGER |
  --                               |           |
  --                               *-----------*
  --   \`\`\`
  , postByronTransactionResponseBody202Status :: PostByronTransactionResponseBody202Status
  -- | validity_interval
  , postByronTransactionResponseBody202Validity_interval :: (GHC.Maybe.Maybe PostByronTransactionResponseBody202Validity_interval)
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postByronTransactionResponseBody202Withdrawals :: ([PostByronTransactionResponseBody202Withdrawals])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Fee obj] : ["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Withdrawals obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Fee obj] : ["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Withdrawals obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202" (\obj -> (((((((((((((((((((((((GHC.Base.pure PostByronTransactionResponseBody202 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "burn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral_outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "depth")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "direction")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "expires_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "extra_signatures")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fee")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "inserted_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pending_since")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_integrity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_validity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "validity_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "withdrawals"))
-- | Create a new 'PostByronTransactionResponseBody202' with all required fields.
mkPostByronTransactionResponseBody202 :: PostByronTransactionResponseBody202Amount -- ^ 'postByronTransactionResponseBody202Amount'
  -> PostByronTransactionResponseBody202Deposit_returned -- ^ 'postByronTransactionResponseBody202Deposit_returned'
  -> PostByronTransactionResponseBody202Deposit_taken -- ^ 'postByronTransactionResponseBody202Deposit_taken'
  -> PostByronTransactionResponseBody202Direction -- ^ 'postByronTransactionResponseBody202Direction'
  -> PostByronTransactionResponseBody202Fee -- ^ 'postByronTransactionResponseBody202Fee'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202Id'
  -> [PostByronTransactionResponseBody202Inputs] -- ^ 'postByronTransactionResponseBody202Inputs'
  -> [PostByronTransactionResponseBody202Outputs] -- ^ 'postByronTransactionResponseBody202Outputs'
  -> PostByronTransactionResponseBody202Status -- ^ 'postByronTransactionResponseBody202Status'
  -> [PostByronTransactionResponseBody202Withdrawals] -- ^ 'postByronTransactionResponseBody202Withdrawals'
  -> PostByronTransactionResponseBody202
mkPostByronTransactionResponseBody202 postByronTransactionResponseBody202Amount postByronTransactionResponseBody202Deposit_returned postByronTransactionResponseBody202Deposit_taken postByronTransactionResponseBody202Direction postByronTransactionResponseBody202Fee postByronTransactionResponseBody202Id postByronTransactionResponseBody202Inputs postByronTransactionResponseBody202Outputs postByronTransactionResponseBody202Status postByronTransactionResponseBody202Withdrawals = PostByronTransactionResponseBody202{postByronTransactionResponseBody202Amount = postByronTransactionResponseBody202Amount,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Burn = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Certificates = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Collateral = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Collateral_outputs = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Deposit_returned = postByronTransactionResponseBody202Deposit_returned,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Deposit_taken = postByronTransactionResponseBody202Deposit_taken,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Depth = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Direction = postByronTransactionResponseBody202Direction,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Expires_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Extra_signatures = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Fee = postByronTransactionResponseBody202Fee,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Id = postByronTransactionResponseBody202Id,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Inputs = postByronTransactionResponseBody202Inputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Inserted_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Mint = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Outputs = postByronTransactionResponseBody202Outputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Pending_since = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Script_integrity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Script_validity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Status = postByronTransactionResponseBody202Status,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Validity_interval = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202Withdrawals = postByronTransactionResponseBody202Withdrawals}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.amount@ in the specification.
-- 
-- An amount of Ada spent or received, from the perspective of the wallet.
-- 
-- That is, for outgoing transaction, it represents the amount of Ada consumed
-- as inputs including the amount of Ada spent as fees or deposits.
-- 
-- For incoming transaction, it represents the total amount of Ada received to
-- addresses that belong to the wallet.
data PostByronTransactionResponseBody202Amount = PostByronTransactionResponseBody202Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Amount" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202Amount' with all required fields.
mkPostByronTransactionResponseBody202Amount :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202AmountQuantity'
  -> PostByronTransactionResponseBody202Amount
mkPostByronTransactionResponseBody202Amount postByronTransactionResponseBody202AmountQuantity = PostByronTransactionResponseBody202Amount{postByronTransactionResponseBody202AmountQuantity = postByronTransactionResponseBody202AmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202Burn = PostByronTransactionResponseBody202Burn {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  postByronTransactionResponseBody202BurnTokens :: ([PostByronTransactionResponseBody202BurnTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , postByronTransactionResponseBody202BurnWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , postByronTransactionResponseBody202BurnWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202BurnWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202BurnWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Burn" (\obj -> ((GHC.Base.pure PostByronTransactionResponseBody202Burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'PostByronTransactionResponseBody202Burn' with all required fields.
mkPostByronTransactionResponseBody202Burn :: [PostByronTransactionResponseBody202BurnTokens] -- ^ 'postByronTransactionResponseBody202BurnTokens'
  -> PostByronTransactionResponseBody202Burn
mkPostByronTransactionResponseBody202Burn postByronTransactionResponseBody202BurnTokens = PostByronTransactionResponseBody202Burn{postByronTransactionResponseBody202BurnTokens = postByronTransactionResponseBody202BurnTokens,
                                                                                                                                  postByronTransactionResponseBody202BurnWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                                  postByronTransactionResponseBody202BurnWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202BurnTokens = PostByronTransactionResponseBody202BurnTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postByronTransactionResponseBody202BurnTokensAssets :: ([PostByronTransactionResponseBody202BurnTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postByronTransactionResponseBody202BurnTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , postByronTransactionResponseBody202BurnTokensPolicy_script :: PostByronTransactionResponseBody202BurnTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202BurnTokens" (\obj -> ((GHC.Base.pure PostByronTransactionResponseBody202BurnTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'PostByronTransactionResponseBody202BurnTokens' with all required fields.
mkPostByronTransactionResponseBody202BurnTokens :: [PostByronTransactionResponseBody202BurnTokensAssets] -- ^ 'postByronTransactionResponseBody202BurnTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_id'
  -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptVariants -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_script'
  -> PostByronTransactionResponseBody202BurnTokens
mkPostByronTransactionResponseBody202BurnTokens postByronTransactionResponseBody202BurnTokensAssets postByronTransactionResponseBody202BurnTokensPolicy_id postByronTransactionResponseBody202BurnTokensPolicy_script = PostByronTransactionResponseBody202BurnTokens{postByronTransactionResponseBody202BurnTokensAssets = postByronTransactionResponseBody202BurnTokensAssets,
                                                                                                                                                                                                                                                                      postByronTransactionResponseBody202BurnTokensPolicy_id = postByronTransactionResponseBody202BurnTokensPolicy_id,
                                                                                                                                                                                                                                                                      postByronTransactionResponseBody202BurnTokensPolicy_script = postByronTransactionResponseBody202BurnTokensPolicy_script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202BurnTokensAssets = PostByronTransactionResponseBody202BurnTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postByronTransactionResponseBody202BurnTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , postByronTransactionResponseBody202BurnTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202BurnTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202BurnTokensAssets" (\obj -> ((GHC.Base.pure PostByronTransactionResponseBody202BurnTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202BurnTokensAssets' with all required fields.
mkPostByronTransactionResponseBody202BurnTokensAssets :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202BurnTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202BurnTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202BurnTokensAssetsQuantity'
  -> PostByronTransactionResponseBody202BurnTokensAssets
mkPostByronTransactionResponseBody202BurnTokensAssets postByronTransactionResponseBody202BurnTokensAssetsAsset_name postByronTransactionResponseBody202BurnTokensAssetsFingerprint postByronTransactionResponseBody202BurnTokensAssetsQuantity = PostByronTransactionResponseBody202BurnTokensAssets{postByronTransactionResponseBody202BurnTokensAssetsAsset_name = postByronTransactionResponseBody202BurnTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                                     postByronTransactionResponseBody202BurnTokensAssetsFingerprint = postByronTransactionResponseBody202BurnTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                                     postByronTransactionResponseBody202BurnTokensAssetsQuantity = postByronTransactionResponseBody202BurnTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1 = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference)
  -- | script
  , postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script :: PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1' with all required fields.
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1 :: PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script'
  -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1 postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1{postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                             postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference' with all required fields.
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex'
  -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1Reference{postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2{postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3{postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 :: PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4{postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some{postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                                    postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5{postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6{postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants =
   PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
  | PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
  | PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
  | PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
  | PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2 = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info :: PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2' with all required fields.
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2 :: PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info'
  -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2 postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2{postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                                  postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference' with all required fields.
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex'
  -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Reference{postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version :: PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info :: PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_info{postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                                               postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3 = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References :: ([PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3' with all required fields.
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3 :: [PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References] -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash'
  -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3 postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3{postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                                             postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References' with all required fields.
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex'
  -> PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References
mkPostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex = PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3References{postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                                       postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex = postByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202BurnTokensPolicy_scriptVariants =
   PostByronTransactionResponseBody202BurnTokensPolicy_scriptVariant1 PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf1
  | PostByronTransactionResponseBody202BurnTokensPolicy_scriptVariant2 PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf2
  | PostByronTransactionResponseBody202BurnTokensPolicy_scriptVariant3 PostByronTransactionResponseBody202BurnTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptVariants
    where toJSON (PostByronTransactionResponseBody202BurnTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202BurnTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202BurnTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202BurnTokensPolicy_scriptVariants
    where parseJSON val = case (PostByronTransactionResponseBody202BurnTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202BurnTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202BurnTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data PostByronTransactionResponseBody202CertificatesOneOf1 = PostByronTransactionResponseBody202CertificatesOneOf1 {
  -- | certificate_type
  postByronTransactionResponseBody202CertificatesOneOf1Certificate_type :: PostByronTransactionResponseBody202CertificatesOneOf1Certificate_type
  -- | pool: A unique identifier for the pool.
  , postByronTransactionResponseBody202CertificatesOneOf1Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , postByronTransactionResponseBody202CertificatesOneOf1Reward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202CertificatesOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202CertificatesOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202CertificatesOneOf1" (\obj -> ((GHC.Base.pure PostByronTransactionResponseBody202CertificatesOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'PostByronTransactionResponseBody202CertificatesOneOf1' with all required fields.
mkPostByronTransactionResponseBody202CertificatesOneOf1 :: PostByronTransactionResponseBody202CertificatesOneOf1Certificate_type -- ^ 'postByronTransactionResponseBody202CertificatesOneOf1Certificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'postByronTransactionResponseBody202CertificatesOneOf1Reward_account_path'
  -> PostByronTransactionResponseBody202CertificatesOneOf1
mkPostByronTransactionResponseBody202CertificatesOneOf1 postByronTransactionResponseBody202CertificatesOneOf1Certificate_type postByronTransactionResponseBody202CertificatesOneOf1Reward_account_path = PostByronTransactionResponseBody202CertificatesOneOf1{postByronTransactionResponseBody202CertificatesOneOf1Certificate_type = postByronTransactionResponseBody202CertificatesOneOf1Certificate_type,
                                                                                                                                                                                                                                                               postByronTransactionResponseBody202CertificatesOneOf1Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                               postByronTransactionResponseBody202CertificatesOneOf1Reward_account_path = postByronTransactionResponseBody202CertificatesOneOf1Reward_account_path}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202CertificatesOneOf1Certificate_type =
   PostByronTransactionResponseBody202CertificatesOneOf1Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostByronTransactionResponseBody202CertificatesOneOf1Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostByronTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | PostByronTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | PostByronTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202CertificatesOneOf1Certificate_type
    where toJSON (PostByronTransactionResponseBody202CertificatesOneOf1Certificate_typeOther val) = val
          toJSON (PostByronTransactionResponseBody202CertificatesOneOf1Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostByronTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool) = "join_pool"
          toJSON (PostByronTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (PostByronTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202CertificatesOneOf1Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> PostByronTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> PostByronTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> PostByronTransactionResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> PostByronTransactionResponseBody202CertificatesOneOf1Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate not belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data PostByronTransactionResponseBody202CertificatesOneOf2 = PostByronTransactionResponseBody202CertificatesOneOf2 {
  -- | certificate_type
  postByronTransactionResponseBody202CertificatesOneOf2Certificate_type :: PostByronTransactionResponseBody202CertificatesOneOf2Certificate_type
  -- | pool: A unique identifier for the pool.
  , postByronTransactionResponseBody202CertificatesOneOf2Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account
  , postByronTransactionResponseBody202CertificatesOneOf2Reward_account :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202CertificatesOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf2Reward_account obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf2Reward_account obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202CertificatesOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202CertificatesOneOf2" (\obj -> ((GHC.Base.pure PostByronTransactionResponseBody202CertificatesOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account"))
-- | Create a new 'PostByronTransactionResponseBody202CertificatesOneOf2' with all required fields.
mkPostByronTransactionResponseBody202CertificatesOneOf2 :: PostByronTransactionResponseBody202CertificatesOneOf2Certificate_type -- ^ 'postByronTransactionResponseBody202CertificatesOneOf2Certificate_type'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202CertificatesOneOf2Reward_account'
  -> PostByronTransactionResponseBody202CertificatesOneOf2
mkPostByronTransactionResponseBody202CertificatesOneOf2 postByronTransactionResponseBody202CertificatesOneOf2Certificate_type postByronTransactionResponseBody202CertificatesOneOf2Reward_account = PostByronTransactionResponseBody202CertificatesOneOf2{postByronTransactionResponseBody202CertificatesOneOf2Certificate_type = postByronTransactionResponseBody202CertificatesOneOf2Certificate_type,
                                                                                                                                                                                                                                                          postByronTransactionResponseBody202CertificatesOneOf2Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                          postByronTransactionResponseBody202CertificatesOneOf2Reward_account = postByronTransactionResponseBody202CertificatesOneOf2Reward_account}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202CertificatesOneOf2Certificate_type =
   PostByronTransactionResponseBody202CertificatesOneOf2Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostByronTransactionResponseBody202CertificatesOneOf2Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostByronTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external -- ^ Represents the JSON value @"join_pool_external"@
  | PostByronTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external -- ^ Represents the JSON value @"quit_pool_external"@
  | PostByronTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external -- ^ Represents the JSON value @"register_reward_account_external"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202CertificatesOneOf2Certificate_type
    where toJSON (PostByronTransactionResponseBody202CertificatesOneOf2Certificate_typeOther val) = val
          toJSON (PostByronTransactionResponseBody202CertificatesOneOf2Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostByronTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external) = "join_pool_external"
          toJSON (PostByronTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external) = "quit_pool_external"
          toJSON (PostByronTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external) = "register_reward_account_external"
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202CertificatesOneOf2Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool_external" -> PostByronTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external
                                            | val GHC.Classes.== "quit_pool_external" -> PostByronTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external
                                            | val GHC.Classes.== "register_reward_account_external" -> PostByronTransactionResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external
                                            | GHC.Base.otherwise -> PostByronTransactionResponseBody202CertificatesOneOf2Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202CertificatesOneOf3 = PostByronTransactionResponseBody202CertificatesOneOf3 {
  -- | pool_cost: Estimated cost set by the pool operator when registering his pool.
  -- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  postByronTransactionResponseBody202CertificatesOneOf3Pool_cost :: PostByronTransactionResponseBody202CertificatesOneOf3Pool_cost
  -- | pool_id: A unique identifier for the pool.
  , postByronTransactionResponseBody202CertificatesOneOf3Pool_id :: Data.Text.Internal.Text
  -- | pool_margin: Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , postByronTransactionResponseBody202CertificatesOneOf3Pool_margin :: PostByronTransactionResponseBody202CertificatesOneOf3Pool_margin
  -- | pool_metadata
  , postByronTransactionResponseBody202CertificatesOneOf3Pool_metadata :: (GHC.Maybe.Maybe PostByronTransactionResponseBody202CertificatesOneOf3Pool_metadata)
  -- | pool_owners
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , postByronTransactionResponseBody202CertificatesOneOf3Pool_owners :: ([Data.Text.Internal.Text])
  -- | pool_pledge: Minimal stake amount that a stake pool is willing to honor.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , postByronTransactionResponseBody202CertificatesOneOf3Pool_pledge :: PostByronTransactionResponseBody202CertificatesOneOf3Pool_pledge
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202CertificatesOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202CertificatesOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202CertificatesOneOf3" (\obj -> (((((GHC.Base.pure PostByronTransactionResponseBody202CertificatesOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_cost")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_margin")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool_metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_owners")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_pledge"))
-- | Create a new 'PostByronTransactionResponseBody202CertificatesOneOf3' with all required fields.
mkPostByronTransactionResponseBody202CertificatesOneOf3 :: PostByronTransactionResponseBody202CertificatesOneOf3Pool_cost -- ^ 'postByronTransactionResponseBody202CertificatesOneOf3Pool_cost'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202CertificatesOneOf3Pool_id'
  -> PostByronTransactionResponseBody202CertificatesOneOf3Pool_margin -- ^ 'postByronTransactionResponseBody202CertificatesOneOf3Pool_margin'
  -> [Data.Text.Internal.Text] -- ^ 'postByronTransactionResponseBody202CertificatesOneOf3Pool_owners'
  -> PostByronTransactionResponseBody202CertificatesOneOf3Pool_pledge -- ^ 'postByronTransactionResponseBody202CertificatesOneOf3Pool_pledge'
  -> PostByronTransactionResponseBody202CertificatesOneOf3
mkPostByronTransactionResponseBody202CertificatesOneOf3 postByronTransactionResponseBody202CertificatesOneOf3Pool_cost postByronTransactionResponseBody202CertificatesOneOf3Pool_id postByronTransactionResponseBody202CertificatesOneOf3Pool_margin postByronTransactionResponseBody202CertificatesOneOf3Pool_owners postByronTransactionResponseBody202CertificatesOneOf3Pool_pledge = PostByronTransactionResponseBody202CertificatesOneOf3{postByronTransactionResponseBody202CertificatesOneOf3Pool_cost = postByronTransactionResponseBody202CertificatesOneOf3Pool_cost,
                                                                                                                                                                                                                                                                                                                                                                                                                                               postByronTransactionResponseBody202CertificatesOneOf3Pool_id = postByronTransactionResponseBody202CertificatesOneOf3Pool_id,
                                                                                                                                                                                                                                                                                                                                                                                                                                               postByronTransactionResponseBody202CertificatesOneOf3Pool_margin = postByronTransactionResponseBody202CertificatesOneOf3Pool_margin,
                                                                                                                                                                                                                                                                                                                                                                                                                                               postByronTransactionResponseBody202CertificatesOneOf3Pool_metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               postByronTransactionResponseBody202CertificatesOneOf3Pool_owners = postByronTransactionResponseBody202CertificatesOneOf3Pool_owners,
                                                                                                                                                                                                                                                                                                                                                                                                                                               postByronTransactionResponseBody202CertificatesOneOf3Pool_pledge = postByronTransactionResponseBody202CertificatesOneOf3Pool_pledge}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_cost@ in the specification.
-- 
-- Estimated cost set by the pool operator when registering his pool.
-- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data PostByronTransactionResponseBody202CertificatesOneOf3Pool_cost = PostByronTransactionResponseBody202CertificatesOneOf3Pool_cost {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202CertificatesOneOf3Pool_costQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202CertificatesOneOf3Pool_cost
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202CertificatesOneOf3Pool_cost
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202CertificatesOneOf3Pool_cost" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202CertificatesOneOf3Pool_cost GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202CertificatesOneOf3Pool_cost' with all required fields.
mkPostByronTransactionResponseBody202CertificatesOneOf3Pool_cost :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202CertificatesOneOf3Pool_costQuantity'
  -> PostByronTransactionResponseBody202CertificatesOneOf3Pool_cost
mkPostByronTransactionResponseBody202CertificatesOneOf3Pool_cost postByronTransactionResponseBody202CertificatesOneOf3Pool_costQuantity = PostByronTransactionResponseBody202CertificatesOneOf3Pool_cost{postByronTransactionResponseBody202CertificatesOneOf3Pool_costQuantity = postByronTransactionResponseBody202CertificatesOneOf3Pool_costQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_margin@ in the specification.
-- 
-- Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data PostByronTransactionResponseBody202CertificatesOneOf3Pool_margin = PostByronTransactionResponseBody202CertificatesOneOf3Pool_margin {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202CertificatesOneOf3Pool_margin
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202CertificatesOneOf3Pool_margin
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202CertificatesOneOf3Pool_margin" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202CertificatesOneOf3Pool_margin GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202CertificatesOneOf3Pool_margin' with all required fields.
mkPostByronTransactionResponseBody202CertificatesOneOf3Pool_margin :: GHC.Types.Double -- ^ 'postByronTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity'
  -> PostByronTransactionResponseBody202CertificatesOneOf3Pool_margin
mkPostByronTransactionResponseBody202CertificatesOneOf3Pool_margin postByronTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity = PostByronTransactionResponseBody202CertificatesOneOf3Pool_margin{postByronTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity = postByronTransactionResponseBody202CertificatesOneOf3Pool_marginQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_metadata@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202CertificatesOneOf3Pool_metadata = PostByronTransactionResponseBody202CertificatesOneOf3Pool_metadata {
  -- | hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  postByronTransactionResponseBody202CertificatesOneOf3Pool_metadataHash :: Data.Text.Internal.Text
  -- | url: A URL to the stake pool\'s website.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 250
  -- * Must match pattern \'^https:\/\/.+\'
  , postByronTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202CertificatesOneOf3Pool_metadata
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202CertificatesOneOf3Pool_metadata
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202CertificatesOneOf3Pool_metadata" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202CertificatesOneOf3Pool_metadata GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))
-- | Create a new 'PostByronTransactionResponseBody202CertificatesOneOf3Pool_metadata' with all required fields.
mkPostByronTransactionResponseBody202CertificatesOneOf3Pool_metadata :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202CertificatesOneOf3Pool_metadataHash'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl'
  -> PostByronTransactionResponseBody202CertificatesOneOf3Pool_metadata
mkPostByronTransactionResponseBody202CertificatesOneOf3Pool_metadata postByronTransactionResponseBody202CertificatesOneOf3Pool_metadataHash postByronTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl = PostByronTransactionResponseBody202CertificatesOneOf3Pool_metadata{postByronTransactionResponseBody202CertificatesOneOf3Pool_metadataHash = postByronTransactionResponseBody202CertificatesOneOf3Pool_metadataHash,
                                                                                                                                                                                                                                                                                       postByronTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl = postByronTransactionResponseBody202CertificatesOneOf3Pool_metadataUrl}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.pool_pledge@ in the specification.
-- 
-- Minimal stake amount that a stake pool is willing to honor.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data PostByronTransactionResponseBody202CertificatesOneOf3Pool_pledge = PostByronTransactionResponseBody202CertificatesOneOf3Pool_pledge {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202CertificatesOneOf3Pool_pledge
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202CertificatesOneOf3Pool_pledge
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202CertificatesOneOf3Pool_pledge" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202CertificatesOneOf3Pool_pledge GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202CertificatesOneOf3Pool_pledge' with all required fields.
mkPostByronTransactionResponseBody202CertificatesOneOf3Pool_pledge :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity'
  -> PostByronTransactionResponseBody202CertificatesOneOf3Pool_pledge
mkPostByronTransactionResponseBody202CertificatesOneOf3Pool_pledge postByronTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity = PostByronTransactionResponseBody202CertificatesOneOf3Pool_pledge{postByronTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity = postByronTransactionResponseBody202CertificatesOneOf3Pool_pledgeQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202CertificatesOneOf4 = PostByronTransactionResponseBody202CertificatesOneOf4 {
  -- | pool_id: A unique identifier for the pool.
  postByronTransactionResponseBody202CertificatesOneOf4Pool_id :: Data.Text.Internal.Text
  -- | retirement_epoch: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202CertificatesOneOf4Retirement_epoch :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202CertificatesOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202CertificatesOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202CertificatesOneOf4" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202CertificatesOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "retirement_epoch"))
-- | Create a new 'PostByronTransactionResponseBody202CertificatesOneOf4' with all required fields.
mkPostByronTransactionResponseBody202CertificatesOneOf4 :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202CertificatesOneOf4Pool_id'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202CertificatesOneOf4Retirement_epoch'
  -> PostByronTransactionResponseBody202CertificatesOneOf4
mkPostByronTransactionResponseBody202CertificatesOneOf4 postByronTransactionResponseBody202CertificatesOneOf4Pool_id postByronTransactionResponseBody202CertificatesOneOf4Retirement_epoch = PostByronTransactionResponseBody202CertificatesOneOf4{postByronTransactionResponseBody202CertificatesOneOf4Pool_id = postByronTransactionResponseBody202CertificatesOneOf4Pool_id,
                                                                                                                                                                                                                                                   postByronTransactionResponseBody202CertificatesOneOf4Retirement_epoch = postByronTransactionResponseBody202CertificatesOneOf4Retirement_epoch}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202CertificatesOneOf5 = PostByronTransactionResponseBody202CertificatesOneOf5 {
  -- | certificate_type
  postByronTransactionResponseBody202CertificatesOneOf5Certificate_type :: PostByronTransactionResponseBody202CertificatesOneOf5Certificate_type
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202CertificatesOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202CertificatesOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202CertificatesOneOf5" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202CertificatesOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type"))
-- | Create a new 'PostByronTransactionResponseBody202CertificatesOneOf5' with all required fields.
mkPostByronTransactionResponseBody202CertificatesOneOf5 :: PostByronTransactionResponseBody202CertificatesOneOf5Certificate_type -- ^ 'postByronTransactionResponseBody202CertificatesOneOf5Certificate_type'
  -> PostByronTransactionResponseBody202CertificatesOneOf5
mkPostByronTransactionResponseBody202CertificatesOneOf5 postByronTransactionResponseBody202CertificatesOneOf5Certificate_type = PostByronTransactionResponseBody202CertificatesOneOf5{postByronTransactionResponseBody202CertificatesOneOf5Certificate_type = postByronTransactionResponseBody202CertificatesOneOf5Certificate_type}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202CertificatesOneOf5Certificate_type =
   PostByronTransactionResponseBody202CertificatesOneOf5Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostByronTransactionResponseBody202CertificatesOneOf5Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostByronTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumMir -- ^ Represents the JSON value @"mir"@
  | PostByronTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis -- ^ Represents the JSON value @"genesis"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202CertificatesOneOf5Certificate_type
    where toJSON (PostByronTransactionResponseBody202CertificatesOneOf5Certificate_typeOther val) = val
          toJSON (PostByronTransactionResponseBody202CertificatesOneOf5Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostByronTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumMir) = "mir"
          toJSON (PostByronTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis) = "genesis"
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202CertificatesOneOf5Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "mir" -> PostByronTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumMir
                                            | val GHC.Classes.== "genesis" -> PostByronTransactionResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis
                                            | GHC.Base.otherwise -> PostByronTransactionResponseBody202CertificatesOneOf5Certificate_typeOther val)
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.certificates.items.oneOf@ in the specification.
-- 
-- Any certificate that could occur in an arbitrary transaction:
-- might be related to delegation, pool activities, genesis or MIR.
data PostByronTransactionResponseBody202CertificatesVariants =
   PostByronTransactionResponseBody202CertificatesVariant1 PostByronTransactionResponseBody202CertificatesOneOf1
  | PostByronTransactionResponseBody202CertificatesVariant2 PostByronTransactionResponseBody202CertificatesOneOf2
  | PostByronTransactionResponseBody202CertificatesVariant3 PostByronTransactionResponseBody202CertificatesOneOf3
  | PostByronTransactionResponseBody202CertificatesVariant4 PostByronTransactionResponseBody202CertificatesOneOf4
  | PostByronTransactionResponseBody202CertificatesVariant5 PostByronTransactionResponseBody202CertificatesOneOf5
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202CertificatesVariants
    where toJSON (PostByronTransactionResponseBody202CertificatesVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202CertificatesVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202CertificatesVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202CertificatesVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202CertificatesVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202CertificatesVariants
    where parseJSON val = case (PostByronTransactionResponseBody202CertificatesVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202CertificatesVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202CertificatesVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202CertificatesVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202CertificatesVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.collateral.items@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202Collateral = PostByronTransactionResponseBody202Collateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  postByronTransactionResponseBody202CollateralAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postByronTransactionResponseBody202CollateralAmount :: (GHC.Maybe.Maybe PostByronTransactionResponseBody202CollateralAmount)
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , postByronTransactionResponseBody202CollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202CollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Collateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Collateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Collateral" (\obj -> (((GHC.Base.pure PostByronTransactionResponseBody202Collateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostByronTransactionResponseBody202Collateral' with all required fields.
mkPostByronTransactionResponseBody202Collateral :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202CollateralId'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202CollateralIndex'
  -> PostByronTransactionResponseBody202Collateral
mkPostByronTransactionResponseBody202Collateral postByronTransactionResponseBody202CollateralId postByronTransactionResponseBody202CollateralIndex = PostByronTransactionResponseBody202Collateral{postByronTransactionResponseBody202CollateralAddress = GHC.Maybe.Nothing,
                                                                                                                                                                                                   postByronTransactionResponseBody202CollateralAmount = GHC.Maybe.Nothing,
                                                                                                                                                                                                   postByronTransactionResponseBody202CollateralId = postByronTransactionResponseBody202CollateralId,
                                                                                                                                                                                                   postByronTransactionResponseBody202CollateralIndex = postByronTransactionResponseBody202CollateralIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionResponseBody202CollateralAmount = PostByronTransactionResponseBody202CollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202CollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202CollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202CollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202CollateralAmount" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202CollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202CollateralAmount' with all required fields.
mkPostByronTransactionResponseBody202CollateralAmount :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202CollateralAmountQuantity'
  -> PostByronTransactionResponseBody202CollateralAmount
mkPostByronTransactionResponseBody202CollateralAmount postByronTransactionResponseBody202CollateralAmountQuantity = PostByronTransactionResponseBody202CollateralAmount{postByronTransactionResponseBody202CollateralAmountQuantity = postByronTransactionResponseBody202CollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.collateral_outputs.items@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202Collateral_outputs = PostByronTransactionResponseBody202Collateral_outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  postByronTransactionResponseBody202Collateral_outputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postByronTransactionResponseBody202Collateral_outputsAmount :: PostByronTransactionResponseBody202Collateral_outputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , postByronTransactionResponseBody202Collateral_outputsAssets :: (GHC.Maybe.Maybe ([PostByronTransactionResponseBody202Collateral_outputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Collateral_outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Collateral_outputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202Collateral_outputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Collateral_outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Collateral_outputs" (\obj -> ((GHC.Base.pure PostByronTransactionResponseBody202Collateral_outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'PostByronTransactionResponseBody202Collateral_outputs' with all required fields.
mkPostByronTransactionResponseBody202Collateral_outputs :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202Collateral_outputsAddress'
  -> PostByronTransactionResponseBody202Collateral_outputsAmount -- ^ 'postByronTransactionResponseBody202Collateral_outputsAmount'
  -> PostByronTransactionResponseBody202Collateral_outputs
mkPostByronTransactionResponseBody202Collateral_outputs postByronTransactionResponseBody202Collateral_outputsAddress postByronTransactionResponseBody202Collateral_outputsAmount = PostByronTransactionResponseBody202Collateral_outputs{postByronTransactionResponseBody202Collateral_outputsAddress = postByronTransactionResponseBody202Collateral_outputsAddress,
                                                                                                                                                                                                                                         postByronTransactionResponseBody202Collateral_outputsAmount = postByronTransactionResponseBody202Collateral_outputsAmount,
                                                                                                                                                                                                                                         postByronTransactionResponseBody202Collateral_outputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.collateral_outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionResponseBody202Collateral_outputsAmount = PostByronTransactionResponseBody202Collateral_outputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202Collateral_outputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Collateral_outputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Collateral_outputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Collateral_outputsAmount" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202Collateral_outputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202Collateral_outputsAmount' with all required fields.
mkPostByronTransactionResponseBody202Collateral_outputsAmount :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Collateral_outputsAmountQuantity'
  -> PostByronTransactionResponseBody202Collateral_outputsAmount
mkPostByronTransactionResponseBody202Collateral_outputsAmount postByronTransactionResponseBody202Collateral_outputsAmountQuantity = PostByronTransactionResponseBody202Collateral_outputsAmount{postByronTransactionResponseBody202Collateral_outputsAmountQuantity = postByronTransactionResponseBody202Collateral_outputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.collateral_outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostByronTransactionResponseBody202Collateral_outputsAssets = PostByronTransactionResponseBody202Collateral_outputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postByronTransactionResponseBody202Collateral_outputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postByronTransactionResponseBody202Collateral_outputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202Collateral_outputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Collateral_outputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Collateral_outputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Collateral_outputsAssets" (\obj -> ((GHC.Base.pure PostByronTransactionResponseBody202Collateral_outputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202Collateral_outputsAssets' with all required fields.
mkPostByronTransactionResponseBody202Collateral_outputsAssets :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202Collateral_outputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202Collateral_outputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Collateral_outputsAssetsQuantity'
  -> PostByronTransactionResponseBody202Collateral_outputsAssets
mkPostByronTransactionResponseBody202Collateral_outputsAssets postByronTransactionResponseBody202Collateral_outputsAssetsAsset_name postByronTransactionResponseBody202Collateral_outputsAssetsPolicy_id postByronTransactionResponseBody202Collateral_outputsAssetsQuantity = PostByronTransactionResponseBody202Collateral_outputsAssets{postByronTransactionResponseBody202Collateral_outputsAssetsAsset_name = postByronTransactionResponseBody202Collateral_outputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                           postByronTransactionResponseBody202Collateral_outputsAssetsPolicy_id = postByronTransactionResponseBody202Collateral_outputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                           postByronTransactionResponseBody202Collateral_outputsAssetsQuantity = postByronTransactionResponseBody202Collateral_outputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.deposit_returned@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionResponseBody202Deposit_returned = PostByronTransactionResponseBody202Deposit_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202Deposit_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Deposit_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Deposit_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Deposit_returned" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202Deposit_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202Deposit_returned' with all required fields.
mkPostByronTransactionResponseBody202Deposit_returned :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Deposit_returnedQuantity'
  -> PostByronTransactionResponseBody202Deposit_returned
mkPostByronTransactionResponseBody202Deposit_returned postByronTransactionResponseBody202Deposit_returnedQuantity = PostByronTransactionResponseBody202Deposit_returned{postByronTransactionResponseBody202Deposit_returnedQuantity = postByronTransactionResponseBody202Deposit_returnedQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.deposit_taken@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionResponseBody202Deposit_taken = PostByronTransactionResponseBody202Deposit_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202Deposit_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Deposit_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Deposit_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Deposit_taken" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202Deposit_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202Deposit_taken' with all required fields.
mkPostByronTransactionResponseBody202Deposit_taken :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Deposit_takenQuantity'
  -> PostByronTransactionResponseBody202Deposit_taken
mkPostByronTransactionResponseBody202Deposit_taken postByronTransactionResponseBody202Deposit_takenQuantity = PostByronTransactionResponseBody202Deposit_taken{postByronTransactionResponseBody202Deposit_takenQuantity = postByronTransactionResponseBody202Deposit_takenQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.depth@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Current depth of the transaction in the local chain
data PostByronTransactionResponseBody202Depth = PostByronTransactionResponseBody202Depth {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202DepthQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Depth
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Depth
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Depth" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202Depth GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202Depth' with all required fields.
mkPostByronTransactionResponseBody202Depth :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202DepthQuantity'
  -> PostByronTransactionResponseBody202Depth
mkPostByronTransactionResponseBody202Depth postByronTransactionResponseBody202DepthQuantity = PostByronTransactionResponseBody202Depth{postByronTransactionResponseBody202DepthQuantity = postByronTransactionResponseBody202DepthQuantity}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.direction@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202Direction =
   PostByronTransactionResponseBody202DirectionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostByronTransactionResponseBody202DirectionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostByronTransactionResponseBody202DirectionEnumOutgoing -- ^ Represents the JSON value @"outgoing"@
  | PostByronTransactionResponseBody202DirectionEnumIncoming -- ^ Represents the JSON value @"incoming"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Direction
    where toJSON (PostByronTransactionResponseBody202DirectionOther val) = val
          toJSON (PostByronTransactionResponseBody202DirectionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostByronTransactionResponseBody202DirectionEnumOutgoing) = "outgoing"
          toJSON (PostByronTransactionResponseBody202DirectionEnumIncoming) = "incoming"
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Direction
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "outgoing" -> PostByronTransactionResponseBody202DirectionEnumOutgoing
                                            | val GHC.Classes.== "incoming" -> PostByronTransactionResponseBody202DirectionEnumIncoming
                                            | GHC.Base.otherwise -> PostByronTransactionResponseBody202DirectionOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.expires_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending OR status == expired
-- \<\/span>\<br\/>
-- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
data PostByronTransactionResponseBody202Expires_at = PostByronTransactionResponseBody202Expires_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202Expires_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202Expires_atEpoch_number :: GHC.Types.Int
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202Expires_atSlot_number :: GHC.Types.Int
  -- | time
  , postByronTransactionResponseBody202Expires_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Expires_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Expires_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Expires_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Expires_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Expires_at" (\obj -> (((GHC.Base.pure PostByronTransactionResponseBody202Expires_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'PostByronTransactionResponseBody202Expires_at' with all required fields.
mkPostByronTransactionResponseBody202Expires_at :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Expires_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Expires_atEpoch_number'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Expires_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202Expires_atTime'
  -> PostByronTransactionResponseBody202Expires_at
mkPostByronTransactionResponseBody202Expires_at postByronTransactionResponseBody202Expires_atAbsolute_slot_number postByronTransactionResponseBody202Expires_atEpoch_number postByronTransactionResponseBody202Expires_atSlot_number postByronTransactionResponseBody202Expires_atTime = PostByronTransactionResponseBody202Expires_at{postByronTransactionResponseBody202Expires_atAbsolute_slot_number = postByronTransactionResponseBody202Expires_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                       postByronTransactionResponseBody202Expires_atEpoch_number = postByronTransactionResponseBody202Expires_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                       postByronTransactionResponseBody202Expires_atSlot_number = postByronTransactionResponseBody202Expires_atSlot_number,
                                                                                                                                                                                                                                                                                                                                       postByronTransactionResponseBody202Expires_atTime = postByronTransactionResponseBody202Expires_atTime}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.fee@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionResponseBody202Fee = PostByronTransactionResponseBody202Fee {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202FeeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Fee
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Fee
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Fee" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202Fee GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202Fee' with all required fields.
mkPostByronTransactionResponseBody202Fee :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202FeeQuantity'
  -> PostByronTransactionResponseBody202Fee
mkPostByronTransactionResponseBody202Fee postByronTransactionResponseBody202FeeQuantity = PostByronTransactionResponseBody202Fee{postByronTransactionResponseBody202FeeQuantity = postByronTransactionResponseBody202FeeQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.inputs.items@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202Inputs = PostByronTransactionResponseBody202Inputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  postByronTransactionResponseBody202InputsAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postByronTransactionResponseBody202InputsAmount :: (GHC.Maybe.Maybe PostByronTransactionResponseBody202InputsAmount)
  -- | assets: A flat list of assets (possibly empty).
  , postByronTransactionResponseBody202InputsAssets :: (GHC.Maybe.Maybe ([PostByronTransactionResponseBody202InputsAssets]))
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , postByronTransactionResponseBody202InputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202InputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Inputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202InputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202InputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Inputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Inputs" (\obj -> ((((GHC.Base.pure PostByronTransactionResponseBody202Inputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostByronTransactionResponseBody202Inputs' with all required fields.
mkPostByronTransactionResponseBody202Inputs :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202InputsId'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202InputsIndex'
  -> PostByronTransactionResponseBody202Inputs
mkPostByronTransactionResponseBody202Inputs postByronTransactionResponseBody202InputsId postByronTransactionResponseBody202InputsIndex = PostByronTransactionResponseBody202Inputs{postByronTransactionResponseBody202InputsAddress = GHC.Maybe.Nothing,
                                                                                                                                                                                   postByronTransactionResponseBody202InputsAmount = GHC.Maybe.Nothing,
                                                                                                                                                                                   postByronTransactionResponseBody202InputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                                                   postByronTransactionResponseBody202InputsId = postByronTransactionResponseBody202InputsId,
                                                                                                                                                                                   postByronTransactionResponseBody202InputsIndex = postByronTransactionResponseBody202InputsIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionResponseBody202InputsAmount = PostByronTransactionResponseBody202InputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202InputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202InputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202InputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202InputsAmount" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202InputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202InputsAmount' with all required fields.
mkPostByronTransactionResponseBody202InputsAmount :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202InputsAmountQuantity'
  -> PostByronTransactionResponseBody202InputsAmount
mkPostByronTransactionResponseBody202InputsAmount postByronTransactionResponseBody202InputsAmountQuantity = PostByronTransactionResponseBody202InputsAmount{postByronTransactionResponseBody202InputsAmountQuantity = postByronTransactionResponseBody202InputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostByronTransactionResponseBody202InputsAssets = PostByronTransactionResponseBody202InputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postByronTransactionResponseBody202InputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postByronTransactionResponseBody202InputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202InputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202InputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202InputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202InputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202InputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202InputsAssets" (\obj -> ((GHC.Base.pure PostByronTransactionResponseBody202InputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202InputsAssets' with all required fields.
mkPostByronTransactionResponseBody202InputsAssets :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202InputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202InputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202InputsAssetsQuantity'
  -> PostByronTransactionResponseBody202InputsAssets
mkPostByronTransactionResponseBody202InputsAssets postByronTransactionResponseBody202InputsAssetsAsset_name postByronTransactionResponseBody202InputsAssetsPolicy_id postByronTransactionResponseBody202InputsAssetsQuantity = PostByronTransactionResponseBody202InputsAssets{postByronTransactionResponseBody202InputsAssetsAsset_name = postByronTransactionResponseBody202InputsAssetsAsset_name,
                                                                                                                                                                                                                                                                               postByronTransactionResponseBody202InputsAssetsPolicy_id = postByronTransactionResponseBody202InputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                               postByronTransactionResponseBody202InputsAssetsQuantity = postByronTransactionResponseBody202InputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.inserted_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Absolute time at which the transaction was inserted in a block.
data PostByronTransactionResponseBody202Inserted_at = PostByronTransactionResponseBody202Inserted_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202Inserted_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202Inserted_atEpoch_number :: GHC.Types.Int
  -- | height
  , postByronTransactionResponseBody202Inserted_atHeight :: PostByronTransactionResponseBody202Inserted_atHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202Inserted_atSlot_number :: GHC.Types.Int
  -- | time
  , postByronTransactionResponseBody202Inserted_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Inserted_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Inserted_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Inserted_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Inserted_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Inserted_at" (\obj -> ((((GHC.Base.pure PostByronTransactionResponseBody202Inserted_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'PostByronTransactionResponseBody202Inserted_at' with all required fields.
mkPostByronTransactionResponseBody202Inserted_at :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Inserted_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Inserted_atEpoch_number'
  -> PostByronTransactionResponseBody202Inserted_atHeight -- ^ 'postByronTransactionResponseBody202Inserted_atHeight'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Inserted_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202Inserted_atTime'
  -> PostByronTransactionResponseBody202Inserted_at
mkPostByronTransactionResponseBody202Inserted_at postByronTransactionResponseBody202Inserted_atAbsolute_slot_number postByronTransactionResponseBody202Inserted_atEpoch_number postByronTransactionResponseBody202Inserted_atHeight postByronTransactionResponseBody202Inserted_atSlot_number postByronTransactionResponseBody202Inserted_atTime = PostByronTransactionResponseBody202Inserted_at{postByronTransactionResponseBody202Inserted_atAbsolute_slot_number = postByronTransactionResponseBody202Inserted_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                                                  postByronTransactionResponseBody202Inserted_atEpoch_number = postByronTransactionResponseBody202Inserted_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                                                  postByronTransactionResponseBody202Inserted_atHeight = postByronTransactionResponseBody202Inserted_atHeight,
                                                                                                                                                                                                                                                                                                                                                                                                  postByronTransactionResponseBody202Inserted_atSlot_number = postByronTransactionResponseBody202Inserted_atSlot_number,
                                                                                                                                                                                                                                                                                                                                                                                                  postByronTransactionResponseBody202Inserted_atTime = postByronTransactionResponseBody202Inserted_atTime}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.inserted_at.properties.height@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202Inserted_atHeight = PostByronTransactionResponseBody202Inserted_atHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202Inserted_atHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Inserted_atHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Inserted_atHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Inserted_atHeight" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202Inserted_atHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202Inserted_atHeight' with all required fields.
mkPostByronTransactionResponseBody202Inserted_atHeight :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Inserted_atHeightQuantity'
  -> PostByronTransactionResponseBody202Inserted_atHeight
mkPostByronTransactionResponseBody202Inserted_atHeight postByronTransactionResponseBody202Inserted_atHeightQuantity = PostByronTransactionResponseBody202Inserted_atHeight{postByronTransactionResponseBody202Inserted_atHeightQuantity = postByronTransactionResponseBody202Inserted_atHeightQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202Mint = PostByronTransactionResponseBody202Mint {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  postByronTransactionResponseBody202MintTokens :: ([PostByronTransactionResponseBody202MintTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , postByronTransactionResponseBody202MintWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , postByronTransactionResponseBody202MintWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Mint
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202MintWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202MintWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Mint
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Mint" (\obj -> ((GHC.Base.pure PostByronTransactionResponseBody202Mint GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'PostByronTransactionResponseBody202Mint' with all required fields.
mkPostByronTransactionResponseBody202Mint :: [PostByronTransactionResponseBody202MintTokens] -- ^ 'postByronTransactionResponseBody202MintTokens'
  -> PostByronTransactionResponseBody202Mint
mkPostByronTransactionResponseBody202Mint postByronTransactionResponseBody202MintTokens = PostByronTransactionResponseBody202Mint{postByronTransactionResponseBody202MintTokens = postByronTransactionResponseBody202MintTokens,
                                                                                                                                  postByronTransactionResponseBody202MintWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                                  postByronTransactionResponseBody202MintWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202MintTokens = PostByronTransactionResponseBody202MintTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postByronTransactionResponseBody202MintTokensAssets :: ([PostByronTransactionResponseBody202MintTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postByronTransactionResponseBody202MintTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , postByronTransactionResponseBody202MintTokensPolicy_script :: PostByronTransactionResponseBody202MintTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202MintTokens" (\obj -> ((GHC.Base.pure PostByronTransactionResponseBody202MintTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'PostByronTransactionResponseBody202MintTokens' with all required fields.
mkPostByronTransactionResponseBody202MintTokens :: [PostByronTransactionResponseBody202MintTokensAssets] -- ^ 'postByronTransactionResponseBody202MintTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_id'
  -> PostByronTransactionResponseBody202MintTokensPolicy_scriptVariants -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_script'
  -> PostByronTransactionResponseBody202MintTokens
mkPostByronTransactionResponseBody202MintTokens postByronTransactionResponseBody202MintTokensAssets postByronTransactionResponseBody202MintTokensPolicy_id postByronTransactionResponseBody202MintTokensPolicy_script = PostByronTransactionResponseBody202MintTokens{postByronTransactionResponseBody202MintTokensAssets = postByronTransactionResponseBody202MintTokensAssets,
                                                                                                                                                                                                                                                                      postByronTransactionResponseBody202MintTokensPolicy_id = postByronTransactionResponseBody202MintTokensPolicy_id,
                                                                                                                                                                                                                                                                      postByronTransactionResponseBody202MintTokensPolicy_script = postByronTransactionResponseBody202MintTokensPolicy_script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202MintTokensAssets = PostByronTransactionResponseBody202MintTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postByronTransactionResponseBody202MintTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , postByronTransactionResponseBody202MintTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202MintTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202MintTokensAssets" (\obj -> ((GHC.Base.pure PostByronTransactionResponseBody202MintTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202MintTokensAssets' with all required fields.
mkPostByronTransactionResponseBody202MintTokensAssets :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202MintTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202MintTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202MintTokensAssetsQuantity'
  -> PostByronTransactionResponseBody202MintTokensAssets
mkPostByronTransactionResponseBody202MintTokensAssets postByronTransactionResponseBody202MintTokensAssetsAsset_name postByronTransactionResponseBody202MintTokensAssetsFingerprint postByronTransactionResponseBody202MintTokensAssetsQuantity = PostByronTransactionResponseBody202MintTokensAssets{postByronTransactionResponseBody202MintTokensAssetsAsset_name = postByronTransactionResponseBody202MintTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                                     postByronTransactionResponseBody202MintTokensAssetsFingerprint = postByronTransactionResponseBody202MintTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                                     postByronTransactionResponseBody202MintTokensAssetsQuantity = postByronTransactionResponseBody202MintTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1 = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference)
  -- | script
  , postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script :: PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1' with all required fields.
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1 :: PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script'
  -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1 postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1{postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                             postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference' with all required fields.
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex'
  -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1Reference{postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2{postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3{postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 :: PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4{postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some{postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                                    postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5{postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6{postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants =
   PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
  | PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
  | PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
  | PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
  | PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2 = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info :: PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2' with all required fields.
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2 :: PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info'
  -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2 postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2{postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                                  postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference' with all required fields.
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex'
  -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Reference{postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                                   postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version :: PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info :: PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_info{postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                                               postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3 = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References :: ([PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3' with all required fields.
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3 :: [PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References] -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash'
  -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3 postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3{postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                                             postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References' with all required fields.
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex'
  -> PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References
mkPostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex = PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3References{postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                                       postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex = postByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202MintTokensPolicy_scriptVariants =
   PostByronTransactionResponseBody202MintTokensPolicy_scriptVariant1 PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf1
  | PostByronTransactionResponseBody202MintTokensPolicy_scriptVariant2 PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf2
  | PostByronTransactionResponseBody202MintTokensPolicy_scriptVariant3 PostByronTransactionResponseBody202MintTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptVariants
    where toJSON (PostByronTransactionResponseBody202MintTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202MintTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody202MintTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202MintTokensPolicy_scriptVariants
    where parseJSON val = case (PostByronTransactionResponseBody202MintTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202MintTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody202MintTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.outputs.items@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202Outputs = PostByronTransactionResponseBody202Outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  postByronTransactionResponseBody202OutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postByronTransactionResponseBody202OutputsAmount :: PostByronTransactionResponseBody202OutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , postByronTransactionResponseBody202OutputsAssets :: (GHC.Maybe.Maybe ([PostByronTransactionResponseBody202OutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202OutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody202OutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Outputs" (\obj -> ((GHC.Base.pure PostByronTransactionResponseBody202Outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'PostByronTransactionResponseBody202Outputs' with all required fields.
mkPostByronTransactionResponseBody202Outputs :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202OutputsAddress'
  -> PostByronTransactionResponseBody202OutputsAmount -- ^ 'postByronTransactionResponseBody202OutputsAmount'
  -> PostByronTransactionResponseBody202Outputs
mkPostByronTransactionResponseBody202Outputs postByronTransactionResponseBody202OutputsAddress postByronTransactionResponseBody202OutputsAmount = PostByronTransactionResponseBody202Outputs{postByronTransactionResponseBody202OutputsAddress = postByronTransactionResponseBody202OutputsAddress,
                                                                                                                                                                                             postByronTransactionResponseBody202OutputsAmount = postByronTransactionResponseBody202OutputsAmount,
                                                                                                                                                                                             postByronTransactionResponseBody202OutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionResponseBody202OutputsAmount = PostByronTransactionResponseBody202OutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202OutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202OutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202OutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202OutputsAmount" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202OutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202OutputsAmount' with all required fields.
mkPostByronTransactionResponseBody202OutputsAmount :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202OutputsAmountQuantity'
  -> PostByronTransactionResponseBody202OutputsAmount
mkPostByronTransactionResponseBody202OutputsAmount postByronTransactionResponseBody202OutputsAmountQuantity = PostByronTransactionResponseBody202OutputsAmount{postByronTransactionResponseBody202OutputsAmountQuantity = postByronTransactionResponseBody202OutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data PostByronTransactionResponseBody202OutputsAssets = PostByronTransactionResponseBody202OutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  postByronTransactionResponseBody202OutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , postByronTransactionResponseBody202OutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202OutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202OutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202OutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202OutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202OutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202OutputsAssets" (\obj -> ((GHC.Base.pure PostByronTransactionResponseBody202OutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202OutputsAssets' with all required fields.
mkPostByronTransactionResponseBody202OutputsAssets :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202OutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202OutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202OutputsAssetsQuantity'
  -> PostByronTransactionResponseBody202OutputsAssets
mkPostByronTransactionResponseBody202OutputsAssets postByronTransactionResponseBody202OutputsAssetsAsset_name postByronTransactionResponseBody202OutputsAssetsPolicy_id postByronTransactionResponseBody202OutputsAssetsQuantity = PostByronTransactionResponseBody202OutputsAssets{postByronTransactionResponseBody202OutputsAssetsAsset_name = postByronTransactionResponseBody202OutputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                    postByronTransactionResponseBody202OutputsAssetsPolicy_id = postByronTransactionResponseBody202OutputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                    postByronTransactionResponseBody202OutputsAssetsQuantity = postByronTransactionResponseBody202OutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.pending_since@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending
-- \<\/span>\<br\/>
-- The point in time at which a transaction became pending.
data PostByronTransactionResponseBody202Pending_since = PostByronTransactionResponseBody202Pending_since {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202Pending_sinceAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202Pending_sinceEpoch_number :: GHC.Types.Int
  -- | height
  , postByronTransactionResponseBody202Pending_sinceHeight :: PostByronTransactionResponseBody202Pending_sinceHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , postByronTransactionResponseBody202Pending_sinceSlot_number :: GHC.Types.Int
  -- | time
  , postByronTransactionResponseBody202Pending_sinceTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Pending_since
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Pending_sinceTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Pending_sinceTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Pending_since
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Pending_since" (\obj -> ((((GHC.Base.pure PostByronTransactionResponseBody202Pending_since GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'PostByronTransactionResponseBody202Pending_since' with all required fields.
mkPostByronTransactionResponseBody202Pending_since :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Pending_sinceAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Pending_sinceEpoch_number'
  -> PostByronTransactionResponseBody202Pending_sinceHeight -- ^ 'postByronTransactionResponseBody202Pending_sinceHeight'
  -> GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Pending_sinceSlot_number'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202Pending_sinceTime'
  -> PostByronTransactionResponseBody202Pending_since
mkPostByronTransactionResponseBody202Pending_since postByronTransactionResponseBody202Pending_sinceAbsolute_slot_number postByronTransactionResponseBody202Pending_sinceEpoch_number postByronTransactionResponseBody202Pending_sinceHeight postByronTransactionResponseBody202Pending_sinceSlot_number postByronTransactionResponseBody202Pending_sinceTime = PostByronTransactionResponseBody202Pending_since{postByronTransactionResponseBody202Pending_sinceAbsolute_slot_number = postByronTransactionResponseBody202Pending_sinceAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                                                                postByronTransactionResponseBody202Pending_sinceEpoch_number = postByronTransactionResponseBody202Pending_sinceEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                                                                postByronTransactionResponseBody202Pending_sinceHeight = postByronTransactionResponseBody202Pending_sinceHeight,
                                                                                                                                                                                                                                                                                                                                                                                                                postByronTransactionResponseBody202Pending_sinceSlot_number = postByronTransactionResponseBody202Pending_sinceSlot_number,
                                                                                                                                                                                                                                                                                                                                                                                                                postByronTransactionResponseBody202Pending_sinceTime = postByronTransactionResponseBody202Pending_sinceTime}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.pending_since.properties.height@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202Pending_sinceHeight = PostByronTransactionResponseBody202Pending_sinceHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202Pending_sinceHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Pending_sinceHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Pending_sinceHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Pending_sinceHeight" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202Pending_sinceHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202Pending_sinceHeight' with all required fields.
mkPostByronTransactionResponseBody202Pending_sinceHeight :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Pending_sinceHeightQuantity'
  -> PostByronTransactionResponseBody202Pending_sinceHeight
mkPostByronTransactionResponseBody202Pending_sinceHeight postByronTransactionResponseBody202Pending_sinceHeightQuantity = PostByronTransactionResponseBody202Pending_sinceHeight{postByronTransactionResponseBody202Pending_sinceHeightQuantity = postByronTransactionResponseBody202Pending_sinceHeightQuantity}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.script_validity@ in the specification.
-- 
-- Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
-- used in the transaction validated or not. Validity may be null if this
-- transaction was from an era that doesn\'t support phase-2 monetary policy
-- scripts, or is a pending transaction (we don\'t know if validation passed or
-- failed until the transaction hits the ledger).
data PostByronTransactionResponseBody202Script_validityNonNullable =
   PostByronTransactionResponseBody202Script_validityNonNullableOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostByronTransactionResponseBody202Script_validityNonNullableTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostByronTransactionResponseBody202Script_validityNonNullableEnumValid -- ^ Represents the JSON value @"valid"@
  | PostByronTransactionResponseBody202Script_validityNonNullableEnumInvalid -- ^ Represents the JSON value @"invalid"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Script_validityNonNullable
    where toJSON (PostByronTransactionResponseBody202Script_validityNonNullableOther val) = val
          toJSON (PostByronTransactionResponseBody202Script_validityNonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostByronTransactionResponseBody202Script_validityNonNullableEnumValid) = "valid"
          toJSON (PostByronTransactionResponseBody202Script_validityNonNullableEnumInvalid) = "invalid"
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Script_validityNonNullable
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "valid" -> PostByronTransactionResponseBody202Script_validityNonNullableEnumValid
                                            | val GHC.Classes.== "invalid" -> PostByronTransactionResponseBody202Script_validityNonNullableEnumInvalid
                                            | GHC.Base.otherwise -> PostByronTransactionResponseBody202Script_validityNonNullableOther val)
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.status@ in the specification.
-- 
-- Current transaction status.
-- 
--   \`\`\`
--        *-----------*
--   ---> |  PENDING  |----------------*
--        *-----------*                |
--              |                      |
--              V                      V
--        *-----------*          *-----------*
--        |           |---------->  EXPIRED  |
--        |           |  (ttl)   *-----------*
--        | SUBMITTED |
--        |           \<----------------*
--        |           |                |
--        *-----------*           (rollback)
--               |                     |
--          (in ledger)          *-----------*
--               |               |           |
--               *---------------> IN_LEDGER |
--                               |           |
--                               *-----------*
--   \`\`\`
data PostByronTransactionResponseBody202Status =
   PostByronTransactionResponseBody202StatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | PostByronTransactionResponseBody202StatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | PostByronTransactionResponseBody202StatusEnumPending -- ^ Represents the JSON value @"pending"@
  | PostByronTransactionResponseBody202StatusEnumSubmitted -- ^ Represents the JSON value @"submitted"@
  | PostByronTransactionResponseBody202StatusEnumIn_ledger -- ^ Represents the JSON value @"in_ledger"@
  | PostByronTransactionResponseBody202StatusEnumExpired -- ^ Represents the JSON value @"expired"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Status
    where toJSON (PostByronTransactionResponseBody202StatusOther val) = val
          toJSON (PostByronTransactionResponseBody202StatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (PostByronTransactionResponseBody202StatusEnumPending) = "pending"
          toJSON (PostByronTransactionResponseBody202StatusEnumSubmitted) = "submitted"
          toJSON (PostByronTransactionResponseBody202StatusEnumIn_ledger) = "in_ledger"
          toJSON (PostByronTransactionResponseBody202StatusEnumExpired) = "expired"
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Status
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "pending" -> PostByronTransactionResponseBody202StatusEnumPending
                                            | val GHC.Classes.== "submitted" -> PostByronTransactionResponseBody202StatusEnumSubmitted
                                            | val GHC.Classes.== "in_ledger" -> PostByronTransactionResponseBody202StatusEnumIn_ledger
                                            | val GHC.Classes.== "expired" -> PostByronTransactionResponseBody202StatusEnumExpired
                                            | GHC.Base.otherwise -> PostByronTransactionResponseBody202StatusOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.validity_interval@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202Validity_interval = PostByronTransactionResponseBody202Validity_interval {
  -- | invalid_before
  postByronTransactionResponseBody202Validity_intervalInvalid_before :: PostByronTransactionResponseBody202Validity_intervalInvalid_before
  -- | invalid_hereafter
  , postByronTransactionResponseBody202Validity_intervalInvalid_hereafter :: PostByronTransactionResponseBody202Validity_intervalInvalid_hereafter
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Validity_interval
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Validity_interval
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Validity_interval" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202Validity_interval GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_before")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_hereafter"))
-- | Create a new 'PostByronTransactionResponseBody202Validity_interval' with all required fields.
mkPostByronTransactionResponseBody202Validity_interval :: PostByronTransactionResponseBody202Validity_intervalInvalid_before -- ^ 'postByronTransactionResponseBody202Validity_intervalInvalid_before'
  -> PostByronTransactionResponseBody202Validity_intervalInvalid_hereafter -- ^ 'postByronTransactionResponseBody202Validity_intervalInvalid_hereafter'
  -> PostByronTransactionResponseBody202Validity_interval
mkPostByronTransactionResponseBody202Validity_interval postByronTransactionResponseBody202Validity_intervalInvalid_before postByronTransactionResponseBody202Validity_intervalInvalid_hereafter = PostByronTransactionResponseBody202Validity_interval{postByronTransactionResponseBody202Validity_intervalInvalid_before = postByronTransactionResponseBody202Validity_intervalInvalid_before,
                                                                                                                                                                                                                                                       postByronTransactionResponseBody202Validity_intervalInvalid_hereafter = postByronTransactionResponseBody202Validity_intervalInvalid_hereafter}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.validity_interval.properties.invalid_before@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202Validity_intervalInvalid_before = PostByronTransactionResponseBody202Validity_intervalInvalid_before {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202Validity_intervalInvalid_beforeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Validity_intervalInvalid_before
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Validity_intervalInvalid_before
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Validity_intervalInvalid_before" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202Validity_intervalInvalid_before GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202Validity_intervalInvalid_before' with all required fields.
mkPostByronTransactionResponseBody202Validity_intervalInvalid_before :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Validity_intervalInvalid_beforeQuantity'
  -> PostByronTransactionResponseBody202Validity_intervalInvalid_before
mkPostByronTransactionResponseBody202Validity_intervalInvalid_before postByronTransactionResponseBody202Validity_intervalInvalid_beforeQuantity = PostByronTransactionResponseBody202Validity_intervalInvalid_before{postByronTransactionResponseBody202Validity_intervalInvalid_beforeQuantity = postByronTransactionResponseBody202Validity_intervalInvalid_beforeQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.validity_interval.properties.invalid_hereafter@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202Validity_intervalInvalid_hereafter = PostByronTransactionResponseBody202Validity_intervalInvalid_hereafter {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Validity_intervalInvalid_hereafter
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Validity_intervalInvalid_hereafter
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Validity_intervalInvalid_hereafter" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202Validity_intervalInvalid_hereafter GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202Validity_intervalInvalid_hereafter' with all required fields.
mkPostByronTransactionResponseBody202Validity_intervalInvalid_hereafter :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity'
  -> PostByronTransactionResponseBody202Validity_intervalInvalid_hereafter
mkPostByronTransactionResponseBody202Validity_intervalInvalid_hereafter postByronTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity = PostByronTransactionResponseBody202Validity_intervalInvalid_hereafter{postByronTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity = postByronTransactionResponseBody202Validity_intervalInvalid_hereafterQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.withdrawals.items@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody202Withdrawals = PostByronTransactionResponseBody202Withdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  postByronTransactionResponseBody202WithdrawalsAmount :: PostByronTransactionResponseBody202WithdrawalsAmount
  -- | stake_address
  , postByronTransactionResponseBody202WithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202Withdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202WithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202WithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202Withdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202Withdrawals" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody202Withdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'PostByronTransactionResponseBody202Withdrawals' with all required fields.
mkPostByronTransactionResponseBody202Withdrawals :: PostByronTransactionResponseBody202WithdrawalsAmount -- ^ 'postByronTransactionResponseBody202WithdrawalsAmount'
  -> Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody202WithdrawalsStake_address'
  -> PostByronTransactionResponseBody202Withdrawals
mkPostByronTransactionResponseBody202Withdrawals postByronTransactionResponseBody202WithdrawalsAmount postByronTransactionResponseBody202WithdrawalsStake_address = PostByronTransactionResponseBody202Withdrawals{postByronTransactionResponseBody202WithdrawalsAmount = postByronTransactionResponseBody202WithdrawalsAmount,
                                                                                                                                                                                                                   postByronTransactionResponseBody202WithdrawalsStake_address = postByronTransactionResponseBody202WithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.202.content.application\/json.schema.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionResponseBody202WithdrawalsAmount = PostByronTransactionResponseBody202WithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody202WithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody202WithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody202WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody202WithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody202WithdrawalsAmount" (\obj -> GHC.Base.pure PostByronTransactionResponseBody202WithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody202WithdrawalsAmount' with all required fields.
mkPostByronTransactionResponseBody202WithdrawalsAmount :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody202WithdrawalsAmountQuantity'
  -> PostByronTransactionResponseBody202WithdrawalsAmount
mkPostByronTransactionResponseBody202WithdrawalsAmount postByronTransactionResponseBody202WithdrawalsAmountQuantity = PostByronTransactionResponseBody202WithdrawalsAmount{postByronTransactionResponseBody202WithdrawalsAmountQuantity = postByronTransactionResponseBody202WithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody400 = PostByronTransactionResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  postByronTransactionResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody400" (\obj -> GHC.Base.pure PostByronTransactionResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionResponseBody400' with all required fields.
mkPostByronTransactionResponseBody400 :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody400Message'
  -> PostByronTransactionResponseBody400
mkPostByronTransactionResponseBody400 postByronTransactionResponseBody400Message = PostByronTransactionResponseBody400{postByronTransactionResponseBody400Message = postByronTransactionResponseBody400Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody403OneOf1 = PostByronTransactionResponseBody403OneOf1 {
  -- | message: May occur when trying to perform an operation not supported by this type of wallet.
  postByronTransactionResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "invalid_wallet_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody403OneOf1" (\obj -> GHC.Base.pure PostByronTransactionResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionResponseBody403OneOf1' with all required fields.
mkPostByronTransactionResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody403OneOf1Message'
  -> PostByronTransactionResponseBody403OneOf1
mkPostByronTransactionResponseBody403OneOf1 postByronTransactionResponseBody403OneOf1Message = PostByronTransactionResponseBody403OneOf1{postByronTransactionResponseBody403OneOf1Message = postByronTransactionResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody403OneOf2 = PostByronTransactionResponseBody403OneOf2 {
  -- | message: May occur when submitting a withdrawal while another withdrawal is pending.
  postByronTransactionResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "already_withdrawing"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody403OneOf2" (\obj -> GHC.Base.pure PostByronTransactionResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionResponseBody403OneOf2' with all required fields.
mkPostByronTransactionResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody403OneOf2Message'
  -> PostByronTransactionResponseBody403OneOf2
mkPostByronTransactionResponseBody403OneOf2 postByronTransactionResponseBody403OneOf2Message = PostByronTransactionResponseBody403OneOf2{postByronTransactionResponseBody403OneOf2Message = postByronTransactionResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody403OneOf3 = PostByronTransactionResponseBody403OneOf3 {
  -- | info
  postByronTransactionResponseBody403OneOf3Info :: (GHC.Maybe.Maybe PostByronTransactionResponseBody403OneOf3Info)
  -- | message: Occurs when a requested output has a quantity of lovelace that is below the minimum required by the ledger.
  , postByronTransactionResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody403OneOf3Info obj) : ["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("info" Data.Aeson.Types.ToJSON..=)) (postByronTransactionResponseBody403OneOf3Info obj) : ["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "utxo_too_small"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody403OneOf3" (\obj -> (GHC.Base.pure PostByronTransactionResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "info")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionResponseBody403OneOf3' with all required fields.
mkPostByronTransactionResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody403OneOf3Message'
  -> PostByronTransactionResponseBody403OneOf3
mkPostByronTransactionResponseBody403OneOf3 postByronTransactionResponseBody403OneOf3Message = PostByronTransactionResponseBody403OneOf3{postByronTransactionResponseBody403OneOf3Info = GHC.Maybe.Nothing,
                                                                                                                                         postByronTransactionResponseBody403OneOf3Message = postByronTransactionResponseBody403OneOf3Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf.properties.info@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody403OneOf3Info = PostByronTransactionResponseBody403OneOf3Info {
  -- | tx_output_index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody403OneOf3InfoTx_output_index :: GHC.Types.Int
  -- | tx_output_lovelace_required_minimum: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum :: PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
  -- | tx_output_lovelace_specified: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified :: PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody403OneOf3Info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf3InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tx_output_index" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf3InfoTx_output_index obj] : ["tx_output_lovelace_required_minimum" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum obj] : ["tx_output_lovelace_specified" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody403OneOf3Info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody403OneOf3Info" (\obj -> ((GHC.Base.pure PostByronTransactionResponseBody403OneOf3Info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_index")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_required_minimum")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tx_output_lovelace_specified"))
-- | Create a new 'PostByronTransactionResponseBody403OneOf3Info' with all required fields.
mkPostByronTransactionResponseBody403OneOf3Info :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody403OneOf3InfoTx_output_index'
  -> PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum -- ^ 'postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum'
  -> PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified -- ^ 'postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified'
  -> PostByronTransactionResponseBody403OneOf3Info
mkPostByronTransactionResponseBody403OneOf3Info postByronTransactionResponseBody403OneOf3InfoTx_output_index postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified = PostByronTransactionResponseBody403OneOf3Info{postByronTransactionResponseBody403OneOf3InfoTx_output_index = postByronTransactionResponseBody403OneOf3InfoTx_output_index,
                                                                                                                                                                                                                                                                                                                        postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum = postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum,
                                                                                                                                                                                                                                                                                                                        postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified = postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_required_minimum@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum = PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum" (\obj -> GHC.Base.pure PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum' with all required fields.
mkPostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity'
  -> PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum
mkPostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity = PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimum{postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity = postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_required_minimumQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf.properties.info.properties.tx_output_lovelace_specified@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified = PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified" (\obj -> GHC.Base.pure PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified' with all required fields.
mkPostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified :: GHC.Types.Int -- ^ 'postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity'
  -> PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified
mkPostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity = PostByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specified{postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity = postByronTransactionResponseBody403OneOf3InfoTx_output_lovelace_specifiedQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody403OneOf4 = PostByronTransactionResponseBody403OneOf4 {
  -- | message: May occur when a transaction can\'t be balanced for fees.
  postByronTransactionResponseBody403OneOf4Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody403OneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf4Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "cannot_cover_fee"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody403OneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody403OneOf4" (\obj -> GHC.Base.pure PostByronTransactionResponseBody403OneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionResponseBody403OneOf4' with all required fields.
mkPostByronTransactionResponseBody403OneOf4 :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody403OneOf4Message'
  -> PostByronTransactionResponseBody403OneOf4
mkPostByronTransactionResponseBody403OneOf4 postByronTransactionResponseBody403OneOf4Message = PostByronTransactionResponseBody403OneOf4{postByronTransactionResponseBody403OneOf4Message = postByronTransactionResponseBody403OneOf4Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody403OneOf5 = PostByronTransactionResponseBody403OneOf5 {
  -- | message: May occur when there\'s not enough money in the wallet to cover a requested payment.
  postByronTransactionResponseBody403OneOf5Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody403OneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf5Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_enough_money"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody403OneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody403OneOf5" (\obj -> GHC.Base.pure PostByronTransactionResponseBody403OneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionResponseBody403OneOf5' with all required fields.
mkPostByronTransactionResponseBody403OneOf5 :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody403OneOf5Message'
  -> PostByronTransactionResponseBody403OneOf5
mkPostByronTransactionResponseBody403OneOf5 postByronTransactionResponseBody403OneOf5Message = PostByronTransactionResponseBody403OneOf5{postByronTransactionResponseBody403OneOf5Message = postByronTransactionResponseBody403OneOf5Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody403OneOf6 = PostByronTransactionResponseBody403OneOf6 {
  -- | message: May occur when the total balance of pure ada UTxOs in the wallet is
  -- insufficient to cover the minimum collateral amount required for a
  -- transaction requiring collateral.
  postByronTransactionResponseBody403OneOf6Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody403OneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf6Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "insufficient_collateral"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody403OneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody403OneOf6" (\obj -> GHC.Base.pure PostByronTransactionResponseBody403OneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionResponseBody403OneOf6' with all required fields.
mkPostByronTransactionResponseBody403OneOf6 :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody403OneOf6Message'
  -> PostByronTransactionResponseBody403OneOf6
mkPostByronTransactionResponseBody403OneOf6 postByronTransactionResponseBody403OneOf6Message = PostByronTransactionResponseBody403OneOf6{postByronTransactionResponseBody403OneOf6Message = postByronTransactionResponseBody403OneOf6Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody403OneOf7 = PostByronTransactionResponseBody403OneOf7 {
  -- | message: May occur when the wallet can\'t cover for all requested outputs without making the transaction too large.
  postByronTransactionResponseBody403OneOf7Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody403OneOf7
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_is_too_big"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf7Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "transaction_is_too_big"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody403OneOf7
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody403OneOf7" (\obj -> GHC.Base.pure PostByronTransactionResponseBody403OneOf7 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionResponseBody403OneOf7' with all required fields.
mkPostByronTransactionResponseBody403OneOf7 :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody403OneOf7Message'
  -> PostByronTransactionResponseBody403OneOf7
mkPostByronTransactionResponseBody403OneOf7 postByronTransactionResponseBody403OneOf7Message = PostByronTransactionResponseBody403OneOf7{postByronTransactionResponseBody403OneOf7Message = postByronTransactionResponseBody403OneOf7Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody403OneOf8 = PostByronTransactionResponseBody403OneOf8 {
  -- | message: May occur when an action require a signing key but the wallet has only access to verification keys.
  postByronTransactionResponseBody403OneOf8Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody403OneOf8
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf8Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody403OneOf8
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody403OneOf8" (\obj -> GHC.Base.pure PostByronTransactionResponseBody403OneOf8 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionResponseBody403OneOf8' with all required fields.
mkPostByronTransactionResponseBody403OneOf8 :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody403OneOf8Message'
  -> PostByronTransactionResponseBody403OneOf8
mkPostByronTransactionResponseBody403OneOf8 postByronTransactionResponseBody403OneOf8Message = PostByronTransactionResponseBody403OneOf8{postByronTransactionResponseBody403OneOf8Message = postByronTransactionResponseBody403OneOf8Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody403OneOf9 = PostByronTransactionResponseBody403OneOf9 {
  -- | message: May occur when the given spending passphrase is wrong.
  postByronTransactionResponseBody403OneOf9Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody403OneOf9
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody403OneOf9Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody403OneOf9
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody403OneOf9" (\obj -> GHC.Base.pure PostByronTransactionResponseBody403OneOf9 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionResponseBody403OneOf9' with all required fields.
mkPostByronTransactionResponseBody403OneOf9 :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody403OneOf9Message'
  -> PostByronTransactionResponseBody403OneOf9
mkPostByronTransactionResponseBody403OneOf9 postByronTransactionResponseBody403OneOf9Message = PostByronTransactionResponseBody403OneOf9{postByronTransactionResponseBody403OneOf9Message = postByronTransactionResponseBody403OneOf9Message}
-- | Defines the oneOf schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody403Variants =
   PostByronTransactionResponseBody403Variant1 PostByronTransactionResponseBody403OneOf1
  | PostByronTransactionResponseBody403Variant2 PostByronTransactionResponseBody403OneOf2
  | PostByronTransactionResponseBody403Variant3 PostByronTransactionResponseBody403OneOf3
  | PostByronTransactionResponseBody403Variant4 PostByronTransactionResponseBody403OneOf4
  | PostByronTransactionResponseBody403Variant5 PostByronTransactionResponseBody403OneOf5
  | PostByronTransactionResponseBody403Variant6 PostByronTransactionResponseBody403OneOf6
  | PostByronTransactionResponseBody403Variant7 PostByronTransactionResponseBody403OneOf7
  | PostByronTransactionResponseBody403Variant8 PostByronTransactionResponseBody403OneOf8
  | PostByronTransactionResponseBody403Variant9 PostByronTransactionResponseBody403OneOf9
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody403Variants
    where toJSON (PostByronTransactionResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody403Variant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody403Variant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody403Variant6 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody403Variant7 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody403Variant8 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PostByronTransactionResponseBody403Variant9 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody403Variants
    where parseJSON val = case (PostByronTransactionResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody403Variant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody403Variant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody403Variant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody403Variant7 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody403Variant8 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PostByronTransactionResponseBody403Variant9 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody404 = PostByronTransactionResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  postByronTransactionResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody404" (\obj -> GHC.Base.pure PostByronTransactionResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionResponseBody404' with all required fields.
mkPostByronTransactionResponseBody404 :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody404Message'
  -> PostByronTransactionResponseBody404
mkPostByronTransactionResponseBody404 postByronTransactionResponseBody404Message = PostByronTransactionResponseBody404{postByronTransactionResponseBody404Message = postByronTransactionResponseBody404Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody406 = PostByronTransactionResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  postByronTransactionResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody406" (\obj -> GHC.Base.pure PostByronTransactionResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionResponseBody406' with all required fields.
mkPostByronTransactionResponseBody406 :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody406Message'
  -> PostByronTransactionResponseBody406
mkPostByronTransactionResponseBody406 postByronTransactionResponseBody406Message = PostByronTransactionResponseBody406{postByronTransactionResponseBody406Message = postByronTransactionResponseBody406Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody415 = PostByronTransactionResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  postByronTransactionResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody415" (\obj -> GHC.Base.pure PostByronTransactionResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionResponseBody415' with all required fields.
mkPostByronTransactionResponseBody415 :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody415Message'
  -> PostByronTransactionResponseBody415
mkPostByronTransactionResponseBody415 postByronTransactionResponseBody415Message = PostByronTransactionResponseBody415{postByronTransactionResponseBody415Message = postByronTransactionResponseBody415Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/transactions.POST.responses.425.content.application\/json.schema@ in the specification.
-- 
-- 
data PostByronTransactionResponseBody425 = PostByronTransactionResponseBody425 {
  -- | message: May occur when submitting a serialized transaction to a node with full mempool.
  postByronTransactionResponseBody425Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PostByronTransactionResponseBody425
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody425Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "mempool_is_full"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= postByronTransactionResponseBody425Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "mempool_is_full"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PostByronTransactionResponseBody425
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PostByronTransactionResponseBody425" (\obj -> GHC.Base.pure PostByronTransactionResponseBody425 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PostByronTransactionResponseBody425' with all required fields.
mkPostByronTransactionResponseBody425 :: Data.Text.Internal.Text -- ^ 'postByronTransactionResponseBody425Message'
  -> PostByronTransactionResponseBody425
mkPostByronTransactionResponseBody425 postByronTransactionResponseBody425Message = PostByronTransactionResponseBody425{postByronTransactionResponseBody425Message = postByronTransactionResponseBody425Message}
-- | > POST /byron-wallets/{walletId}/transactions
-- 
-- The same as 'postByronTransaction' but accepts an explicit configuration.
postByronTransactionWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostByronTransactionRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response PostByronTransactionResponse) -- ^ Monadic computation which returns the result of the operation
postByronTransactionWithConfiguration config
                                      walletId
                                      body = GHC.Base.fmap (\response_8 -> GHC.Base.fmap (Data.Either.either PostByronTransactionResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                PostByronTransactionResponseBody202)
                                                                                                                                                                                            | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                  PostByronTransactionResponseBody400)
                                                                                                                                                                                            | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                  PostByronTransactionResponseBody403Variants)
                                                                                                                                                                                            | (\status_12 -> Network.HTTP.Types.Status.statusCode status_12 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                  PostByronTransactionResponseBody404)
                                                                                                                                                                                            | (\status_13 -> Network.HTTP.Types.Status.statusCode status_13 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                  PostByronTransactionResponseBody406)
                                                                                                                                                                                            | (\status_14 -> Network.HTTP.Types.Status.statusCode status_14 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                  PostByronTransactionResponseBody415)
                                                                                                                                                                                            | (\status_15 -> Network.HTTP.Types.Status.statusCode status_15 GHC.Classes.== 425) (Network.HTTP.Client.Types.responseStatus response) -> PostByronTransactionResponse425 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                  PostByronTransactionResponseBody425)
                                                                                                                                                                                            | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_8) response_8) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /byron-wallets/{walletId}/transactions
-- 
-- The same as 'postByronTransaction' but returns the raw 'Data.ByteString.ByteString'.
postByronTransactionRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostByronTransactionRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postByronTransactionRaw walletId
                        body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /byron-wallets/{walletId}/transactions
-- 
-- The same as 'postByronTransaction' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
postByronTransactionWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PostByronTransactionRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
postByronTransactionWithConfigurationRaw config
                                         walletId
                                         body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/transactions")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
