-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation putWalletPassphrase
module Wallet.Operations.PutWalletPassphrase where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > PUT /wallets/{walletId}/passphrase
-- 
-- \<p align=\"right\">status: \<strong>stable\<\/strong>\<\/p>
putWalletPassphrase :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutWalletPassphraseRequestBodyVariants -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response PutWalletPassphraseResponse) -- ^ Monadic computation which returns the result of the operation
putWalletPassphrase walletId
                    body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either PutWalletPassphraseResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 204) (Network.HTTP.Client.Types.responseStatus response) -> Data.Either.Right PutWalletPassphraseResponse204
                                                                                                                                                                         | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletPassphraseResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                            PutWalletPassphraseResponseBody400)
                                                                                                                                                                         | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletPassphraseResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                            PutWalletPassphraseResponseBody403Variants)
                                                                                                                                                                         | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletPassphraseResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                            PutWalletPassphraseResponseBody404)
                                                                                                                                                                         | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletPassphraseResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                            PutWalletPassphraseResponseBody406)
                                                                                                                                                                         | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletPassphraseResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                            PutWalletPassphraseResponseBody415)
                                                                                                                                                                         | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/passphrase")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/passphrase.PUT.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PutWalletPassphraseRequestBodyOneOf1 = PutWalletPassphraseRequestBodyOneOf1 {
  -- | new_passphrase: A master passphrase to lock and protect the wallet for sensitive operation (e.g. sending funds).
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 10
  putWalletPassphraseRequestBodyOneOf1New_passphrase :: Data.Text.Internal.Text
  -- | old_passphrase: The current master passphrase.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 10
  , putWalletPassphraseRequestBodyOneOf1Old_passphrase :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletPassphraseRequestBodyOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["new_passphrase" Data.Aeson.Types.ToJSON..= putWalletPassphraseRequestBodyOneOf1New_passphrase obj] : ["old_passphrase" Data.Aeson.Types.ToJSON..= putWalletPassphraseRequestBodyOneOf1Old_passphrase obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["new_passphrase" Data.Aeson.Types.ToJSON..= putWalletPassphraseRequestBodyOneOf1New_passphrase obj] : ["old_passphrase" Data.Aeson.Types.ToJSON..= putWalletPassphraseRequestBodyOneOf1Old_passphrase obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletPassphraseRequestBodyOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletPassphraseRequestBodyOneOf1" (\obj -> (GHC.Base.pure PutWalletPassphraseRequestBodyOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "new_passphrase")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "old_passphrase"))
-- | Create a new 'PutWalletPassphraseRequestBodyOneOf1' with all required fields.
mkPutWalletPassphraseRequestBodyOneOf1 :: Data.Text.Internal.Text -- ^ 'putWalletPassphraseRequestBodyOneOf1New_passphrase'
  -> Data.Text.Internal.Text -- ^ 'putWalletPassphraseRequestBodyOneOf1Old_passphrase'
  -> PutWalletPassphraseRequestBodyOneOf1
mkPutWalletPassphraseRequestBodyOneOf1 putWalletPassphraseRequestBodyOneOf1New_passphrase putWalletPassphraseRequestBodyOneOf1Old_passphrase = PutWalletPassphraseRequestBodyOneOf1{putWalletPassphraseRequestBodyOneOf1New_passphrase = putWalletPassphraseRequestBodyOneOf1New_passphrase,
                                                                                                                                                                                    putWalletPassphraseRequestBodyOneOf1Old_passphrase = putWalletPassphraseRequestBodyOneOf1Old_passphrase}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/passphrase.PUT.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PutWalletPassphraseRequestBodyOneOf2 = PutWalletPassphraseRequestBodyOneOf2 {
  -- | mnemonic_second_factor: An optional passphrase used to encrypt the mnemonic sentence.
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 12 items
  -- * Must have a minimum of 9 items
  putWalletPassphraseRequestBodyOneOf2Mnemonic_second_factor :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | mnemonic_sentence: The mnemonic list of words to restore the wallet
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 24 items
  -- * Must have a minimum of 15 items
  , putWalletPassphraseRequestBodyOneOf2Mnemonic_sentence :: ([Data.Text.Internal.Text])
  -- | new_passphrase: The new master passphrase to lock and protect the wallet for sensitive operation (e.g. sending funds)
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 10
  , putWalletPassphraseRequestBodyOneOf2New_passphrase :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletPassphraseRequestBodyOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mnemonic_second_factor" Data.Aeson.Types.ToJSON..=)) (putWalletPassphraseRequestBodyOneOf2Mnemonic_second_factor obj) : ["mnemonic_sentence" Data.Aeson.Types.ToJSON..= putWalletPassphraseRequestBodyOneOf2Mnemonic_sentence obj] : ["new_passphrase" Data.Aeson.Types.ToJSON..= putWalletPassphraseRequestBodyOneOf2New_passphrase obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mnemonic_second_factor" Data.Aeson.Types.ToJSON..=)) (putWalletPassphraseRequestBodyOneOf2Mnemonic_second_factor obj) : ["mnemonic_sentence" Data.Aeson.Types.ToJSON..= putWalletPassphraseRequestBodyOneOf2Mnemonic_sentence obj] : ["new_passphrase" Data.Aeson.Types.ToJSON..= putWalletPassphraseRequestBodyOneOf2New_passphrase obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletPassphraseRequestBodyOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletPassphraseRequestBodyOneOf2" (\obj -> ((GHC.Base.pure PutWalletPassphraseRequestBodyOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mnemonic_second_factor")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "mnemonic_sentence")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "new_passphrase"))
-- | Create a new 'PutWalletPassphraseRequestBodyOneOf2' with all required fields.
mkPutWalletPassphraseRequestBodyOneOf2 :: [Data.Text.Internal.Text] -- ^ 'putWalletPassphraseRequestBodyOneOf2Mnemonic_sentence'
  -> Data.Text.Internal.Text -- ^ 'putWalletPassphraseRequestBodyOneOf2New_passphrase'
  -> PutWalletPassphraseRequestBodyOneOf2
mkPutWalletPassphraseRequestBodyOneOf2 putWalletPassphraseRequestBodyOneOf2Mnemonic_sentence putWalletPassphraseRequestBodyOneOf2New_passphrase = PutWalletPassphraseRequestBodyOneOf2{putWalletPassphraseRequestBodyOneOf2Mnemonic_second_factor = GHC.Maybe.Nothing,
                                                                                                                                                                                       putWalletPassphraseRequestBodyOneOf2Mnemonic_sentence = putWalletPassphraseRequestBodyOneOf2Mnemonic_sentence,
                                                                                                                                                                                       putWalletPassphraseRequestBodyOneOf2New_passphrase = putWalletPassphraseRequestBodyOneOf2New_passphrase}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/passphrase.PUT.requestBody.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PutWalletPassphraseRequestBodyVariants =
   PutWalletPassphraseRequestBodyVariant1 PutWalletPassphraseRequestBodyOneOf1
  | PutWalletPassphraseRequestBodyVariant2 PutWalletPassphraseRequestBodyOneOf2
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletPassphraseRequestBodyVariants
    where toJSON (PutWalletPassphraseRequestBodyVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PutWalletPassphraseRequestBodyVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletPassphraseRequestBodyVariants
    where parseJSON val = case (PutWalletPassphraseRequestBodyVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PutWalletPassphraseRequestBodyVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched") of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Represents a response of the operation 'putWalletPassphrase'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'PutWalletPassphraseResponseError' is used.
data PutWalletPassphraseResponse =
   PutWalletPassphraseResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | PutWalletPassphraseResponse204 -- ^ No Content
  | PutWalletPassphraseResponse400 PutWalletPassphraseResponseBody400 -- ^ Bad Request
  | PutWalletPassphraseResponse403 PutWalletPassphraseResponseBody403Variants -- ^ Forbidden
  | PutWalletPassphraseResponse404 PutWalletPassphraseResponseBody404 -- ^ Not Found
  | PutWalletPassphraseResponse406 PutWalletPassphraseResponseBody406 -- ^ Not Acceptable
  | PutWalletPassphraseResponse415 PutWalletPassphraseResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/passphrase.PUT.responses.400.content.application\/json.schema@ in the specification.
-- 
-- 
data PutWalletPassphraseResponseBody400 = PutWalletPassphraseResponseBody400 {
  -- | message: May occur when a request is not well-formed; that is, it fails to parse
  -- successfully. This could be the case when some required parameters
  -- are missing or, when malformed values are provided.
  putWalletPassphraseResponseBody400Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletPassphraseResponseBody400
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletPassphraseResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletPassphraseResponseBody400Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "bad_request"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletPassphraseResponseBody400
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletPassphraseResponseBody400" (\obj -> GHC.Base.pure PutWalletPassphraseResponseBody400 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutWalletPassphraseResponseBody400' with all required fields.
mkPutWalletPassphraseResponseBody400 :: Data.Text.Internal.Text -- ^ 'putWalletPassphraseResponseBody400Message'
  -> PutWalletPassphraseResponseBody400
mkPutWalletPassphraseResponseBody400 putWalletPassphraseResponseBody400Message = PutWalletPassphraseResponseBody400{putWalletPassphraseResponseBody400Message = putWalletPassphraseResponseBody400Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/passphrase.PUT.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PutWalletPassphraseResponseBody403OneOf1 = PutWalletPassphraseResponseBody403OneOf1 {
  -- | message: May occur when an action require a signing key but the wallet has only access to verification keys.
  putWalletPassphraseResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletPassphraseResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletPassphraseResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletPassphraseResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletPassphraseResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletPassphraseResponseBody403OneOf1" (\obj -> GHC.Base.pure PutWalletPassphraseResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutWalletPassphraseResponseBody403OneOf1' with all required fields.
mkPutWalletPassphraseResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'putWalletPassphraseResponseBody403OneOf1Message'
  -> PutWalletPassphraseResponseBody403OneOf1
mkPutWalletPassphraseResponseBody403OneOf1 putWalletPassphraseResponseBody403OneOf1Message = PutWalletPassphraseResponseBody403OneOf1{putWalletPassphraseResponseBody403OneOf1Message = putWalletPassphraseResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/passphrase.PUT.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PutWalletPassphraseResponseBody403OneOf2 = PutWalletPassphraseResponseBody403OneOf2 {
  -- | message: May occur when the given spending passphrase is wrong.
  putWalletPassphraseResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletPassphraseResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletPassphraseResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletPassphraseResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletPassphraseResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletPassphraseResponseBody403OneOf2" (\obj -> GHC.Base.pure PutWalletPassphraseResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutWalletPassphraseResponseBody403OneOf2' with all required fields.
mkPutWalletPassphraseResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'putWalletPassphraseResponseBody403OneOf2Message'
  -> PutWalletPassphraseResponseBody403OneOf2
mkPutWalletPassphraseResponseBody403OneOf2 putWalletPassphraseResponseBody403OneOf2Message = PutWalletPassphraseResponseBody403OneOf2{putWalletPassphraseResponseBody403OneOf2Message = putWalletPassphraseResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/passphrase.PUT.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PutWalletPassphraseResponseBody403OneOf3 = PutWalletPassphraseResponseBody403OneOf3 {
  -- | message: May occur when the given mnemonic is wrong.
  putWalletPassphraseResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletPassphraseResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletPassphraseResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_mnemonic"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletPassphraseResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_mnemonic"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletPassphraseResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletPassphraseResponseBody403OneOf3" (\obj -> GHC.Base.pure PutWalletPassphraseResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutWalletPassphraseResponseBody403OneOf3' with all required fields.
mkPutWalletPassphraseResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'putWalletPassphraseResponseBody403OneOf3Message'
  -> PutWalletPassphraseResponseBody403OneOf3
mkPutWalletPassphraseResponseBody403OneOf3 putWalletPassphraseResponseBody403OneOf3Message = PutWalletPassphraseResponseBody403OneOf3{putWalletPassphraseResponseBody403OneOf3Message = putWalletPassphraseResponseBody403OneOf3Message}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/passphrase.PUT.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data PutWalletPassphraseResponseBody403Variants =
   PutWalletPassphraseResponseBody403Variant1 PutWalletPassphraseResponseBody403OneOf1
  | PutWalletPassphraseResponseBody403Variant2 PutWalletPassphraseResponseBody403OneOf2
  | PutWalletPassphraseResponseBody403Variant3 PutWalletPassphraseResponseBody403OneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletPassphraseResponseBody403Variants
    where toJSON (PutWalletPassphraseResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PutWalletPassphraseResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (PutWalletPassphraseResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletPassphraseResponseBody403Variants
    where parseJSON val = case (PutWalletPassphraseResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PutWalletPassphraseResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((PutWalletPassphraseResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/passphrase.PUT.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data PutWalletPassphraseResponseBody404 = PutWalletPassphraseResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  putWalletPassphraseResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletPassphraseResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletPassphraseResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletPassphraseResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletPassphraseResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletPassphraseResponseBody404" (\obj -> GHC.Base.pure PutWalletPassphraseResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutWalletPassphraseResponseBody404' with all required fields.
mkPutWalletPassphraseResponseBody404 :: Data.Text.Internal.Text -- ^ 'putWalletPassphraseResponseBody404Message'
  -> PutWalletPassphraseResponseBody404
mkPutWalletPassphraseResponseBody404 putWalletPassphraseResponseBody404Message = PutWalletPassphraseResponseBody404{putWalletPassphraseResponseBody404Message = putWalletPassphraseResponseBody404Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/passphrase.PUT.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data PutWalletPassphraseResponseBody406 = PutWalletPassphraseResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  putWalletPassphraseResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletPassphraseResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletPassphraseResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletPassphraseResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletPassphraseResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletPassphraseResponseBody406" (\obj -> GHC.Base.pure PutWalletPassphraseResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutWalletPassphraseResponseBody406' with all required fields.
mkPutWalletPassphraseResponseBody406 :: Data.Text.Internal.Text -- ^ 'putWalletPassphraseResponseBody406Message'
  -> PutWalletPassphraseResponseBody406
mkPutWalletPassphraseResponseBody406 putWalletPassphraseResponseBody406Message = PutWalletPassphraseResponseBody406{putWalletPassphraseResponseBody406Message = putWalletPassphraseResponseBody406Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/passphrase.PUT.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data PutWalletPassphraseResponseBody415 = PutWalletPassphraseResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  putWalletPassphraseResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON PutWalletPassphraseResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletPassphraseResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= putWalletPassphraseResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON PutWalletPassphraseResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "PutWalletPassphraseResponseBody415" (\obj -> GHC.Base.pure PutWalletPassphraseResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'PutWalletPassphraseResponseBody415' with all required fields.
mkPutWalletPassphraseResponseBody415 :: Data.Text.Internal.Text -- ^ 'putWalletPassphraseResponseBody415Message'
  -> PutWalletPassphraseResponseBody415
mkPutWalletPassphraseResponseBody415 putWalletPassphraseResponseBody415Message = PutWalletPassphraseResponseBody415{putWalletPassphraseResponseBody415Message = putWalletPassphraseResponseBody415Message}
-- | > PUT /wallets/{walletId}/passphrase
-- 
-- The same as 'putWalletPassphrase' but accepts an explicit configuration.
putWalletPassphraseWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutWalletPassphraseRequestBodyVariants -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response PutWalletPassphraseResponse) -- ^ Monadic computation which returns the result of the operation
putWalletPassphraseWithConfiguration config
                                     walletId
                                     body = GHC.Base.fmap (\response_7 -> GHC.Base.fmap (Data.Either.either PutWalletPassphraseResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 204) (Network.HTTP.Client.Types.responseStatus response) -> Data.Either.Right PutWalletPassphraseResponse204
                                                                                                                                                                                          | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 400) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletPassphraseResponse400 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                             PutWalletPassphraseResponseBody400)
                                                                                                                                                                                          | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletPassphraseResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                               PutWalletPassphraseResponseBody403Variants)
                                                                                                                                                                                          | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletPassphraseResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                               PutWalletPassphraseResponseBody404)
                                                                                                                                                                                          | (\status_12 -> Network.HTTP.Types.Status.statusCode status_12 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletPassphraseResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                               PutWalletPassphraseResponseBody406)
                                                                                                                                                                                          | (\status_13 -> Network.HTTP.Types.Status.statusCode status_13 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> PutWalletPassphraseResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                               PutWalletPassphraseResponseBody415)
                                                                                                                                                                                          | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_7) response_7) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/passphrase")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > PUT /wallets/{walletId}/passphrase
-- 
-- The same as 'putWalletPassphrase' but returns the raw 'Data.ByteString.ByteString'.
putWalletPassphraseRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutWalletPassphraseRequestBodyVariants -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
putWalletPassphraseRaw walletId
                       body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/passphrase")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > PUT /wallets/{walletId}/passphrase
-- 
-- The same as 'putWalletPassphrase' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
putWalletPassphraseWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> PutWalletPassphraseRequestBodyVariants -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
putWalletPassphraseWithConfigurationRaw config
                                        walletId
                                        body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "PUT") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/passphrase")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
