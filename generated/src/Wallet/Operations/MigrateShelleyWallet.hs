-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation migrateShelleyWallet
module Wallet.Operations.MigrateShelleyWallet where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /wallets/{walletId}/migrations
-- 
-- Migrate the UTxO balance of this wallet to the given set of addresses.
-- 
-- This operation will attempt to transfer as much of the wallet\'s balance
-- as possible to the given set of addresses, by creating and submitting
-- as many transactions as may be necessary to migrate the entire balance.
-- 
-- In order to minimize the total transaction fee required, UTxO entries
-- are coalesced together to the greatest extent possible in the resulting
-- transactions. No attempt is made to preserve the wallet\'s UTxO
-- distribution.
-- 
-- This operation is performed on a best-effort basis. If there is
-- insufficient ada available to pay for the entire UTxO set to be
-- migrated, then only a subset of the wallet\'s UTxO set will be migrated.
-- 
-- A typical use of this operation would be to move all funds from an old
-- wallet to a new wallet, by providing addresses that belong to the new
-- wallet.
migrateShelleyWallet :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> MigrateShelleyWalletRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response MigrateShelleyWalletResponse) -- ^ Monadic computation which returns the result of the operation
migrateShelleyWallet walletId
                     body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either MigrateShelleyWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> MigrateShelleyWalletResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               ([MigrateShelleyWalletResponseBody202]))
                                                                                                                                                                           | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> MigrateShelleyWalletResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               MigrateShelleyWalletResponseBody403Variants)
                                                                                                                                                                           | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> MigrateShelleyWalletResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               MigrateShelleyWalletResponseBody404)
                                                                                                                                                                           | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> MigrateShelleyWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               MigrateShelleyWalletResponseBody406)
                                                                                                                                                                           | (\status_5 -> Network.HTTP.Types.Status.statusCode status_5 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> MigrateShelleyWalletResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                               MigrateShelleyWalletResponseBody415)
                                                                                                                                                                           | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/migrations")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.requestBody.content.application\/json.schema@ in the specification.
-- 
-- 
data MigrateShelleyWalletRequestBody = MigrateShelleyWalletRequestBody {
  -- | addresses: The recipient addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateShelleyWalletRequestBodyAddresses :: ([Data.Text.Internal.Text])
  -- | passphrase: The wallet\'s master passphrase.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 255
  -- * Minimum length of 10
  , migrateShelleyWalletRequestBodyPassphrase :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["addresses" Data.Aeson.Types.ToJSON..= migrateShelleyWalletRequestBodyAddresses obj] : ["passphrase" Data.Aeson.Types.ToJSON..= migrateShelleyWalletRequestBodyPassphrase obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["addresses" Data.Aeson.Types.ToJSON..= migrateShelleyWalletRequestBodyAddresses obj] : ["passphrase" Data.Aeson.Types.ToJSON..= migrateShelleyWalletRequestBodyPassphrase obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletRequestBody" (\obj -> (GHC.Base.pure MigrateShelleyWalletRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "addresses")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "passphrase"))
-- | Create a new 'MigrateShelleyWalletRequestBody' with all required fields.
mkMigrateShelleyWalletRequestBody :: [Data.Text.Internal.Text] -- ^ 'migrateShelleyWalletRequestBodyAddresses'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletRequestBodyPassphrase'
  -> MigrateShelleyWalletRequestBody
mkMigrateShelleyWalletRequestBody migrateShelleyWalletRequestBodyAddresses migrateShelleyWalletRequestBodyPassphrase = MigrateShelleyWalletRequestBody{migrateShelleyWalletRequestBodyAddresses = migrateShelleyWalletRequestBodyAddresses,
                                                                                                                                                       migrateShelleyWalletRequestBodyPassphrase = migrateShelleyWalletRequestBodyPassphrase}
-- | Represents a response of the operation 'migrateShelleyWallet'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'MigrateShelleyWalletResponseError' is used.
data MigrateShelleyWalletResponse =
   MigrateShelleyWalletResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | MigrateShelleyWalletResponse202 ([MigrateShelleyWalletResponseBody202]) -- ^ Accepted
  | MigrateShelleyWalletResponse403 MigrateShelleyWalletResponseBody403Variants -- ^ Forbidden
  | MigrateShelleyWalletResponse404 MigrateShelleyWalletResponseBody404 -- ^ Not Found
  | MigrateShelleyWalletResponse406 MigrateShelleyWalletResponseBody406 -- ^ Not Acceptable
  | MigrateShelleyWalletResponse415 MigrateShelleyWalletResponseBody415 -- ^ Unsupported Media Type
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202 = MigrateShelleyWalletResponseBody202 {
  -- | amount: An amount of Ada spent or received, from the perspective of the wallet.
  -- 
  -- That is, for outgoing transaction, it represents the amount of Ada consumed
  -- as inputs including the amount of Ada spent as fees or deposits.
  -- 
  -- For incoming transaction, it represents the total amount of Ada received to
  -- addresses that belong to the wallet.
  migrateShelleyWalletResponseBody202Amount :: MigrateShelleyWalletResponseBody202Amount
  -- | burn
  , migrateShelleyWalletResponseBody202Burn :: (GHC.Maybe.Maybe MigrateShelleyWalletResponseBody202Burn)
  -- | certificates
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , migrateShelleyWalletResponseBody202Certificates :: (GHC.Maybe.Maybe ([MigrateShelleyWalletResponseBody202CertificatesVariants]))
  -- | collateral: A list of transaction inputs used for collateral.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , migrateShelleyWalletResponseBody202Collateral :: (GHC.Maybe.Maybe ([MigrateShelleyWalletResponseBody202Collateral]))
  -- | collateral_outputs: A list of collateral return outputs with amounts specified.
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 1 items
  -- * Must have a minimum of 0 items
  , migrateShelleyWalletResponseBody202Collateral_outputs :: (GHC.Maybe.Maybe ([MigrateShelleyWalletResponseBody202Collateral_outputs]))
  -- | deposit_returned: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , migrateShelleyWalletResponseBody202Deposit_returned :: MigrateShelleyWalletResponseBody202Deposit_returned
  -- | deposit_taken: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , migrateShelleyWalletResponseBody202Deposit_taken :: MigrateShelleyWalletResponseBody202Deposit_taken
  -- | depth: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Current depth of the transaction in the local chain
  , migrateShelleyWalletResponseBody202Depth :: (GHC.Maybe.Maybe MigrateShelleyWalletResponseBody202Depth)
  -- | direction
  , migrateShelleyWalletResponseBody202Direction :: MigrateShelleyWalletResponseBody202Direction
  -- | expires_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending OR status == expired
  -- \<\/span>\<br\/>
  -- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
  , migrateShelleyWalletResponseBody202Expires_at :: (GHC.Maybe.Maybe MigrateShelleyWalletResponseBody202Expires_at)
  -- | extra_signatures
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , migrateShelleyWalletResponseBody202Extra_signatures :: (GHC.Maybe.Maybe ([Data.Text.Internal.Text]))
  -- | fee: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , migrateShelleyWalletResponseBody202Fee :: MigrateShelleyWalletResponseBody202Fee
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , migrateShelleyWalletResponseBody202Id :: Data.Text.Internal.Text
  -- | inputs: A list of transaction inputs.
  -- 
  -- \`assets\` and \`address\` are always present for \`outgoing\`
  -- transactions but generally absent for \`incoming\`
  -- transactions. This information is present on the Cardano explorer,
  -- but is not tracked by the wallet.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , migrateShelleyWalletResponseBody202Inputs :: ([MigrateShelleyWalletResponseBody202Inputs])
  -- | inserted_at: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == in_ledger
  -- \<\/span>\<br\/>
  -- Absolute time at which the transaction was inserted in a block.
  , migrateShelleyWalletResponseBody202Inserted_at :: (GHC.Maybe.Maybe MigrateShelleyWalletResponseBody202Inserted_at)
  -- | metadata: **⚠️ WARNING ⚠️**
  -- 
  -- _Please note that metadata provided in a transaction will be
  -- stored on the blockchain forever. Make sure not to include any sensitive data,
  -- in particular personally identifiable information (PII)._
  -- 
  -- Extra application data attached to the transaction.
  -- 
  -- Cardano allows users and developers to embed their own
  -- authenticated metadata when submitting transactions. Metadata can
  -- be expressed as a JSON object with some restrictions:
  -- 
  -- 1. All top-level keys must be integers between \`0\` and \`2^64 - 1\`.
  -- 
  -- 2. Each metadata value is tagged with its type.
  -- 
  -- 3. Strings must be at most 64 bytes when UTF-8 encoded.
  -- 
  -- 4. Bytestrings are hex-encoded, with a maximum length of 64 bytes.
  -- 
  -- Metadata aren\'t stored as JSON on the Cardano blockchain but are
  -- instead stored using a compact binary encoding (CBOR).
  -- 
  -- The binary encoding of metadata values supports three simple types:
  -- 
  -- * Integers in the range \`-(2^64 - 1)\` to \`2^64 - 1\`
  -- * Strings (UTF-8 encoded)
  -- * Bytestrings
  -- 
  -- And two compound types:
  -- 
  -- * Lists of metadata values
  -- * Mappings from metadata values to metadata values
  -- 
  -- It is possible to transform any JSON object into this schema.
  -- 
  -- However, if your application uses floating point values, they will
  -- need to be converted somehow, according to your
  -- requirements. Likewise for \`null\` or \`bool\` values. When reading
  -- metadata from chain, be aware that integers may exceed the
  -- javascript numeric range, and may need special \"bigint\" parsing.
  , migrateShelleyWalletResponseBody202Metadata :: (GHC.Maybe.Maybe Data.Aeson.Types.Internal.Object)
  -- | mint
  , migrateShelleyWalletResponseBody202Mint :: (GHC.Maybe.Maybe MigrateShelleyWalletResponseBody202Mint)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , migrateShelleyWalletResponseBody202Outputs :: ([MigrateShelleyWalletResponseBody202Outputs])
  -- | pending_since: \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
  -- \<strong>if:\<\/strong> status == pending
  -- \<\/span>\<br\/>
  -- The point in time at which a transaction became pending.
  , migrateShelleyWalletResponseBody202Pending_since :: (GHC.Maybe.Maybe MigrateShelleyWalletResponseBody202Pending_since)
  -- | script_integrity: A script data integrity hash - 32 bytes
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^(script_data)1[0-9a-z]*\$\'
  , migrateShelleyWalletResponseBody202Script_integrity :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | script_validity: Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
  -- used in the transaction validated or not. Validity may be null if this
  -- transaction was from an era that doesn\'t support phase-2 monetary policy
  -- scripts, or is a pending transaction (we don\'t know if validation passed or
  -- failed until the transaction hits the ledger).
  , migrateShelleyWalletResponseBody202Script_validity :: (GHC.Maybe.Maybe (Wallet.Common.Nullable MigrateShelleyWalletResponseBody202Script_validityNonNullable))
  -- | status: Current transaction status.
  -- 
  --   \`\`\`
  --        *-----------*
  --   ---> |  PENDING  |----------------*
  --        *-----------*                |
  --              |                      |
  --              V                      V
  --        *-----------*          *-----------*
  --        |           |---------->  EXPIRED  |
  --        |           |  (ttl)   *-----------*
  --        | SUBMITTED |
  --        |           \<----------------*
  --        |           |                |
  --        *-----------*           (rollback)
  --               |                     |
  --          (in ledger)          *-----------*
  --               |               |           |
  --               *---------------> IN_LEDGER |
  --                               |           |
  --                               *-----------*
  --   \`\`\`
  , migrateShelleyWalletResponseBody202Status :: MigrateShelleyWalletResponseBody202Status
  -- | validity_interval
  , migrateShelleyWalletResponseBody202Validity_interval :: (GHC.Maybe.Maybe MigrateShelleyWalletResponseBody202Validity_interval)
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , migrateShelleyWalletResponseBody202Withdrawals :: ([MigrateShelleyWalletResponseBody202Withdrawals])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Fee obj] : ["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Withdrawals obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Amount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("burn" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Burn obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Certificates obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Collateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral_outputs" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Collateral_outputs obj) : ["deposit_returned" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Deposit_returned obj] : ["deposit_taken" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Deposit_taken obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("depth" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Depth obj) : ["direction" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Direction obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("expires_at" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Expires_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("extra_signatures" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Extra_signatures obj) : ["fee" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Fee obj] : ["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Id obj] : ["inputs" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Inputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("inserted_at" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Inserted_at obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Metadata obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("mint" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Mint obj) : ["outputs" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Outputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pending_since" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Pending_since obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_integrity" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Script_integrity obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("script_validity" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Script_validity obj) : ["status" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Status obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("validity_interval" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Validity_interval obj) : ["withdrawals" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Withdrawals obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202" (\obj -> (((((((((((((((((((((((GHC.Base.pure MigrateShelleyWalletResponseBody202 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "burn")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral_outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "deposit_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "depth")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "direction")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "expires_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "extra_signatures")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fee")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "inserted_at")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "mint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pending_since")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_integrity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "script_validity")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "status")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "validity_interval")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "withdrawals"))
-- | Create a new 'MigrateShelleyWalletResponseBody202' with all required fields.
mkMigrateShelleyWalletResponseBody202 :: MigrateShelleyWalletResponseBody202Amount -- ^ 'migrateShelleyWalletResponseBody202Amount'
  -> MigrateShelleyWalletResponseBody202Deposit_returned -- ^ 'migrateShelleyWalletResponseBody202Deposit_returned'
  -> MigrateShelleyWalletResponseBody202Deposit_taken -- ^ 'migrateShelleyWalletResponseBody202Deposit_taken'
  -> MigrateShelleyWalletResponseBody202Direction -- ^ 'migrateShelleyWalletResponseBody202Direction'
  -> MigrateShelleyWalletResponseBody202Fee -- ^ 'migrateShelleyWalletResponseBody202Fee'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202Id'
  -> [MigrateShelleyWalletResponseBody202Inputs] -- ^ 'migrateShelleyWalletResponseBody202Inputs'
  -> [MigrateShelleyWalletResponseBody202Outputs] -- ^ 'migrateShelleyWalletResponseBody202Outputs'
  -> MigrateShelleyWalletResponseBody202Status -- ^ 'migrateShelleyWalletResponseBody202Status'
  -> [MigrateShelleyWalletResponseBody202Withdrawals] -- ^ 'migrateShelleyWalletResponseBody202Withdrawals'
  -> MigrateShelleyWalletResponseBody202
mkMigrateShelleyWalletResponseBody202 migrateShelleyWalletResponseBody202Amount migrateShelleyWalletResponseBody202Deposit_returned migrateShelleyWalletResponseBody202Deposit_taken migrateShelleyWalletResponseBody202Direction migrateShelleyWalletResponseBody202Fee migrateShelleyWalletResponseBody202Id migrateShelleyWalletResponseBody202Inputs migrateShelleyWalletResponseBody202Outputs migrateShelleyWalletResponseBody202Status migrateShelleyWalletResponseBody202Withdrawals = MigrateShelleyWalletResponseBody202{migrateShelleyWalletResponseBody202Amount = migrateShelleyWalletResponseBody202Amount,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Burn = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Certificates = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Collateral = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Collateral_outputs = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Deposit_returned = migrateShelleyWalletResponseBody202Deposit_returned,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Deposit_taken = migrateShelleyWalletResponseBody202Deposit_taken,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Depth = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Direction = migrateShelleyWalletResponseBody202Direction,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Expires_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Extra_signatures = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Fee = migrateShelleyWalletResponseBody202Fee,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Id = migrateShelleyWalletResponseBody202Id,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Inputs = migrateShelleyWalletResponseBody202Inputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Inserted_at = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Mint = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Outputs = migrateShelleyWalletResponseBody202Outputs,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Pending_since = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Script_integrity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Script_validity = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Status = migrateShelleyWalletResponseBody202Status,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Validity_interval = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202Withdrawals = migrateShelleyWalletResponseBody202Withdrawals}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.amount@ in the specification.
-- 
-- An amount of Ada spent or received, from the perspective of the wallet.
-- 
-- That is, for outgoing transaction, it represents the amount of Ada consumed
-- as inputs including the amount of Ada spent as fees or deposits.
-- 
-- For incoming transaction, it represents the total amount of Ada received to
-- addresses that belong to the wallet.
data MigrateShelleyWalletResponseBody202Amount = MigrateShelleyWalletResponseBody202Amount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202AmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Amount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202AmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Amount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Amount" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202Amount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Amount' with all required fields.
mkMigrateShelleyWalletResponseBody202Amount :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202AmountQuantity'
  -> MigrateShelleyWalletResponseBody202Amount
mkMigrateShelleyWalletResponseBody202Amount migrateShelleyWalletResponseBody202AmountQuantity = MigrateShelleyWalletResponseBody202Amount{migrateShelleyWalletResponseBody202AmountQuantity = migrateShelleyWalletResponseBody202AmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202Burn = MigrateShelleyWalletResponseBody202Burn {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  migrateShelleyWalletResponseBody202BurnTokens :: ([MigrateShelleyWalletResponseBody202BurnTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , migrateShelleyWalletResponseBody202BurnWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , migrateShelleyWalletResponseBody202BurnWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Burn
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202BurnWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202BurnWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202BurnWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Burn
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Burn" (\obj -> ((GHC.Base.pure MigrateShelleyWalletResponseBody202Burn GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Burn' with all required fields.
mkMigrateShelleyWalletResponseBody202Burn :: [MigrateShelleyWalletResponseBody202BurnTokens] -- ^ 'migrateShelleyWalletResponseBody202BurnTokens'
  -> MigrateShelleyWalletResponseBody202Burn
mkMigrateShelleyWalletResponseBody202Burn migrateShelleyWalletResponseBody202BurnTokens = MigrateShelleyWalletResponseBody202Burn{migrateShelleyWalletResponseBody202BurnTokens = migrateShelleyWalletResponseBody202BurnTokens,
                                                                                                                                  migrateShelleyWalletResponseBody202BurnWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                                  migrateShelleyWalletResponseBody202BurnWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202BurnTokens = MigrateShelleyWalletResponseBody202BurnTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateShelleyWalletResponseBody202BurnTokensAssets :: ([MigrateShelleyWalletResponseBody202BurnTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateShelleyWalletResponseBody202BurnTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , migrateShelleyWalletResponseBody202BurnTokensPolicy_script :: MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202BurnTokens" (\obj -> ((GHC.Base.pure MigrateShelleyWalletResponseBody202BurnTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'MigrateShelleyWalletResponseBody202BurnTokens' with all required fields.
mkMigrateShelleyWalletResponseBody202BurnTokens :: [MigrateShelleyWalletResponseBody202BurnTokensAssets] -- ^ 'migrateShelleyWalletResponseBody202BurnTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_id'
  -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptVariants -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_script'
  -> MigrateShelleyWalletResponseBody202BurnTokens
mkMigrateShelleyWalletResponseBody202BurnTokens migrateShelleyWalletResponseBody202BurnTokensAssets migrateShelleyWalletResponseBody202BurnTokensPolicy_id migrateShelleyWalletResponseBody202BurnTokensPolicy_script = MigrateShelleyWalletResponseBody202BurnTokens{migrateShelleyWalletResponseBody202BurnTokensAssets = migrateShelleyWalletResponseBody202BurnTokensAssets,
                                                                                                                                                                                                                                                                      migrateShelleyWalletResponseBody202BurnTokensPolicy_id = migrateShelleyWalletResponseBody202BurnTokensPolicy_id,
                                                                                                                                                                                                                                                                      migrateShelleyWalletResponseBody202BurnTokensPolicy_script = migrateShelleyWalletResponseBody202BurnTokensPolicy_script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202BurnTokensAssets = MigrateShelleyWalletResponseBody202BurnTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  migrateShelleyWalletResponseBody202BurnTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , migrateShelleyWalletResponseBody202BurnTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202BurnTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202BurnTokensAssets" (\obj -> ((GHC.Base.pure MigrateShelleyWalletResponseBody202BurnTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202BurnTokensAssets' with all required fields.
mkMigrateShelleyWalletResponseBody202BurnTokensAssets :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202BurnTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202BurnTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202BurnTokensAssetsQuantity'
  -> MigrateShelleyWalletResponseBody202BurnTokensAssets
mkMigrateShelleyWalletResponseBody202BurnTokensAssets migrateShelleyWalletResponseBody202BurnTokensAssetsAsset_name migrateShelleyWalletResponseBody202BurnTokensAssetsFingerprint migrateShelleyWalletResponseBody202BurnTokensAssetsQuantity = MigrateShelleyWalletResponseBody202BurnTokensAssets{migrateShelleyWalletResponseBody202BurnTokensAssetsAsset_name = migrateShelleyWalletResponseBody202BurnTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                                     migrateShelleyWalletResponseBody202BurnTokensAssetsFingerprint = migrateShelleyWalletResponseBody202BurnTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                                     migrateShelleyWalletResponseBody202BurnTokensAssetsQuantity = migrateShelleyWalletResponseBody202BurnTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1 = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference)
  -- | script
  , migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Script :: MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1' with all required fields.
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1 :: MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Script'
  -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1 migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Script = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1{migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                             migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Script = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference' with all required fields.
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex'
  -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1Reference{migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2 migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2{migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3 migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3{migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 :: MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4 migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4{migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4Some{migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                                    migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5 migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5{migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6 migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6{migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants =
   MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf2
  | MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf3
  | MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf4
  | MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf5
  | MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2 = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info :: MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2' with all required fields.
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2 :: MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info'
  -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2 migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2{migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                                  migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference' with all required fields.
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex'
  -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Reference{migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version :: MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info :: MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_info{migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                                               migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3 = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References :: ([MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3' with all required fields.
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3 :: [MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References] -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash'
  -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3 migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3{migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                                             migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References' with all required fields.
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex'
  -> MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References
mkMigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex = MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3References{migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                                       migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex = migrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.burn.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptVariants =
   MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptVariant1 MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf1
  | MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptVariant2 MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf2
  | MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptVariant3 MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptVariants
    where toJSON (MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptVariants
    where parseJSON val = case (MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202BurnTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data MigrateShelleyWalletResponseBody202CertificatesOneOf1 = MigrateShelleyWalletResponseBody202CertificatesOneOf1 {
  -- | certificate_type
  migrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_type :: MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_type
  -- | pool: A unique identifier for the pool.
  , migrateShelleyWalletResponseBody202CertificatesOneOf1Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , migrateShelleyWalletResponseBody202CertificatesOneOf1Reward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202CertificatesOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202CertificatesOneOf1Pool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf1Reward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202CertificatesOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202CertificatesOneOf1" (\obj -> ((GHC.Base.pure MigrateShelleyWalletResponseBody202CertificatesOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'MigrateShelleyWalletResponseBody202CertificatesOneOf1' with all required fields.
mkMigrateShelleyWalletResponseBody202CertificatesOneOf1 :: MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_type -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf1Reward_account_path'
  -> MigrateShelleyWalletResponseBody202CertificatesOneOf1
mkMigrateShelleyWalletResponseBody202CertificatesOneOf1 migrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_type migrateShelleyWalletResponseBody202CertificatesOneOf1Reward_account_path = MigrateShelleyWalletResponseBody202CertificatesOneOf1{migrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_type = migrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_type,
                                                                                                                                                                                                                                                               migrateShelleyWalletResponseBody202CertificatesOneOf1Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                               migrateShelleyWalletResponseBody202CertificatesOneOf1Reward_account_path = migrateShelleyWalletResponseBody202CertificatesOneOf1Reward_account_path}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_type =
   MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_type
    where toJSON (MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_typeOther val) = val
          toJSON (MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool) = "join_pool"
          toJSON (MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> MigrateShelleyWalletResponseBody202CertificatesOneOf1Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- A delegation certificate not belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data MigrateShelleyWalletResponseBody202CertificatesOneOf2 = MigrateShelleyWalletResponseBody202CertificatesOneOf2 {
  -- | certificate_type
  migrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_type :: MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_type
  -- | pool: A unique identifier for the pool.
  , migrateShelleyWalletResponseBody202CertificatesOneOf2Pool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account
  , migrateShelleyWalletResponseBody202CertificatesOneOf2Reward_account :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202CertificatesOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf2Reward_account obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202CertificatesOneOf2Pool obj) : ["reward_account" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf2Reward_account obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202CertificatesOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202CertificatesOneOf2" (\obj -> ((GHC.Base.pure MigrateShelleyWalletResponseBody202CertificatesOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account"))
-- | Create a new 'MigrateShelleyWalletResponseBody202CertificatesOneOf2' with all required fields.
mkMigrateShelleyWalletResponseBody202CertificatesOneOf2 :: MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_type -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_type'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf2Reward_account'
  -> MigrateShelleyWalletResponseBody202CertificatesOneOf2
mkMigrateShelleyWalletResponseBody202CertificatesOneOf2 migrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_type migrateShelleyWalletResponseBody202CertificatesOneOf2Reward_account = MigrateShelleyWalletResponseBody202CertificatesOneOf2{migrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_type = migrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_type,
                                                                                                                                                                                                                                                          migrateShelleyWalletResponseBody202CertificatesOneOf2Pool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                          migrateShelleyWalletResponseBody202CertificatesOneOf2Reward_account = migrateShelleyWalletResponseBody202CertificatesOneOf2Reward_account}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_type =
   MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external -- ^ Represents the JSON value @"join_pool_external"@
  | MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external -- ^ Represents the JSON value @"quit_pool_external"@
  | MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external -- ^ Represents the JSON value @"register_reward_account_external"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_type
    where toJSON (MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_typeOther val) = val
          toJSON (MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external) = "join_pool_external"
          toJSON (MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external) = "quit_pool_external"
          toJSON (MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external) = "register_reward_account_external"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool_external" -> MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_typeEnumJoin_pool_external
                                            | val GHC.Classes.== "quit_pool_external" -> MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_typeEnumQuit_pool_external
                                            | val GHC.Classes.== "register_reward_account_external" -> MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_typeEnumRegister_reward_account_external
                                            | GHC.Base.otherwise -> MigrateShelleyWalletResponseBody202CertificatesOneOf2Certificate_typeOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202CertificatesOneOf3 = MigrateShelleyWalletResponseBody202CertificatesOneOf3 {
  -- | pool_cost: Estimated cost set by the pool operator when registering his pool.
  -- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost :: MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost
  -- | pool_id: A unique identifier for the pool.
  , migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_id :: Data.Text.Internal.Text
  -- | pool_margin: Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin :: MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin
  -- | pool_metadata
  , migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata :: (GHC.Maybe.Maybe MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata)
  -- | pool_owners
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_owners :: ([Data.Text.Internal.Text])
  -- | pool_pledge: Minimal stake amount that a stake pool is willing to honor.
  -- 
  -- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
  , migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge :: MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202CertificatesOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_cost" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost obj] : ["pool_id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_id obj] : ["pool_margin" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool_metadata" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata obj) : ["pool_owners" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_owners obj] : ["pool_pledge" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "register_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202CertificatesOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202CertificatesOneOf3" (\obj -> (((((GHC.Base.pure MigrateShelleyWalletResponseBody202CertificatesOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_cost")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_margin")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool_metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_owners")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_pledge"))
-- | Create a new 'MigrateShelleyWalletResponseBody202CertificatesOneOf3' with all required fields.
mkMigrateShelleyWalletResponseBody202CertificatesOneOf3 :: MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_id'
  -> MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin'
  -> [Data.Text.Internal.Text] -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_owners'
  -> MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge'
  -> MigrateShelleyWalletResponseBody202CertificatesOneOf3
mkMigrateShelleyWalletResponseBody202CertificatesOneOf3 migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_id migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_owners migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge = MigrateShelleyWalletResponseBody202CertificatesOneOf3{migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost = migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost,
                                                                                                                                                                                                                                                                                                                                                                                                                                               migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_id = migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_id,
                                                                                                                                                                                                                                                                                                                                                                                                                                               migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin = migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin,
                                                                                                                                                                                                                                                                                                                                                                                                                                               migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                               migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_owners = migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_owners,
                                                                                                                                                                                                                                                                                                                                                                                                                                               migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge = migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_cost@ in the specification.
-- 
-- Estimated cost set by the pool operator when registering his pool.
-- This fixed cost is taken from each reward earned by the pool before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost = MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_costQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_costQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost' with all required fields.
mkMigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_costQuantity'
  -> MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost
mkMigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_costQuantity = MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_cost{migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_costQuantity = migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_costQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_margin@ in the specification.
-- 
-- Variable margin on the total reward given to an operator before splitting rewards between stakeholders.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin = MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 100.0
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_marginQuantity :: GHC.Types.Double
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_marginQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "percent"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin' with all required fields.
mkMigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin :: GHC.Types.Double -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_marginQuantity'
  -> MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin
mkMigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_marginQuantity = MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_margin{migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_marginQuantity = migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_marginQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_metadata@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata = MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata {
  -- | hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadataHash :: Data.Text.Internal.Text
  -- | url: A URL to the stake pool\'s website.
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 250
  -- * Must match pattern \'^https:\/\/.+\'
  , migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadataUrl :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["hash" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadataHash obj] : ["url" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadataUrl obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "url"))
-- | Create a new 'MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata' with all required fields.
mkMigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadataHash'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadataUrl'
  -> MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata
mkMigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadataHash migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadataUrl = MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadata{migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadataHash = migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadataHash,
                                                                                                                                                                                                                                                                                       migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadataUrl = migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_metadataUrl}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.pool_pledge@ in the specification.
-- 
-- Minimal stake amount that a stake pool is willing to honor.
-- 
-- May be omitted if the wallet hasn\'t found the pool\'s registration cerificate yet.
data MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge = MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledgeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledgeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge' with all required fields.
mkMigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledgeQuantity'
  -> MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge
mkMigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledgeQuantity = MigrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledge{migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledgeQuantity = migrateShelleyWalletResponseBody202CertificatesOneOf3Pool_pledgeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202CertificatesOneOf4 = MigrateShelleyWalletResponseBody202CertificatesOneOf4 {
  -- | pool_id: A unique identifier for the pool.
  migrateShelleyWalletResponseBody202CertificatesOneOf4Pool_id :: Data.Text.Internal.Text
  -- | retirement_epoch: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202CertificatesOneOf4Retirement_epoch :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202CertificatesOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["pool_id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf4Pool_id obj] : ["retirement_epoch" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf4Retirement_epoch obj] : ["certificate_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "deregister_pool"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202CertificatesOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202CertificatesOneOf4" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202CertificatesOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "pool_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "retirement_epoch"))
-- | Create a new 'MigrateShelleyWalletResponseBody202CertificatesOneOf4' with all required fields.
mkMigrateShelleyWalletResponseBody202CertificatesOneOf4 :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf4Pool_id'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf4Retirement_epoch'
  -> MigrateShelleyWalletResponseBody202CertificatesOneOf4
mkMigrateShelleyWalletResponseBody202CertificatesOneOf4 migrateShelleyWalletResponseBody202CertificatesOneOf4Pool_id migrateShelleyWalletResponseBody202CertificatesOneOf4Retirement_epoch = MigrateShelleyWalletResponseBody202CertificatesOneOf4{migrateShelleyWalletResponseBody202CertificatesOneOf4Pool_id = migrateShelleyWalletResponseBody202CertificatesOneOf4Pool_id,
                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202CertificatesOneOf4Retirement_epoch = migrateShelleyWalletResponseBody202CertificatesOneOf4Retirement_epoch}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202CertificatesOneOf5 = MigrateShelleyWalletResponseBody202CertificatesOneOf5 {
  -- | certificate_type
  migrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_type :: MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_type
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202CertificatesOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_type obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202CertificatesOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202CertificatesOneOf5" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202CertificatesOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type"))
-- | Create a new 'MigrateShelleyWalletResponseBody202CertificatesOneOf5' with all required fields.
mkMigrateShelleyWalletResponseBody202CertificatesOneOf5 :: MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_type -- ^ 'migrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_type'
  -> MigrateShelleyWalletResponseBody202CertificatesOneOf5
mkMigrateShelleyWalletResponseBody202CertificatesOneOf5 migrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_type = MigrateShelleyWalletResponseBody202CertificatesOneOf5{migrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_type = migrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_type}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf.properties.certificate_type@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_type =
   MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_typeEnumMir -- ^ Represents the JSON value @"mir"@
  | MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis -- ^ Represents the JSON value @"genesis"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_type
    where toJSON (MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_typeOther val) = val
          toJSON (MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_typeEnumMir) = "mir"
          toJSON (MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis) = "genesis"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "mir" -> MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_typeEnumMir
                                            | val GHC.Classes.== "genesis" -> MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_typeEnumGenesis
                                            | GHC.Base.otherwise -> MigrateShelleyWalletResponseBody202CertificatesOneOf5Certificate_typeOther val)
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.certificates.items.oneOf@ in the specification.
-- 
-- Any certificate that could occur in an arbitrary transaction:
-- might be related to delegation, pool activities, genesis or MIR.
data MigrateShelleyWalletResponseBody202CertificatesVariants =
   MigrateShelleyWalletResponseBody202CertificatesVariant1 MigrateShelleyWalletResponseBody202CertificatesOneOf1
  | MigrateShelleyWalletResponseBody202CertificatesVariant2 MigrateShelleyWalletResponseBody202CertificatesOneOf2
  | MigrateShelleyWalletResponseBody202CertificatesVariant3 MigrateShelleyWalletResponseBody202CertificatesOneOf3
  | MigrateShelleyWalletResponseBody202CertificatesVariant4 MigrateShelleyWalletResponseBody202CertificatesOneOf4
  | MigrateShelleyWalletResponseBody202CertificatesVariant5 MigrateShelleyWalletResponseBody202CertificatesOneOf5
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202CertificatesVariants
    where toJSON (MigrateShelleyWalletResponseBody202CertificatesVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202CertificatesVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202CertificatesVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202CertificatesVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202CertificatesVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202CertificatesVariants
    where parseJSON val = case (MigrateShelleyWalletResponseBody202CertificatesVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202CertificatesVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202CertificatesVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202CertificatesVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202CertificatesVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.collateral.items@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202Collateral = MigrateShelleyWalletResponseBody202Collateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  migrateShelleyWalletResponseBody202CollateralAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , migrateShelleyWalletResponseBody202CollateralAmount :: (GHC.Maybe.Maybe MigrateShelleyWalletResponseBody202CollateralAmount)
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , migrateShelleyWalletResponseBody202CollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202CollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Collateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202CollateralAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202CollateralAmount obj) : ["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Collateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Collateral" (\obj -> (((GHC.Base.pure MigrateShelleyWalletResponseBody202Collateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Collateral' with all required fields.
mkMigrateShelleyWalletResponseBody202Collateral :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202CollateralId'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202CollateralIndex'
  -> MigrateShelleyWalletResponseBody202Collateral
mkMigrateShelleyWalletResponseBody202Collateral migrateShelleyWalletResponseBody202CollateralId migrateShelleyWalletResponseBody202CollateralIndex = MigrateShelleyWalletResponseBody202Collateral{migrateShelleyWalletResponseBody202CollateralAddress = GHC.Maybe.Nothing,
                                                                                                                                                                                                   migrateShelleyWalletResponseBody202CollateralAmount = GHC.Maybe.Nothing,
                                                                                                                                                                                                   migrateShelleyWalletResponseBody202CollateralId = migrateShelleyWalletResponseBody202CollateralId,
                                                                                                                                                                                                   migrateShelleyWalletResponseBody202CollateralIndex = migrateShelleyWalletResponseBody202CollateralIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateShelleyWalletResponseBody202CollateralAmount = MigrateShelleyWalletResponseBody202CollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202CollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202CollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202CollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202CollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202CollateralAmount" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202CollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202CollateralAmount' with all required fields.
mkMigrateShelleyWalletResponseBody202CollateralAmount :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202CollateralAmountQuantity'
  -> MigrateShelleyWalletResponseBody202CollateralAmount
mkMigrateShelleyWalletResponseBody202CollateralAmount migrateShelleyWalletResponseBody202CollateralAmountQuantity = MigrateShelleyWalletResponseBody202CollateralAmount{migrateShelleyWalletResponseBody202CollateralAmountQuantity = migrateShelleyWalletResponseBody202CollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.collateral_outputs.items@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202Collateral_outputs = MigrateShelleyWalletResponseBody202Collateral_outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  migrateShelleyWalletResponseBody202Collateral_outputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , migrateShelleyWalletResponseBody202Collateral_outputsAmount :: MigrateShelleyWalletResponseBody202Collateral_outputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , migrateShelleyWalletResponseBody202Collateral_outputsAssets :: (GHC.Maybe.Maybe ([MigrateShelleyWalletResponseBody202Collateral_outputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Collateral_outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Collateral_outputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Collateral_outputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Collateral_outputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202Collateral_outputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Collateral_outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Collateral_outputs" (\obj -> ((GHC.Base.pure MigrateShelleyWalletResponseBody202Collateral_outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Collateral_outputs' with all required fields.
mkMigrateShelleyWalletResponseBody202Collateral_outputs :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202Collateral_outputsAddress'
  -> MigrateShelleyWalletResponseBody202Collateral_outputsAmount -- ^ 'migrateShelleyWalletResponseBody202Collateral_outputsAmount'
  -> MigrateShelleyWalletResponseBody202Collateral_outputs
mkMigrateShelleyWalletResponseBody202Collateral_outputs migrateShelleyWalletResponseBody202Collateral_outputsAddress migrateShelleyWalletResponseBody202Collateral_outputsAmount = MigrateShelleyWalletResponseBody202Collateral_outputs{migrateShelleyWalletResponseBody202Collateral_outputsAddress = migrateShelleyWalletResponseBody202Collateral_outputsAddress,
                                                                                                                                                                                                                                         migrateShelleyWalletResponseBody202Collateral_outputsAmount = migrateShelleyWalletResponseBody202Collateral_outputsAmount,
                                                                                                                                                                                                                                         migrateShelleyWalletResponseBody202Collateral_outputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.collateral_outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateShelleyWalletResponseBody202Collateral_outputsAmount = MigrateShelleyWalletResponseBody202Collateral_outputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202Collateral_outputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Collateral_outputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Collateral_outputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Collateral_outputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Collateral_outputsAmount" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202Collateral_outputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Collateral_outputsAmount' with all required fields.
mkMigrateShelleyWalletResponseBody202Collateral_outputsAmount :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Collateral_outputsAmountQuantity'
  -> MigrateShelleyWalletResponseBody202Collateral_outputsAmount
mkMigrateShelleyWalletResponseBody202Collateral_outputsAmount migrateShelleyWalletResponseBody202Collateral_outputsAmountQuantity = MigrateShelleyWalletResponseBody202Collateral_outputsAmount{migrateShelleyWalletResponseBody202Collateral_outputsAmountQuantity = migrateShelleyWalletResponseBody202Collateral_outputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.collateral_outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data MigrateShelleyWalletResponseBody202Collateral_outputsAssets = MigrateShelleyWalletResponseBody202Collateral_outputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  migrateShelleyWalletResponseBody202Collateral_outputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateShelleyWalletResponseBody202Collateral_outputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202Collateral_outputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Collateral_outputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Collateral_outputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Collateral_outputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Collateral_outputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Collateral_outputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Collateral_outputsAssets" (\obj -> ((GHC.Base.pure MigrateShelleyWalletResponseBody202Collateral_outputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Collateral_outputsAssets' with all required fields.
mkMigrateShelleyWalletResponseBody202Collateral_outputsAssets :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202Collateral_outputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202Collateral_outputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Collateral_outputsAssetsQuantity'
  -> MigrateShelleyWalletResponseBody202Collateral_outputsAssets
mkMigrateShelleyWalletResponseBody202Collateral_outputsAssets migrateShelleyWalletResponseBody202Collateral_outputsAssetsAsset_name migrateShelleyWalletResponseBody202Collateral_outputsAssetsPolicy_id migrateShelleyWalletResponseBody202Collateral_outputsAssetsQuantity = MigrateShelleyWalletResponseBody202Collateral_outputsAssets{migrateShelleyWalletResponseBody202Collateral_outputsAssetsAsset_name = migrateShelleyWalletResponseBody202Collateral_outputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                           migrateShelleyWalletResponseBody202Collateral_outputsAssetsPolicy_id = migrateShelleyWalletResponseBody202Collateral_outputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                           migrateShelleyWalletResponseBody202Collateral_outputsAssetsQuantity = migrateShelleyWalletResponseBody202Collateral_outputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.deposit_returned@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateShelleyWalletResponseBody202Deposit_returned = MigrateShelleyWalletResponseBody202Deposit_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202Deposit_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Deposit_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Deposit_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Deposit_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Deposit_returned" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202Deposit_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Deposit_returned' with all required fields.
mkMigrateShelleyWalletResponseBody202Deposit_returned :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Deposit_returnedQuantity'
  -> MigrateShelleyWalletResponseBody202Deposit_returned
mkMigrateShelleyWalletResponseBody202Deposit_returned migrateShelleyWalletResponseBody202Deposit_returnedQuantity = MigrateShelleyWalletResponseBody202Deposit_returned{migrateShelleyWalletResponseBody202Deposit_returnedQuantity = migrateShelleyWalletResponseBody202Deposit_returnedQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.deposit_taken@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateShelleyWalletResponseBody202Deposit_taken = MigrateShelleyWalletResponseBody202Deposit_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202Deposit_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Deposit_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Deposit_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Deposit_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Deposit_taken" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202Deposit_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Deposit_taken' with all required fields.
mkMigrateShelleyWalletResponseBody202Deposit_taken :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Deposit_takenQuantity'
  -> MigrateShelleyWalletResponseBody202Deposit_taken
mkMigrateShelleyWalletResponseBody202Deposit_taken migrateShelleyWalletResponseBody202Deposit_takenQuantity = MigrateShelleyWalletResponseBody202Deposit_taken{migrateShelleyWalletResponseBody202Deposit_takenQuantity = migrateShelleyWalletResponseBody202Deposit_takenQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.depth@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Current depth of the transaction in the local chain
data MigrateShelleyWalletResponseBody202Depth = MigrateShelleyWalletResponseBody202Depth {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202DepthQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Depth
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202DepthQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Depth
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Depth" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202Depth GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Depth' with all required fields.
mkMigrateShelleyWalletResponseBody202Depth :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202DepthQuantity'
  -> MigrateShelleyWalletResponseBody202Depth
mkMigrateShelleyWalletResponseBody202Depth migrateShelleyWalletResponseBody202DepthQuantity = MigrateShelleyWalletResponseBody202Depth{migrateShelleyWalletResponseBody202DepthQuantity = migrateShelleyWalletResponseBody202DepthQuantity}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.direction@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202Direction =
   MigrateShelleyWalletResponseBody202DirectionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateShelleyWalletResponseBody202DirectionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateShelleyWalletResponseBody202DirectionEnumOutgoing -- ^ Represents the JSON value @"outgoing"@
  | MigrateShelleyWalletResponseBody202DirectionEnumIncoming -- ^ Represents the JSON value @"incoming"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Direction
    where toJSON (MigrateShelleyWalletResponseBody202DirectionOther val) = val
          toJSON (MigrateShelleyWalletResponseBody202DirectionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateShelleyWalletResponseBody202DirectionEnumOutgoing) = "outgoing"
          toJSON (MigrateShelleyWalletResponseBody202DirectionEnumIncoming) = "incoming"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Direction
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "outgoing" -> MigrateShelleyWalletResponseBody202DirectionEnumOutgoing
                                            | val GHC.Classes.== "incoming" -> MigrateShelleyWalletResponseBody202DirectionEnumIncoming
                                            | GHC.Base.otherwise -> MigrateShelleyWalletResponseBody202DirectionOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.expires_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending OR status == expired
-- \<\/span>\<br\/>
-- Absolute time and slot at which the pending transaction TTL (time to live) will lapse.
data MigrateShelleyWalletResponseBody202Expires_at = MigrateShelleyWalletResponseBody202Expires_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202Expires_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202Expires_atEpoch_number :: GHC.Types.Int
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202Expires_atSlot_number :: GHC.Types.Int
  -- | time
  , migrateShelleyWalletResponseBody202Expires_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Expires_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Expires_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Expires_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Expires_atEpoch_number obj] : ["slot_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Expires_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Expires_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Expires_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Expires_at" (\obj -> (((GHC.Base.pure MigrateShelleyWalletResponseBody202Expires_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Expires_at' with all required fields.
mkMigrateShelleyWalletResponseBody202Expires_at :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Expires_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Expires_atEpoch_number'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Expires_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202Expires_atTime'
  -> MigrateShelleyWalletResponseBody202Expires_at
mkMigrateShelleyWalletResponseBody202Expires_at migrateShelleyWalletResponseBody202Expires_atAbsolute_slot_number migrateShelleyWalletResponseBody202Expires_atEpoch_number migrateShelleyWalletResponseBody202Expires_atSlot_number migrateShelleyWalletResponseBody202Expires_atTime = MigrateShelleyWalletResponseBody202Expires_at{migrateShelleyWalletResponseBody202Expires_atAbsolute_slot_number = migrateShelleyWalletResponseBody202Expires_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                       migrateShelleyWalletResponseBody202Expires_atEpoch_number = migrateShelleyWalletResponseBody202Expires_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                       migrateShelleyWalletResponseBody202Expires_atSlot_number = migrateShelleyWalletResponseBody202Expires_atSlot_number,
                                                                                                                                                                                                                                                                                                                                       migrateShelleyWalletResponseBody202Expires_atTime = migrateShelleyWalletResponseBody202Expires_atTime}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.fee@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateShelleyWalletResponseBody202Fee = MigrateShelleyWalletResponseBody202Fee {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202FeeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Fee
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202FeeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Fee
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Fee" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202Fee GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Fee' with all required fields.
mkMigrateShelleyWalletResponseBody202Fee :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202FeeQuantity'
  -> MigrateShelleyWalletResponseBody202Fee
mkMigrateShelleyWalletResponseBody202Fee migrateShelleyWalletResponseBody202FeeQuantity = MigrateShelleyWalletResponseBody202Fee{migrateShelleyWalletResponseBody202FeeQuantity = migrateShelleyWalletResponseBody202FeeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.inputs.items@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202Inputs = MigrateShelleyWalletResponseBody202Inputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  migrateShelleyWalletResponseBody202InputsAddress :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , migrateShelleyWalletResponseBody202InputsAmount :: (GHC.Maybe.Maybe MigrateShelleyWalletResponseBody202InputsAmount)
  -- | assets: A flat list of assets (possibly empty).
  , migrateShelleyWalletResponseBody202InputsAssets :: (GHC.Maybe.Maybe ([MigrateShelleyWalletResponseBody202InputsAssets]))
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , migrateShelleyWalletResponseBody202InputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202InputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Inputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202InputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("address" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202InputsAddress obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("amount" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202InputsAmount obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202InputsAssets obj) : ["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202InputsId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202InputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Inputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Inputs" (\obj -> ((((GHC.Base.pure MigrateShelleyWalletResponseBody202Inputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Inputs' with all required fields.
mkMigrateShelleyWalletResponseBody202Inputs :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202InputsId'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202InputsIndex'
  -> MigrateShelleyWalletResponseBody202Inputs
mkMigrateShelleyWalletResponseBody202Inputs migrateShelleyWalletResponseBody202InputsId migrateShelleyWalletResponseBody202InputsIndex = MigrateShelleyWalletResponseBody202Inputs{migrateShelleyWalletResponseBody202InputsAddress = GHC.Maybe.Nothing,
                                                                                                                                                                                   migrateShelleyWalletResponseBody202InputsAmount = GHC.Maybe.Nothing,
                                                                                                                                                                                   migrateShelleyWalletResponseBody202InputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                                                   migrateShelleyWalletResponseBody202InputsId = migrateShelleyWalletResponseBody202InputsId,
                                                                                                                                                                                   migrateShelleyWalletResponseBody202InputsIndex = migrateShelleyWalletResponseBody202InputsIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateShelleyWalletResponseBody202InputsAmount = MigrateShelleyWalletResponseBody202InputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202InputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202InputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202InputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202InputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202InputsAmount" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202InputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202InputsAmount' with all required fields.
mkMigrateShelleyWalletResponseBody202InputsAmount :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202InputsAmountQuantity'
  -> MigrateShelleyWalletResponseBody202InputsAmount
mkMigrateShelleyWalletResponseBody202InputsAmount migrateShelleyWalletResponseBody202InputsAmountQuantity = MigrateShelleyWalletResponseBody202InputsAmount{migrateShelleyWalletResponseBody202InputsAmountQuantity = migrateShelleyWalletResponseBody202InputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data MigrateShelleyWalletResponseBody202InputsAssets = MigrateShelleyWalletResponseBody202InputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  migrateShelleyWalletResponseBody202InputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateShelleyWalletResponseBody202InputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202InputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202InputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202InputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202InputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202InputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202InputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202InputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202InputsAssets" (\obj -> ((GHC.Base.pure MigrateShelleyWalletResponseBody202InputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202InputsAssets' with all required fields.
mkMigrateShelleyWalletResponseBody202InputsAssets :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202InputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202InputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202InputsAssetsQuantity'
  -> MigrateShelleyWalletResponseBody202InputsAssets
mkMigrateShelleyWalletResponseBody202InputsAssets migrateShelleyWalletResponseBody202InputsAssetsAsset_name migrateShelleyWalletResponseBody202InputsAssetsPolicy_id migrateShelleyWalletResponseBody202InputsAssetsQuantity = MigrateShelleyWalletResponseBody202InputsAssets{migrateShelleyWalletResponseBody202InputsAssetsAsset_name = migrateShelleyWalletResponseBody202InputsAssetsAsset_name,
                                                                                                                                                                                                                                                                               migrateShelleyWalletResponseBody202InputsAssetsPolicy_id = migrateShelleyWalletResponseBody202InputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                               migrateShelleyWalletResponseBody202InputsAssetsQuantity = migrateShelleyWalletResponseBody202InputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.inserted_at@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == in_ledger
-- \<\/span>\<br\/>
-- Absolute time at which the transaction was inserted in a block.
data MigrateShelleyWalletResponseBody202Inserted_at = MigrateShelleyWalletResponseBody202Inserted_at {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202Inserted_atAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202Inserted_atEpoch_number :: GHC.Types.Int
  -- | height
  , migrateShelleyWalletResponseBody202Inserted_atHeight :: MigrateShelleyWalletResponseBody202Inserted_atHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202Inserted_atSlot_number :: GHC.Types.Int
  -- | time
  , migrateShelleyWalletResponseBody202Inserted_atTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Inserted_at
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Inserted_atTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Inserted_atAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Inserted_atEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Inserted_atHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Inserted_atSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Inserted_atTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Inserted_at
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Inserted_at" (\obj -> ((((GHC.Base.pure MigrateShelleyWalletResponseBody202Inserted_at GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Inserted_at' with all required fields.
mkMigrateShelleyWalletResponseBody202Inserted_at :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Inserted_atAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Inserted_atEpoch_number'
  -> MigrateShelleyWalletResponseBody202Inserted_atHeight -- ^ 'migrateShelleyWalletResponseBody202Inserted_atHeight'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Inserted_atSlot_number'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202Inserted_atTime'
  -> MigrateShelleyWalletResponseBody202Inserted_at
mkMigrateShelleyWalletResponseBody202Inserted_at migrateShelleyWalletResponseBody202Inserted_atAbsolute_slot_number migrateShelleyWalletResponseBody202Inserted_atEpoch_number migrateShelleyWalletResponseBody202Inserted_atHeight migrateShelleyWalletResponseBody202Inserted_atSlot_number migrateShelleyWalletResponseBody202Inserted_atTime = MigrateShelleyWalletResponseBody202Inserted_at{migrateShelleyWalletResponseBody202Inserted_atAbsolute_slot_number = migrateShelleyWalletResponseBody202Inserted_atAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                                                  migrateShelleyWalletResponseBody202Inserted_atEpoch_number = migrateShelleyWalletResponseBody202Inserted_atEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                                                  migrateShelleyWalletResponseBody202Inserted_atHeight = migrateShelleyWalletResponseBody202Inserted_atHeight,
                                                                                                                                                                                                                                                                                                                                                                                                  migrateShelleyWalletResponseBody202Inserted_atSlot_number = migrateShelleyWalletResponseBody202Inserted_atSlot_number,
                                                                                                                                                                                                                                                                                                                                                                                                  migrateShelleyWalletResponseBody202Inserted_atTime = migrateShelleyWalletResponseBody202Inserted_atTime}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.inserted_at.properties.height@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202Inserted_atHeight = MigrateShelleyWalletResponseBody202Inserted_atHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202Inserted_atHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Inserted_atHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Inserted_atHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Inserted_atHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Inserted_atHeight" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202Inserted_atHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Inserted_atHeight' with all required fields.
mkMigrateShelleyWalletResponseBody202Inserted_atHeight :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Inserted_atHeightQuantity'
  -> MigrateShelleyWalletResponseBody202Inserted_atHeight
mkMigrateShelleyWalletResponseBody202Inserted_atHeight migrateShelleyWalletResponseBody202Inserted_atHeightQuantity = MigrateShelleyWalletResponseBody202Inserted_atHeight{migrateShelleyWalletResponseBody202Inserted_atHeightQuantity = migrateShelleyWalletResponseBody202Inserted_atHeightQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202Mint = MigrateShelleyWalletResponseBody202Mint {
  -- | tokens
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  migrateShelleyWalletResponseBody202MintTokens :: ([MigrateShelleyWalletResponseBody202MintTokens])
  -- | wallet_policy_key_hash
  -- 
  -- Constraints:
  -- 
  -- * Must match pattern \'^((policy_vk)|(policy_vkh))1[0-9a-z]*\$\'
  , migrateShelleyWalletResponseBody202MintWallet_policy_key_hash :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | wallet_policy_key_index: An individual segment within a derivation path.
  -- 
  -- The \`H\` suffix indicates a _Hardened_ child private key, which
  -- means that children of this key cannot be derived from the public
  -- key. Indices without a \`H\` suffix are called _Soft_.
  , migrateShelleyWalletResponseBody202MintWallet_policy_key_index :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Mint
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202MintWallet_policy_key_index obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["tokens" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokens obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_hash" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202MintWallet_policy_key_hash obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("wallet_policy_key_index" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202MintWallet_policy_key_index obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Mint
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Mint" (\obj -> ((GHC.Base.pure MigrateShelleyWalletResponseBody202Mint GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "tokens")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_hash")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "wallet_policy_key_index"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Mint' with all required fields.
mkMigrateShelleyWalletResponseBody202Mint :: [MigrateShelleyWalletResponseBody202MintTokens] -- ^ 'migrateShelleyWalletResponseBody202MintTokens'
  -> MigrateShelleyWalletResponseBody202Mint
mkMigrateShelleyWalletResponseBody202Mint migrateShelleyWalletResponseBody202MintTokens = MigrateShelleyWalletResponseBody202Mint{migrateShelleyWalletResponseBody202MintTokens = migrateShelleyWalletResponseBody202MintTokens,
                                                                                                                                  migrateShelleyWalletResponseBody202MintWallet_policy_key_hash = GHC.Maybe.Nothing,
                                                                                                                                  migrateShelleyWalletResponseBody202MintWallet_policy_key_index = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202MintTokens = MigrateShelleyWalletResponseBody202MintTokens {
  -- | assets
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateShelleyWalletResponseBody202MintTokensAssets :: ([MigrateShelleyWalletResponseBody202MintTokensAssets])
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateShelleyWalletResponseBody202MintTokensPolicy_id :: Data.Text.Internal.Text
  -- | policy_script
  , migrateShelleyWalletResponseBody202MintTokensPolicy_script :: MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokens
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_script obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["assets" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensAssets obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_id obj] : ["policy_script" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_script obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokens
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202MintTokens" (\obj -> ((GHC.Base.pure MigrateShelleyWalletResponseBody202MintTokens GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_script"))
-- | Create a new 'MigrateShelleyWalletResponseBody202MintTokens' with all required fields.
mkMigrateShelleyWalletResponseBody202MintTokens :: [MigrateShelleyWalletResponseBody202MintTokensAssets] -- ^ 'migrateShelleyWalletResponseBody202MintTokensAssets'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_id'
  -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptVariants -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_script'
  -> MigrateShelleyWalletResponseBody202MintTokens
mkMigrateShelleyWalletResponseBody202MintTokens migrateShelleyWalletResponseBody202MintTokensAssets migrateShelleyWalletResponseBody202MintTokensPolicy_id migrateShelleyWalletResponseBody202MintTokensPolicy_script = MigrateShelleyWalletResponseBody202MintTokens{migrateShelleyWalletResponseBody202MintTokensAssets = migrateShelleyWalletResponseBody202MintTokensAssets,
                                                                                                                                                                                                                                                                      migrateShelleyWalletResponseBody202MintTokensPolicy_id = migrateShelleyWalletResponseBody202MintTokensPolicy_id,
                                                                                                                                                                                                                                                                      migrateShelleyWalletResponseBody202MintTokensPolicy_script = migrateShelleyWalletResponseBody202MintTokensPolicy_script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.assets.items@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202MintTokensAssets = MigrateShelleyWalletResponseBody202MintTokensAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  migrateShelleyWalletResponseBody202MintTokensAssetsAsset_name :: Data.Text.Internal.Text
  -- | fingerprint: A user-facing short fingerprint which combines the \`policy_id\` and \`asset_name\`
  -- to allow for an easier human comparison of assets. Note that it is generally
  -- **not okay** to use this fingerprint as a unique identifier for it is not collision
  -- resistant. Yet within the context of a single wallet, it makes for a (rather)
  -- short user-facing comparison mean.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 44
  -- * Minimum length of 44
  -- * Must match pattern \'^(asset)1[0-9a-z]*\$\'
  , migrateShelleyWalletResponseBody202MintTokensAssetsFingerprint :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202MintTokensAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensAssetsAsset_name obj] : ["fingerprint" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensAssetsFingerprint obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202MintTokensAssets" (\obj -> ((GHC.Base.pure MigrateShelleyWalletResponseBody202MintTokensAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "fingerprint")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202MintTokensAssets' with all required fields.
mkMigrateShelleyWalletResponseBody202MintTokensAssets :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202MintTokensAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202MintTokensAssetsFingerprint'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202MintTokensAssetsQuantity'
  -> MigrateShelleyWalletResponseBody202MintTokensAssets
mkMigrateShelleyWalletResponseBody202MintTokensAssets migrateShelleyWalletResponseBody202MintTokensAssetsAsset_name migrateShelleyWalletResponseBody202MintTokensAssetsFingerprint migrateShelleyWalletResponseBody202MintTokensAssetsQuantity = MigrateShelleyWalletResponseBody202MintTokensAssets{migrateShelleyWalletResponseBody202MintTokensAssetsAsset_name = migrateShelleyWalletResponseBody202MintTokensAssetsAsset_name,
                                                                                                                                                                                                                                                                                                     migrateShelleyWalletResponseBody202MintTokensAssetsFingerprint = migrateShelleyWalletResponseBody202MintTokensAssetsFingerprint,
                                                                                                                                                                                                                                                                                                     migrateShelleyWalletResponseBody202MintTokensAssetsQuantity = migrateShelleyWalletResponseBody202MintTokensAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1 = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1 {
  -- | reference: A reference input.
  migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference :: (GHC.Maybe.Maybe MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference)
  -- | script
  , migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Script :: MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference obj) : ["script" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Script obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "native"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script"))
-- | Create a new 'MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1' with all required fields.
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1 :: MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Script'
  -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1 migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Script = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1{migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                             migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Script = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Script}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference' with all required fields.
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex'
  -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1Reference{migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceId,
                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 {
  -- | all: Script primitive for which all signing keys corresponding to all list elements\' verification keys are expected to make the script valid.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["all" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "all"))
-- | Create a new 'MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2' with all required fields.
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 :: [ScriptValue] -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All'
  -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2 migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2{migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2All}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 {
  -- | any: Script primitive for which a signing key corresponding to any of the list elements\' verification keys is expected to make the script valid. It is equivalent to \`some\` with \`\"at_least\"=1\`.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["any" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "any"))
-- | Create a new 'MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3' with all required fields.
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 :: [ScriptValue] -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any'
  -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3 migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3{migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3Any}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 {
  -- | some: Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
  migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["some" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "some"))
-- | Create a new 'MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4' with all required fields.
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 :: MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some'
  -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4 migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4{migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf.properties.some@ in the specification.
-- 
-- Script primitive for which at least a given number of signing keys corresponding to the list elements\' verification keys are expected to make the script valid.
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some {
  -- | at_least
  -- 
  -- Constraints:
  -- 
  -- * Maxium  of 255.0
  -- * Minimum  of 1.0
  migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least :: GHC.Types.Int
  -- | from
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom :: ([ScriptValue])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["at_least" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least obj] : ["from" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "at_least")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "from"))
-- | Create a new 'MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some' with all required fields.
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least'
  -> [ScriptValue] -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom'
  -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4Some{migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeAt_least,
                                                                                                                                                                                                                                                                                                                                                    migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4SomeFrom}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 {
  -- | active_from: Transaction is only valid starting at the specified slot number (\`≥ active_from\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_from" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_from"))
-- | Create a new 'MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5' with all required fields.
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from'
  -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5 migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5{migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5Active_from}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 {
  -- | active_until: Transaction is only valid before the specified slot number (\`\< active_until\`).
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["active_until" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "active_until"))
-- | Create a new 'MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6' with all required fields.
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until'
  -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6 migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6{migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6Active_until}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants =
   MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Text.Internal.Text
  | MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf2
  | MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf3
  | MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf4
  | MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf5
  | MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptOneOf6
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
    where toJSON (MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariants
    where parseJSON val = case (MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant4 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant5 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1ScriptVariant6 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched"))))) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2 = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2 {
  -- | reference: A reference input.
  migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference :: (GHC.Maybe.Maybe MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference)
  -- | script_info
  , migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info :: MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("reference" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference obj) : ["script_info" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "plutus"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "reference")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_info"))
-- | Create a new 'MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2' with all required fields.
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2 :: MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info'
  -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2 migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2{migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference = GHC.Maybe.Nothing,
                                                                                                                                                                                                                  migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.reference@ in the specification.
-- 
-- A reference input.
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference' with all required fields.
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex'
  -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Reference{migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceId,
                                                                                                                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2ReferenceIndex}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info {
  -- | language_version
  migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version :: MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["language_version" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "language_version")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info' with all required fields.
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info :: MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash'
  -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_info{migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version,
                                                                                                                                                                                                                                                                                                                                               migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoScript_hash}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.script_info.properties.language_version@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version =
   MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1 -- ^ Represents the JSON value @"v1"@
  | MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2 -- ^ Represents the JSON value @"v2"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where toJSON (MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val) = val
          toJSON (MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1) = "v1"
          toJSON (MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2) = "v2"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_version
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "v1" -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV1
                                            | val GHC.Classes.== "v2" -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionEnumV2
                                            | GHC.Base.otherwise -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2Script_infoLanguage_versionOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3 = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3 {
  -- | references
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References :: ([MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References])
  -- | script_hash
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3Script_hash :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["references" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References obj] : ["script_hash" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3Script_hash obj] : ["script_type" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "reference script"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "references")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "script_hash"))
-- | Create a new 'MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3' with all required fields.
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3 :: [MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References] -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3Script_hash'
  -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3 migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3Script_hash = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3{migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References,
                                                                                                                                                                                                                                                                                             migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3Script_hash = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3Script_hash}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf.properties.references.items@ in the specification.
-- 
-- A reference input.
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References {
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId obj] : ["index" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References' with all required fields.
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex'
  -> MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References
mkMigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex = MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3References{migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesId,
                                                                                                                                                                                                                                                                                                                       migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex = migrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3ReferencesIndex}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.mint.properties.tokens.items.properties.policy_script.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptVariants =
   MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptVariant1 MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf1
  | MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptVariant2 MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf2
  | MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptVariant3 MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptOneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptVariants
    where toJSON (MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptVariant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptVariant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptVariant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptVariants
    where parseJSON val = case (MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptVariant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptVariant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody202MintTokensPolicy_scriptVariant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.outputs.items@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202Outputs = MigrateShelleyWalletResponseBody202Outputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  migrateShelleyWalletResponseBody202OutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , migrateShelleyWalletResponseBody202OutputsAmount :: MigrateShelleyWalletResponseBody202OutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , migrateShelleyWalletResponseBody202OutputsAssets :: (GHC.Maybe.Maybe ([MigrateShelleyWalletResponseBody202OutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Outputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202OutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202OutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202OutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (migrateShelleyWalletResponseBody202OutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Outputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Outputs" (\obj -> ((GHC.Base.pure MigrateShelleyWalletResponseBody202Outputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Outputs' with all required fields.
mkMigrateShelleyWalletResponseBody202Outputs :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202OutputsAddress'
  -> MigrateShelleyWalletResponseBody202OutputsAmount -- ^ 'migrateShelleyWalletResponseBody202OutputsAmount'
  -> MigrateShelleyWalletResponseBody202Outputs
mkMigrateShelleyWalletResponseBody202Outputs migrateShelleyWalletResponseBody202OutputsAddress migrateShelleyWalletResponseBody202OutputsAmount = MigrateShelleyWalletResponseBody202Outputs{migrateShelleyWalletResponseBody202OutputsAddress = migrateShelleyWalletResponseBody202OutputsAddress,
                                                                                                                                                                                             migrateShelleyWalletResponseBody202OutputsAmount = migrateShelleyWalletResponseBody202OutputsAmount,
                                                                                                                                                                                             migrateShelleyWalletResponseBody202OutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateShelleyWalletResponseBody202OutputsAmount = MigrateShelleyWalletResponseBody202OutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202OutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202OutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202OutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202OutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202OutputsAmount" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202OutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202OutputsAmount' with all required fields.
mkMigrateShelleyWalletResponseBody202OutputsAmount :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202OutputsAmountQuantity'
  -> MigrateShelleyWalletResponseBody202OutputsAmount
mkMigrateShelleyWalletResponseBody202OutputsAmount migrateShelleyWalletResponseBody202OutputsAmountQuantity = MigrateShelleyWalletResponseBody202OutputsAmount{migrateShelleyWalletResponseBody202OutputsAmountQuantity = migrateShelleyWalletResponseBody202OutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data MigrateShelleyWalletResponseBody202OutputsAssets = MigrateShelleyWalletResponseBody202OutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  migrateShelleyWalletResponseBody202OutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , migrateShelleyWalletResponseBody202OutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202OutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202OutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202OutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202OutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202OutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202OutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202OutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202OutputsAssets" (\obj -> ((GHC.Base.pure MigrateShelleyWalletResponseBody202OutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202OutputsAssets' with all required fields.
mkMigrateShelleyWalletResponseBody202OutputsAssets :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202OutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202OutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202OutputsAssetsQuantity'
  -> MigrateShelleyWalletResponseBody202OutputsAssets
mkMigrateShelleyWalletResponseBody202OutputsAssets migrateShelleyWalletResponseBody202OutputsAssetsAsset_name migrateShelleyWalletResponseBody202OutputsAssetsPolicy_id migrateShelleyWalletResponseBody202OutputsAssetsQuantity = MigrateShelleyWalletResponseBody202OutputsAssets{migrateShelleyWalletResponseBody202OutputsAssetsAsset_name = migrateShelleyWalletResponseBody202OutputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                    migrateShelleyWalletResponseBody202OutputsAssetsPolicy_id = migrateShelleyWalletResponseBody202OutputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                    migrateShelleyWalletResponseBody202OutputsAssetsQuantity = migrateShelleyWalletResponseBody202OutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.pending_since@ in the specification.
-- 
-- \<span style=\"position: relative; left: 35px; top: -21px; vertical-align: middle; background-color: rgba(142, 142, 220, 0.05); color: rgba(50, 50, 159, 0.9); margin: 0 5px; padding: 0 5px; border: 1px solid rgba(50, 50, 159, 0.1); line-height: 20px; font-size: 13px; border-radius: 2px;\">
-- \<strong>if:\<\/strong> status == pending
-- \<\/span>\<br\/>
-- The point in time at which a transaction became pending.
data MigrateShelleyWalletResponseBody202Pending_since = MigrateShelleyWalletResponseBody202Pending_since {
  -- | absolute_slot_number: The 0-based slot index starting from genesis of the blockchain.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202Pending_sinceAbsolute_slot_number :: GHC.Types.Int
  -- | epoch_number: An epoch is a time period which is divided into slots.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202Pending_sinceEpoch_number :: GHC.Types.Int
  -- | height
  , migrateShelleyWalletResponseBody202Pending_sinceHeight :: MigrateShelleyWalletResponseBody202Pending_sinceHeight
  -- | slot_number: The zero-based slot index within an epoch.
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , migrateShelleyWalletResponseBody202Pending_sinceSlot_number :: GHC.Types.Int
  -- | time
  , migrateShelleyWalletResponseBody202Pending_sinceTime :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Pending_since
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Pending_sinceTime obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["absolute_slot_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Pending_sinceAbsolute_slot_number obj] : ["epoch_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Pending_sinceEpoch_number obj] : ["height" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Pending_sinceHeight obj] : ["slot_number" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Pending_sinceSlot_number obj] : ["time" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Pending_sinceTime obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Pending_since
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Pending_since" (\obj -> ((((GHC.Base.pure MigrateShelleyWalletResponseBody202Pending_since GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "absolute_slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "epoch_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "height")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "slot_number")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "time"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Pending_since' with all required fields.
mkMigrateShelleyWalletResponseBody202Pending_since :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Pending_sinceAbsolute_slot_number'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Pending_sinceEpoch_number'
  -> MigrateShelleyWalletResponseBody202Pending_sinceHeight -- ^ 'migrateShelleyWalletResponseBody202Pending_sinceHeight'
  -> GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Pending_sinceSlot_number'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202Pending_sinceTime'
  -> MigrateShelleyWalletResponseBody202Pending_since
mkMigrateShelleyWalletResponseBody202Pending_since migrateShelleyWalletResponseBody202Pending_sinceAbsolute_slot_number migrateShelleyWalletResponseBody202Pending_sinceEpoch_number migrateShelleyWalletResponseBody202Pending_sinceHeight migrateShelleyWalletResponseBody202Pending_sinceSlot_number migrateShelleyWalletResponseBody202Pending_sinceTime = MigrateShelleyWalletResponseBody202Pending_since{migrateShelleyWalletResponseBody202Pending_sinceAbsolute_slot_number = migrateShelleyWalletResponseBody202Pending_sinceAbsolute_slot_number,
                                                                                                                                                                                                                                                                                                                                                                                                                migrateShelleyWalletResponseBody202Pending_sinceEpoch_number = migrateShelleyWalletResponseBody202Pending_sinceEpoch_number,
                                                                                                                                                                                                                                                                                                                                                                                                                migrateShelleyWalletResponseBody202Pending_sinceHeight = migrateShelleyWalletResponseBody202Pending_sinceHeight,
                                                                                                                                                                                                                                                                                                                                                                                                                migrateShelleyWalletResponseBody202Pending_sinceSlot_number = migrateShelleyWalletResponseBody202Pending_sinceSlot_number,
                                                                                                                                                                                                                                                                                                                                                                                                                migrateShelleyWalletResponseBody202Pending_sinceTime = migrateShelleyWalletResponseBody202Pending_sinceTime}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.pending_since.properties.height@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202Pending_sinceHeight = MigrateShelleyWalletResponseBody202Pending_sinceHeight {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202Pending_sinceHeightQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Pending_sinceHeight
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Pending_sinceHeightQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "block"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Pending_sinceHeight
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Pending_sinceHeight" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202Pending_sinceHeight GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Pending_sinceHeight' with all required fields.
mkMigrateShelleyWalletResponseBody202Pending_sinceHeight :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Pending_sinceHeightQuantity'
  -> MigrateShelleyWalletResponseBody202Pending_sinceHeight
mkMigrateShelleyWalletResponseBody202Pending_sinceHeight migrateShelleyWalletResponseBody202Pending_sinceHeightQuantity = MigrateShelleyWalletResponseBody202Pending_sinceHeight{migrateShelleyWalletResponseBody202Pending_sinceHeightQuantity = migrateShelleyWalletResponseBody202Pending_sinceHeightQuantity}
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.script_validity@ in the specification.
-- 
-- Indicates whether the phase-2 monetary policy script (e.g. Plutus script)
-- used in the transaction validated or not. Validity may be null if this
-- transaction was from an era that doesn\'t support phase-2 monetary policy
-- scripts, or is a pending transaction (we don\'t know if validation passed or
-- failed until the transaction hits the ledger).
data MigrateShelleyWalletResponseBody202Script_validityNonNullable =
   MigrateShelleyWalletResponseBody202Script_validityNonNullableOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateShelleyWalletResponseBody202Script_validityNonNullableTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateShelleyWalletResponseBody202Script_validityNonNullableEnumValid -- ^ Represents the JSON value @"valid"@
  | MigrateShelleyWalletResponseBody202Script_validityNonNullableEnumInvalid -- ^ Represents the JSON value @"invalid"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Script_validityNonNullable
    where toJSON (MigrateShelleyWalletResponseBody202Script_validityNonNullableOther val) = val
          toJSON (MigrateShelleyWalletResponseBody202Script_validityNonNullableTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateShelleyWalletResponseBody202Script_validityNonNullableEnumValid) = "valid"
          toJSON (MigrateShelleyWalletResponseBody202Script_validityNonNullableEnumInvalid) = "invalid"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Script_validityNonNullable
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "valid" -> MigrateShelleyWalletResponseBody202Script_validityNonNullableEnumValid
                                            | val GHC.Classes.== "invalid" -> MigrateShelleyWalletResponseBody202Script_validityNonNullableEnumInvalid
                                            | GHC.Base.otherwise -> MigrateShelleyWalletResponseBody202Script_validityNonNullableOther val)
-- | Defines the enum schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.status@ in the specification.
-- 
-- Current transaction status.
-- 
--   \`\`\`
--        *-----------*
--   ---> |  PENDING  |----------------*
--        *-----------*                |
--              |                      |
--              V                      V
--        *-----------*          *-----------*
--        |           |---------->  EXPIRED  |
--        |           |  (ttl)   *-----------*
--        | SUBMITTED |
--        |           \<----------------*
--        |           |                |
--        *-----------*           (rollback)
--               |                     |
--          (in ledger)          *-----------*
--               |               |           |
--               *---------------> IN_LEDGER |
--                               |           |
--                               *-----------*
--   \`\`\`
data MigrateShelleyWalletResponseBody202Status =
   MigrateShelleyWalletResponseBody202StatusOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | MigrateShelleyWalletResponseBody202StatusTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | MigrateShelleyWalletResponseBody202StatusEnumPending -- ^ Represents the JSON value @"pending"@
  | MigrateShelleyWalletResponseBody202StatusEnumSubmitted -- ^ Represents the JSON value @"submitted"@
  | MigrateShelleyWalletResponseBody202StatusEnumIn_ledger -- ^ Represents the JSON value @"in_ledger"@
  | MigrateShelleyWalletResponseBody202StatusEnumExpired -- ^ Represents the JSON value @"expired"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Status
    where toJSON (MigrateShelleyWalletResponseBody202StatusOther val) = val
          toJSON (MigrateShelleyWalletResponseBody202StatusTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (MigrateShelleyWalletResponseBody202StatusEnumPending) = "pending"
          toJSON (MigrateShelleyWalletResponseBody202StatusEnumSubmitted) = "submitted"
          toJSON (MigrateShelleyWalletResponseBody202StatusEnumIn_ledger) = "in_ledger"
          toJSON (MigrateShelleyWalletResponseBody202StatusEnumExpired) = "expired"
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Status
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "pending" -> MigrateShelleyWalletResponseBody202StatusEnumPending
                                            | val GHC.Classes.== "submitted" -> MigrateShelleyWalletResponseBody202StatusEnumSubmitted
                                            | val GHC.Classes.== "in_ledger" -> MigrateShelleyWalletResponseBody202StatusEnumIn_ledger
                                            | val GHC.Classes.== "expired" -> MigrateShelleyWalletResponseBody202StatusEnumExpired
                                            | GHC.Base.otherwise -> MigrateShelleyWalletResponseBody202StatusOther val)
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.validity_interval@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202Validity_interval = MigrateShelleyWalletResponseBody202Validity_interval {
  -- | invalid_before
  migrateShelleyWalletResponseBody202Validity_intervalInvalid_before :: MigrateShelleyWalletResponseBody202Validity_intervalInvalid_before
  -- | invalid_hereafter
  , migrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter :: MigrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Validity_interval
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["invalid_before" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Validity_intervalInvalid_before obj] : ["invalid_hereafter" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Validity_interval
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Validity_interval" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202Validity_interval GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_before")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "invalid_hereafter"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Validity_interval' with all required fields.
mkMigrateShelleyWalletResponseBody202Validity_interval :: MigrateShelleyWalletResponseBody202Validity_intervalInvalid_before -- ^ 'migrateShelleyWalletResponseBody202Validity_intervalInvalid_before'
  -> MigrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter -- ^ 'migrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter'
  -> MigrateShelleyWalletResponseBody202Validity_interval
mkMigrateShelleyWalletResponseBody202Validity_interval migrateShelleyWalletResponseBody202Validity_intervalInvalid_before migrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter = MigrateShelleyWalletResponseBody202Validity_interval{migrateShelleyWalletResponseBody202Validity_intervalInvalid_before = migrateShelleyWalletResponseBody202Validity_intervalInvalid_before,
                                                                                                                                                                                                                                                       migrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter = migrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.validity_interval.properties.invalid_before@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202Validity_intervalInvalid_before = MigrateShelleyWalletResponseBody202Validity_intervalInvalid_before {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202Validity_intervalInvalid_beforeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Validity_intervalInvalid_before
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Validity_intervalInvalid_beforeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Validity_intervalInvalid_before
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Validity_intervalInvalid_before" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202Validity_intervalInvalid_before GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Validity_intervalInvalid_before' with all required fields.
mkMigrateShelleyWalletResponseBody202Validity_intervalInvalid_before :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Validity_intervalInvalid_beforeQuantity'
  -> MigrateShelleyWalletResponseBody202Validity_intervalInvalid_before
mkMigrateShelleyWalletResponseBody202Validity_intervalInvalid_before migrateShelleyWalletResponseBody202Validity_intervalInvalid_beforeQuantity = MigrateShelleyWalletResponseBody202Validity_intervalInvalid_before{migrateShelleyWalletResponseBody202Validity_intervalInvalid_beforeQuantity = migrateShelleyWalletResponseBody202Validity_intervalInvalid_beforeQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.validity_interval.properties.invalid_hereafter@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter = MigrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafterQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafterQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "slot"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter' with all required fields.
mkMigrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafterQuantity'
  -> MigrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter
mkMigrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter migrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafterQuantity = MigrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafter{migrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafterQuantity = migrateShelleyWalletResponseBody202Validity_intervalInvalid_hereafterQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.withdrawals.items@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody202Withdrawals = MigrateShelleyWalletResponseBody202Withdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  migrateShelleyWalletResponseBody202WithdrawalsAmount :: MigrateShelleyWalletResponseBody202WithdrawalsAmount
  -- | stake_address
  , migrateShelleyWalletResponseBody202WithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202Withdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202WithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202WithdrawalsAmount obj] : ["stake_address" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202WithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202Withdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202Withdrawals" (\obj -> (GHC.Base.pure MigrateShelleyWalletResponseBody202Withdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'MigrateShelleyWalletResponseBody202Withdrawals' with all required fields.
mkMigrateShelleyWalletResponseBody202Withdrawals :: MigrateShelleyWalletResponseBody202WithdrawalsAmount -- ^ 'migrateShelleyWalletResponseBody202WithdrawalsAmount'
  -> Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody202WithdrawalsStake_address'
  -> MigrateShelleyWalletResponseBody202Withdrawals
mkMigrateShelleyWalletResponseBody202Withdrawals migrateShelleyWalletResponseBody202WithdrawalsAmount migrateShelleyWalletResponseBody202WithdrawalsStake_address = MigrateShelleyWalletResponseBody202Withdrawals{migrateShelleyWalletResponseBody202WithdrawalsAmount = migrateShelleyWalletResponseBody202WithdrawalsAmount,
                                                                                                                                                                                                                   migrateShelleyWalletResponseBody202WithdrawalsStake_address = migrateShelleyWalletResponseBody202WithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.202.content.application\/json.schema.items.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data MigrateShelleyWalletResponseBody202WithdrawalsAmount = MigrateShelleyWalletResponseBody202WithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  migrateShelleyWalletResponseBody202WithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody202WithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody202WithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody202WithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody202WithdrawalsAmount" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody202WithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'MigrateShelleyWalletResponseBody202WithdrawalsAmount' with all required fields.
mkMigrateShelleyWalletResponseBody202WithdrawalsAmount :: GHC.Types.Int -- ^ 'migrateShelleyWalletResponseBody202WithdrawalsAmountQuantity'
  -> MigrateShelleyWalletResponseBody202WithdrawalsAmount
mkMigrateShelleyWalletResponseBody202WithdrawalsAmount migrateShelleyWalletResponseBody202WithdrawalsAmountQuantity = MigrateShelleyWalletResponseBody202WithdrawalsAmount{migrateShelleyWalletResponseBody202WithdrawalsAmountQuantity = migrateShelleyWalletResponseBody202WithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody403OneOf1 = MigrateShelleyWalletResponseBody403OneOf1 {
  -- | message: May occur when trying to migrate a wallet that is empty or full of dust.
  migrateShelleyWalletResponseBody403OneOf1Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody403OneOf1
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "nothing_to_migrate"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody403OneOf1Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "nothing_to_migrate"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody403OneOf1
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody403OneOf1" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody403OneOf1 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'MigrateShelleyWalletResponseBody403OneOf1' with all required fields.
mkMigrateShelleyWalletResponseBody403OneOf1 :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody403OneOf1Message'
  -> MigrateShelleyWalletResponseBody403OneOf1
mkMigrateShelleyWalletResponseBody403OneOf1 migrateShelleyWalletResponseBody403OneOf1Message = MigrateShelleyWalletResponseBody403OneOf1{migrateShelleyWalletResponseBody403OneOf1Message = migrateShelleyWalletResponseBody403OneOf1Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody403OneOf2 = MigrateShelleyWalletResponseBody403OneOf2 {
  -- | message: May occur when an action require a signing key but the wallet has only access to verification keys.
  migrateShelleyWalletResponseBody403OneOf2Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody403OneOf2
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody403OneOf2Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_root_key"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody403OneOf2
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody403OneOf2" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody403OneOf2 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'MigrateShelleyWalletResponseBody403OneOf2' with all required fields.
mkMigrateShelleyWalletResponseBody403OneOf2 :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody403OneOf2Message'
  -> MigrateShelleyWalletResponseBody403OneOf2
mkMigrateShelleyWalletResponseBody403OneOf2 migrateShelleyWalletResponseBody403OneOf2Message = MigrateShelleyWalletResponseBody403OneOf2{migrateShelleyWalletResponseBody403OneOf2Message = migrateShelleyWalletResponseBody403OneOf2Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody403OneOf3 = MigrateShelleyWalletResponseBody403OneOf3 {
  -- | message: May occur when the given spending passphrase is wrong.
  migrateShelleyWalletResponseBody403OneOf3Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody403OneOf3
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody403OneOf3Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "wrong_encryption_passphrase"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody403OneOf3
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody403OneOf3" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody403OneOf3 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'MigrateShelleyWalletResponseBody403OneOf3' with all required fields.
mkMigrateShelleyWalletResponseBody403OneOf3 :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody403OneOf3Message'
  -> MigrateShelleyWalletResponseBody403OneOf3
mkMigrateShelleyWalletResponseBody403OneOf3 migrateShelleyWalletResponseBody403OneOf3Message = MigrateShelleyWalletResponseBody403OneOf3{migrateShelleyWalletResponseBody403OneOf3Message = migrateShelleyWalletResponseBody403OneOf3Message}
-- | Defines the oneOf schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.403.content.application\/json.schema.oneOf@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody403Variants =
   MigrateShelleyWalletResponseBody403Variant1 MigrateShelleyWalletResponseBody403OneOf1
  | MigrateShelleyWalletResponseBody403Variant2 MigrateShelleyWalletResponseBody403OneOf2
  | MigrateShelleyWalletResponseBody403Variant3 MigrateShelleyWalletResponseBody403OneOf3
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody403Variants
    where toJSON (MigrateShelleyWalletResponseBody403Variant1 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody403Variant2 a) = Data.Aeson.Types.ToJSON.toJSON a
          toJSON (MigrateShelleyWalletResponseBody403Variant3 a) = Data.Aeson.Types.ToJSON.toJSON a
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody403Variants
    where parseJSON val = case (MigrateShelleyWalletResponseBody403Variant1 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody403Variant2 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> ((MigrateShelleyWalletResponseBody403Variant3 Data.Functor.<$> Data.Aeson.Types.FromJSON.fromJSON val) GHC.Base.<|> Data.Aeson.Types.Internal.Error "No variant matched")) of
                              Data.Aeson.Types.Internal.Success a -> GHC.Base.pure a
                              Data.Aeson.Types.Internal.Error a -> Control.Monad.Fail.fail a
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody404 = MigrateShelleyWalletResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  migrateShelleyWalletResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody404" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'MigrateShelleyWalletResponseBody404' with all required fields.
mkMigrateShelleyWalletResponseBody404 :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody404Message'
  -> MigrateShelleyWalletResponseBody404
mkMigrateShelleyWalletResponseBody404 migrateShelleyWalletResponseBody404Message = MigrateShelleyWalletResponseBody404{migrateShelleyWalletResponseBody404Message = migrateShelleyWalletResponseBody404Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody406 = MigrateShelleyWalletResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  migrateShelleyWalletResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody406" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'MigrateShelleyWalletResponseBody406' with all required fields.
mkMigrateShelleyWalletResponseBody406 :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody406Message'
  -> MigrateShelleyWalletResponseBody406
mkMigrateShelleyWalletResponseBody406 migrateShelleyWalletResponseBody406Message = MigrateShelleyWalletResponseBody406{migrateShelleyWalletResponseBody406Message = migrateShelleyWalletResponseBody406Message}
-- | Defines the object schema located at @paths.\/wallets\/{walletId}\/migrations.POST.responses.415.content.application\/json.schema@ in the specification.
-- 
-- 
data MigrateShelleyWalletResponseBody415 = MigrateShelleyWalletResponseBody415 {
  -- | message: May occur when providing an invalid \'Content-Type\' header.
  migrateShelleyWalletResponseBody415Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON MigrateShelleyWalletResponseBody415
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= migrateShelleyWalletResponseBody415Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "unsupported_media_type"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON MigrateShelleyWalletResponseBody415
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "MigrateShelleyWalletResponseBody415" (\obj -> GHC.Base.pure MigrateShelleyWalletResponseBody415 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'MigrateShelleyWalletResponseBody415' with all required fields.
mkMigrateShelleyWalletResponseBody415 :: Data.Text.Internal.Text -- ^ 'migrateShelleyWalletResponseBody415Message'
  -> MigrateShelleyWalletResponseBody415
mkMigrateShelleyWalletResponseBody415 migrateShelleyWalletResponseBody415Message = MigrateShelleyWalletResponseBody415{migrateShelleyWalletResponseBody415Message = migrateShelleyWalletResponseBody415Message}
-- | > POST /wallets/{walletId}/migrations
-- 
-- The same as 'migrateShelleyWallet' but accepts an explicit configuration.
migrateShelleyWalletWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> MigrateShelleyWalletRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response MigrateShelleyWalletResponse) -- ^ Monadic computation which returns the result of the operation
migrateShelleyWalletWithConfiguration config
                                      walletId
                                      body = GHC.Base.fmap (\response_6 -> GHC.Base.fmap (Data.Either.either MigrateShelleyWalletResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> MigrateShelleyWalletResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                ([MigrateShelleyWalletResponseBody202]))
                                                                                                                                                                                            | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> MigrateShelleyWalletResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                MigrateShelleyWalletResponseBody403Variants)
                                                                                                                                                                                            | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> MigrateShelleyWalletResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                MigrateShelleyWalletResponseBody404)
                                                                                                                                                                                            | (\status_10 -> Network.HTTP.Types.Status.statusCode status_10 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> MigrateShelleyWalletResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                  MigrateShelleyWalletResponseBody406)
                                                                                                                                                                                            | (\status_11 -> Network.HTTP.Types.Status.statusCode status_11 GHC.Classes.== 415) (Network.HTTP.Client.Types.responseStatus response) -> MigrateShelleyWalletResponse415 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                  MigrateShelleyWalletResponseBody415)
                                                                                                                                                                                            | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_6) response_6) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/migrations")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/migrations
-- 
-- The same as 'migrateShelleyWallet' but returns the raw 'Data.ByteString.ByteString'.
migrateShelleyWalletRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> MigrateShelleyWalletRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
migrateShelleyWalletRaw walletId
                        body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/migrations")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /wallets/{walletId}/migrations
-- 
-- The same as 'migrateShelleyWallet' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
migrateShelleyWalletWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> MigrateShelleyWalletRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
migrateShelleyWalletWithConfigurationRaw config
                                         walletId
                                         body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/migrations")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
