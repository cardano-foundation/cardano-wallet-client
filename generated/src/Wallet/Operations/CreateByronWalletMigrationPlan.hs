-- CHANGE WITH CAUTION: This is a generated code file generated by https://github.com/Haskell-OpenAPI-Code-Generator/Haskell-OpenAPI-Client-Code-Generator.

{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE ExplicitForAll #-}
{-# LANGUAGE MultiWayIf #-}

-- | Contains the different functions to run the operation createByronWalletMigrationPlan
module Wallet.Operations.CreateByronWalletMigrationPlan where

import qualified Prelude as GHC.Integer.Type
import qualified Prelude as GHC.Maybe
import qualified Control.Monad.Fail
import qualified Control.Monad.Trans.Reader
import qualified Data.Aeson
import qualified Data.Aeson as Data.Aeson.Encoding.Internal
import qualified Data.Aeson as Data.Aeson.Types
import qualified Data.Aeson as Data.Aeson.Types.FromJSON
import qualified Data.Aeson as Data.Aeson.Types.ToJSON
import qualified Data.Aeson as Data.Aeson.Types.Internal
import qualified Data.ByteString
import qualified Data.ByteString as Data.ByteString.Internal
import qualified Data.ByteString as Data.ByteString.Internal.Type
import qualified Data.Either
import qualified Data.Foldable
import qualified Data.Functor
import qualified Data.Maybe
import qualified Data.Scientific
import qualified Data.Text
import qualified Data.Text.Internal
import qualified Data.Time.Calendar as Data.Time.Calendar.Days
import qualified Data.Time.LocalTime as Data.Time.LocalTime.Internal.ZonedTime
import qualified Data.Vector
import qualified GHC.Base
import qualified GHC.Classes
import qualified GHC.Int
import qualified GHC.Show
import qualified GHC.Types
import qualified Network.HTTP.Client
import qualified Network.HTTP.Client as Network.HTTP.Client.Request
import qualified Network.HTTP.Client as Network.HTTP.Client.Types
import qualified Network.HTTP.Simple
import qualified Network.HTTP.Types
import qualified Network.HTTP.Types as Network.HTTP.Types.Status
import qualified Network.HTTP.Types as Network.HTTP.Types.URI
import qualified Wallet.Common
import Wallet.Types

-- | > POST /byron-wallets/{walletId}/migrations/plan
-- 
-- Generate a plan for migrating the UTxO balance of this wallet to
-- another wallet, without executing the plan.
-- 
-- This operation generates a plan that transfers as much of the wallet\'s
-- balance as possible, by creating as many selections as may be necessary
-- to migrate the entire balance.  Each selection created is the basis for
-- a transaction.
-- 
-- In order to minimize the total transaction fee required, UTxO entries
-- are coalesced together to the greatest extent possible in the resulting
-- selections. No attempt is made to preserve the wallet\'s UTxO
-- distribution.
-- 
-- The plan is generated on a best-effort basis. If there is insufficient
-- ada available to pay for the entire UTxO set to be migrated, then only
-- a subset of the wallet\'s UTxO set will be included in the resultant
-- plan.
createByronWalletMigrationPlan :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> CreateByronWalletMigrationPlanRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response CreateByronWalletMigrationPlanResponse) -- ^ Monadic computation which returns the result of the operation
createByronWalletMigrationPlan walletId
                               body = GHC.Base.fmap (\response_0 -> GHC.Base.fmap (Data.Either.either CreateByronWalletMigrationPlanResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_1 -> Network.HTTP.Types.Status.statusCode status_1 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> CreateByronWalletMigrationPlanResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                             CreateByronWalletMigrationPlanResponseBody202)
                                                                                                                                                                                               | (\status_2 -> Network.HTTP.Types.Status.statusCode status_2 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> CreateByronWalletMigrationPlanResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                             CreateByronWalletMigrationPlanResponseBody403)
                                                                                                                                                                                               | (\status_3 -> Network.HTTP.Types.Status.statusCode status_3 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> CreateByronWalletMigrationPlanResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                             CreateByronWalletMigrationPlanResponseBody404)
                                                                                                                                                                                               | (\status_4 -> Network.HTTP.Types.Status.statusCode status_4 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> CreateByronWalletMigrationPlanResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                             CreateByronWalletMigrationPlanResponseBody406)
                                                                                                                                                                                               | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_0) response_0) (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/migrations/plan")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.requestBody.content.application\/json.schema@ in the specification.
-- 
-- 
data CreateByronWalletMigrationPlanRequestBody = CreateByronWalletMigrationPlanRequestBody {
  -- | addresses: The recipient addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  createByronWalletMigrationPlanRequestBodyAddresses :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanRequestBody
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["addresses" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanRequestBodyAddresses obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["addresses" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanRequestBodyAddresses obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanRequestBody
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanRequestBody" (\obj -> GHC.Base.pure CreateByronWalletMigrationPlanRequestBody GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "addresses"))
-- | Create a new 'CreateByronWalletMigrationPlanRequestBody' with all required fields.
mkCreateByronWalletMigrationPlanRequestBody :: [Data.Text.Internal.Text] -- ^ 'createByronWalletMigrationPlanRequestBodyAddresses'
  -> CreateByronWalletMigrationPlanRequestBody
mkCreateByronWalletMigrationPlanRequestBody createByronWalletMigrationPlanRequestBodyAddresses = CreateByronWalletMigrationPlanRequestBody{createByronWalletMigrationPlanRequestBodyAddresses = createByronWalletMigrationPlanRequestBodyAddresses}
-- | Represents a response of the operation 'createByronWalletMigrationPlan'.
-- 
-- The response constructor is chosen by the status code of the response. If no case matches (no specific case for the response code, no range case, no default case), 'CreateByronWalletMigrationPlanResponseError' is used.
data CreateByronWalletMigrationPlanResponse =
   CreateByronWalletMigrationPlanResponseError GHC.Base.String -- ^ Means either no matching case available or a parse error
  | CreateByronWalletMigrationPlanResponse202 CreateByronWalletMigrationPlanResponseBody202 -- ^ Accepted
  | CreateByronWalletMigrationPlanResponse403 CreateByronWalletMigrationPlanResponseBody403 -- ^ Forbidden
  | CreateByronWalletMigrationPlanResponse404 CreateByronWalletMigrationPlanResponseBody404 -- ^ Not Found
  | CreateByronWalletMigrationPlanResponse406 CreateByronWalletMigrationPlanResponseBody406 -- ^ Not Acceptable
  deriving (GHC.Show.Show, GHC.Classes.Eq)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema@ in the specification.
-- 
-- 
data CreateByronWalletMigrationPlanResponseBody202 = CreateByronWalletMigrationPlanResponseBody202 {
  -- | balance_leftover: The total balance of assets that **cannot** be migrated.
  -- 
  -- The **ada** component of this balance is the total sum of all dust
  -- ada entries in the UTxO set. An ada entry is considered to be dust
  -- if its value is not large enough to pay for the marginal cost of
  -- including it in a transaction.
  -- 
  -- The **assets** component of this balance is the total sum of all
  -- non-ada assets that cannot currently be migrated. Tokens of a
  -- non-ada asset cannot be migrated if there is insufficient ada
  -- available to pay for their inclusion in a transaction.
  createByronWalletMigrationPlanResponseBody202Balance_leftover :: CreateByronWalletMigrationPlanResponseBody202Balance_leftover
  -- | balance_selected: The total balance of assets that **can** be migrated.
  , createByronWalletMigrationPlanResponseBody202Balance_selected :: CreateByronWalletMigrationPlanResponseBody202Balance_selected
  -- | selections: The complete set of selections required for a migration.
  -- 
  -- Each selection is the basis for a single transaction.
  -- 
  -- The ordering of selections within the list is not significant.
  -- After conversion into transactions, the transactions can be
  -- broadcast to the network in any order to perform the migration.
  , createByronWalletMigrationPlanResponseBody202Selections :: ([CreateByronWalletMigrationPlanResponseBody202Selections])
  -- | total_fee: The total amount to be paid in fees for a migration.
  -- 
  -- This is the total sum of the fees of the individual selections.
  , createByronWalletMigrationPlanResponseBody202Total_fee :: CreateByronWalletMigrationPlanResponseBody202Total_fee
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["balance_leftover" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_leftover obj] : ["balance_selected" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_selected obj] : ["selections" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Selections obj] : ["total_fee" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Total_fee obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["balance_leftover" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_leftover obj] : ["balance_selected" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_selected obj] : ["selections" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Selections obj] : ["total_fee" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Total_fee obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202" (\obj -> (((GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "balance_leftover")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "balance_selected")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "selections")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "total_fee"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202 :: CreateByronWalletMigrationPlanResponseBody202Balance_leftover -- ^ 'createByronWalletMigrationPlanResponseBody202Balance_leftover'
  -> CreateByronWalletMigrationPlanResponseBody202Balance_selected -- ^ 'createByronWalletMigrationPlanResponseBody202Balance_selected'
  -> [CreateByronWalletMigrationPlanResponseBody202Selections] -- ^ 'createByronWalletMigrationPlanResponseBody202Selections'
  -> CreateByronWalletMigrationPlanResponseBody202Total_fee -- ^ 'createByronWalletMigrationPlanResponseBody202Total_fee'
  -> CreateByronWalletMigrationPlanResponseBody202
mkCreateByronWalletMigrationPlanResponseBody202 createByronWalletMigrationPlanResponseBody202Balance_leftover createByronWalletMigrationPlanResponseBody202Balance_selected createByronWalletMigrationPlanResponseBody202Selections createByronWalletMigrationPlanResponseBody202Total_fee = CreateByronWalletMigrationPlanResponseBody202{createByronWalletMigrationPlanResponseBody202Balance_leftover = createByronWalletMigrationPlanResponseBody202Balance_leftover,
                                                                                                                                                                                                                                                                                                                                           createByronWalletMigrationPlanResponseBody202Balance_selected = createByronWalletMigrationPlanResponseBody202Balance_selected,
                                                                                                                                                                                                                                                                                                                                           createByronWalletMigrationPlanResponseBody202Selections = createByronWalletMigrationPlanResponseBody202Selections,
                                                                                                                                                                                                                                                                                                                                           createByronWalletMigrationPlanResponseBody202Total_fee = createByronWalletMigrationPlanResponseBody202Total_fee}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.balance_leftover@ in the specification.
-- 
-- The total balance of assets that **cannot** be migrated.
-- 
-- The **ada** component of this balance is the total sum of all dust
-- ada entries in the UTxO set. An ada entry is considered to be dust
-- if its value is not large enough to pay for the marginal cost of
-- including it in a transaction.
-- 
-- The **assets** component of this balance is the total sum of all
-- non-ada assets that cannot currently be migrated. Tokens of a
-- non-ada asset cannot be migrated if there is insufficient ada
-- available to pay for their inclusion in a transaction.
data CreateByronWalletMigrationPlanResponseBody202Balance_leftover = CreateByronWalletMigrationPlanResponseBody202Balance_leftover {
  -- | ada: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  createByronWalletMigrationPlanResponseBody202Balance_leftoverAda :: CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAda
  -- | assets: A flat list of assets (possibly empty).
  , createByronWalletMigrationPlanResponseBody202Balance_leftoverAssets :: ([CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAssets])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202Balance_leftover
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["ada" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_leftoverAda obj] : ["assets" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_leftoverAssets obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["ada" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_leftoverAda obj] : ["assets" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_leftoverAssets obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202Balance_leftover
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202Balance_leftover" (\obj -> (GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202Balance_leftover GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ada")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202Balance_leftover' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202Balance_leftover :: CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAda -- ^ 'createByronWalletMigrationPlanResponseBody202Balance_leftoverAda'
  -> [CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAssets] -- ^ 'createByronWalletMigrationPlanResponseBody202Balance_leftoverAssets'
  -> CreateByronWalletMigrationPlanResponseBody202Balance_leftover
mkCreateByronWalletMigrationPlanResponseBody202Balance_leftover createByronWalletMigrationPlanResponseBody202Balance_leftoverAda createByronWalletMigrationPlanResponseBody202Balance_leftoverAssets = CreateByronWalletMigrationPlanResponseBody202Balance_leftover{createByronWalletMigrationPlanResponseBody202Balance_leftoverAda = createByronWalletMigrationPlanResponseBody202Balance_leftoverAda,
                                                                                                                                                                                                                                                                     createByronWalletMigrationPlanResponseBody202Balance_leftoverAssets = createByronWalletMigrationPlanResponseBody202Balance_leftoverAssets}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.balance_leftover.properties.ada@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAda = CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAda {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  createByronWalletMigrationPlanResponseBody202Balance_leftoverAdaQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAda
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_leftoverAdaQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_leftoverAdaQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAda
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAda" (\obj -> GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAda GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAda' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202Balance_leftoverAda :: GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202Balance_leftoverAdaQuantity'
  -> CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAda
mkCreateByronWalletMigrationPlanResponseBody202Balance_leftoverAda createByronWalletMigrationPlanResponseBody202Balance_leftoverAdaQuantity = CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAda{createByronWalletMigrationPlanResponseBody202Balance_leftoverAdaQuantity = createByronWalletMigrationPlanResponseBody202Balance_leftoverAdaQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.balance_leftover.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAssets = CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAssets" (\obj -> ((GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAssets' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202Balance_leftoverAssets :: Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsQuantity'
  -> CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAssets
mkCreateByronWalletMigrationPlanResponseBody202Balance_leftoverAssets createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsAsset_name createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsPolicy_id createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsQuantity = CreateByronWalletMigrationPlanResponseBody202Balance_leftoverAssets{createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsAsset_name = createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                                                                   createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsPolicy_id = createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                                                                   createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsQuantity = createByronWalletMigrationPlanResponseBody202Balance_leftoverAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.balance_selected@ in the specification.
-- 
-- The total balance of assets that **can** be migrated.
data CreateByronWalletMigrationPlanResponseBody202Balance_selected = CreateByronWalletMigrationPlanResponseBody202Balance_selected {
  -- | ada: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  createByronWalletMigrationPlanResponseBody202Balance_selectedAda :: CreateByronWalletMigrationPlanResponseBody202Balance_selectedAda
  -- | assets: A flat list of assets (possibly empty).
  , createByronWalletMigrationPlanResponseBody202Balance_selectedAssets :: ([CreateByronWalletMigrationPlanResponseBody202Balance_selectedAssets])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202Balance_selected
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["ada" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_selectedAda obj] : ["assets" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_selectedAssets obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["ada" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_selectedAda obj] : ["assets" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_selectedAssets obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202Balance_selected
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202Balance_selected" (\obj -> (GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202Balance_selected GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "ada")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "assets"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202Balance_selected' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202Balance_selected :: CreateByronWalletMigrationPlanResponseBody202Balance_selectedAda -- ^ 'createByronWalletMigrationPlanResponseBody202Balance_selectedAda'
  -> [CreateByronWalletMigrationPlanResponseBody202Balance_selectedAssets] -- ^ 'createByronWalletMigrationPlanResponseBody202Balance_selectedAssets'
  -> CreateByronWalletMigrationPlanResponseBody202Balance_selected
mkCreateByronWalletMigrationPlanResponseBody202Balance_selected createByronWalletMigrationPlanResponseBody202Balance_selectedAda createByronWalletMigrationPlanResponseBody202Balance_selectedAssets = CreateByronWalletMigrationPlanResponseBody202Balance_selected{createByronWalletMigrationPlanResponseBody202Balance_selectedAda = createByronWalletMigrationPlanResponseBody202Balance_selectedAda,
                                                                                                                                                                                                                                                                     createByronWalletMigrationPlanResponseBody202Balance_selectedAssets = createByronWalletMigrationPlanResponseBody202Balance_selectedAssets}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.balance_selected.properties.ada@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data CreateByronWalletMigrationPlanResponseBody202Balance_selectedAda = CreateByronWalletMigrationPlanResponseBody202Balance_selectedAda {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  createByronWalletMigrationPlanResponseBody202Balance_selectedAdaQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202Balance_selectedAda
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_selectedAdaQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_selectedAdaQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202Balance_selectedAda
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202Balance_selectedAda" (\obj -> GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202Balance_selectedAda GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202Balance_selectedAda' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202Balance_selectedAda :: GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202Balance_selectedAdaQuantity'
  -> CreateByronWalletMigrationPlanResponseBody202Balance_selectedAda
mkCreateByronWalletMigrationPlanResponseBody202Balance_selectedAda createByronWalletMigrationPlanResponseBody202Balance_selectedAdaQuantity = CreateByronWalletMigrationPlanResponseBody202Balance_selectedAda{createByronWalletMigrationPlanResponseBody202Balance_selectedAdaQuantity = createByronWalletMigrationPlanResponseBody202Balance_selectedAdaQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.balance_selected.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data CreateByronWalletMigrationPlanResponseBody202Balance_selectedAssets = CreateByronWalletMigrationPlanResponseBody202Balance_selectedAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202Balance_selectedAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202Balance_selectedAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202Balance_selectedAssets" (\obj -> ((GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202Balance_selectedAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202Balance_selectedAssets' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202Balance_selectedAssets :: Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsQuantity'
  -> CreateByronWalletMigrationPlanResponseBody202Balance_selectedAssets
mkCreateByronWalletMigrationPlanResponseBody202Balance_selectedAssets createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsAsset_name createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsPolicy_id createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsQuantity = CreateByronWalletMigrationPlanResponseBody202Balance_selectedAssets{createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsAsset_name = createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                                                                   createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsPolicy_id = createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                                                                   createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsQuantity = createByronWalletMigrationPlanResponseBody202Balance_selectedAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items@ in the specification.
-- 
-- 
data CreateByronWalletMigrationPlanResponseBody202Selections = CreateByronWalletMigrationPlanResponseBody202Selections {
  -- | certificates
  createByronWalletMigrationPlanResponseBody202SelectionsCertificates :: (GHC.Maybe.Maybe ([CreateByronWalletMigrationPlanResponseBody202SelectionsCertificates]))
  -- | change: A list of transaction change outputs.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , createByronWalletMigrationPlanResponseBody202SelectionsChange :: ([CreateByronWalletMigrationPlanResponseBody202SelectionsChange])
  -- | collateral: A list of transaction inputs used for collateral
  , createByronWalletMigrationPlanResponseBody202SelectionsCollateral :: (GHC.Maybe.Maybe ([CreateByronWalletMigrationPlanResponseBody202SelectionsCollateral]))
  -- | deposits_returned: A list of deposits associated with a transaction.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , createByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned :: (GHC.Maybe.Maybe ([CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned]))
  -- | deposits_taken: A list of deposits associated with a transaction.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , createByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken :: (GHC.Maybe.Maybe ([CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken]))
  -- | inputs: A list of transaction inputs
  , createByronWalletMigrationPlanResponseBody202SelectionsInputs :: ([CreateByronWalletMigrationPlanResponseBody202SelectionsInputs])
  -- | metadata: Transaction metadata, serialized according to the expected on-chain binary format, base64-encoded.
  , createByronWalletMigrationPlanResponseBody202SelectionsMetadata :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | outputs: A list of target outputs with amounts specified.
  -- 
  -- When creating a new transaction, the wallet software ensures that all
  -- user-specified transaction outputs have ada amounts that satisfy the ledger
  -- minimum UTxO rule:
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **zero**, the wallet software will automatically assign a minimal amount
  --   of ada to the output so that it satisfies the ledger minimum UTxO rule.
  -- 
  -- - If a user-specified transaction output has an ada \`amount\` that is
  --   **non-zero**, the wallet software will verify that the specified amount
  --   is large enough to satisfy the ledger minimum UTxO rule. If the amount is
  --   not large enough, the wallet software will return a \`utxo_too_small\`
  --   error, together with a revised ada amount that does satisfy the minimum
  --   UTxO rule.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , createByronWalletMigrationPlanResponseBody202SelectionsOutputs :: ([CreateByronWalletMigrationPlanResponseBody202SelectionsOutputs])
  -- | withdrawals: A list of withdrawals from stake addresses.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 0 items
  , createByronWalletMigrationPlanResponseBody202SelectionsWithdrawals :: (GHC.Maybe.Maybe ([CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawals]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202Selections
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsCertificates obj) : ["change" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChange obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsCollateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_returned" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_taken" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken obj) : ["inputs" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsMetadata obj) : ["outputs" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsOutputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawals" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsWithdrawals obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("certificates" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsCertificates obj) : ["change" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChange obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("collateral" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsCollateral obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_returned" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned obj) : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("deposits_taken" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken obj) : ["inputs" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("metadata" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsMetadata obj) : ["outputs" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsOutputs obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("withdrawals" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsWithdrawals obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202Selections
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202Selections" (\obj -> ((((((((GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202Selections GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "certificates")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "change")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "collateral")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "deposits_returned")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "deposits_taken")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "inputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "metadata")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "outputs")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "withdrawals"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202Selections' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202Selections :: [CreateByronWalletMigrationPlanResponseBody202SelectionsChange] -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsChange'
  -> [CreateByronWalletMigrationPlanResponseBody202SelectionsInputs] -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsInputs'
  -> [CreateByronWalletMigrationPlanResponseBody202SelectionsOutputs] -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsOutputs'
  -> CreateByronWalletMigrationPlanResponseBody202Selections
mkCreateByronWalletMigrationPlanResponseBody202Selections createByronWalletMigrationPlanResponseBody202SelectionsChange createByronWalletMigrationPlanResponseBody202SelectionsInputs createByronWalletMigrationPlanResponseBody202SelectionsOutputs = CreateByronWalletMigrationPlanResponseBody202Selections{createByronWalletMigrationPlanResponseBody202SelectionsCertificates = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                               createByronWalletMigrationPlanResponseBody202SelectionsChange = createByronWalletMigrationPlanResponseBody202SelectionsChange,
                                                                                                                                                                                                                                                                                                               createByronWalletMigrationPlanResponseBody202SelectionsCollateral = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                               createByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                               createByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                               createByronWalletMigrationPlanResponseBody202SelectionsInputs = createByronWalletMigrationPlanResponseBody202SelectionsInputs,
                                                                                                                                                                                                                                                                                                               createByronWalletMigrationPlanResponseBody202SelectionsMetadata = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                               createByronWalletMigrationPlanResponseBody202SelectionsOutputs = createByronWalletMigrationPlanResponseBody202SelectionsOutputs,
                                                                                                                                                                                                                                                                                                               createByronWalletMigrationPlanResponseBody202SelectionsWithdrawals = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.certificates.items@ in the specification.
-- 
-- A delegation certificate belonging to wallet
-- 
-- Only for \'join_pool\' the \'pool\' property is required.
data CreateByronWalletMigrationPlanResponseBody202SelectionsCertificates = CreateByronWalletMigrationPlanResponseBody202SelectionsCertificates {
  -- | certificate_type
  createByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_type :: CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_type
  -- | pool: A unique identifier for the pool.
  , createByronWalletMigrationPlanResponseBody202SelectionsCertificatesPool :: (GHC.Maybe.Maybe Data.Text.Internal.Text)
  -- | reward_account_path
  -- 
  -- Constraints:
  -- 
  -- * Must have a maximum of 5 items
  -- * Must have a minimum of 5 items
  , createByronWalletMigrationPlanResponseBody202SelectionsCertificatesReward_account_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsCertificates
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsCertificatesPool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCertificatesReward_account_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["certificate_type" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_type obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("pool" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsCertificatesPool obj) : ["reward_account_path" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCertificatesReward_account_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsCertificates
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsCertificates" (\obj -> ((GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsCertificates GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "certificate_type")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "pool")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "reward_account_path"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsCertificates' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsCertificates :: CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_type -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_type'
  -> [Data.Text.Internal.Text] -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsCertificatesReward_account_path'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsCertificates
mkCreateByronWalletMigrationPlanResponseBody202SelectionsCertificates createByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_type createByronWalletMigrationPlanResponseBody202SelectionsCertificatesReward_account_path = CreateByronWalletMigrationPlanResponseBody202SelectionsCertificates{createByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_type = createByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_type,
                                                                                                                                                                                                                                                                                                                       createByronWalletMigrationPlanResponseBody202SelectionsCertificatesPool = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                       createByronWalletMigrationPlanResponseBody202SelectionsCertificatesReward_account_path = createByronWalletMigrationPlanResponseBody202SelectionsCertificatesReward_account_path}
-- | Defines the enum schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.certificates.items.properties.certificate_type@ in the specification.
-- 
-- 
data CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_type =
   CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_typeOther Data.Aeson.Types.Internal.Value -- ^ This case is used if the value encountered during decoding does not match any of the provided cases in the specification.
  | CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_typeTyped Data.Text.Internal.Text -- ^ This constructor can be used to send values to the server which are not present in the specification yet.
  | CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_typeEnumJoin_pool -- ^ Represents the JSON value @"join_pool"@
  | CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_typeEnumQuit_pool -- ^ Represents the JSON value @"quit_pool"@
  | CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_typeEnumRegister_reward_account -- ^ Represents the JSON value @"register_reward_account"@
  deriving (GHC.Show.Show, GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_type
    where toJSON (CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_typeOther val) = val
          toJSON (CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_typeTyped val) = Data.Aeson.Types.ToJSON.toJSON val
          toJSON (CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_typeEnumJoin_pool) = "join_pool"
          toJSON (CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_typeEnumQuit_pool) = "quit_pool"
          toJSON (CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_typeEnumRegister_reward_account) = "register_reward_account"
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_type
    where parseJSON val = GHC.Base.pure (if | val GHC.Classes.== "join_pool" -> CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_typeEnumJoin_pool
                                            | val GHC.Classes.== "quit_pool" -> CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_typeEnumQuit_pool
                                            | val GHC.Classes.== "register_reward_account" -> CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_typeEnumRegister_reward_account
                                            | GHC.Base.otherwise -> CreateByronWalletMigrationPlanResponseBody202SelectionsCertificatesCertificate_typeOther val)
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.change.items@ in the specification.
-- 
-- 
data CreateByronWalletMigrationPlanResponseBody202SelectionsChange = CreateByronWalletMigrationPlanResponseBody202SelectionsChange {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  createByronWalletMigrationPlanResponseBody202SelectionsChangeAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , createByronWalletMigrationPlanResponseBody202SelectionsChangeAmount :: CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAmount
  -- | assets: A flat list of assets (possibly empty).
  , createByronWalletMigrationPlanResponseBody202SelectionsChangeAssets :: (GHC.Maybe.Maybe ([CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAssets]))
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , createByronWalletMigrationPlanResponseBody202SelectionsChangeDerivation_path :: ([Data.Text.Internal.Text])
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsChange
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChangeAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChangeAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsChangeAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChangeDerivation_path obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChangeAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChangeAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsChangeAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChangeDerivation_path obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsChange
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsChange" (\obj -> (((GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsChange GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsChange' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsChange :: Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsChangeAddress'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAmount -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsChangeAmount'
  -> [Data.Text.Internal.Text] -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsChangeDerivation_path'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsChange
mkCreateByronWalletMigrationPlanResponseBody202SelectionsChange createByronWalletMigrationPlanResponseBody202SelectionsChangeAddress createByronWalletMigrationPlanResponseBody202SelectionsChangeAmount createByronWalletMigrationPlanResponseBody202SelectionsChangeDerivation_path = CreateByronWalletMigrationPlanResponseBody202SelectionsChange{createByronWalletMigrationPlanResponseBody202SelectionsChangeAddress = createByronWalletMigrationPlanResponseBody202SelectionsChangeAddress,
                                                                                                                                                                                                                                                                                                                                                      createByronWalletMigrationPlanResponseBody202SelectionsChangeAmount = createByronWalletMigrationPlanResponseBody202SelectionsChangeAmount,
                                                                                                                                                                                                                                                                                                                                                      createByronWalletMigrationPlanResponseBody202SelectionsChangeAssets = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                      createByronWalletMigrationPlanResponseBody202SelectionsChangeDerivation_path = createByronWalletMigrationPlanResponseBody202SelectionsChangeDerivation_path}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.change.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAmount = CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  createByronWalletMigrationPlanResponseBody202SelectionsChangeAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChangeAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChangeAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAmount" (\obj -> GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAmount' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsChangeAmount :: GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsChangeAmountQuantity'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAmount
mkCreateByronWalletMigrationPlanResponseBody202SelectionsChangeAmount createByronWalletMigrationPlanResponseBody202SelectionsChangeAmountQuantity = CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAmount{createByronWalletMigrationPlanResponseBody202SelectionsChangeAmountQuantity = createByronWalletMigrationPlanResponseBody202SelectionsChangeAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.change.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAssets = CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAssets" (\obj -> ((GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAssets' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsChangeAssets :: Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsQuantity'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAssets
mkCreateByronWalletMigrationPlanResponseBody202SelectionsChangeAssets createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsAsset_name createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsPolicy_id createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsQuantity = CreateByronWalletMigrationPlanResponseBody202SelectionsChangeAssets{createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsAsset_name = createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                                                                   createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsPolicy_id = createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                                                                   createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsQuantity = createByronWalletMigrationPlanResponseBody202SelectionsChangeAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.collateral.items@ in the specification.
-- 
-- 
data CreateByronWalletMigrationPlanResponseBody202SelectionsCollateral = CreateByronWalletMigrationPlanResponseBody202SelectionsCollateral {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  createByronWalletMigrationPlanResponseBody202SelectionsCollateralAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , createByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount :: CreateByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , createByronWalletMigrationPlanResponseBody202SelectionsCollateralDerivation_path :: ([Data.Text.Internal.Text])
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , createByronWalletMigrationPlanResponseBody202SelectionsCollateralId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , createByronWalletMigrationPlanResponseBody202SelectionsCollateralIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsCollateral
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCollateralAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCollateralDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCollateralIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCollateralAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCollateralDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCollateralId obj] : ["index" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCollateralIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsCollateral
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsCollateral" (\obj -> ((((GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsCollateral GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsCollateral' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsCollateral :: Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsCollateralAddress'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount'
  -> [Data.Text.Internal.Text] -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsCollateralDerivation_path'
  -> Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsCollateralId'
  -> GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsCollateralIndex'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsCollateral
mkCreateByronWalletMigrationPlanResponseBody202SelectionsCollateral createByronWalletMigrationPlanResponseBody202SelectionsCollateralAddress createByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount createByronWalletMigrationPlanResponseBody202SelectionsCollateralDerivation_path createByronWalletMigrationPlanResponseBody202SelectionsCollateralId createByronWalletMigrationPlanResponseBody202SelectionsCollateralIndex = CreateByronWalletMigrationPlanResponseBody202SelectionsCollateral{createByronWalletMigrationPlanResponseBody202SelectionsCollateralAddress = createByronWalletMigrationPlanResponseBody202SelectionsCollateralAddress,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     createByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount = createByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     createByronWalletMigrationPlanResponseBody202SelectionsCollateralDerivation_path = createByronWalletMigrationPlanResponseBody202SelectionsCollateralDerivation_path,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     createByronWalletMigrationPlanResponseBody202SelectionsCollateralId = createByronWalletMigrationPlanResponseBody202SelectionsCollateralId,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     createByronWalletMigrationPlanResponseBody202SelectionsCollateralIndex = createByronWalletMigrationPlanResponseBody202SelectionsCollateralIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.collateral.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data CreateByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount = CreateByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  createByronWalletMigrationPlanResponseBody202SelectionsCollateralAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsCollateralAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount" (\obj -> GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount :: GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsCollateralAmountQuantity'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount
mkCreateByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount createByronWalletMigrationPlanResponseBody202SelectionsCollateralAmountQuantity = CreateByronWalletMigrationPlanResponseBody202SelectionsCollateralAmount{createByronWalletMigrationPlanResponseBody202SelectionsCollateralAmountQuantity = createByronWalletMigrationPlanResponseBody202SelectionsCollateralAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.deposits_returned.items@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned = CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  createByronWalletMigrationPlanResponseBody202SelectionsDeposits_returnedQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsDeposits_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsDeposits_returnedQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned" (\obj -> GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned :: GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsDeposits_returnedQuantity'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned
mkCreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned createByronWalletMigrationPlanResponseBody202SelectionsDeposits_returnedQuantity = CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_returned{createByronWalletMigrationPlanResponseBody202SelectionsDeposits_returnedQuantity = createByronWalletMigrationPlanResponseBody202SelectionsDeposits_returnedQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.deposits_taken.items@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken = CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  createByronWalletMigrationPlanResponseBody202SelectionsDeposits_takenQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsDeposits_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsDeposits_takenQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken" (\obj -> GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken :: GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsDeposits_takenQuantity'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken
mkCreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken createByronWalletMigrationPlanResponseBody202SelectionsDeposits_takenQuantity = CreateByronWalletMigrationPlanResponseBody202SelectionsDeposits_taken{createByronWalletMigrationPlanResponseBody202SelectionsDeposits_takenQuantity = createByronWalletMigrationPlanResponseBody202SelectionsDeposits_takenQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.inputs.items@ in the specification.
-- 
-- 
data CreateByronWalletMigrationPlanResponseBody202SelectionsInputs = CreateByronWalletMigrationPlanResponseBody202SelectionsInputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  createByronWalletMigrationPlanResponseBody202SelectionsInputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , createByronWalletMigrationPlanResponseBody202SelectionsInputsAmount :: CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , createByronWalletMigrationPlanResponseBody202SelectionsInputsAssets :: (GHC.Maybe.Maybe ([CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAssets]))
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , createByronWalletMigrationPlanResponseBody202SelectionsInputsDerivation_path :: ([Data.Text.Internal.Text])
  -- | id: A unique identifier for this transaction
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  -- * Minimum length of 64
  , createByronWalletMigrationPlanResponseBody202SelectionsInputsId :: Data.Text.Internal.Text
  -- | index
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , createByronWalletMigrationPlanResponseBody202SelectionsInputsIndex :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsInputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsInputsAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsId obj] : ["index" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsIndex obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsInputsAssets obj) : ["derivation_path" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsDerivation_path obj] : ["id" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsId obj] : ["index" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsIndex obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsInputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsInputs" (\obj -> (((((GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsInputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "index"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsInputs' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsInputs :: Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsInputsAddress'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAmount -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsInputsAmount'
  -> [Data.Text.Internal.Text] -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsInputsDerivation_path'
  -> Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsInputsId'
  -> GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsInputsIndex'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsInputs
mkCreateByronWalletMigrationPlanResponseBody202SelectionsInputs createByronWalletMigrationPlanResponseBody202SelectionsInputsAddress createByronWalletMigrationPlanResponseBody202SelectionsInputsAmount createByronWalletMigrationPlanResponseBody202SelectionsInputsDerivation_path createByronWalletMigrationPlanResponseBody202SelectionsInputsId createByronWalletMigrationPlanResponseBody202SelectionsInputsIndex = CreateByronWalletMigrationPlanResponseBody202SelectionsInputs{createByronWalletMigrationPlanResponseBody202SelectionsInputsAddress = createByronWalletMigrationPlanResponseBody202SelectionsInputsAddress,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         createByronWalletMigrationPlanResponseBody202SelectionsInputsAmount = createByronWalletMigrationPlanResponseBody202SelectionsInputsAmount,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         createByronWalletMigrationPlanResponseBody202SelectionsInputsAssets = GHC.Maybe.Nothing,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         createByronWalletMigrationPlanResponseBody202SelectionsInputsDerivation_path = createByronWalletMigrationPlanResponseBody202SelectionsInputsDerivation_path,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         createByronWalletMigrationPlanResponseBody202SelectionsInputsId = createByronWalletMigrationPlanResponseBody202SelectionsInputsId,
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         createByronWalletMigrationPlanResponseBody202SelectionsInputsIndex = createByronWalletMigrationPlanResponseBody202SelectionsInputsIndex}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.inputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAmount = CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  createByronWalletMigrationPlanResponseBody202SelectionsInputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAmount" (\obj -> GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAmount' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsInputsAmount :: GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsInputsAmountQuantity'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAmount
mkCreateByronWalletMigrationPlanResponseBody202SelectionsInputsAmount createByronWalletMigrationPlanResponseBody202SelectionsInputsAmountQuantity = CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAmount{createByronWalletMigrationPlanResponseBody202SelectionsInputsAmountQuantity = createByronWalletMigrationPlanResponseBody202SelectionsInputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.inputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAssets = CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAssets" (\obj -> ((GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAssets' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsInputsAssets :: Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsQuantity'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAssets
mkCreateByronWalletMigrationPlanResponseBody202SelectionsInputsAssets createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsAsset_name createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsPolicy_id createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsQuantity = CreateByronWalletMigrationPlanResponseBody202SelectionsInputsAssets{createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsAsset_name = createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                                                                   createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsPolicy_id = createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                                                                   createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsQuantity = createByronWalletMigrationPlanResponseBody202SelectionsInputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.outputs.items@ in the specification.
-- 
-- 
data CreateByronWalletMigrationPlanResponseBody202SelectionsOutputs = CreateByronWalletMigrationPlanResponseBody202SelectionsOutputs {
  -- | address: A sequence of characters that encodes (in Base58 or Bech32) a sequence of bytes
  -- which represents an address on the Cardano blockchain.
  -- Sequences in Base58 encoding are expected to be legacy Byron addresses,
  -- whereas sequences in Bech32 encoding correspond to current Shelley addresses.
  -- 
  -- For more details, see
  -- [CIP-0019 — Cardano addresses](https:\/\/github.com\/cardano-foundation\/CIPs\/tree\/master\/CIP-0019)
  -- .
  createByronWalletMigrationPlanResponseBody202SelectionsOutputsAddress :: Data.Text.Internal.Text
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  , createByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount :: CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount
  -- | assets: A flat list of assets (possibly empty).
  , createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets :: (GHC.Maybe.Maybe ([CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets]))
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsOutputs
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsOutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets obj) : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["address" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsOutputsAddress obj] : ["amount" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount obj] : Data.Maybe.maybe GHC.Base.mempty (GHC.Base.pure GHC.Base.. ("assets" Data.Aeson.Types.ToJSON..=)) (createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets obj) : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsOutputs
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsOutputs" (\obj -> ((GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsOutputs GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "address")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..:! "assets"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsOutputs' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsOutputs :: Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsOutputsAddress'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsOutputs
mkCreateByronWalletMigrationPlanResponseBody202SelectionsOutputs createByronWalletMigrationPlanResponseBody202SelectionsOutputsAddress createByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount = CreateByronWalletMigrationPlanResponseBody202SelectionsOutputs{createByronWalletMigrationPlanResponseBody202SelectionsOutputsAddress = createByronWalletMigrationPlanResponseBody202SelectionsOutputsAddress,
                                                                                                                                                                                                                                                                             createByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount = createByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount,
                                                                                                                                                                                                                                                                             createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets = GHC.Maybe.Nothing}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.outputs.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount = CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  createByronWalletMigrationPlanResponseBody202SelectionsOutputsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsOutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsOutputsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount" (\obj -> GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount :: GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsOutputsAmountQuantity'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount
mkCreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount createByronWalletMigrationPlanResponseBody202SelectionsOutputsAmountQuantity = CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAmount{createByronWalletMigrationPlanResponseBody202SelectionsOutputsAmountQuantity = createByronWalletMigrationPlanResponseBody202SelectionsOutputsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.outputs.items.properties.assets.items@ in the specification.
-- 
-- An asset on the Cardano blockchain. An asset is uniquely identified by
-- its \`policy_id\` and \`asset_name\` (together, these form the _asset id_).
-- 
-- Two assets with the same \`asset_name\` and \`policy_id\` are
-- interchangeable. Yet, different assets with a same \`policy_id\` but
-- different \`asset_name\` are treated as separate assets, as are two
-- assets with the same \`asset_name\` but different \`policy_id\`.
data CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets = CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets {
  -- | asset_name: The asset on-chain type which acts as a sub-identifier within a
  -- policy. Although we call it \"asset name\", the value needn\'t be
  -- text, and it could even be empty.
  -- 
  -- For policies with a single fungible asset item, asset name is
  -- typically an empty string.
  -- 
  -- This value can be up to 32 bytes of arbitrary data (which is 64
  -- hexadecimal digits).
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 64
  createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsAsset_name :: Data.Text.Internal.Text
  -- | policy_id: A unique identifier of the asset\'s monetary policy. The policy
  -- controls how assets of this kind are created and destroyed.
  -- 
  -- The contents are the blake2b-224 hash of the monetary policy
  -- script, encoded in hexadecimal.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Maximum length of 56
  -- * Minimum length of 56
  , createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsPolicy_id :: Data.Text.Internal.Text
  -- | quantity: Number of assets for the given \`policy_id\` and \`asset_name\`.
  -- 
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  , createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsQuantity obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["asset_name" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsAsset_name obj] : ["policy_id" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsPolicy_id obj] : ["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsQuantity obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets" (\obj -> ((GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "asset_name")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "policy_id")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets :: Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsAsset_name'
  -> Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsPolicy_id'
  -> GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsQuantity'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets
mkCreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsAsset_name createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsPolicy_id createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsQuantity = CreateByronWalletMigrationPlanResponseBody202SelectionsOutputsAssets{createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsAsset_name = createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsAsset_name,
                                                                                                                                                                                                                                                                                                                                                                                        createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsPolicy_id = createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsPolicy_id,
                                                                                                                                                                                                                                                                                                                                                                                        createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsQuantity = createByronWalletMigrationPlanResponseBody202SelectionsOutputsAssetsQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.withdrawals.items@ in the specification.
-- 
-- 
data CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawals = CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawals {
  -- | amount: Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
  createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount :: CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount
  -- | derivation_path: A path for deriving a child key from a parent key.
  -- 
  -- Constraints:
  -- 
  -- * Must have a minimum of 1 items
  , createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsDerivation_path :: ([Data.Text.Internal.Text])
  -- | stake_address
  , createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsStake_address :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawals
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsDerivation_path obj] : ["stake_address" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsStake_address obj] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["amount" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount obj] : ["derivation_path" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsDerivation_path obj] : ["stake_address" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsStake_address obj] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawals
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawals" (\obj -> ((GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawals GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "amount")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "derivation_path")) GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "stake_address"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawals' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawals :: CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount'
  -> [Data.Text.Internal.Text] -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsDerivation_path'
  -> Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsStake_address'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawals
mkCreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawals createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsDerivation_path createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsStake_address = CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawals{createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount = createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount,
                                                                                                                                                                                                                                                                                                                                                                                     createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsDerivation_path = createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsDerivation_path,
                                                                                                                                                                                                                                                                                                                                                                                     createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsStake_address = createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsStake_address}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.selections.items.properties.withdrawals.items.properties.amount@ in the specification.
-- 
-- Coins, in Lovelace. Only relates to \'Ada\'. Refer to \`assets\` for multi-assets wallets instead.
data CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount = CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmountQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmountQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount" (\obj -> GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount :: GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmountQuantity'
  -> CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount
mkCreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmountQuantity = CreateByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmount{createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmountQuantity = createByronWalletMigrationPlanResponseBody202SelectionsWithdrawalsAmountQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.202.content.application\/json.schema.properties.total_fee@ in the specification.
-- 
-- The total amount to be paid in fees for a migration.
-- 
-- This is the total sum of the fees of the individual selections.
data CreateByronWalletMigrationPlanResponseBody202Total_fee = CreateByronWalletMigrationPlanResponseBody202Total_fee {
  -- | quantity
  -- 
  -- Constraints:
  -- 
  -- * Minimum  of 0.0
  createByronWalletMigrationPlanResponseBody202Total_feeQuantity :: GHC.Types.Int
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody202Total_fee
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Total_feeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["quantity" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody202Total_feeQuantity obj] : ["unit" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "lovelace"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody202Total_fee
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody202Total_fee" (\obj -> GHC.Base.pure CreateByronWalletMigrationPlanResponseBody202Total_fee GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "quantity"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody202Total_fee' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody202Total_fee :: GHC.Types.Int -- ^ 'createByronWalletMigrationPlanResponseBody202Total_feeQuantity'
  -> CreateByronWalletMigrationPlanResponseBody202Total_fee
mkCreateByronWalletMigrationPlanResponseBody202Total_fee createByronWalletMigrationPlanResponseBody202Total_feeQuantity = CreateByronWalletMigrationPlanResponseBody202Total_fee{createByronWalletMigrationPlanResponseBody202Total_feeQuantity = createByronWalletMigrationPlanResponseBody202Total_feeQuantity}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.403.content.application\/json.schema@ in the specification.
-- 
-- 
data CreateByronWalletMigrationPlanResponseBody403 = CreateByronWalletMigrationPlanResponseBody403 {
  -- | message: May occur when trying to migrate a wallet that is empty or full of dust.
  createByronWalletMigrationPlanResponseBody403Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody403
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody403Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "nothing_to_migrate"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody403Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "nothing_to_migrate"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody403
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody403" (\obj -> GHC.Base.pure CreateByronWalletMigrationPlanResponseBody403 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody403' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody403 :: Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody403Message'
  -> CreateByronWalletMigrationPlanResponseBody403
mkCreateByronWalletMigrationPlanResponseBody403 createByronWalletMigrationPlanResponseBody403Message = CreateByronWalletMigrationPlanResponseBody403{createByronWalletMigrationPlanResponseBody403Message = createByronWalletMigrationPlanResponseBody403Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.404.content.application\/json.schema@ in the specification.
-- 
-- 
data CreateByronWalletMigrationPlanResponseBody404 = CreateByronWalletMigrationPlanResponseBody404 {
  -- | message: May occur when a given walletId does not match with any known
  -- wallets (because it has been deleted, or has never existed).
  createByronWalletMigrationPlanResponseBody404Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody404
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody404Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "no_such_wallet"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody404
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody404" (\obj -> GHC.Base.pure CreateByronWalletMigrationPlanResponseBody404 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody404' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody404 :: Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody404Message'
  -> CreateByronWalletMigrationPlanResponseBody404
mkCreateByronWalletMigrationPlanResponseBody404 createByronWalletMigrationPlanResponseBody404Message = CreateByronWalletMigrationPlanResponseBody404{createByronWalletMigrationPlanResponseBody404Message = createByronWalletMigrationPlanResponseBody404Message}
-- | Defines the object schema located at @paths.\/byron-wallets\/{walletId}\/migrations\/plan.POST.responses.406.content.application\/json.schema@ in the specification.
-- 
-- 
data CreateByronWalletMigrationPlanResponseBody406 = CreateByronWalletMigrationPlanResponseBody406 {
  -- | message: May occur when providing an invalid \'Accept\' header.
  createByronWalletMigrationPlanResponseBody406Message :: Data.Text.Internal.Text
  } deriving (GHC.Show.Show
  , GHC.Classes.Eq)
instance Data.Aeson.Types.ToJSON.ToJSON CreateByronWalletMigrationPlanResponseBody406
    where toJSON obj = Data.Aeson.Types.Internal.object (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty))
          toEncoding obj = Data.Aeson.Encoding.Internal.pairs (GHC.Base.mconcat (Data.Foldable.concat (["message" Data.Aeson.Types.ToJSON..= createByronWalletMigrationPlanResponseBody406Message obj] : ["code" Data.Aeson.Types.ToJSON..= Data.Aeson.Types.Internal.String "not_acceptable"] : GHC.Base.mempty)))
instance Data.Aeson.Types.FromJSON.FromJSON CreateByronWalletMigrationPlanResponseBody406
    where parseJSON = Data.Aeson.Types.FromJSON.withObject "CreateByronWalletMigrationPlanResponseBody406" (\obj -> GHC.Base.pure CreateByronWalletMigrationPlanResponseBody406 GHC.Base.<*> (obj Data.Aeson.Types.FromJSON..: "message"))
-- | Create a new 'CreateByronWalletMigrationPlanResponseBody406' with all required fields.
mkCreateByronWalletMigrationPlanResponseBody406 :: Data.Text.Internal.Text -- ^ 'createByronWalletMigrationPlanResponseBody406Message'
  -> CreateByronWalletMigrationPlanResponseBody406
mkCreateByronWalletMigrationPlanResponseBody406 createByronWalletMigrationPlanResponseBody406Message = CreateByronWalletMigrationPlanResponseBody406{createByronWalletMigrationPlanResponseBody406Message = createByronWalletMigrationPlanResponseBody406Message}
-- | > POST /byron-wallets/{walletId}/migrations/plan
-- 
-- The same as 'createByronWalletMigrationPlan' but accepts an explicit configuration.
createByronWalletMigrationPlanWithConfiguration :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> CreateByronWalletMigrationPlanRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response CreateByronWalletMigrationPlanResponse) -- ^ Monadic computation which returns the result of the operation
createByronWalletMigrationPlanWithConfiguration config
                                                walletId
                                                body = GHC.Base.fmap (\response_5 -> GHC.Base.fmap (Data.Either.either CreateByronWalletMigrationPlanResponseError GHC.Base.id GHC.Base.. (\response body -> if | (\status_6 -> Network.HTTP.Types.Status.statusCode status_6 GHC.Classes.== 202) (Network.HTTP.Client.Types.responseStatus response) -> CreateByronWalletMigrationPlanResponse202 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              CreateByronWalletMigrationPlanResponseBody202)
                                                                                                                                                                                                                | (\status_7 -> Network.HTTP.Types.Status.statusCode status_7 GHC.Classes.== 403) (Network.HTTP.Client.Types.responseStatus response) -> CreateByronWalletMigrationPlanResponse403 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              CreateByronWalletMigrationPlanResponseBody403)
                                                                                                                                                                                                                | (\status_8 -> Network.HTTP.Types.Status.statusCode status_8 GHC.Classes.== 404) (Network.HTTP.Client.Types.responseStatus response) -> CreateByronWalletMigrationPlanResponse404 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              CreateByronWalletMigrationPlanResponseBody404)
                                                                                                                                                                                                                | (\status_9 -> Network.HTTP.Types.Status.statusCode status_9 GHC.Classes.== 406) (Network.HTTP.Client.Types.responseStatus response) -> CreateByronWalletMigrationPlanResponse406 Data.Functor.<$> (Data.Aeson.eitherDecodeStrict body :: Data.Either.Either GHC.Base.String
                                                                                                                                                                                                                                                                                                                                                                                                                                                                              CreateByronWalletMigrationPlanResponseBody406)
                                                                                                                                                                                                                | GHC.Base.otherwise -> Data.Either.Left "Missing default response type") response_5) response_5) (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/migrations/plan")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /byron-wallets/{walletId}/migrations/plan
-- 
-- The same as 'createByronWalletMigrationPlan' but returns the raw 'Data.ByteString.ByteString'.
createByronWalletMigrationPlanRaw :: forall m . Wallet.Common.MonadHTTP m => Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> CreateByronWalletMigrationPlanRequestBody -- ^ The request body to send
  -> Wallet.Common.ClientT m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
createByronWalletMigrationPlanRaw walletId
                                  body = GHC.Base.id (Wallet.Common.doBodyCallWithConfigurationM (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/migrations/plan")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
-- | > POST /byron-wallets/{walletId}/migrations/plan
-- 
-- The same as 'createByronWalletMigrationPlan' but accepts an explicit configuration and returns the raw 'Data.ByteString.ByteString'.
createByronWalletMigrationPlanWithConfigurationRaw :: forall m . Wallet.Common.MonadHTTP m => Wallet.Common.Configuration -- ^ The configuration to use in the request
  -> Data.Text.Internal.Text -- ^ walletId | Constraints: Maximum length of 40, Minimum length of 40
  -> CreateByronWalletMigrationPlanRequestBody -- ^ The request body to send
  -> m (Network.HTTP.Client.Types.Response Data.ByteString.Internal.Type.ByteString) -- ^ Monadic computation which returns the result of the operation
createByronWalletMigrationPlanWithConfigurationRaw config
                                                   walletId
                                                   body = GHC.Base.id (Wallet.Common.doBodyCallWithConfiguration config (Data.Text.toUpper GHC.Base.$ Data.Text.pack "POST") ("/byron-wallets/" GHC.Base.<> (Wallet.Common.byteToText (Network.HTTP.Types.URI.urlEncode GHC.Types.True GHC.Base.$ (Wallet.Common.textToByte GHC.Base.$ Wallet.Common.stringifyModel walletId)) GHC.Base.<> "/migrations/plan")) GHC.Base.mempty (GHC.Maybe.Just body) Wallet.Common.RequestBodyEncodingJSON)
